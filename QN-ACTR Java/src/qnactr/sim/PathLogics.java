/**
 * 2013 QN-Java project file
 * 
 */

package qnactr.sim;

import qnactr.objectDesigner.Entity;
import qnactr.objectDesigner.Enums;

public class PathLogics
{
  QnactrSimulation sim;  
  
  public PathLogics(QnactrSimulation Sim){
    sim = Sim;
  }
  
  /**
   * 
   * @param fromServerName, lower case without space, e.g., "visualmodule"
   * @param toServerName, lower case without space, e.g., "visualmodule"
   * @param Entity
   * @param probability
   * @return
   */
  public double getPathProbability(Enums.ServerName  fromServerName, Enums.ServerName  toServerName, Entity Entity, double probability) {
    String hmiID = Integer.toString(sim.ID);
    switch (fromServerName) {
      
      case testbuffer:
        switch (toServerName){
          case testmodule:
            return probability;
          default:
            System.out.println("getPathProbability. from: " + fromServerName + ", to: " + toServerName + " has undefined toServerName.");
            return probability;
        }
        
      case testmodule:
        switch (toServerName){
          case prescheduledevents:
            return probability;
          default:
            System.out.println("getPathProbability. from: " + fromServerName + ", to: " + toServerName + " has undefined toServerName.");
            return probability;
        }
      
      case prescheduledevents:
        switch (toServerName){
          case firsttriggerentity:
            return probability;
          default:
            System.out.println("getPathProbability. from: " + fromServerName + ", to: " + toServerName + " has undefined toServerName.");
            return probability;
        }
      
      case firsttriggerentity:
        switch (toServerName){
          case visualandaudiodisplayschedule:
            //return true;
            return 1.0;
          default:
            System.out.println("getPathProbability. from: " + fromServerName + ", to: " + toServerName + " has undefined toServerName.");
            return probability;
        }
      
      case visualandaudiodisplayschedule:
        switch (toServerName){
          //return false; //visualization. real entities generated by new Entity();
          case timertriggeringfeedbackordisplay:
            return 0.0;
          case visualdisplay:
            return 0.0;
          case audiodisplay:
            return 0.0;
          default:
            System.out.println("getPathProbability. from: " + fromServerName + ", to: " + toServerName + " has undefined toServerName.");
            return probability;
        }
      
      case timertriggeringfeedbackordisplay:
        switch (toServerName){
          case visualandaudiodisplayschedule:
            //return true;
            return 1.0;
          default:
            System.out.println("getPathProbability. from: " + fromServerName + ", to: " + toServerName + " has undefined toServerName.");
            return probability;
        }
      
      case visualdisplay:
        switch (toServerName){
          case visionmoduletrigger:
            double returnProb;
            if (Entity.To.equals("Vision Module") && Entity.Trash == false) returnProb = 1.0;
            else returnProb = 0.0;
            return returnProb;
          default:
            System.out.println("getPathProbability. from: " + fromServerName + ", to: " + toServerName + " has undefined toServerName.");
            return probability;
        }
        
      case visionmoduletrigger:
        switch (toServerName){
          case visionmodule:
            double returnProb;
            if (!Entity.Trash && Entity.To.equals("Vision Module")) returnProb = 1.0;
            else returnProb = 0.0;
            return returnProb;
          case visionmoduletriggerloop:
            double returnProb1;
            if (!Entity.Trash && Entity.To.equals("Vision Module Trigger Loop")) returnProb1 = 1.0;
            else returnProb1 = 0.0;
            return returnProb1;
             
          default:
            System.out.println("getPathProbability. from: " + fromServerName + ", to: " + toServerName + " has undefined toServerName.");
            return probability;
        }
        
      case visionmoduletriggerloop:
        switch (toServerName){
          case visionmoduletrigger:
            double returnProb;
            if (!Entity.Trash) returnProb = 1.0;
            else returnProb = 0.0;
            return returnProb;

          default:
            System.out.println("getPathProbability. from: " + fromServerName + ", to: " + toServerName + " has undefined toServerName.");
            return probability;
        }
        
      case visionmodule:
        switch (toServerName){
          case visuallocationbuffer:
            double returnProb;
            if (Entity.To.equals("Visual-location Buffer")  && Entity.Trash == false) returnProb = 1.0;
            else returnProb = 0.0;
            return returnProb;
          case visualbuffer:
            double returnProb1;
            if (Entity.To.equals("Visual Buffer")  && Entity.Trash == false) returnProb1 = 1.0;
            else returnProb1 = 0.0;
            return returnProb1;
             
          default:
            System.out.println("getPathProbability. from: " + fromServerName + ", to: " + toServerName + " has undefined toServerName.");
            return probability;
        }
        
      case visualbuffer:
        switch (toServerName){
          case triggerbuffer:
            double returnProb;
            if (!Entity.Trash) returnProb = 1.0;
            else returnProb = 0.0;
            return returnProb;
          case declarativemodule:
            double returnProb1 = 0.0;
            return returnProb1;
             
          default:
            System.out.println("getPathProbability. from: " + fromServerName + ", to: " + toServerName + " has undefined toServerName.");
            return probability;
        }
        
      case visuallocationbuffer:
        switch (toServerName){
          case triggerbuffer:
            double returnProb;
            if (Entity.To.equals("Matching And Selection") && !Entity.Trash  ) returnProb = 1.0;
            else returnProb = 0.0;
            return returnProb;
          case visionmodule:
            double returnProb1;
            if (Entity.To.equals("Vision Module") && !Entity.Trash  ) returnProb1 = 1.0;
            else returnProb1 = 0.0;
            return returnProb1;
             
          default:
            System.out.println("getPathProbability. from: " + fromServerName + ", to: " + toServerName + " has undefined toServerName.");
            return probability;
        }
        
      case controltodisplay:
        switch (toServerName){
          case visualandaudiodisplayschedule:
            double returnProb;
            if (Entity.To.equals("Visual and Audio Display Schedule") && Entity.Trash == false) returnProb = 1.0;
            else returnProb = 0.0;
            return returnProb;
             
          default:
            System.out.println("getPathProbability. from: " + fromServerName + ", to: " + toServerName + " has undefined toServerName.");
            return probability;
        }
        
      case controlmotor:
        switch (toServerName){
          case manualbuffer:
            double returnProb = 1.0;
            return returnProb;
          case controltodisplay:
            double returnProb1;
            if (Entity.From.equals("Control Motor") && Entity.To.equals("Control To Display") && Entity.Trash == false) returnProb1 = 1.0;
            else returnProb1 = 0.0;
            return returnProb1;
             
          case controlmotor:
         // loop incremental move entity if it's not finished
            double returnProb2;
            if (Entity.Trash == false && Entity.Chunk.Chunk_Type.equals("move-cursor") && Entity.Chunk.Slot.containsKey("incremental-movements")) returnProb2 = 1.0;
            else returnProb2 = 0.0;
            return returnProb2;
            
          default:
            System.out.println("getPathProbability. from: " + fromServerName + ", to: " + toServerName + " has undefined toServerName.");
            return probability;
        }
        
      case controlvoicekey:
        switch (toServerName){
          case vocalbuffer:
            double returnProb = 1.0;
            return returnProb;
          case controltodisplay:
            double returnProb1;
            if (Entity.From.equals("Control Voice Key") && Entity.To.equals("Control To Display")) returnProb1 = 1.0;
            else returnProb1 = 0.0;
            return returnProb1;
       
          default:
            System.out.println("getPathProbability. from: " + fromServerName + ", to: " + toServerName + " has undefined toServerName.");
            return probability;
        }
        
      case declarativemodule:
        switch (toServerName){
          case retrievalbuffer:
            double returnProb;
            if (!Entity.Trash) returnProb = 1.0;
            else returnProb = 0.0;
            return returnProb;
         
          default:
            System.out.println("getPathProbability. from: " + fromServerName + ", to: " + toServerName + " has undefined toServerName.");
            return probability;
        }
        
      case retrievalbuffer:
        switch (toServerName){
          case declarativemodule:
            double returnProb = 0.0;
            return returnProb;
          case triggerbuffer:
            double returnProb1;
            if (!Entity.Trash) returnProb1 = 1.0;
            else returnProb1 = 0.0;
            return returnProb1;
       
          default:
            System.out.println("getPathProbability. from: " + fromServerName + ", to: " + toServerName + " has undefined toServerName.");
            return probability;
        }
        
      case triggerbuffer:
        switch (toServerName){
          case matchingandselection:
            if (sim.vars.centralParametersModule.Use_Procedural_Resources) {
              double returnProb;
              if (!Entity.Trash && Entity.To.equals("Matching And Selection")) {
                returnProb = 1.0; // "Matching And Selection" server may take multiple entities in QN theory
                
              }
              else returnProb = 0.0;
              return returnProb;
            }
            else{
              double returnProb1;
              if ( (!Entity.Trash && Entity.To.equals("Matching And Selection")) && ( sim.funs.getNumberOfQnactrEntityInServer("matchingandselection") < 1) ) returnProb1 = 1.0; //if there is a matching and selecting cycle going on in a 50ms, end this trigger entity
              else returnProb1 = 0.0;              
              return returnProb1;  
            }
            
          case triggerbufferloop:
            double returnProb1;
            if (!Entity.Trash && Entity.To.equals("Trigger Buffer Loop")) returnProb1 = 1.0;
            else returnProb1 = 0.0;
            return returnProb1;
       
          default:
            System.out.println("getPathProbability. from: " + fromServerName + ", to: " + toServerName + " has undefined toServerName.");
            return probability;
        }
        
      case triggerbufferloop:
        switch (toServerName){
          case triggerbuffer:
            double returnProb;
            if (!Entity.Trash) returnProb = 1.0;
            else returnProb = 0.0;
            return returnProb;
       
          default:
            System.out.println("getPathProbability. from: " + fromServerName + ", to: " + toServerName + " has undefined toServerName.");
            return probability;
        }
        
      case matchingandselection:
        switch (toServerName){
          case execution:
            double returnProb;
            if (!Entity.Trash) returnProb = 1.0;
            else returnProb = 0.0;
            return returnProb;
       
          default:
            System.out.println("getPathProbability. from: " + fromServerName + ", to: " + toServerName + " has undefined toServerName.");
            return probability;
        }
        
      case execution:
        switch (toServerName){
          case triggerbuffer:
            double returnProb;
            if (Entity.Trash == false) returnProb = 1.0;
            else returnProb = 0.0;
            return returnProb;
       
          case declarativemodule:
          case intentionalmodule:
          case goalbuffer:
          case goalbuffer2:
          case imaginarymodule:
          case imaginalbuffer:
          case motormodule:
          case visualbuffer:
          case speechmodule:
          case temporalmodule:
        //pass is for visualization, in fact, use direct entity cast 
          return 0.0;
          
          default:
            System.out.println("getPathProbability. from: " + fromServerName + ", to: " + toServerName + " has undefined toServerName.");
            return probability;
        }
        
      case motormodule:
        switch (toServerName){
          case manualbuffer:
            double returnProb;
            if (Entity.Trash == false) returnProb = 1.0;
            else returnProb = 0.0;
            return returnProb;
          case motorpreparation:
            double returnProb1;
            if (Entity.To.equals("Motor Preparation") && Entity.Trash == false) returnProb1 = 1.0;
            else returnProb1 = 0.0;
            return returnProb1;
       
          default:
            System.out.println("getPathProbability. from: " + fromServerName + ", to: " + toServerName + " has undefined toServerName.");
            return probability;
        }
        
      case motorpreparation:
        switch (toServerName){
          case manualbuffer:
            double returnProb;
            if (Entity.Trash == false) returnProb = 1.0;
            else returnProb = 0.0;
            return returnProb;
          case motorinitiation:
            double returnProb1;
            if (Entity.To.equals("Motor Initiation") && Entity.Trash == false) returnProb1 = 1.0;
            else returnProb1 = 0.0;
            return returnProb1;
       
          default:
            System.out.println("getPathProbability. from: " + fromServerName + ", to: " + toServerName + " has undefined toServerName.");
            return probability;
        }
        
      case motorinitiation:
        switch (toServerName){
          case manualbuffer:
            double returnProb;
            if (Entity.Trash == false) returnProb = 1.0;
            else returnProb = 0.0;
            return returnProb;
          case motorexecution:
            double returnProb1;
            if (Entity.To.equals("Motor Execution") && Entity.Trash == false) returnProb1 = 1.0;
            else returnProb1 = 0.0;
            return returnProb1;
       
          default:
            System.out.println("getPathProbability. from: " + fromServerName + ", to: " + toServerName + " has undefined toServerName.");
            return probability;
        }
        
      case motorexecution:
        switch (toServerName){
          case manualbuffer:
            
            return 1.0;
          case controlmotor:
            
            return 0.0;
       
          default:
            System.out.println("getPathProbability. from: " + fromServerName + ", to: " + toServerName + " has undefined toServerName.");
            return probability;
        }
        
      case manualbuffer:
        switch (toServerName){
          case triggerbuffer:
            
            return 1.0;
          case motorinitiation:
            
            return 0.0;
       
          default:
            System.out.println("getPathProbability. from: " + fromServerName + ", to: " + toServerName + " has undefined toServerName.");
            return probability;
        }
        
      case speechmodule:
        switch (toServerName){
          case vocalbuffer:

            return 1.0;
          case speechpreparation:
            double returnProb1;
            if (Entity.To.equals("Speech Preparation") && Entity.Trash == false) returnProb1 = 1.0;
            else returnProb1 = 0.0;
            return returnProb1;
       
          default:
            System.out.println("getPathProbability. from: " + fromServerName + ", to: " + toServerName + " has undefined toServerName.");
            return probability;
        }
        
      case speechpreparation:
        switch (toServerName){
          case vocalbuffer:

            return 1.0;
          case speechinitiation:
            double returnProb1;
            if (Entity.To.equals("Speech Initiation") && Entity.Trash == false) returnProb1 = 1.0;
            else returnProb1 = 0.0;
            return returnProb1;
       
          default:
            System.out.println("getPathProbability. from: " + fromServerName + ", to: " + toServerName + " has undefined toServerName.");
            return probability;
        }
        
      case speechinitiation:
        switch (toServerName){
          case vocalbuffer:

            return 1.0;
          case speechexecution:
            double returnProb1;
            if (Entity.To.equals("Speech Execution") && Entity.Trash == false) returnProb1 = 1.0;
            else returnProb1 = 0.0;
            return returnProb1;
       
          default:
            System.out.println("getPathProbability. from: " + fromServerName + ", to: " + toServerName + " has undefined toServerName.");
            return probability;
        }
        
      case speechexecution:
        switch (toServerName){
          case vocalbuffer:

            return 1.0;
            
          case controlvoicekey:
          case audiodisplay:

            return 0.0;
       
          default:
            System.out.println("getPathProbability. from: " + fromServerName + ", to: " + toServerName + " has undefined toServerName.");
            return probability;
        }
        
      case vocalbuffer:
        switch (toServerName){
          case triggerbuffer:

            return 1.0;
            
          default:
            System.out.println("getPathProbability. from: " + fromServerName + ", to: " + toServerName + " has undefined toServerName.");
            return probability;
        }
        
      case audiodisplay:
        switch (toServerName){
          case audiomodule:
            double returnProb;
            if (Entity.To.equals("Audio Module") && Entity.Trash == false ) returnProb = 1.0;
            else returnProb = 0.0;
            return returnProb;
         
          default:
            System.out.println("getPathProbability. from: " + fromServerName + ", to: " + toServerName + " has undefined toServerName.");
            return probability;
        }
        
      case audiomodule:
        switch (toServerName){
          case auralbuffer:
            double returnProb;
            if (Entity.To.equals("Aural Buffer")) returnProb = 1.0;
            else returnProb = 0.0;
            return returnProb;
          case aurallocationbuffer:
            double returnProb1;
            if (Entity.To.equals("Aural-location Buffer")) returnProb1 = 1.0;
            else returnProb1 = 0.0;
            return returnProb1;
       
          default:
            System.out.println("getPathProbability. from: " + fromServerName + ", to: " + toServerName + " has undefined toServerName.");
            return probability;
        }
        
      case auralbuffer:
        switch (toServerName){
          case triggerbuffer:
            double returnProb;
            if (Entity.To.equals("Matching And Selection")) returnProb = 1.0;
            else returnProb = 0.0;
            return returnProb;
         
          default:
            System.out.println("getPathProbability. from: " + fromServerName + ", to: " + toServerName + " has undefined toServerName.");
            return probability;
        }
        
      case aurallocationbuffer:
        switch (toServerName){
          case triggerbuffer:
            double returnProb;
            if (Entity.To.equals("Matching And Selection")) returnProb = 1.0;
            else returnProb = 0.0;
            return returnProb;
         
          default:
            System.out.println("getPathProbability. from: " + fromServerName + ", to: " + toServerName + " has undefined toServerName.");
            return probability;
        }
        
      case intentionalmodule:
        switch (toServerName){
          case goalbuffer:
            double returnProb;
            if (Entity.To.equals("Goal Buffer")) returnProb = 1.0;
            else returnProb = 0.0;
            return returnProb;
          case goalbuffer2:
            double returnProb1;
            if (Entity.To.equals("Goal Buffer-2")) returnProb1 = 1.0;
            else returnProb1 = 0.0;
            return returnProb1;
       
          default:
            System.out.println("getPathProbability. from: " + fromServerName + ", to: " + toServerName + " has undefined toServerName.");
            return probability;
        }
        
      case goalbuffer:
        switch (toServerName){
          case declarativemodule:

            return 0.0;
            
          case triggerbuffer:
            double returnProb1;
            if (!Entity.Trash) returnProb1 = 1.0;
            else returnProb1 = 0.0;
            return returnProb1;
       
          default:
            System.out.println("getPathProbability. from: " + fromServerName + ", to: " + toServerName + " has undefined toServerName.");
            return probability;
        }
        
      case goalbuffer2:
        switch (toServerName){
          case declarativemodule:

            return 0.0;
            
          case triggerbuffer:
            double returnProb1;
            if (!Entity.Trash) returnProb1 = 1.0;
            else returnProb1 = 0.0;
            return returnProb1;
       
          default:
            System.out.println("getPathProbability. from: " + fromServerName + ", to: " + toServerName + " has undefined toServerName.");
            return probability;
        }
        
      case imaginarymodule:
        switch (toServerName){
          case imaginalbuffer:

            return 1.0;

          default:
            System.out.println("getPathProbability. from: " + fromServerName + ", to: " + toServerName + " has undefined toServerName.");
            return probability;
        }
        
      case imaginalbuffer:
        switch (toServerName){
          case declarativemodule:

            return 0.0;
            
          case triggerbuffer:
            double returnProb;
            if (!Entity.Trash) returnProb = 1.0;
            else returnProb = 0.0;
            return returnProb;
       
          default:
            System.out.println("getPathProbability. from: " + fromServerName + ", to: " + toServerName + " has undefined toServerName.");
            return probability;
        }
        
      case temporalmodule:
        switch (toServerName){
          case temporalbuffer:
            double returnProb;
            if (!Entity.Trash) {
              returnProb = 1.0;
            }
            else returnProb = 0.0;
            return returnProb;
            
          case temporalmodule:
         // only let increments loop. clears and modifies only go to buffer
            double returnProb1;
            if (Entity.Entity_Type.equals("Increment Temporal") || Entity.Entity_Type.equals("Request Temporal")) {
              
              returnProb1 = 1.0; 
            }
            else returnProb1 = 0.0;
            return returnProb1;
       
          default:
            System.out.println("getPathProbability. from: " + fromServerName + ", to: " + toServerName + " has undefined toServerName.");
            return probability;
        }
        
      case temporalbuffer:
        switch (toServerName){
          case triggerbuffer:
            double returnProb;
            if (!Entity.Trash) returnProb = 1.0;
            else returnProb = 0.0;
            return returnProb;
       
          default:
            System.out.println("getPathProbability. from: " + fromServerName + ", to: " + toServerName + " has undefined toServerName.");
            return probability;
        }
        
        
      case recurrentevent:
        switch (toServerName){
          case recurrentevent:
            double returnProb;
            if (!Entity.Trash) returnProb = 1.0;
            else returnProb = 0.0;
            return returnProb;
       
          case exit:

            if (!Entity.Trash) returnProb = 0.0;
            else returnProb = 1.0;
            return returnProb;
       
          default:
            System.out.println("getPathProbability. from: " + fromServerName + ", to: " + toServerName + " has undefined toServerName.");
            return probability;
        }
        
      case world3dcyclicrefresh:
    	  switch (toServerName){
          case world3dcyclicrefresh:
            double returnProb;
            if (!Entity.Trash) returnProb = 1.0;
            else returnProb = 0.0;
            return returnProb;
       
          case exit:

            if (!Entity.Trash) returnProb = 0.0;
            else returnProb = 1.0;
            return returnProb;
       
          default:
            System.out.println("getPathProbability. from: " + fromServerName + ", to: " + toServerName + " has undefined toServerName.");
            return probability;
        }
          
      default:
        System.out.println("getPathProbability. from: " + fromServerName + ", to: " + toServerName + " has undefined fromServerName.");
        return probability;
    }
  }
}
