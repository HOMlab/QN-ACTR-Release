/**
 * 2013 QN-Java project file
 * 
 */

package qnactr.sim;

import qnactr.objectDesigner.*;

import java.awt.Color;
import java.util.*;
import java.util.Map.Entry;

import jmt.common.exception.NetException;
import jmt.engine.NodeSections.Server;
import jmt.engine.QueueNet.Job;
import jmt.engine.QueueNet.JobInfo;
import jmt.engine.QueueNet.LinkedJobInfoList;
import jmt.engine.QueueNet.NetEvent;
import jmt.engine.QueueNet.NetNode;
import jmt.engine.QueueNet.NodeSection;
import jmt.engine.QueueNet.JobClass;
import jmt.engine.simEngine.RemoveToken;
import jmt.engine.simEngine.SimSystem;
import jmt.gui.common.animation.Animator;

import java.io.IOException;

import javax.media.j3d.Transform3D;
import javax.vecmath.Vector3f;

import org.apache.poi.ss.usermodel.Sheet;

import jmt.engine.NodeSections.Queue;

/**
 * here are the functions/methods at the global level of an HMI representation,
 * like the "Model" simulation engine functions,
 * especially when the methods are difficult to be included in any variable/object.
 * 
 * @author shicao
 *
 */
public class Functions {
  
  QnactrSimulation sim;  
  
  public Functions(QnactrSimulation Sim){
    sim = Sim;
  }
  
  //JMT Functions
  
  /**
   * immediately remove an Entity in a queue.
   * @param queueLocalName, lower case no space, e.g., just "visionmodule"
   * @param entityTag, the unique Tag number of an QN Entity
   */
  public void abortEntityInQueue(String queueLocalName, int entityTag) {
    
    LinkedList<Entity> entities = sim.funs.getLinkedListOfQnactrEntityInQueue(queueLocalName);
    Iterator<Entity> itr_entities = entities.iterator();
    
    int removeEntityTag = entityTag;
    
    while (itr_entities.hasNext()){
      Entity anEntity = itr_entities.next();
      if(anEntity.Tag == removeEntityTag){
        
        Queue queueSection = null;
        try
        {
          queueSection =  ((Queue)sim.funs.getServerNetNodeWithServerLocalName(queueLocalName).getSection(NodeSection.INPUT));
        } catch (NetException e)
        {
          e.printStackTrace();
        }
       
        JobInfo targetJobInfo = null;
        Iterator<JobInfo> itrJobInfo = ((LinkedJobInfoList)queueSection.getQueueJobInfoList()).getInternalList().iterator();
        while (itrJobInfo.hasNext()){
          JobInfo aJobInfo = itrJobInfo.next();
          if(aJobInfo.getJob().qnactrEntity.Tag == removeEntityTag) {
            targetJobInfo = aJobInfo;
            break;
          }          
        }
        
        try
        {
          queueSection.getQueueJobInfoList().remove(targetJobInfo);
        } catch (NetException e)
        {
          e.printStackTrace();
        }
        
        anEntity.updateCurrentPlace(Enums.EntityPlaceHeader.abortedfrom, null, null); //QN-Java
        anEntity.Trash = true;
        break; // Entity Tag is unique, so can only remove one Entity with the target entity tag.
      }
    }
  }
  
 
  public void abortEntityInServer(String serverLocalName, int entityTag){
    
    String targetServerLocalName = serverLocalName;
    int removeEntityTag = entityTag; 
    
    NetNode serverOwnerNode = sim.funs.getServerNetNodeWithServerLocalName(targetServerLocalName);
    Server server = null;
    try
    {
      server = (Server) serverOwnerNode.getSection(NodeSection.SERVICE);
    } catch (NetException e)
    {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
    LinkedList<Entity> entities =  sim.funs.getLinkedListOfQnactrEntityInServer(targetServerLocalName);
    Iterator<Entity> itr_entities = entities.iterator();
    
    while (itr_entities.hasNext()){
      Entity anEntity = itr_entities.next();
      
      if(anEntity.Tag == removeEntityTag){
        
        //1. abort future event queue
        RemoveToken token = server.removeTokensInServer.remove(removeEntityTag); //server.removeTokensInServer.get(removeEntityTag);
        SimSystem.remove(token);
        
        //1.1 remove job from server. JobInfoList
        JobInfo jobInfo = null;
        try
        {
          jobInfo = serverOwnerNode.getJobInfoList().lookFor(anEntity.ownerJob);
        } catch (NetException e)
        {
          // TODO Auto-generated catch block
          e.printStackTrace();
        }

        if (jobInfo != null) {
          
          try
          {
            serverOwnerNode.getJobInfoList().remove(jobInfo);
          } catch (NetException e)
          {
            // TODO Auto-generated catch block
            e.printStackTrace();
          }
        }
        
        //2. qnactrEntityInServer.remove(job.qnactrEntity.Tag);
        server.qnactrEntityInServer.remove(removeEntityTag);
        
        //3. sendBackward(NetEvent.EVENT_ACK, message.getJob(), 0.0);
        try
        {
          server.publicSendBackward(NetEvent.EVENT_ACK, anEntity.ownerJob, 0.0);
        } catch (NetException e)
        {
          // TODO Auto-generated catch block
          e.printStackTrace();
        }
        
        anEntity.Trash = true;
        anEntity.updateCurrentPlace(Enums.EntityPlaceHeader.abortedfrom, null, null); //QN-Java
        
        break;
      }
      
    } //end of if(anEntity.Tag == removeEntityTag)
    
    
    
  }
  
  /**
   * create and start an QN entity with delay in this QnactrSimulation HMI
   * create new entity in the same HMI ID as the calling sim
   * include settings for .Time, .Tag, .From, .To, .Entity_Type
   * @param  createAtServerName, fromServerName, toServerName :  e.g., "Audio Display"
   * 
   * @return the job so that other properties can be further added.
   * 
   */
  public Entity createEntity(String createAtServerLocalName, String fromServerName, String toServerName, String inputEntityType, double delay){
    
    String createAtServerName = serverLocalNameToGlobalName(createAtServerLocalName);
    
    
    JobClass[] jobClasses = sim.simJMT.getClasses() ;
    if (jobClasses.length < 1){
      System.err.println("Error! createEntity method has jobClasses.length < 1: " + jobClasses.length);
      return null;
    }
    
    //currently just use any jobClass to create the qnEntity
    //TODO: add Task type. Task_ i use [i - 1].
    Job job = new Job(jobClasses[0]);
    
    Entity Temp_Entity = job.qnactrEntity;
        
    //  Temp_Entity.ID = "";  // XXX currently no ID number string associated with Server name.
    Temp_Entity.Time = SimSystem.clock();
    
    //Temp_Entity.Tag = QnactrSimulation.entityNumber; //give it an entity number, init. 1
    //QnactrSimulation.entityNumber++;
    
    Temp_Entity.From = fromServerName; //tag from and to
    Temp_Entity.To = toServerName;
    Temp_Entity.Entity_Type = inputEntityType;  
    
    Temp_Entity.hmiID = Integer.toString(sim.ID); 
    
    
    //back link to job
    Temp_Entity.ownerJob = job;
    
    //find the server
    try
    {

      //      System.out.println("createEntity fun has createAtServerName: " + createAtServerName);
      
      sim.simJMT.getNetwork().getNode(createAtServerName).getSection(NodeSection.INPUT).publicSendMe(job, delay);
    } catch (NetException e)
    {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
    
    
    job.qnactrEntity.updateCurrentPlace(Enums.EntityPlaceHeader.goingto, Enums.ServerName.valueOf(GlobalUtilities.stringLowNoSpace(createAtServerLocalName)), Enums.NodeSection.queue);
    
    return job.qnactrEntity;
        
  }
  

  /**
   * create and start an JMT ACK event with delay in this QnactrSimulation HMI, 
   * i.e., in the same HMI ID as the calling sim
   * mainly used for motor resource coding, i.e., motor initiation and motor execution together have some limited resources, handled in their release conditions. 
   * need ACK event sending to allow motor initiation to release any queued items.
   * @param toServerName, e.g., "Audio Display"
   * @param delay, in second
   */
  public void sendAckToQueue(String toServerName, double delay){
	  String targetServerName = serverLocalNameToGlobalName(toServerName);
	  try
	    {
	      sim.simJMT.getNetwork().getNode(targetServerName).getSection(NodeSection.INPUT).publicAckMe(null, delay);  // queue section is INPUT
	    } catch (NetException e)
	    {
	      // TODO Auto-generated catch block
	      e.printStackTrace();
	    }	  
  }
    
  /**
   * 
   * @param serverLocalName, lower case no space, e.g., just "visionmodule".
   * @return
   */
  public NetNode getServerNetNodeWithServerLocalName (String serverLocalName){
    String serverGlobalName = serverLocalNameToGlobalName ( serverLocalName ); 
    return QnactrSimulation.globalAllNetNodesTable.get(serverGlobalName);
  }
  
  /**
   * 
   * @param serverLocalName, lower case no space, e.g., just "visionmodule"
   * @return
   */
  public int getNumberOfQnactrEntityInServerAndQueue(String serverLocalName){
    return getNumberOfQnactrEntityInServer(serverLocalName) + getNumberOfQnactrEntityInQueue(serverLocalName);
  }
  
  /**
   * 
   * @param serverLocalName , lower case no space, e.g., just "visionmodule"
   * @return
   */
  public LinkedList<Entity> getLinkedListOfQnactrEntityInServerAndQueue(String serverLocalName){
    return ProgramUtilitiesFun__LinkedListEntity_Append(getLinkedListOfQnactrEntityInQueue(serverLocalName) ,getLinkedListOfQnactrEntityInServer(serverLocalName));
  }

  
  /**
   * 
   * @param serverLocalName, lower case no space, e.g., just "visionmodule"
   * @return
   */
  public int getNumberOfQnactrEntityInServer(String serverLocalName){
    return getLinkedListOfQnactrEntityInServer(serverLocalName).size();
  }
  
  /**
   * 
   * @param serverLocalName, lower case no space, e.g., just "visionmodule"
   * @return
   */
  public LinkedList<Entity> getLinkedListOfQnactrEntityInServer(String serverLocalName){

    LinkedList<Entity> returnList = new LinkedList<Entity>();
    Server server = null;
    try
    {
      server =  ((Server)sim.funs.getServerNetNodeWithServerLocalName(serverLocalName).getSection(NodeSection.SERVICE));
    } catch (NetException e)
    {
      e.printStackTrace();
      return null;
    }
    
    Iterator <Entry<Integer, Entity>> itr_entries = server.qnactrEntityInServer.entrySet().iterator();
    while (itr_entries.hasNext()){
      Entry<Integer, Entity> anEntry = itr_entries.next();
      returnList.addLast(anEntry.getValue());
    }
    return returnList;
  }
  
  /**
   * 
   * @param queueLocalName, lower case no space, e.g., just "visionmodule"
   * @return
   */
  public int getNumberOfQnactrEntityInQueue(String queueLocalName){
    Queue queueSection = null;
    try
    {
      queueSection =  ((Queue)sim.funs.getServerNetNodeWithServerLocalName(queueLocalName).getSection(NodeSection.INPUT));
    } catch (NetException e)
    {
      e.printStackTrace();
    }
    
    int returnInt = -1;
    
    try
    {
      returnInt = queueSection.getQueueJobInfoList().size();
    } catch (NetException e)
    {
      e.printStackTrace();
    }
    
    return returnInt;
  }
  
  /**
   * 
   * @param queueLocalName, lower case no space, e.g., just "visionmodule"
   * @return
   */
  public LinkedList<Entity> getLinkedListOfQnactrEntityInQueue(String queueLocalName){

    LinkedList<Entity> returnList = new LinkedList<Entity>();
    Queue queueSection = null;
    try
    {
      queueSection =  ((Queue)sim.funs.getServerNetNodeWithServerLocalName(queueLocalName).getSection(NodeSection.INPUT));
    } catch (NetException e)
    {
      e.printStackTrace();
      return null;
    }
   
    Iterator<JobInfo> itrJobInfo = ((LinkedJobInfoList)queueSection.getQueueJobInfoList()).getInternalList().iterator();
    while (itrJobInfo.hasNext()){
      JobInfo aJobInfo = itrJobInfo.next();
      returnList.addLast(aJobInfo.getJob().qnactrEntity);
    }
    
    return returnList;
  }
  
  public int getServerCapacity(String serverLocalName){
    int returnInt = 0;
    
    try
    {
      returnInt = getServerNetNodeWithServerLocalName(serverLocalName.toString()).getSection(NodeSection.SERVICE).getIntSectionProperty(Server.PROPERTY_ID_MAX_JOBS);
    } catch (NetException e)
    {
      e.printStackTrace();
    }
    
    return returnInt;
    
  }
  

  public String serverLocalNameToGlobalName (String serverLocalName){
    return serverLocalName + "_" + sim.ID;
  }
  
  //AnimatorModuleFun
  
	public void AnimatorModuleFun__Add_Audicon(Chunk the_audicon_chunk){
		
		// sound plugin error
	  System.out.println("TODO SoundPlugin AnimatorModuleFun__Add_Audicon");
	  
	  
		if( sim.vars.animatorModule.Show_Animator == false) return;

		// really play the sound through loud speaker.
		String audicon_type = the_audicon_chunk.Chunk_Type; 
		//System.out.println(audicon_type);

		String kind = sim.funs.ChunkFun__Get_Chunk_Slot_Value( the_audicon_chunk, "kind");
		//System.out.println(  kind );

		if(kind.equals( "tone")){
			String frequency_string = sim.funs.ChunkFun__Get_Chunk_Slot_Value(the_audicon_chunk, "content");
			if( sim.funs.ProgramUtilitiesFun__Is_String_Double ( frequency_string ) == false) System.err.println("Error! AnimatorModuleFun__Add_Audicon has frequency_string not a number but: " + frequency_string);
			double frequency = Double.parseDouble( frequency_string );
			
			String audio_event_chunk_name = sim.funs.ChunkFun__Get_Chunk_Slot_Value(the_audicon_chunk, "event") ;
			Chunk audio_event_chunk = (Chunk) sim.vars.centralParametersModule.Chunks.get(audio_event_chunk_name);
			
			String duration_string = sim.funs.ChunkFun__Get_Chunk_Slot_Value(audio_event_chunk, ":duration" );
			if( sim.funs.ProgramUtilitiesFun__Is_String_Double ( duration_string ) == false) System.err.println("Error! AnimatorModuleFun__Add_Audicon has duration_string not a number but: " + duration_string);
			double duration = Double.parseDouble( duration_string );
			
			//System.out.println( frequency  + " " + duration * 1000);
			
			if(sim.vars.animatorModule.Play_Sound_Through_Speaker) {
				//old version. 
				/*
				frequency
				Type: System.Int32
				The frequency of the beep, ranging from 37 to 32767 hertz.
				duration
				Type: System.Int32
				The duration of the beep measured in milliseconds.
				*/	
				//Console.Beep( frequency, (int) (duration * 1000 ) ); //this beep will pause the simulation, which is just for animation. This will not affect the result of simulation.
				//System.out.println( "AnimatorModuleFun__Add_Audicon: kind = " + kind );
				
			  
			  
				//new version.  
			  
			  //TODO
//			  SoundPlugin.BackgroundBeep( frequency, (int) (duration * 1000 ) );  //this will play the beep in a new thread, not pausing the simulation.
			  
			}
				
		}
		else if (kind.equals( "digit" )){
			if(sim.vars.animatorModule.Vocalize_Speech){
				String content = sim.funs.ChunkFun__Get_Chunk_Slot_Value(the_audicon_chunk, "content");
				// Sound_Plugin.SelectVoiceForTextToSpeech set in Event_00_Set_QN_Parameters
			//TODO // Sound_Plugin.SetSpeechRate(0); // int -10 to 10
			//TODO // Sound_Plugin.TextToSpeech(content);
			}
		}

		else if (kind.equals( "word" )){
			String location = sim.funs.ChunkFun__Get_Chunk_Slot_Value( the_audicon_chunk, "location");
			//System.out.println(location);
			if(location.equals( "external-from-sentence")) {
				// do not vocalize a word in sentence, because it is vocalized in the sentence as a whole.// for external-from-sentence, it is vocalized as a whole sentence in TaskTemplateFun__Show_Display_Item_Display
			}
			else if(sim.vars.animatorModule.Vocalize_Speech){ 
				String content = sim.funs.ChunkFun__Get_Chunk_Slot_Value(the_audicon_chunk, "content");
				// Sound_Plugin.SelectVoiceForTextToSpeech set in Event_00_Set_QN_Parameters
			//TODO // Sound_Plugin.SetSpeechRate(0); // int -10 to 10
			//TODO // Sound_Plugin.TextToSpeech(content);
			}
		}
	}
	
	public void AnimatorModuleFun__Add_Visicon(Chunk the_vicison_chunk){
		
	  
	  
	  
		if( sim.vars.animatorModule.Show_Animator == false) return;
		//ChunkFun__Popout_Message_Show_Chunk_Contents(the_vicison_chunk );
		String visicon_type = the_vicison_chunk.Chunk_Type; 

		//common part:
			String color_on_animator = "";
			color_on_animator = sim.funs.ChunkFun__Get_Chunk_Slot_Value( the_vicison_chunk, "color").toLowerCase();

			String visual_location_screen_pos = sim.funs.ChunkFun__Get_Chunk_Slot_Value(the_vicison_chunk, "screen-pos") ;
			Chunk visual_location_chunk = (Chunk) sim.vars.centralParametersModule.Chunks.get(visual_location_screen_pos);
			String location_x_on_animator = sim.funs.ChunkFun__Get_Chunk_Slot_Value(visual_location_chunk, "screen-x");
			String location_y_on_animator = sim.funs.ChunkFun__Get_Chunk_Slot_Value(visual_location_chunk, "screen-y");
			if( sim.funs.ProgramUtilitiesFun__Is_String_Double(location_x_on_animator) == false )System.err.println("Error! AnimatorModuleFun__Add_Visicon has location_x_on_animator not a number");
			if( sim.funs.ProgramUtilitiesFun__Is_String_Double(location_y_on_animator) == false )System.err.println("Error! AnimatorModuleFun__Add_Visicon has location_y_on_animator not a number");

			double location_x_double_on_animator = Double.parseDouble( location_x_on_animator) ;
			double location_y_double_on_animator = Double.parseDouble ( location_y_on_animator) ;
			
			String height = sim.funs.ChunkFun__Get_Chunk_Slot_Value(visual_location_chunk, "height");
			String width  = sim.funs.ChunkFun__Get_Chunk_Slot_Value(visual_location_chunk, "width");
			if( sim.funs.ProgramUtilitiesFun__Is_String_Double(height) == false )System.err.println("Error! AnimatorModuleFun__Add_Visicon has height not a number, but: " + height);
			if( sim.funs.ProgramUtilitiesFun__Is_String_Double(width) == false )System.err.println("Error! AnimatorModuleFun__Add_Visicon has width not a number, but: " + width);
			int height_int = Integer.parseInt( height);
			int width_int = Integer.parseInt( width);





		if( visicon_type.equals( "text")){ // currently does not need height and width
			String text_on_animator = "";
			text_on_animator = sim.funs.ChunkFun__Get_Chunk_Slot_Value( the_vicison_chunk, "value");
		
			//remove a pair of quotation marks, e.g., "Test"  ->  Test
			if(!text_on_animator.equals("") && text_on_animator.charAt(0) == '\"' ){
			  text_on_animator = text_on_animator.substring(1);
			}
			if(!text_on_animator.equals("") && text_on_animator.charAt(text_on_animator.length()-1) == '\"' ){
			  text_on_animator = text_on_animator.substring(0, text_on_animator.length() - 1);
			}
			
			//create comment with the text
			
			//Animator offset
			location_x_double_on_animator -=   GlobalUtilities.round( ((double) width_int / 2.0 ),0 ) - 1;
			location_y_double_on_animator -=  GlobalUtilities.round( ((double) height_int / 2.0 ),0 ) - 1;
			
			//			System.out.println("AnimatorModuleFun__Add_Visicon has " + text_on_animator);  
			//	    System.out.println("AnimatorModuleFun__Add_Visicon has text_on_animator.Length: "+ text_on_animator.length());	
			//	    System.out.println("AnimatorModuleFun__Add_Visicon has location_x_double_on_animator: " + location_x_double_on_animator);
			
			if(QnactrSimulation.taskVisualization2DEnable){
			  String comment_id = sim.vars.taskVisualization2D.createDynamicText(text_on_animator, (int) location_x_double_on_animator, (int) location_y_double_on_animator); //here create a comment whose left-top cornor is x, y
			  //C# // String comment_id = Animator.CreateComment(location_x_double_on_animator, location_y_double_on_animator , text_on_animator ); //here create a comment whose left-top cornor is x, y
			  
			  //set text color
			  sim.vars.taskVisualization2D.setDynamicTextColor(comment_id, color_on_animator);
			  //C# // Animator.SetCommentTextColor( comment_id, System.Drawing.Color.FromName( color_on_animator ) );
			  
			  //set default comment background and boarder 
			  
			  // I think they are currently by default. ??
			  //?? // Animator.SetCommentBackgroundColor( comment_id , Color.TRANSLUCENT );
			  //?? // Animator.SetCommentBorderColor( comment_id , Color.TRANSLUCENT );
			  
			  //add the display item to the list
			  if( sim.vars.animatorModule.Visicon_Name_Comment_ID_Table.containsKey(the_vicison_chunk.Chunk_Name )) System.out.println("WARNING! in AnimatorModuleFun__Add_Visicon type: " + visicon_type + " , sim.vars.animatorModule.Visicon_Name_Comment_ID_Table.ContainsKey(the_vicison_chunk.Chunk_Name )");
			  sim.vars.animatorModule.Visicon_Name_Comment_ID_Table.put( the_vicison_chunk.Chunk_Name , comment_id);
			}
		} //text

		
		/*
		else if( visicon_type.equals( "oval")){ // in fact, this is box rather than oval, like in ACT-R. // need to do height and width
			//create comment with the text
			String text_on_animator = "";
			text_on_animator = sim.funs.ChunkFun__Get_Chunk_Slot_Value( the_vicison_chunk, "value");
			
			//remove a pair of quotation marks, e.g., "Test"  ->  Test
			if(text_on_animator[0] == '\"' ){text_on_animator = text_on_animator.Remove(0,1);}
			if(text_on_animator[text_on_animator.Length-1] == '\"' ){text_on_animator = text_on_animator.Remove(text_on_animator.Length-1,1);}
			
			//Animator offset
			location_x_double_on_animator -=   GlobalUtilities.round( ((double) width_int / 2.0 ) , 0 ) ;
			location_y_double_on_animator -=   GlobalUtilities.round( ((double) height_int / 2.0 ) , 0 ) ;
			String comment_id = Animator.CreateComment(location_x_double_on_animator, location_y_double_on_animator ,  text_on_animator);
			
			//set oval color
			switch ( color_on_animator.ToLower() ){
				case "gray" :
					Animator.SetCommentBackgroundColor( comment_id, Color.Gray );
					break;
				case "green" :
					Animator.SetCommentBackgroundColor( comment_id, Color.Green );
					break;
				case "red" :
					Animator.SetCommentBackgroundColor( comment_id, Color.Red );
					break;
				default: 
					System.out.println("Error! AnimatorModuleFun__Add_Visicon type: " + visicon_type + " has undefined color code: " + color_on_animator );
					return;
					break;
			}
			
			Animator.SetCommentTextColor(comment_id, Color.Transparent);
			
			
			
			//add the display item to the list
			if( sim.vars.animatorModule.Visicon_Name_Comment_ID_Table.ContainsKey(the_vicison_chunk.Chunk_Name )) System.out.println("WARNING! in AnimatorModuleFun__Add_Visicon type: " + visicon_type + " , sim.vars.animatorModule.Visicon_Name_Comment_ID_Table.ContainsKey(the_vicison_chunk.Chunk_Name )");
			sim.vars.animatorModule.Visicon_Name_Comment_ID_Table.Add( the_vicison_chunk.Chunk_Name , comment_id);


			//System.out.println("ToDo in AnimatorModuleFun__Add_Visicon oval" );
		} //oval

		*/

		else if( visicon_type.equals( "oval")){ // in fact, this is box rather than oval, like in ACT-R.
		  
			//String source_ID = "24"; //gray 2, black is not OK.
			int h = height_int;
			int w = width_int;
			int x = (int) (location_x_double_on_animator - GlobalUtilities.round( ((double) width_int / 2.0 ),0 ) ); 
			int y = (int) (location_y_double_on_animator - GlobalUtilities.round( ((double) height_int / 2.0 ),0 ) );

			//set color
			// data.FilterColor = System.Drawing.Color.FromName( color_on_animator );  //Does QN-Java need this? GlobalUtilities.colorStringToColorType ? 
			Color color = GlobalUtilities.colorStringToColorType (color_on_animator);
			
			if(QnactrSimulation.taskVisualization2DEnable){
			  String image_ID = sim.vars.taskVisualization2D.createDynamicRect(x, y, w, h, color);
			  
			  //			System.out.println("location_x_double_on_animator: " + location_x_double_on_animator + "location_y_double_on_animator: " + location_y_double_on_animator + "CenterX: " + Animator.GetImage(image_ID).CenterX  + ", X: " + Animator.GetImage(image_ID).X );
			  
			  //add the display item to the list
			  if( sim.vars.animatorModule.Visicon_Name_Image_ID_Table.containsKey(the_vicison_chunk.Chunk_Name )) System.out.println("WARNING! in AnimatorModuleFun__Add_Visicon type: " + visicon_type + " , sim.vars.animatorModule.Visicon_Name_Image_ID_Table.ContainsKey(the_vicison_chunk.Chunk_Name )");
			  sim.vars.animatorModule.Visicon_Name_Image_ID_Table.put( the_vicison_chunk.Chunk_Name , image_ID);
			}
			
		}

		/*
		else if( visicon_type.equals( "line")){ //line
			String source_ID = "24"; //gray 2, black is not OK.
			ImageData data = new ImageData (source_ID, location_x_double_on_animator , location_y_double_on_animator ); //since this x, y in new ImageData is for center before rescale, need to assigne X, Y, below for the left top corner

			
			int height_min;
			if (height_int > 3) height_min = height_int;
			else height_min = 3;
			
			int width_min;
			if (width_int > 3) width_min = width_int;
			else width_min = 3;
			
			data.Height = height_min;
			data.Width = width_min;
			
			data.X = location_x_double_on_animator - GlobalUtilities.round( ((double) width_int / 2.0 ) , 0 ) + 31; // +31 because source_ID = "24" is 64 by 64 by default
			data.Y = location_y_double_on_animator - GlobalUtilities.round( ((double) height_int / 2.0 ) , 0 ) + 31;

			//set color
			data.FilterColor = System.Drawing.Color.FromName( color_on_animator ); 
			//

			data.Angle =  Math.Atan2( height_int, width_int ) / Math.PI * 180 ;
			
			String image_ID = Animator.CreateImage( data ) ;
		//System.out.println(Animator.GetImage(image_ID).Angle);	
			double rotation_angle = Math.Atan2( height_int, width_int );
		//System.out.println ( rotation_angle );	 //in radians
//			Animator.RotateImage( image_ID , rotation_angle );
			
			
			//add the display item to the list
			if( sim.vars.animatorModule.Visicon_Name_Image_ID_Table.ContainsKey(the_vicison_chunk.Chunk_Name )) System.out.println("WARNING! in AnimatorModuleFun__Add_Visicon type: " + visicon_type + " , sim.vars.animatorModule.Visicon_Name_Image_ID_Table.ContainsKey(the_vicison_chunk.Chunk_Name )");
			sim.vars.animatorModule.Visicon_Name_Image_ID_Table.Add( the_vicison_chunk.Chunk_Name , image_ID);
			
		}
		*/


		else if( visicon_type.equals( "line")){ //line

		  int x = (int) (location_x_double_on_animator - GlobalUtilities.round( ((double) width_int / 2.0 ),0 ) ); 
      int y = (int) (location_y_double_on_animator - GlobalUtilities.round( ((double) height_int / 2.0 ),0 ) );
		  Color color = GlobalUtilities.colorStringToColorType (color_on_animator);
			
		  if(QnactrSimulation.taskVisualization2DEnable){
		    String image_ID = sim.vars.taskVisualization2D.createDynamicLine(x, y, width_int, height_int, color) ;
		    
		    //add the display item to the list
		    if( sim.vars.animatorModule.Visicon_Name_Image_ID_Table.containsKey(the_vicison_chunk.Chunk_Name )) System.out.println("WARNING! in AnimatorModuleFun__Add_Visicon type: " + visicon_type + " , sim.vars.animatorModule.Visicon_Name_Image_ID_Table.ContainsKey(the_vicison_chunk.Chunk_Name )");
		    sim.vars.animatorModule.Visicon_Name_Image_ID_Table.put( the_vicison_chunk.Chunk_Name , image_ID);
		  }
		}

		//TODO can further add button to replace the current way of dividing buttons into a text and an oval

		else System.err.println("Error! AnimatorModuleFun__Add_Visicon has undefined visicon_type: " + visicon_type);

	}
	
	public  LinkedList<String> AnimatorModuleFun__Animator3D_Add_Dashed_Line_XZ_Plane(double start_x, double start_z,double end_x,double end_z){
		
		// Animator3D
	  System.out.println("TODO Animator3D AnimatorModuleFun__Animator3D_Add_Dashed_Line_XZ_Plane");
	  
	  
		//dash length = space length
		double unit_length = GlobalUtilities.round(10.0, 9); // = dash + space length. in Animator3D unit. 
		double total_length = GlobalUtilities.round(sim.funs.ProgramUtilitiesFun__Geometry2D_Point_Point_Distance(start_x, start_z, end_x, end_z),9);

		//System.out.println("debug! 	AnimatorModuleFun__Animator3D_Add_Dashed_Line_XZ_Plane has total_length : " + total_length + ". start_x: " + start_x + ", start_z: " + start_z + ", end_x: " + end_x + ", end_z: " + end_z );

		if(total_length < 0.0){
//			System.out.println("debug! 	total_length < 0.0");
			System.err.println("Error! 	AnimatorModuleFun__Animator3D_Add_Dashed_Line_XZ_Plane has total_length < 0 : " + total_length);
			//break;
			return null;
		}
		else if( total_length == 0.0) {
//			System.out.println("debug! 	total_length == 0.0");
			//System.out.println("debug! 	AnimatorModuleFun__Animator3D_Add_Dashed_Line_XZ_Plane has total_length : " + total_length + ". start_x: " + start_x + ", start_z: " + start_z + ", end_x: " + end_x + ", end_z: " + end_z );
			
			return new LinkedList<String>();
		}
		else if ( total_length <= unit_length / 2.0) {
//			System.out.println("debug! 	total_length <= unit_length / 2.0");
			return new LinkedList<String>();
		}
		else if ( total_length <= unit_length) {
//			System.out.println("debug! 	total_length <= unit_length ");
			//draw a dash and return it
			double delta_x = (end_x - start_x) / total_length * (unit_length / 2.0);
			double delta_z = (end_z - start_z) / total_length * (unit_length / 2.0);
			double new_end_x = start_x + delta_x;
			double new_end_z = start_z + delta_z;
		//TODO // String animator3d_id = Animator3D.Create3DLine(start_x, 0.0, start_z,     new_end_x, 0.0, new_end_z );
		//TODO // Animator3D.Hide3DLineEndPoint(animator3d_id); // hide
			LinkedList<String> return_list = new LinkedList<String> ();
		//TODO // return_list.addLast( animator3d_id );
			return return_list;
		}
		else{ // > unit_length
//			System.out.println("debug! 	total_length > unit_length ");
			//add one unit, then recursively call self, with updated XZ points.
			double delta_x = (end_x - start_x) / total_length * (unit_length );
			double delta_z = (end_z - start_z) / total_length * (unit_length );
			double cut_x = start_x + delta_x ;
			double cut_z = start_z + delta_z ;
			
			//double check length of the first cut, which should == unit_length
			double first_cut_total_length =  (double) sim.funs.ProgramUtilitiesFun__Geometry2D_Point_Point_Distance(start_x, start_z,(double) cut_x,(double)  cut_z );

//			System.out.println("debug! 	first cut total_length == unit_length? " + (first_cut_total_length == unit_length) + ". first_cut_total_length: " + first_cut_total_length + ", unit_length: " + unit_length);
//			System.out.println("debug! 	first cut total_length == unit_length round 12? " + (GlobalUtilities.round(first_cut_total_length, 13) == GlobalUtilities.round(unit_length, 13)) + ". first_cut_total_length: " + first_cut_total_length + ", unit_length: " + unit_length);
			
			return sim.funs.ProgramUtilitiesFun__LinkedListString_Append( sim.funs.AnimatorModuleFun__Animator3D_Add_Dashed_Line_XZ_Plane (start_x, start_z,(double) cut_x, (double) cut_z ) , sim.funs.AnimatorModuleFun__Animator3D_Add_Dashed_Line_XZ_Plane( (double) cut_x, (double)  cut_z , (double) end_x,(double) end_z   ) );
		}
	}

	public  void AnimatorModuleFun__Animator3D_Driving_Turn_Driver_Car (double turnAngle){
	  if(sim.vars.animator3DModule.Show_Animator3D == false){
	    System.err.println("ERROR! AnimatorModuleFun__Animator3D_Driving_Turn_Driver_Car has sim.vars.animator3DModule.Show_Animator3D == false");
	    return;
	  }
	  
	  if( !(sim.vars.world3DTemplate.Method_Object instanceof World3D_Template_Driving_Method)){
      System.err.println("ERROR! AnimatorModuleFun__Animator3D_Driving_Turn_Driver_Car has !(sim.vars.world3DTemplate.Method_Object instanceof World3D_Template_Driving_Method) ");
      return;
    }
	  
	  QnactrSimulation.taskVisualization3D.viewRotY(turnAngle);
	  
	}
	
   /**
    * 
    * @param distance move forward distance in meter. use negative for moving backward
    */
	 public  void AnimatorModuleFun__Animator3D_Driving_Move_Driver_Car (double distance){
	    if(sim.vars.animator3DModule.Show_Animator3D == false){
	      System.out.println("ERROR! AnimatorModuleFun__Animator3D_Driving_Move_Driver_Car has sim.vars.animator3DModule.Show_Animator3D == false");
	      return;
	    }
	    
	    if( !(sim.vars.world3DTemplate.Method_Object instanceof World3D_Template_Driving_Method)){
	      System.out.println("ERROR! AnimatorModuleFun__Animator3D_Driving_Move_Driver_Car has !(sim.vars.world3DTemplate.Method_Object instanceof World3D_Template_Driving_Method) ");
	      return;
	    }
	    
	    QnactrSimulation.taskVisualization3D.viewTranslationZ(-distance);
	    
	  }
	 
	public  void AnimatorModuleFun__Animator3D_Show_Comment(String comment_id, String text, String duration){
		
		// Animator3D
    System.out.println("TODO Animator3D AnimatorModuleFun__Animator3D_Show_Comment");
	//TODO // Animator3D.SetCommentText(comment_id, text);
	//TODO // Animator3D.Show( comment_id );
		if( !duration.equals( "" )){
			if ( !ProgramUtilitiesFun__Is_String_Double(duration) ) {
				System.err.println("Error! AnimatorModuleFun__Animator3D_Show_Comment duration String must be a double rather than : " + duration);
				//break;
			}
			else{
				sim.funs.ProgramUtilitiesFun__Delayed_Function_Call_No_Return_Value( (double) Double.parseDouble(duration) , "Animator3D_Hide", comment_id);
			}
		}

		
	}
	
	public  void AnimatorModuleFun__Animator3D_Show_Hide_All_Comments(boolean key){
		
		// Animator3D?
	    //System.out.println("TODO Animator3D AnimatorModuleFun__Animator3D_Show_Hide_All_Comments");
	  
		if( key ){//show
		//TODO // Animator3D.Show( sim.vars.programGlobalVar__Animator3D_Comment_IDs );
		}
		else{//hide
		//TODO // Animator3D.Hide( sim.vars.programGlobalVar__Animator3D_Comment_IDs );
		}
	}
	
	public void AnimatorModuleFun__Complete_Speech(){
	  
		if( sim.vars.animatorModule.Show_Animator == false || QnactrSimulation.taskVisualization2DEnable == false) return;

		sim.vars.taskVisualization2D.setStaticTextString(sim.vars.taskVisualization2D.vocalResponseDisplayID, "--"); // Animator.SetCommentText( "701", "--"); //vocal response animator
		sim.vars.taskVisualization2D.setStaticTextBackgroundColor(sim.vars.taskVisualization2D.vocalResponseDisplayID, Color.white); // Animator.SetCommentBackgroundColor( "701", Color.White);
	}
	
	public  void AnimatorModuleFun__Produce_Speech(String the_content){
		
		if( sim.vars.animatorModule.Show_Animator && QnactrSimulation.taskVisualization2DEnable) 
		{
		  sim.vars.taskVisualization2D.setStaticTextString(sim.vars.taskVisualization2D.vocalResponseDisplayID, the_content); // Animator.SetCommentText( "701", the_content); //vocal response animator
		  sim.vars.taskVisualization2D.setStaticTextBackgroundColor(sim.vars.taskVisualization2D.vocalResponseDisplayID, Color.red);  // Animator.SetCommentBackgroundColor( "701", Color.Red);
		}

		
		if(sim.vars.animatorModule.Vocalize_Speech){
		  System.out.println("TODO Sound_Plugin AnimatorModuleFun__Produce_Speech");
		  
		//TODO // Sound_Plugin.SelectVoiceForTextToSpeech("Microsoft Server Speech Text to Speech Voice (en-GB, Hazel)");   // (en-US, ZiraPro)
			//Sound_Plugin.SelectVoiceForTextToSpeech("Microsoft Server Speech Text to Speech Voice (zh-CN, HuiHui)");
		//TODO // Sound_Plugin.TextToSpeech(the_content);
		}
	}
	
	public void AnimatorModuleFun__Remove_Visicon(Chunk the_vicison_chunk){

		if( sim.vars.animatorModule.Show_Animator == false || QnactrSimulation.taskVisualization2DEnable == false) return;

		String visicon_type = the_vicison_chunk.Chunk_Type; 

		switch( visicon_type ){
			case "text":
			
			{
				if( sim.vars.animatorModule.Visicon_Name_Comment_ID_Table.containsKey(the_vicison_chunk.Chunk_Name ) == false) System.out.println("WARNING! in AnimatorModuleFun__Remove_Visicon, sim.vars.animatorModule.Visicon_Name_Comment_ID_Table.ContainsKey(the_vicison_chunk.Chunk_Name ) == false");
			
				sim.vars.taskVisualization2D.removeObject((String)sim.vars.animatorModule.Visicon_Name_Comment_ID_Table.get(the_vicison_chunk.Chunk_Name));  // Animator.RemoveComment(   (String)sim.vars.animatorModule.Visicon_Name_Comment_ID_Table.get(the_vicison_chunk.Chunk_Name));
				
				sim.vars.animatorModule.Visicon_Name_Comment_ID_Table.remove( the_vicison_chunk.Chunk_Name );
				break;
			}
			case "oval":
			case "line":
			{
				if( sim.vars.animatorModule.Visicon_Name_Image_ID_Table.containsKey(the_vicison_chunk.Chunk_Name ) == false) System.out.println("WARNING! in AnimatorModuleFun__Remove_Visicon, sim.vars.animatorModule.Visicon_Name_Image_ID_Table.ContainsKey(the_vicison_chunk.Chunk_Name ) == false");
				
				sim.vars.taskVisualization2D.removeObject( (String)sim.vars.animatorModule.Visicon_Name_Image_ID_Table.get(the_vicison_chunk.Chunk_Name) ); // Animator.RemoveImage (   (String)sim.vars.animatorModule.Visicon_Name_Image_ID_Table.get(the_vicison_chunk.Chunk_Name) );
				sim.vars.animatorModule.Visicon_Name_Image_ID_Table.remove( the_vicison_chunk.Chunk_Name );
				
				break;
			}
			default:
				System.err.println( "Error! AnimatorModuleFun__Remove_Visicon has undefined visicon_type: "+ visicon_type );
				break;
		}
		
	}

	public  void AnimatorModuleFun__Set_Finger_Press_On_A_Place(String hand, String finger, String key){
		
		if( sim.vars.animatorModule.Show_Animator == false || QnactrSimulation.taskVisualization2DEnable == false) return;
		String[] array = null;
    int index;
    if( hand.equals( "left")){
      array = sim.vars.taskVisualization2D.leftHandFingerIDs;
    }
    else if( hand.equals( "right")){
      array = sim.vars.taskVisualization2D.rightHandFingerIDs;
    }
    else System.err.println("Error! AnimatorModuleFun__Set_Finger_Press_On_A_Place has undefined hand: " + hand);

    switch (finger){
      case "thumb":
        index = 0;
        break;
      case "index":
        index = 1;
        break;
      case "middle":
        index = 2;
        break;
      case "ring":
        index = 3;
        break;
      case "pinkie":
        index = 4;
        break;
      default:
        System.err.println( "Error! AnimatorModuleFun__Set_Finger_Press_On_A_Place has undefined finger: " + finger);
        return;
    }
    
    sim.vars.taskVisualization2D.setStaticTextString(array[index], key);      //C#   Animator.SetCommentText( animator_comment_id, key);
    sim.vars.taskVisualization2D.setStaticTextBackgroundColor(array[index], Color.RED); 
	}
	
	public void AnimatorModuleFun__Set_Finger_Rest_On_A_Place(String hand, String finger, String key){

		if( sim.vars.animatorModule.Show_Animator == false || QnactrSimulation.taskVisualization2DEnable == false) return;

		String[] array = null;
		int index;
		if( hand.equals( "left")){
		  array = sim.vars.taskVisualization2D.leftHandFingerIDs;
		}
		else if( hand.equals( "right")){
		  array = sim.vars.taskVisualization2D.rightHandFingerIDs;
		}
		else System.err.println("Error! AnimatorModuleFun__Set_Finger_Rest_On_A_Place has undefined hand: " + hand);

		switch (finger){
			case "thumb":
				index = 0;
				break;
			case "index":
				index = 1;
				break;
			case "middle":
				index = 2;
				break;
			case "ring":
				index = 3;
				break;
			case "pinkie":
				index = 4;
				break;
			default:
				System.err.println( "Error! AnimatorModuleFun__Set_Finger_Rest_On_A_Place has undefined finger: " + finger);
				return;
		}

		//System.out.println( "AnimatorModuleFun__Set_Finger_Rest_On_A_Place has array[index]: " + array[index] + " key: " + key);
		
		sim.vars.taskVisualization2D.setStaticTextString(array[index], key);      //C#   Animator.SetCommentText( animator_comment_id, key);
		sim.vars.taskVisualization2D.setStaticTextBackgroundColor(array[index], Color.LIGHT_GRAY);  //c# // Animator.SetCommentBackgroundColor( animator_comment_id, Color.white);
	}
		
//AudioModuleFun
	
	public void AudioModuleFun__Update_Audicon_Decay(){
		
		LinkedList<String> remove_list = new LinkedList<String>();

		Iterator<Entry<String, Double>> itr_Table = sim.vars.audioModule.Audicon_Decay_Time_Tracking_Table.entrySet().iterator();
		while(itr_Table.hasNext()){
		  Entry<String, Double> entry = itr_Table.next();
		  
			String audicon_name = (String) entry.getKey();
			double sound_end_time = (double)  entry.getValue();
			//System.out.println(audicon_name + " " + sound_end_time);
			if ( GlobalUtilities.round(SimSystem.clock(), 9 ) >= GlobalUtilities.round( (sound_end_time + sim.vars.audioModule.Sound_Decay_Time ),9 )) remove_list.addLast( audicon_name  );
		}
		Enumeration<String> remove_name = Collections.enumeration(remove_list);
		while (remove_name.hasMoreElements()){
		  String currentName = remove_name.nextElement();
			String temp_name = (String) currentName;
			sim.vars.audioModule.Audicon_Decay_Time_Tracking_Table.remove(temp_name);
			
			//remove the audicon chunk from audicon list
			Enumeration<Chunk> enum_chunk = Collections.enumeration(sim.vars.audioDisplay.Audicon);
			int i = 0 ;
			int id = -1;
			while(enum_chunk.hasMoreElements()){
			  Chunk currentChunk = (Chunk)enum_chunk.nextElement();
				if (id == -1 &&  currentChunk.Chunk_Name.equals(temp_name)  ) id = i;
				else if (id == -1 &&  currentChunk.Chunk_Name.equals(temp_name)  ) System.out.println("AudioModuleFun__Update_Audicon_Decay gets multiple audicons with the same name: " + temp_name);
				i++;
			}
			if (id == -1) System.out.println("AudioModuleFun__Update_Audicon_Decay, the audicon list does not have chunk name: " + temp_name);
			Chunk temp_pointer = sim.funs.ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer(sim.vars.audioDisplay.Audicon, id);	
			sim.vars.audioDisplay.Audicon.remove(temp_pointer);
		}

	}
	
	public  int AudioModuleFun__Find_The_Audicon_ID_By_Chunk_Name(String the_chunk_name){
		
		AudioModuleFun__Update_Audicon_Decay(); 

		Enumeration<Chunk> enum_chunk = Collections.enumeration(sim.vars.audioDisplay.Audicon);
		int i = 0 ;
		while(enum_chunk.hasMoreElements()){
			if (  ((Chunk)enum_chunk.nextElement()).Chunk_Name.equals( the_chunk_name)  ) return i;
			i++;
		}

		return -1;
	}
	
	public int AudioModuleFun__Find_The_Ongoing_Sound_ID_By_Chunk_Name(String the_chunk_name){
		
		Enumeration<Chunk> enum_chunk = Collections.enumeration(sim.vars.audioDisplay.Ongoing_Sound);
		int i = 0 ;
		while(enum_chunk.hasMoreElements()){
			if (  ((Chunk)enum_chunk.nextElement()).Chunk_Name.equals(  the_chunk_name)  ) return i;
			i++;
		}

		return -1;
	}
	
	public Chunk AudioModuleFun__Find_Aural_Location_In_Audicons_By_Chunk_Spec(Chunk The_Chunk_Spec, boolean Exclude_Buffer_Stuffing_Just_Selected_Attended_Nil_Locations){
		
		boolean debug_trace = false;

		AudioModuleFun__Update_Audicon_Decay();

		//get all the audiol-event chunks that belongs to the chunks currently in the audicon list
		LinkedList<Chunk> aural_location_chunk_list = new LinkedList<Chunk> ();
		Enumeration<Chunk> enum_audicon_chunk = Collections.enumeration(sim.vars.audioDisplay.Audicon);
		while(enum_audicon_chunk.hasMoreElements()){
			Chunk audicon_chunk = (Chunk) enum_audicon_chunk.nextElement();
			String event_name = sim.funs.ChunkFun__Get_Chunk_Slot_Value( audicon_chunk, "event") ;
			//System.out.println("AudioModuleFun__Find_Aural_Location_In_Audicons_By_Chunk_Spec event_name: "+ event_name);	
				
				
				
			if( Exclude_Buffer_Stuffing_Just_Selected_Attended_Nil_Locations && sim.vars.audioModule.Buffer_Stuffing_Just_Selected_Attended_Nil_Aural_Location_Names.contains( event_name ) ){
				//pass
				//System.out.println("Show. AudioModuleFun__Find_Aural_Location_In_Audicons_By_Chunk_Spec has passed Buffer_Stuffing_Just_Selected_Attended_Nil_Aural_Location_Names event_name: "+ event_name);
			}
			else aural_location_chunk_list.addLast( (Chunk) sim.vars.centralParametersModule.Chunks.get(event_name) ) ;
			
			
			
		}




		int i;
		int Matched_Chunk_Number = 0; //how many matched chunk found, and also the index of the next empty index of Matched_Chunk_Index
		if (aural_location_chunk_list.size() < 1){
			//System.out.println("AudioModuleFun__Find_Aural_Location_In_Audicons_By_Chunk_Spec Error! aural_location_chunk_list.Count < 1");
			return new Chunk();	
		}
		int[] Matched_Chunk_Index = new int[aural_location_chunk_list.size()]; 

		//name match is another function, because each chunk should have an unique name.

		if (The_Chunk_Spec.Chunk_Type.equals( "nil")){  //the first round is chunk type, ISA match
			//may add later for chunk type is nil
			System.out.println("AudioModuleFun__Find_Aural_Location_In_Audicons_By_Chunk_Spec has chunk type nil");
			}
		else if (The_Chunk_Spec.Chunk_Type.equals( "" )){
			//matching any chunk type that is not nil
			for (i = 0; i < aural_location_chunk_list.size() ; i ++){ 	
				if (!sim.funs.ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer(aural_location_chunk_list, i).Chunk_Type.equals( "nil")){
					Matched_Chunk_Index[Matched_Chunk_Number] = i;
					Matched_Chunk_Number++;
				}
			}
		}
		else {  //matching a specific chunk type 
			for (i = 0; i < aural_location_chunk_list.size() ; i ++){ 	
				if (sim.funs.ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer(aural_location_chunk_list, i).Chunk_Type.equals(The_Chunk_Spec.Chunk_Type)){
					Matched_Chunk_Index[Matched_Chunk_Number] = i;
					Matched_Chunk_Number++;
				}
			}
		}

		if (Matched_Chunk_Number == 0){	 return new Chunk();}

		//int Slot_Matching_Round = 0;
		int[] Temp_Index;
		int Temp_Index_Current = 0;

		Hashtable<String,String> lowest_highest_slots = new Hashtable<String,String> (); //stores any lowest or highest slot tests in the request

		Iterator<Entry<String, String>> itr_slot = The_Chunk_Spec.Slot.entrySet().iterator();
		
		while ( itr_slot.hasNext() ){  // get every element
			//System.out.println( myEnumerator.Key + " " + myEnumerator.Value);
		  Entry<String, String> currentItem = itr_slot.next();
			String key = (String) currentItem.getKey();
			String value = (String) currentItem.getValue();
			if(value.equals( "lowest" ) || value.equals( "highest" )){ //get the lowest/highest value //You can use the values lowest and highest in the specification of any slot which has a numeric value.
				//save this to the next round.
				lowest_highest_slots.put(key, value );
				continue;	
			}
			
			
			Temp_Index = new int[Matched_Chunk_Number];
			for (i = 0; i < Matched_Chunk_Number; i++){   //matching chunks survived are recorded in Temp_Index array
				Chunk temp_chunk_pointer = sim.funs.ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer( aural_location_chunk_list,  Matched_Chunk_Index[i] );
				if (key.equals( ":attended" ) && value.equals( "nil")){ //special slot like ":attended" and if test "nil", note that "new" must also be "nil"
					if (  sim.funs.ChunkFun__Get_Chunk_Slot_Value( temp_chunk_pointer , ":attended").equals( "nil") || sim.funs.ChunkFun__Get_Chunk_Slot_Value( temp_chunk_pointer , ":attended").equals( "new" ) ){
						Temp_Index[Temp_Index_Current] = Matched_Chunk_Index[i];
						Temp_Index_Current++;
					}
				}
				else{ //normal slot like "value" //and special slot like ":attended" when testing "t" and "new" test, same with normal slot test, because "nil" cannot not be "new"
					if ((value).length() >= 4 && (value).substring(0,4).equals( "NOT_")) { //protection for out of index
						//NOT match "arg1 NOT_book" (changed from "-arg1 book") , match !"arg1 book"
						String new_slot_value = (value).substring(4, (value).length());
						//System.out.println(The_Chunk_Spec.Slot[Slot_Matching_Round, 1].Substring(0,4));
						//System.out.println(new_slot_value);
						
						if (  ! ProgramUtilitiesFun__StringsEqualByStringOrDouble( sim.funs.ChunkFun__Get_Chunk_Slot_Value( temp_chunk_pointer, key),  new_slot_value ) ){ //if (  ! sim.funs.ChunkFun__Get_Chunk_Slot_Value( temp_chunk_pointer, key).equals( new_slot_value )){
						
							Temp_Index[Temp_Index_Current] = Matched_Chunk_Index[i];
							Temp_Index_Current++;
						}
					}
					else{ 
						String slot_key = key; 
						String slot_value = value;
						if (!slot_key.substring(0,2).equals( "<=" ) && slot_key.substring(0,1).equals( "<") ){ //match "<arg1 book"
						//modified from ProductionModuleFun__Match_A_Rule_Test
						//debug_trace = true;
						String new_slot_key = slot_key.substring(1); // without the first char '<'
						if (debug_trace) System.out.println("Find_Visual_Location_In_Visicons_By_Chunk_Spec < match, new_slot_key: " + new_slot_key);
						if (temp_chunk_pointer.Slot.containsKey(new_slot_key) == false && !new_slot_key.toLowerCase().equals( "isa" )){ // if the buffer chunk does not have the slot. 
							if (debug_trace) System.out.println("Find_Visual_Location_In_Visicons_By_Chunk_Spec '<' test, Buffer_chunk doesn't have the slot_key. test fail");
							continue;
						}
						if(sim.funs.ProgramUtilitiesFun__Is_String_Double(slot_value) == false){
							System.out.println("AudioModuleFun__Find_Aural_Location_In_Audicons_By_Chunk_Spec:   relative value test must have numbers as slot values.");
							continue;
						}
						if (new_slot_key.toLowerCase().equals( "isa") ){ //< isa test. illegal
							System.out.println("AudioModuleFun__Find_Aural_Location_In_Audicons_By_Chunk_Spec:   relative value test cannot be applied to isa chunk type.");
						}
						else{ //< test match value, not isa 
							String buffer_chunk_value_string = sim.funs.ChunkFun__Get_Chunk_Slot_Value(temp_chunk_pointer, new_slot_key);
							if(sim.funs.ProgramUtilitiesFun__Is_String_Double( buffer_chunk_value_string ) == false){
								System.out.println("AudioModuleFun__Find_Aural_Location_In_Audicons_By_Chunk_Spec:   relative value test has buffer chunk slot value that is not a number: " + buffer_chunk_value_string);
								continue;
							}
							
							if ( (Double.parseDouble(buffer_chunk_value_string) < Double.parseDouble(slot_value) ) == false){
								if (debug_trace) System.out.println("Find_Visual_Location_In_Visicons_By_Chunk_Spec, < Match value, not ISA test fail");
								continue;
							}
							else{
								if(debug_trace)	System.out.println(slot_key + " " + slot_value + " pass");
								Temp_Index[Temp_Index_Current] = Matched_Chunk_Index[i];
								Temp_Index_Current++;	
							}
						}
					}// end of < test
						else if (slot_key.substring(0,2).equals( "<=")){ // <= test
							//modified from ProductionModuleFun__Match_A_Rule_Test
							//debug_trace = true;
							String new_slot_key = slot_key.substring(2); // without the first char '<='
							if (debug_trace) System.out.println("Find_Visual_Location_In_Visicons_By_Chunk_Spec <= match, new_slot_key: " + new_slot_key);
							if (temp_chunk_pointer.Slot.containsKey(new_slot_key) == false && !new_slot_key.toLowerCase().equals( "isa" )){ // if the buffer chunk does not have the slot. 
								if (debug_trace) System.out.println("Find_Visual_Location_In_Visicons_By_Chunk_Spec '<=' test, Buffer_chunk doesn't have the slot_key. test fail");
								continue;
							}
							if(sim.funs.ProgramUtilitiesFun__Is_String_Double(slot_value) == false){
								System.out.println("AudioModuleFun__Find_Aural_Location_In_Audicons_By_Chunk_Spec:   relative value test must have numbers as slot values.");
								continue;
							}
							if (new_slot_key.toLowerCase().equals( "isa") ){ //< isa test. illegal
								System.out.println("AudioModuleFun__Find_Aural_Location_In_Audicons_By_Chunk_Spec:   relative value test cannot be applied to isa chunk type.");
							}
							else{ //<= test match value, not isa 
								String buffer_chunk_value_string = sim.funs.ChunkFun__Get_Chunk_Slot_Value(temp_chunk_pointer, new_slot_key);
								if(sim.funs.ProgramUtilitiesFun__Is_String_Double( buffer_chunk_value_string ) == false){
									System.out.println("AudioModuleFun__Find_Aural_Location_In_Audicons_By_Chunk_Spec:   relative value test has buffer chunk slot value that is not a number: " + buffer_chunk_value_string);
									continue;
								}
								
								if ( (Double.parseDouble(buffer_chunk_value_string) <= Double.parseDouble(slot_value) ) == false){
									if (debug_trace) System.out.println("Find_Visual_Location_In_Visicons_By_Chunk_Spec, < Match value, not ISA test fail");
									continue;
								}
								else{
									if(debug_trace)	System.out.println(slot_key + " " + slot_value + " pass");
									Temp_Index[Temp_Index_Current] = Matched_Chunk_Index[i];
									Temp_Index_Current++;	
								}
							}
						}// end of <= test
						else if (!slot_key.substring(0,2).equals( ">=" ) && slot_key.charAt(0) == '>'){ // > test
							//modified from ProductionModuleFun__Match_A_Rule_Test
							//debug_trace = true;
							String new_slot_key = slot_key.substring(1); // without the first char '>'
							if (debug_trace) System.out.println("Find_Visual_Location_In_Visicons_By_Chunk_Spec > match, new_slot_key: " + new_slot_key);
							if (temp_chunk_pointer.Slot.containsKey(new_slot_key) == false && !new_slot_key.toLowerCase().equals( "isa" )){ // if the buffer chunk does not have the slot. 
								if (debug_trace) System.out.println("Find_Visual_Location_In_Visicons_By_Chunk_Spec '>' test, Buffer_chunk doesn't have the slot_key. test fail");
								continue;
							}
							if(sim.funs.ProgramUtilitiesFun__Is_String_Double(slot_value) == false){
								System.out.println("AudioModuleFun__Find_Aural_Location_In_Audicons_By_Chunk_Spec:   relative value test must have numbers as slot values.");
								continue;
							}
							if (new_slot_key.toLowerCase().equals( "isa") ){ //> isa test. illegal
								System.out.println("AudioModuleFun__Find_Aural_Location_In_Audicons_By_Chunk_Spec:   relative value test cannot be applied to isa chunk type.");
							}
							else{ //> test match value, not isa 
								String buffer_chunk_value_string = sim.funs.ChunkFun__Get_Chunk_Slot_Value(temp_chunk_pointer, new_slot_key);
								if(sim.funs.ProgramUtilitiesFun__Is_String_Double( buffer_chunk_value_string ) == false){
									System.out.println("AudioModuleFun__Find_Aural_Location_In_Audicons_By_Chunk_Spec:   relative value test has buffer chunk slot value that is not a number: " + buffer_chunk_value_string);
									continue;
								}
								
								if ( (Double.parseDouble(buffer_chunk_value_string) > Double.parseDouble(slot_value) ) == false){
									if (debug_trace) System.out.println("Find_Visual_Location_In_Visicons_By_Chunk_Spec, > Match value, not ISA test fail");
									continue;
								}
								else{
									if(debug_trace)	System.out.println(slot_key + " " + slot_value + " pass");
									Temp_Index[Temp_Index_Current] = Matched_Chunk_Index[i];
									Temp_Index_Current++;	
								}
							}
						}// end of > test
						else if (slot_key.substring(0,2).equals( ">=")){ // >= test
							//modified from ProductionModuleFun__Match_A_Rule_Test
							//debug_trace = true;
							String new_slot_key = slot_key.substring(2); // without the first char '>='
							if (debug_trace) System.out.println("Find_Visual_Location_In_Visicons_By_Chunk_Spec >= match, new_slot_key: " + new_slot_key);
							if (temp_chunk_pointer.Slot.containsKey(new_slot_key) == false && !new_slot_key.toLowerCase().equals( "isa")){ // if the buffer chunk does not have the slot. 
								if (debug_trace) System.out.println("Find_Visual_Location_In_Visicons_By_Chunk_Spec '>=' test, Buffer_chunk doesn't have the slot_key. test fail");
								continue;
							}
							if(sim.funs.ProgramUtilitiesFun__Is_String_Double(slot_value) == false){
								System.out.println("AudioModuleFun__Find_Aural_Location_In_Audicons_By_Chunk_Spec:   relative value test must have numbers as slot values.");
								continue;
							}
							if (new_slot_key.toLowerCase().equals( "isa") ){ //>= isa test. illegal
								System.out.println("AudioModuleFun__Find_Aural_Location_In_Audicons_By_Chunk_Spec:   relative value test cannot be applied to isa chunk type.");
							}
							else{ //>= test match value, not isa 
								String buffer_chunk_value_string = sim.funs.ChunkFun__Get_Chunk_Slot_Value(temp_chunk_pointer, new_slot_key);
								if(sim.funs.ProgramUtilitiesFun__Is_String_Double( buffer_chunk_value_string ) == false){
									System.out.println("AudioModuleFun__Find_Aural_Location_In_Audicons_By_Chunk_Spec:   relative value test has buffer chunk slot value that is not a number: " + buffer_chunk_value_string);
									continue;
								}
								
								if ( (Double.parseDouble(buffer_chunk_value_string) >= Double.parseDouble(slot_value) ) == false){
									if (debug_trace) System.out.println("Find_Visual_Location_In_Visicons_By_Chunk_Spec, >= Match value, not ISA test fail");
									continue;
								}
								else{
									if(debug_trace)	System.out.println(slot_key + " " + slot_value + " pass");
									Temp_Index[Temp_Index_Current] = Matched_Chunk_Index[i];
									Temp_Index_Current++;	
								}
							}
						}// end of >= test
						
						//else if (  sim.funs.ChunkFun__Get_Chunk_Slot_Value( temp_chunk_pointer, key).equals( value )){ // normal test like "arg1 book"
						else if (   ProgramUtilitiesFun__StringsEqualByStringOrDouble(sim.funs.ChunkFun__Get_Chunk_Slot_Value( temp_chunk_pointer, key), value ) ){ // normal test like "arg1 book"
								Temp_Index[Temp_Index_Current] = Matched_Chunk_Index[i];
								Temp_Index_Current++;
						}
					}
				}
			}
			for (i = 0; i < Temp_Index_Current; i++){      //put Temp_Index array into Matched_Chunk_Index array
				Matched_Chunk_Index[i] = Temp_Index[i];
			}
			Matched_Chunk_Number = Temp_Index_Current;
			Temp_Index_Current = 0;
			//Slot_Matching_Round++;
			if(Matched_Chunk_Number == 0) break;
		}


		// lowest and highest must be used in the end, if there is any, after other test to make sense. only when previous tests get more than 1 candidate.
		if(lowest_highest_slots.size() > 0 && Matched_Chunk_Number > 1) {
			
			Iterator<Entry<String, String>> itr_slot2 = lowest_highest_slots.entrySet().iterator();
			while ( itr_slot2.hasNext() ){  // get every element
				//System.out.println( myEnumerator_2.Key + " " + myEnumerator_2.Value);
			  Entry<String, String> currentSlot = itr_slot2.next();
				String key = (String) currentSlot.getKey();
				String value = (String) currentSlot.getValue();
				if(value.equals( "lowest" ) || value.equals( "highest" )){ //get the lowest/highest value //You can use the values lowest and highest in the specification of any slot which has a numeric value.
					Chunk temp_chunk_pointer = sim.funs.ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer( aural_location_chunk_list,  Matched_Chunk_Index[0] );
					String extreme_value_string =   sim.funs.ChunkFun__Get_Chunk_Slot_Value( temp_chunk_pointer , key) ;
					double extreme_value;
					if (sim.funs.ProgramUtilitiesFun__Is_String_Double(extreme_value_string) ) extreme_value = Double.parseDouble(extreme_value_string);
					else {
						System.out.println("AudioModuleFun__Find_Aural_Location_In_Audicons_By_Chunk_Spec, String: " + extreme_value_string + " cannot be converted to a number.");
						return null;
					}
					for (i = 1; i < Matched_Chunk_Number; i++){
						temp_chunk_pointer = sim.funs.ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer( aural_location_chunk_list,  Matched_Chunk_Index[i] );
						String temp_value_string =   sim.funs.ChunkFun__Get_Chunk_Slot_Value( temp_chunk_pointer , key) ;
						double temp_value;
						if (sim.funs.ProgramUtilitiesFun__Is_String_Double(temp_value_string) ) temp_value = Double.parseDouble(temp_value_string);
						else {
							System.out.println("AudioModuleFun__Find_Aural_Location_In_Audicons_By_Chunk_Spec, String: " + temp_value_string + " cannot be converted to a number.");
							return null;
						}
						if(value.equals( "lowest" )){
							if (temp_value < extreme_value)  extreme_value = temp_value;
						}
						else if (value.equals( "highest" )){
							if (temp_value > extreme_value)  extreme_value = temp_value;
						}
					}
					value = Double.toString(extreme_value);		
				}
				
				
				Temp_Index = new int[Matched_Chunk_Number];
				for (i = 0; i < Matched_Chunk_Number; i++){   //matching chunks survived are recorded in Temp_Index array
					Chunk temp_chunk_pointer = sim.funs.ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer( aural_location_chunk_list,  Matched_Chunk_Index[i] );
					if (key.equals( ":attended" ) && value.equals( "nil")){ //special slot like ":attended" and if test "nil", note that "new" must also be "nil"
						if (  sim.funs.ChunkFun__Get_Chunk_Slot_Value( temp_chunk_pointer , ":attended").equals( "nil") || sim.funs.ChunkFun__Get_Chunk_Slot_Value( temp_chunk_pointer , ":attended").equals( "new" ) ){
							Temp_Index[Temp_Index_Current] = Matched_Chunk_Index[i];
							Temp_Index_Current++;
						}
					}
					else{ //normal slot like "value" //and special slot like ":attended" when testing "t" and "new" test, same with normal slot test, because "nil" cannot not be "new"
						if ((value).length() >= 4 && (value).substring(0,4).equals( "NOT_")) { //protection for out of index
							//NOT match "arg1 NOT_book" (changed from "-arg1 book") , match !"arg1 book"
							String new_slot_value = (value).substring(4, (value).length());
							//System.out.println(The_Chunk_Spec.Slot[Slot_Matching_Round, 1].Substring(0,4));
							//System.out.println(new_slot_value);
							if ( ! ProgramUtilitiesFun__StringsEqualByStringOrDouble(sim.funs.ChunkFun__Get_Chunk_Slot_Value( temp_chunk_pointer, key), new_slot_value) ){//if ( !sim.funs.ChunkFun__Get_Chunk_Slot_Value( temp_chunk_pointer, key).equals(new_slot_value) ){
							
								Temp_Index[Temp_Index_Current] = Matched_Chunk_Index[i];
								Temp_Index_Current++;
							}
						}
						else{ 
							String slot_key = key; 
							String slot_value = value;
							if (!slot_key.substring(0,2).equals( "<=" ) && slot_key.substring(0,1).equals( "<") ){ //match "<arg1 book"
							//modified from ProductionModuleFun__Match_A_Rule_Test
							//debug_trace = true;
							String new_slot_key = slot_key.substring(1); // without the first char '<'
							if (debug_trace) System.out.println("Find_Visual_Location_In_Visicons_By_Chunk_Spec < match, new_slot_key: " + new_slot_key);
							if (temp_chunk_pointer.Slot.containsKey(new_slot_key) == false && !new_slot_key.toLowerCase().equals( "isa" )){ // if the buffer chunk does not have the slot. 
								if (debug_trace) System.out.println("Find_Visual_Location_In_Visicons_By_Chunk_Spec '<' test, Buffer_chunk doesn't have the slot_key. test fail");
								continue;
							}
							if(sim.funs.ProgramUtilitiesFun__Is_String_Double(slot_value) == false){
								System.out.println("AudioModuleFun__Find_Aural_Location_In_Audicons_By_Chunk_Spec:   relative value test must have numbers as slot values.");
								continue;
							}
							if (new_slot_key.toLowerCase().equals( "isa") ){ //< isa test. illegal
								System.out.println("AudioModuleFun__Find_Aural_Location_In_Audicons_By_Chunk_Spec:   relative value test cannot be applied to isa chunk type.");
							}
							else{ //< test match value, not isa 
								String buffer_chunk_value_string = sim.funs.ChunkFun__Get_Chunk_Slot_Value(temp_chunk_pointer, new_slot_key);
								if(sim.funs.ProgramUtilitiesFun__Is_String_Double( buffer_chunk_value_string ) == false){
									System.out.println("AudioModuleFun__Find_Aural_Location_In_Audicons_By_Chunk_Spec:   relative value test has buffer chunk slot value that is not a number: " + buffer_chunk_value_string);
									continue;
								}
								
								if ( (Double.parseDouble(buffer_chunk_value_string) < Double.parseDouble(slot_value) ) == false){
									if (debug_trace) System.out.println("Find_Visual_Location_In_Visicons_By_Chunk_Spec, < Match value, not ISA test fail");
									continue;
								}
								else{
									if(debug_trace)	System.out.println(slot_key + " " + slot_value + " pass");
									Temp_Index[Temp_Index_Current] = Matched_Chunk_Index[i];
									Temp_Index_Current++;	
								}
							}
						}// end of < test
							else if (slot_key.substring(0,2).equals( "<=")){ // <= test
								//modified from ProductionModuleFun__Match_A_Rule_Test
								//debug_trace = true;
								String new_slot_key = slot_key.substring(2); // without the first char '<='
								if (debug_trace) System.out.println("Find_Visual_Location_In_Visicons_By_Chunk_Spec <= match, new_slot_key: " + new_slot_key);
								if (temp_chunk_pointer.Slot.containsKey(new_slot_key) == false && !new_slot_key.toLowerCase().equals( "isa")){ // if the buffer chunk does not have the slot. 
									if (debug_trace) System.out.println("Find_Visual_Location_In_Visicons_By_Chunk_Spec '<=' test, Buffer_chunk doesn't have the slot_key. test fail");
									continue;
								}
								if(sim.funs.ProgramUtilitiesFun__Is_String_Double(slot_value) == false){
									System.out.println("AudioModuleFun__Find_Aural_Location_In_Audicons_By_Chunk_Spec:   relative value test must have numbers as slot values.");
									continue;
								}
								if (new_slot_key.toLowerCase().equals( "isa") ){ //< isa test. illegal
									System.out.println("AudioModuleFun__Find_Aural_Location_In_Audicons_By_Chunk_Spec:   relative value test cannot be applied to isa chunk type.");
								}
								else{ //<= test match value, not isa 
									String buffer_chunk_value_string = sim.funs.ChunkFun__Get_Chunk_Slot_Value(temp_chunk_pointer, new_slot_key);
									if(sim.funs.ProgramUtilitiesFun__Is_String_Double( buffer_chunk_value_string ) == false){
										System.out.println("AudioModuleFun__Find_Aural_Location_In_Audicons_By_Chunk_Spec:   relative value test has buffer chunk slot value that is not a number: " + buffer_chunk_value_string);
										continue;
									}
									
									if ( (Double.parseDouble(buffer_chunk_value_string) <= Double.parseDouble(slot_value) ) == false){
										if (debug_trace) System.out.println("Find_Visual_Location_In_Visicons_By_Chunk_Spec, < Match value, not ISA test fail");
										continue;
									}
									else{
										if(debug_trace)	System.out.println(slot_key + " " + slot_value + " pass");
										Temp_Index[Temp_Index_Current] = Matched_Chunk_Index[i];
										Temp_Index_Current++;	
									}
								}
							}// end of <= test
							else if (!slot_key.substring(0,2).equals( ">=" ) && slot_key.charAt(0) == '>'){ // > test
								//modified from ProductionModuleFun__Match_A_Rule_Test
								//debug_trace = true;
								String new_slot_key = slot_key.substring(1); // without the first char '>'
								if (debug_trace) System.out.println("Find_Visual_Location_In_Visicons_By_Chunk_Spec > match, new_slot_key: " + new_slot_key);
								if (temp_chunk_pointer.Slot.containsKey(new_slot_key) == false && !new_slot_key.toLowerCase().equals( "isa")) { // if the buffer chunk does not have the slot. 
									if (debug_trace) System.out.println("Find_Visual_Location_In_Visicons_By_Chunk_Spec '>' test, Buffer_chunk doesn't have the slot_key. test fail");
									continue;
								}
								if(sim.funs.ProgramUtilitiesFun__Is_String_Double(slot_value) == false){
									System.out.println("AudioModuleFun__Find_Aural_Location_In_Audicons_By_Chunk_Spec:   relative value test must have numbers as slot values.");
									continue;
								}
								if (new_slot_key.toLowerCase().equals( "isa") ){ //> isa test. illegal
									System.out.println("AudioModuleFun__Find_Aural_Location_In_Audicons_By_Chunk_Spec:   relative value test cannot be applied to isa chunk type.");
								}
								else{ //> test match value, not isa 
									String buffer_chunk_value_string = sim.funs.ChunkFun__Get_Chunk_Slot_Value(temp_chunk_pointer, new_slot_key);
									if(sim.funs.ProgramUtilitiesFun__Is_String_Double( buffer_chunk_value_string ) == false){
										System.out.println("AudioModuleFun__Find_Aural_Location_In_Audicons_By_Chunk_Spec:   relative value test has buffer chunk slot value that is not a number: " + buffer_chunk_value_string);
										continue;
									}
									
									if ( (Double.parseDouble(buffer_chunk_value_string) > Double.parseDouble(slot_value) ) == false){
										if (debug_trace) System.out.println("Find_Visual_Location_In_Visicons_By_Chunk_Spec, > Match value, not ISA test fail");
										continue;
									}
									else{
										if(debug_trace)	System.out.println(slot_key + " " + slot_value + " pass");
										Temp_Index[Temp_Index_Current] = Matched_Chunk_Index[i];
										Temp_Index_Current++;	
									}
								}
							}// end of > test
							else if (slot_key.substring(0,2).equals( ">=")){ // >= test
								//modified from ProductionModuleFun__Match_A_Rule_Test
								//debug_trace = true;
								String new_slot_key = slot_key.substring(2); // without the first char '>='
								if (debug_trace) System.out.println("Find_Visual_Location_In_Visicons_By_Chunk_Spec >= match, new_slot_key: " + new_slot_key);
								if (temp_chunk_pointer.Slot.containsKey(new_slot_key) == false && !new_slot_key.toLowerCase().equals( "isa")){ // if the buffer chunk does not have the slot. 
									if (debug_trace) System.out.println("Find_Visual_Location_In_Visicons_By_Chunk_Spec '>=' test, Buffer_chunk doesn't have the slot_key. test fail");
									continue;
								}
								if(sim.funs.ProgramUtilitiesFun__Is_String_Double(slot_value) == false){
									System.out.println("AudioModuleFun__Find_Aural_Location_In_Audicons_By_Chunk_Spec:   relative value test must have numbers as slot values.");
									continue;
								}
								if (new_slot_key.toLowerCase().equals( "isa") ){ //>= isa test. illegal
									System.out.println("AudioModuleFun__Find_Aural_Location_In_Audicons_By_Chunk_Spec:   relative value test cannot be applied to isa chunk type.");
								}
								else{ //>= test match value, not isa 
									String buffer_chunk_value_string = sim.funs.ChunkFun__Get_Chunk_Slot_Value(temp_chunk_pointer, new_slot_key);
									if(sim.funs.ProgramUtilitiesFun__Is_String_Double( buffer_chunk_value_string ) == false){
										System.out.println("AudioModuleFun__Find_Aural_Location_In_Audicons_By_Chunk_Spec:   relative value test has buffer chunk slot value that is not a number: " + buffer_chunk_value_string);
										continue;
									}
									
									if ( (Double.parseDouble(buffer_chunk_value_string) >= Double.parseDouble(slot_value) ) == false){
										if (debug_trace) System.out.println("Find_Visual_Location_In_Visicons_By_Chunk_Spec, >= Match value, not ISA test fail");
										continue;
									}
									else{
										if(debug_trace)	System.out.println(slot_key + " " + slot_value + " pass");
										Temp_Index[Temp_Index_Current] = Matched_Chunk_Index[i];
										Temp_Index_Current++;	
									}
								}
							}// end of >= test
							
							else if (  ProgramUtilitiesFun__StringsEqualByStringOrDouble(sim.funs.ChunkFun__Get_Chunk_Slot_Value( temp_chunk_pointer, key) , value )){ // normal test like "arg1 book" //else if (  sim.funs.ChunkFun__Get_Chunk_Slot_Value( temp_chunk_pointer, key).equals(value )){ // normal test like "arg1 book"
									Temp_Index[Temp_Index_Current] = Matched_Chunk_Index[i];
									Temp_Index_Current++;
							}
						}
					}
				}
				for (i = 0; i < Temp_Index_Current; i++){      //put Temp_Index array into Matched_Chunk_Index array
					Matched_Chunk_Index[i] = Temp_Index[i];
				}
				Matched_Chunk_Number = Temp_Index_Current;
				Temp_Index_Current = 0;
				//Slot_Matching_Round++;
				if(Matched_Chunk_Number == 0) break;
			}
		}



		if (Matched_Chunk_Number == 0) return new Chunk();
		else if (Matched_Chunk_Number == 1){
			Chunk the_matched_chunk_pointer = sim.funs.ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer( aural_location_chunk_list,  Matched_Chunk_Index[0] );
			return sim.funs.ChunkFun__Chunk_Clone(the_matched_chunk_pointer);
		}
		else{
		//ACT-R aural-location request multiple matches: Choose a random one. 
		
			int rand_int = GlobalUtilities.randomInteger(0, Matched_Chunk_Number - 1) ;//need multiple runs and randomize seed in Micro Saint execution settings to word randomly from run to run
			
			System.out.println("AudioModuleFun__Find_Aural_Location_In_Audicons_By_Chunk_Spec ACT-R aural-location request multiple matches: " + Matched_Chunk_Number + " " + rand_int);
			
			for(Chunk a_location : aural_location_chunk_list){
			  System.out.println(ChunkFun__Get_Chunk_Slot_Value( a_location, ":attended"));
			}

			Chunk the_matched_chunk_pointer = sim.funs.ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer( aural_location_chunk_list,  Matched_Chunk_Index[rand_int] );
			return sim.funs.ChunkFun__Chunk_Clone(the_matched_chunk_pointer);
		}
	}
	
	public Chunk AudioModuleFun__Find_Audicon_By_Chunk_Spec(Chunk The_Chunk_Spec){
		
		//Modifed from AudioModuleFun__Find_Audicon_By_Chunk_Spec

		AudioModuleFun__Update_Audicon_Decay();

		int i;
		int Matched_Chunk_Number = 0; //how many matched chunk found, and also the index of the next empty index of Matched_Chunk_Index
		if (sim.vars.audioDisplay.Audicon.size() < 1) {//this happens when aural display is cleared right after a add visual request was issued
			//System.out.println("AudioModuleFun__Find_Audicon_By_Chunk_Spec() Error! sim.vars.audioDisplay.Audicon.Count < 1");
			return new Chunk();
		}
		int[] Matched_Chunk_Index = new int[sim.vars.audioDisplay.Audicon.size()]; //at this time, should Add at least 1 Audicon, sim.vars.audioDisplay.Audicon.Count need to > 0

		//name match is another function, because each chunk should have an unique name.

		if (The_Chunk_Spec.Chunk_Type.equals( "nil")){  //the first round is chunk type, ISA match
			//may add later for chunk type is nil
			System.out.println("AudioModuleFun__Find_Audicon_By_Chunk_Spec has chunk type nil");
			}
		else if (The_Chunk_Spec.Chunk_Type.equals( "" )){
			//matching any chunk type that is not nil
			//System.out.println("AudioModuleFun__Find_Audicon_By_Chunk_Spec has chunk type empty");
			for (i = 0; i < sim.vars.audioDisplay.Audicon.size() ; i ++){ 	
				if (!sim.funs.ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer(sim.vars.audioDisplay.Audicon, i).Chunk_Type.equals( "nil")){
					Matched_Chunk_Index[Matched_Chunk_Number] = i;
					Matched_Chunk_Number++;
				}
			}
		}
		else {  //matching a specific chunk type 
			for (i = 0; i < sim.vars.audioDisplay.Audicon.size() ; i ++){ 	
			if (sim.funs.ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer(sim.vars.audioDisplay.Audicon, i).Chunk_Type.equals( The_Chunk_Spec.Chunk_Type)){
				Matched_Chunk_Index[Matched_Chunk_Number] = i;
				Matched_Chunk_Number++;
				}
			}
		}

		if (Matched_Chunk_Number == 0){	 return new Chunk();}

		//int Slot_Matching_Round = 0;
		int[] Temp_Index;
		int Temp_Index_Current = 0;

		

		Iterator<Entry<String, String>> itrSlot = The_Chunk_Spec.Slot.entrySet().iterator();
		
		while ( itrSlot.hasNext()){  // get every element
			//System.out.println( myEnumerator.Key + " " + myEnumerator.Value);
		  Entry<String, String> currentEntry = itrSlot.next();
			Temp_Index = new int[Matched_Chunk_Number];
			String key = currentEntry.getKey();
			String value = currentEntry.getValue();
			for (i = 0; i < Matched_Chunk_Number; i++){   //matching chunks survived are recorded in Temp_Index array
			Chunk temp_chunk_pointer = sim.funs.ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer( sim.vars.audioDisplay.Audicon,  Matched_Chunk_Index[i] );

				if ((value).length() >= 4 ) { //protection for out of index
					if(!(value).substring(0,4).equals( "NOT_")){	//normal match "arg1 book"
					   if (  ProgramUtilitiesFun__StringsEqualByStringOrDouble(sim.funs.ChunkFun__Get_Chunk_Slot_Value( temp_chunk_pointer, key), value )){//if (  sim.funs.ChunkFun__Get_Chunk_Slot_Value( temp_chunk_pointer, key).equals( (String)value )){
							Temp_Index[Temp_Index_Current] = Matched_Chunk_Index[i];
							Temp_Index_Current++;
						}
					}
				
					else {//NOT match "arg1 NOT_book" (changed from "-arg1 book") , match !"arg1 book"
						String new_slot_value = (value).substring(4, (value).length());
						//System.out.println(The_Chunk_Spec.Slot[Slot_Matching_Round, 1].Substring(0,4));
						//System.out.println(new_slot_value);
						if (  ! ProgramUtilitiesFun__StringsEqualByStringOrDouble(sim.funs.ChunkFun__Get_Chunk_Slot_Value( temp_chunk_pointer, key), new_slot_value )){ //if (  ! sim.funs.ChunkFun__Get_Chunk_Slot_Value( temp_chunk_pointer, key).equals( new_slot_value )){
							Temp_Index[Temp_Index_Current] = Matched_Chunk_Index[i];
							Temp_Index_Current++;
						}
					}
				}
				else{ //normal match "arg1 book"
					if (  ProgramUtilitiesFun__StringsEqualByStringOrDouble(sim.funs.ChunkFun__Get_Chunk_Slot_Value( temp_chunk_pointer, key),value) ){  //if (  sim.funs.ChunkFun__Get_Chunk_Slot_Value( temp_chunk_pointer, key).equals(value) ){
							Temp_Index[Temp_Index_Current] = Matched_Chunk_Index[i];
							Temp_Index_Current++;
					}
				}
			
			}
			for (i = 0; i < Temp_Index_Current; i++){      //put Temp_Index array into Matched_Chunk_Index array
				Matched_Chunk_Index[i] = Temp_Index[i];
			}
			Matched_Chunk_Number = Temp_Index_Current;
			Temp_Index_Current = 0;
			//Slot_Matching_Round++;
		}


		if (Matched_Chunk_Number == 0) return new Chunk();
		else if (Matched_Chunk_Number == 1){
			Chunk the_matched_chunk_pointer = sim.funs.ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer( sim.vars.audioDisplay.Audicon,  Matched_Chunk_Index[0] );
			return sim.funs.ChunkFun__Chunk_Clone(the_matched_chunk_pointer);
		}
		else{
			//Chunk[] Matched_Chunk = new Chunk[Matched_Chunk_Number];
			//for (i = 0; i < Matched_Chunk_Number; i++){       //put all matched chunks together in an array of chunks
			//	Matched_Chunk[i] = sim.vars.audioDisplay.Audicon[ Matched_Chunk_Index[i] ];
			//}
			//ToDo: may add conflict resolution for multipal audicons matched later. currently just return the first match. 
			System.out.println("AudioModuleFun__Find_Audicon_By_Chunk_Spec has multiple matches");
			Chunk the_matched_chunk_pointer = sim.funs.ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer( sim.vars.audioDisplay.Audicon,  Matched_Chunk_Index[0] );
			return sim.funs.ChunkFun__Chunk_Clone(the_matched_chunk_pointer);
		}
	}
	
	//ChunkFun
	
	public String ChunkFun__Get_Chunk_Contents(Chunk temp_Chunk){
		
		//if(temp_Chunk.Chunk_Name.equals( "" ) ) return "[EMPTY]";

		List<String> return_list = new ArrayList<String>();
		if(temp_Chunk.Chunk_Name.equals( "" ) )return_list.add("NO_NAME");
		else return_list.add( temp_Chunk.Chunk_Name);
		return_list.add( " ISA ");
		return_list.add( temp_Chunk.Chunk_Type);
		
		Iterator<Entry<String, String>>itrSlot = temp_Chunk.Slot.entrySet().iterator();
		
		while (itrSlot.hasNext()){
		  Entry<String, String> currentEntry = itrSlot.next();
			return_list.add( currentEntry.getKey());
			return_list.add( currentEntry.getValue());
		}

		return  sim.funs.ProgramUtilitiesFun__ListString_To_String_Show_Empty( return_list)       ;
	}
	
	public Chunk ChunkFun__Define_Chunk(Chunk the_chunk){
		
		String chunk_name = the_chunk.Chunk_Name;
		String chunk_type = the_chunk.Chunk_Type;
//		System.out.println("beginning defining chunk: "+ chunk_name + ", of type: " + chunk_type);
//		System.out.println("sim.vars.centralParametersModule.Chunks number: "+ sim.vars.centralParametersModule.Chunks.size());
		if (sim.funs.ChunkFun__Is_Chunk_Name(chunk_name)){
			System.err.println("ChunkFun__Define_Chunk error, " + chunk_name + " is a already defined chunk name.");
			return the_chunk;
		}
		if (sim.funs.ChunkFun__Is_Chunk_Type(chunk_type)==false){
			System.err.println("ChunkFun__Define_Chunk error, " + chunk_type + " is not defined.");
		}

		if (chunk_name.equals( "" )) { //name not specified, need a name
			System.out.println("ChunkFun__Define_Chunk, name not specified, need a name");
			//use the name Chunk_Typei.i start from 0.  If "Chunk_Typei" is already a name in the model chunk list, then i++, until it is a new name.
			if(chunk_type.equals( "sound")){ //special case for audicon chunk naming
				String kind = sim.funs.ChunkFun__Get_Chunk_Slot_Value(the_chunk, "kind");
				int i = 0;
				String new_chunk_name = kind + Integer.toString(i);
				while(sim.funs.ChunkFun__Is_Chunk_Name(new_chunk_name)){
					i++;
					new_chunk_name = kind + Integer.toString(i);
				}
				the_chunk.Chunk_Name = new_chunk_name;
			}
			else{
				int i = 0;
				String new_chunk_name = chunk_type + Integer.toString(i);
				while(sim.funs.ChunkFun__Is_Chunk_Name(new_chunk_name)){
					i++;
					new_chunk_name = chunk_type + Integer.toString(i);
				}
				the_chunk.Chunk_Name = new_chunk_name;
			}
			System.out.println("ChunkFun__Define_Chunk, name not specified, get a new name: " + the_chunk.Chunk_Name);
		} //else //a specified name that is not in the model chunk list

		sim.funs.ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.centralParametersModule.Chunks , the_chunk.Chunk_Name , the_chunk ); //ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.centralParametersModule.Chunks , chunk_name , the_chunk );
		sim.funs.ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.centralParametersModule.Chunk_Types_Numbers, chunk_type, (int)sim.vars.centralParametersModule.Chunk_Types_Numbers.get(chunk_type) + 1  );

			//GlobalUtilities.popUpMessage("Define_Chunk chunk_name: " + chunk_name );
		//check if any slot value is any undefined symbol that needs to be defined as a default chunk type
		
		Iterator<Entry<String, String>>itrSlot = the_chunk.Slot.entrySet().iterator();
		while(itrSlot.hasNext()){
		  Entry<String, String> currentEntry = itrSlot.next();
			String value = currentEntry.getValue();
			//GlobalUtilities.popUpMessage("Define_Chunk value: " + value);
			if( value.charAt(0) != '=' && value.charAt(0) != '"' && sim.vars.productionModule.Forbidden_Name_In_Production_Rule.contains(value)==false && sim.funs.ChunkFun__Is_Chunk_Name(value)==false  && sim.funs.ProgramUtilitiesFun__Is_String_Double(value) == false){ // should define this as a default type of chunk: chunk (also show trace) and change this to an object of Chunk. Like ACT-R, do not define numbers as chunks
				//GlobalUtilities.popUpMessage(value + " " + sim.funs.ProgramUtilitiesFun__Is_String_Double(value) );
				Chunk temp_chunk_2 = sim.funs.ChunkFun__Make_Chunk_From_Descritption(new String[] { value, "isa", "chunk" });				
				ChunkFun__Define_Chunk (temp_chunk_2);
				ProgramUtilitiesFun__Output_Trace_Txt("#|Warning: Creating chunk " + value + " of default type chunk |#");
			}
		}

		//System.out.println("ChunkFun__Define_Chunk returning, chunk name: "+ the_chunk.Chunk_Name);
		//System.out.println("ChunkFun__Define_Chunk returning, chunk: ");
		//sim.funs.ChunkFun__Print_Chunk((Chunk) sim.vars.centralParametersModule.Chunks.get(the_chunk.Chunk_Name));
		//System.out.println("ChunkFun__Define_Chunk returning, sim.vars.centralParametersModule.Chunks number: "+ sim.vars.centralParametersModule.Chunks.size());
		return the_chunk;
	}
	
	public void ChunkFun__Add_Chunk_Slot_Name_And_Value (Chunk The_Chunk, String The_Slot_Name,String The_Slot_Value){
			if (The_Slot_Name.toLowerCase().equals( "isa")) The_Chunk.Chunk_Type = The_Slot_Value; // exception for ISA chunk-type
			else {
				if(The_Chunk.Slot.containsKey(The_Slot_Name)){
					System.out.println ("WARNING! sim.funs.ChunkFun__Add_Chunk_Slot_Name_And_Value, chunk: " + The_Chunk.Chunk_Name + " already have the slot name: "  + The_Slot_Name +", so it will be overridden.");
					The_Chunk.Slot.remove(The_Slot_Name);
				}
				The_Chunk.Slot.put(The_Slot_Name, The_Slot_Value);
			}


			//String array version
			/*
			int i;

			if (The_Slot_Name.equals( "ISA") || The_Slot_Name.equals( "isa")) The_Chunk.Chunk_Type = The_Slot_Value; // exception for ISA chunk-type
			else {

				for (i = 0; (i < 1010 && !The_Chunk.Slot[i, 0].equals( "" )); i++) { //for Chunk with Slot[1010,2], find the next empty slot
				}
				The_Chunk.Slot[i,0] = The_Slot_Name;
				The_Chunk.Slot[i,1] = The_Slot_Value;
			}
			*/
			
		}

	public String ChunkFun__Get_Chunk_Slot_Value(Chunk The_Chunk, String The_Slot_Name){
			
			
			if(The_Chunk.Slot.containsKey(The_Slot_Name)){
				return (String) The_Chunk.Slot.get(The_Slot_Name);
			}
			else{
				System.out.println ("ChunkFun__Get_Chunk_Slot_Value, chunk: " + The_Chunk.Chunk_Name + " don't have the slot name: "  + The_Slot_Name);
				ChunkFun__Print_Chunk(The_Chunk);
				return "_No_Such_Slot_Name_";
			}

		}
		
	public void ChunkFun__Set_Chunk_Slot_Value(Chunk The_Chunk, String The_Slot_Name, String The_Slot_Value){
			
			if(The_Chunk.Slot.containsKey(The_Slot_Name)){
				The_Chunk.Slot.remove(The_Slot_Name);
				The_Chunk.Slot.put(The_Slot_Name, The_Slot_Value);
			}
			else System.out.println ("ChunkFun__Set_Chunk_Slot_Value, chunk: " + The_Chunk.Chunk_Name + " don't have the slot name: "  + The_Slot_Name);

		}
		
	public Chunk ChunkFun__Chunk_Clone(Chunk the_chunk){
		
		Chunk return_chunk = new Chunk();

		return_chunk.Activation = the_chunk.Activation;
		return_chunk.base_level = the_chunk.base_level;
		return_chunk.Chunk_Name = the_chunk.Chunk_Name;
		return_chunk.Chunk_Type = the_chunk.Chunk_Type;
		return_chunk.Creation_Time =the_chunk.Creation_Time;
		return_chunk.DM_Name_Origin = the_chunk.DM_Name_Origin;
		//return_chunk.Last_Marked_T_Time 
		return_chunk.Number_Of_Presentations = the_chunk.Number_Of_Presentations;
		return_chunk.permanent_noise = the_chunk.permanent_noise;
		return_chunk.Presentation_Time_References  = sim.funs.ProgramUtilitiesFun__LinkedListDouble_Clone(the_chunk.Presentation_Time_References);


		//Hashtable version, shallow copy works for String slot names and values. Not problem like pointers 
		return_chunk.Slot = (Hashtable)  the_chunk.Slot.clone();

		return return_chunk;
	}
	
	public  void ChunkFun__Add_Chunk_Include_Type(LinkedList<String> the_descriptors){
		
		if(the_descriptors.size() < 2) System.out.println("ChunkFun__Add_Chunk_Include_Type Input needs 2 but has: " + the_descriptors.size()); 
		String child_type_name = (String)the_descriptors.get(0);
		the_descriptors.removeFirst();
		String father_type_name = (String)the_descriptors.get(0);
		if ( child_type_name.equals( father_type_name ) ){
			 System.out.println("ChunkFun__Add_Chunk_Include_Type child_type_name == father_type_name");
			return;
		}
		if ( sim.vars.centralParametersModule.Chunk_Types_Include.containsKey(child_type_name) == true){
			 System.out.println("ChunkFun__Add_Chunk_Include_Type " + child_type_name + " is already defined as a child type of " + sim.vars.centralParametersModule.Chunk_Types_Include.get(child_type_name));
			return;
		}
		 sim.vars.centralParametersModule.Chunk_Types_Include.put(child_type_name, father_type_name);
	}
	
	public boolean ChunkFun__Is_Chunk_Type(String the_chunk_type){
		
		if(sim.vars.centralParametersModule.Chunk_Types_Description.containsKey(the_chunk_type.toLowerCase())){
			return true;
		}
		else return false;
	}
	
	public  void ChunkFun__Add_Chunk_Type(LinkedList<String> the_descriptors){
		
		if(the_descriptors.size() == 0) System.out.println("ChunkFun__Add_Chunk_Type Input is empty!"); //should at least have a chunk type name
		String chunk_type_name = (String)the_descriptors.get(0);
		//GlobalUtilities.popUpMessage(chunk_type_name);
		//old // if ( !chunk_type_name.Substring(0,6) .equals( "CHUNK_" )) chunk_type_name =  "CHUNK_" + chunk_type_name ; //do not need this, CHUNK_ means it is an object of Chunk, chunk type is a kind of class name
		the_descriptors.removeFirst();
		if ( sim.funs.ChunkFun__Is_Chunk_Type (chunk_type_name) ) {
			System.out.println("#|Warning: Chunk-type "+ chunk_type_name + " is already defined and redefinition is not allowed. |#");
			return;
		}
		sim.funs.ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.centralParametersModule.Chunk_Types_Description, chunk_type_name, the_descriptors  );
		sim.funs.ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.centralParametersModule.Chunk_Types_Numbers, chunk_type_name, 0  );

}
	
	public boolean ChunkFun__Is_Chunk_Name(String the_chunk_name){
		
		if (  sim.vars.centralParametersModule.Chunks.containsKey(the_chunk_name.toLowerCase()) ){
			return true;
		}
		else return false;
	}
	
	public Chunk ChunkFun__Make_Chunk_From_Descritption(String[] The_Chunk_Spec){
		
		//check the validity of the input chunk description. ToDo: take care every cases handled in chunks.lisp, function define-chunks
		if(The_Chunk_Spec.length < 2){
			System.err.println("ChunkFun__Make_Chunk_From_Descritption has too few input parameters: " + sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty(The_Chunk_Spec));
			return null;
		}

		String chunk_name =  The_Chunk_Spec[0].toLowerCase(); 
		if(chunk_name.equals( "nil")){//non-standard usage, changed to ""
			chunk_name = "";
		}
		else if (chunk_name.equals( "isa")) { //chunk name is not specified, input start from isa
			String [] temp_array = sim.funs.ProgramUtilitiesFun__StringArray_Clone(The_Chunk_Spec);
			The_Chunk_Spec = new String [ temp_array.length + 1];
			int i;
			The_Chunk_Spec[0] = ""; //for the empty chunk_name
			for (i = 0; i < temp_array.length ; i++){
				The_Chunk_Spec[i + 1] = temp_array[i];
			}
			chunk_name = "";
		}

		if (sim.funs.ChunkFun__Is_Chunk_Name(chunk_name) == true){ // check whether a chunk with the same name is already defined in this model. ACT-R does not allow two chunks (either same type or not) to have the same name. Here empty name does not matter, because "" name is nevered defined in model chunk list.
			//GlobalUtilities.popUpMessage("ChunkFun__Make_Chunk_From_Descritption wants to make chunk: " + sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty(The_Chunk_Spec) + ", whose name is already a defined chunk name.");
			//return null;
			
			//new method, return the chunk from the model chunk list if it has been defined.
			//System.out.println("ChunkFun__Make_Chunk_From_Descritption, chunk: " + chunk_name +"exists.");
			return (Chunk) sim.vars.centralParametersModule.Chunks.get(chunk_name ) ;
			
		}

		if (!The_Chunk_Spec[1].toLowerCase().equals( "isa" )){ // the second descritpor (or the first if chunk name omitted) must be "isa"
			System.err.println("ChunkFun__Make_Chunk_From_Descritption, the second descriptor (or the first if chunk name omitted) must be 'isa': " + sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty(The_Chunk_Spec) );
			return null;
		}

		String chunk_type = The_Chunk_Spec[2].toLowerCase(); 
		if (sim.funs.ChunkFun__Is_Chunk_Type(chunk_type) == false){//check whether the chunk type is defined. Must be defined.
			if (sim.vars.centralParametersModule.Special_Chunk_Types_For_Programming.contains (chunk_type) == false ){
				System.err.println("ChunkFun__Make_Chunk_From_Descritption has a chunk type: " + chunk_type + " that is not defined but has to be defined." );
				return null;
			}
		}

		//make the chunk
		Chunk temp_chunk = new Chunk();
		ChunkFun__Add_Chunk_Slot_Name_And_Value(temp_chunk, "isa",  chunk_type); //this function can handle ISA chunk_type input
		temp_chunk.Chunk_Name = chunk_name; 
		if (sim.vars.centralParametersModule.Special_Chunk_Types_For_Programming.contains (chunk_type) == false ){ //not a special chunk type for programming
			LinkedList<String> slot_names = sim.funs.ProgramUtilitiesFun__LinkedListString_Clone ((LinkedList<String>) sim.vars.centralParametersModule.Chunk_Types_Description.get(chunk_type));
			int j;
			//add all the slots mentioned in the The_Chunk_Spec to temp_chunk
			for (j = 3; j < The_Chunk_Spec.length; j+=2){ //start from j = 3, if there is any, after ISA Chunk_type. 
				String first_descritpor = The_Chunk_Spec[j];
				if (slot_names.contains(first_descritpor) ==false){ // the defined chunk type must have the slot name
					System.out.println("slot_names of chunk_type:" + chunk_type + "are:");
					for(String str: slot_names) {
						System.out.print(str + ";");
					}
					System.out.println("\nChunkFun__Make_Chunk_From_Descritption: " + sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty(The_Chunk_Spec) + ". Chunk type " + chunk_type + " does not have the slot: " + first_descritpor);
					return null;
				}
			
				String second_descritpor = "nil"; //
				if ( (j + 1) < The_Chunk_Spec.length  ){ // there is a [j + 1 ] item
					if ( The_Chunk_Spec[j+1].equals( first_descritpor) ) { // fix the special case caused by ACT-R tutorial unit 5 group.lisp (goal ISA recall-list list list) the first list is a slot name, but the second list is the slot value
						second_descritpor = The_Chunk_Spec[j+1]; //in this case, slot_names.Contains(The_Chunk_Spec[j+1]) == true, but still cannot set the second_descriptor as nil
					}
					else if (slot_names.contains(The_Chunk_Spec[j+1])==false) second_descritpor = The_Chunk_Spec[j+1]; //then this is a slot value rather than another slot name
				}
				ChunkFun__Add_Chunk_Slot_Name_And_Value(temp_chunk, first_descritpor, second_descritpor);
				slot_names.remove(first_descritpor);
			}
			
			//add all the slots in the slot_names but not mentioned in the The_Chunk_Spec to temp_chunk, set to default value "nil"
			Enumeration<String> enum_slot_name = Collections.enumeration(slot_names);
			while(enum_slot_name.hasMoreElements()){
				ChunkFun__Add_Chunk_Slot_Name_And_Value(temp_chunk, (String)enum_slot_name.nextElement(), "nil" );
			}

		}
		else { //is a special chunk type for programming
			int j;
			//add all the slots mentioned in the The_Chunk_Spec to temp_chunk
			for (j = 3; j < The_Chunk_Spec.length; j+=2){ //start from j = 3, if there is any, after ISA Chunk_type. 
				String first_descritpor = The_Chunk_Spec[j];
				String second_descritpor = The_Chunk_Spec[j+1];
				ChunkFun__Add_Chunk_Slot_Name_And_Value(temp_chunk, first_descritpor, second_descritpor);
			}	
		}

		return temp_chunk;
	}
	
	public  boolean ChunkFun__Is_Descendant_Of(String the_tested_descendant_type_name, String the_tested_ancestor_type_name){
		
		if(sim.vars.centralParametersModule.Chunk_Types_Description.containsKey(the_tested_descendant_type_name) == false) {
			if (!the_tested_descendant_type_name.equals( ""))System.out.println("ChunkFun__Is_Descendant_Of has sim.vars.centralParametersModule.Chunk_Types_Description.ContainsKey(the_tested_descendant_type_name) == false: " + the_tested_descendant_type_name);
			return false;
		}
		if(sim.vars.centralParametersModule.Chunk_Types_Description.containsKey(the_tested_ancestor_type_name) == false) {
			System.out.println("ChunkFun__Is_Descendant_Of has sim.vars.centralParametersModule.Chunk_Types_Description.ContainsKey(the_tested_ancestor_type_name) == false. the_tested_ancestor_type_name: " + the_tested_ancestor_type_name + ". the_tested_descendant_type_name " + the_tested_descendant_type_name);
			return false;
		}
		String child_name = the_tested_descendant_type_name;
		while (sim.vars.centralParametersModule.Chunk_Types_Include.containsKey(child_name) ){
			String father_name = (String)sim.vars.centralParametersModule.Chunk_Types_Include.get(child_name);
			if (father_name.equals( the_tested_ancestor_type_name))return true;
			else child_name = father_name;
		}
		return false;
	}

	public  void ChunkFun__Popout_Message_Show_Chunk_Contents(Chunk temp_Chunk){
		
		List<String> return_list = new ArrayList<String>();
		return_list.add( "Chunk_Name:");
		return_list.add( temp_Chunk.Chunk_Name);
		return_list.add( "Chunk_Type:");
		return_list.add( temp_Chunk.Chunk_Type);

		Iterator<Entry<String, String>>itrSlot = temp_Chunk.Slot.entrySet().iterator();
		while (itrSlot.hasNext()){
		  Entry<String, String> currentEntry = itrSlot.next();
		  
			return_list.add( currentEntry.getKey());
			return_list.add( currentEntry.getValue());
		}

		if(sim.vars.printingModule.Popout_Message) System.out.println(   sim.funs.ProgramUtilitiesFun__ListString_To_String_Show_Empty( return_list)       );
	}
	
	public  void ChunkFun__Print_All_Chunks_In_Model(){
		
		
		ProgramUtilitiesFun__Output_Trace_Txt("");
		ProgramUtilitiesFun__Output_Trace_Txt("ChunkFun__Print_All_Chunks_In_Model at: " + GlobalUtilities.round(SimSystem.clock(),3));
		Iterator<Entry> itrEntries = sim.vars.centralParametersModule.Chunks.entrySet().iterator();
		
		while(itrEntries.hasNext()){
		  Entry currentEntry = itrEntries.next();
			Chunk temp_Chunk = (Chunk) currentEntry.getValue();
			ProgramUtilitiesFun__Output_Trace_Txt(" ");
			String temp_string = "";
			if (!temp_Chunk.DM_Name_Origin.equals( "" )) temp_string = "(" + temp_Chunk.DM_Name_Origin + ")";
			ProgramUtilitiesFun__Output_Trace_Txt(temp_Chunk.Chunk_Name + "  " + temp_string );
			ProgramUtilitiesFun__Output_Trace_Txt( "   ISA        " + temp_Chunk.Chunk_Type);
			
			
			Iterator<Entry<String, String>> itrSlot = temp_Chunk.Slot.entrySet().iterator();
			while ( itrSlot.hasNext() ){  // get every element
			  Entry<String, String> currentEntry1 = itrSlot.next();
				ProgramUtilitiesFun__Output_Trace_Txt( "   " + currentEntry1.getKey() + "       " + currentEntry1.getValue());
			}
		}
	}
	
	public void ChunkFun__Print_Chunk(Chunk temp_Chunk){
		ProgramUtilitiesFun__Output_Trace_Txt(" ");
		ProgramUtilitiesFun__Output_Trace_Txt(temp_Chunk.Chunk_Name + ", Last-Retrieval-Activation: " + temp_Chunk.Activation + ", base_level: " + temp_Chunk.base_level + ", permanent_noise: " +  temp_Chunk.permanent_noise+", creation time: " + temp_Chunk.Creation_Time );
		ProgramUtilitiesFun__Output_Trace_Txt("             , Number_Of_Presentations: " + temp_Chunk.Number_Of_Presentations +  ", last presentation time: " + temp_Chunk.Last_Presentation_Time);
		ProgramUtilitiesFun__Output_Trace_Txt("             , references: " + sim.funs.ProgramUtilitiesFun__LinkedListDouble_To_String(temp_Chunk.Presentation_Time_References));
		ProgramUtilitiesFun__Output_Trace_Txt(temp_Chunk.Chunk_Name);
		ProgramUtilitiesFun__Output_Trace_Txt( "   ISA        " + temp_Chunk.Chunk_Type);
		
		System.out.println("ChunkFun__Print_Chunk: ");
		System.out.println(temp_Chunk.Chunk_Name + ", Last-Retrieval-Activation: " + temp_Chunk.Activation + ", base_level: " + temp_Chunk.base_level + ", permanent_noise: " +  temp_Chunk.permanent_noise+", creation time: " + temp_Chunk.Creation_Time );
		System.out.println("             , Number_Of_Presentations: " + temp_Chunk.Number_Of_Presentations +  ", last presentation time: " + temp_Chunk.Last_Presentation_Time);
		System.out.println("             , references: " + sim.funs.ProgramUtilitiesFun__LinkedListDouble_To_String(temp_Chunk.Presentation_Time_References));
		System.out.println(temp_Chunk.Chunk_Name);
		System.out.println( "   ISA        " + temp_Chunk.Chunk_Type);
		
		if(sim.vars.qn_answer) {
			ProgramUtilitiesFun__Output_QN_Result_Txt(" ");
			ProgramUtilitiesFun__Output_QN_Result_Txt(temp_Chunk.Chunk_Name + ", Last-Retrieval-Activation: " + temp_Chunk.Activation + ", base_level: " + temp_Chunk.base_level + ", permanent_noise: " +  temp_Chunk.permanent_noise+", creation time: " + temp_Chunk.Creation_Time );
			ProgramUtilitiesFun__Output_QN_Result_Txt("             , Number_Of_Presentations: " + temp_Chunk.Number_Of_Presentations +  ", last presentation time: " + temp_Chunk.Last_Presentation_Time);
			ProgramUtilitiesFun__Output_QN_Result_Txt("             , references: " + sim.funs.ProgramUtilitiesFun__LinkedListDouble_To_String(temp_Chunk.Presentation_Time_References));
			ProgramUtilitiesFun__Output_QN_Result_Txt(temp_Chunk.Chunk_Name);
			ProgramUtilitiesFun__Output_QN_Result_Txt( "   ISA        " + temp_Chunk.Chunk_Type);
		}
		
		Iterator<Entry<String, String>> itrSlot = temp_Chunk.Slot.entrySet().iterator();
		while ( itrSlot.hasNext() ){  // get every element
			Entry<String, String> currentEntry1 = itrSlot.next();
			ProgramUtilitiesFun__Output_Trace_Txt( "   " + currentEntry1.getKey() + "       " + currentEntry1.getValue());
			System.out.println( "   " + currentEntry1.getKey() + "       " + currentEntry1.getValue());
			if(sim.vars.qn_answer) ProgramUtilitiesFun__Output_QN_Result_Txt("   " + currentEntry1.getKey() + "       " + currentEntry1.getValue());
		}
	}
	
	//DeclarativeModuleFun
	
	public Chunk DeclarativeModuleFun__Find_DM_Chunk_By_Chunk_Name(String The_Chunk_Name){
		sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("DeclarativeModuleFun__Find_DM_Chunk_By_Chunk_Name, sim.vars.declarativeModule.Number_of_Chunks: " + sim.vars.declarativeModule.Number_of_Chunks);
		int i;
		for (i = 0; i < sim.vars.declarativeModule.Number_of_Chunks ; i ++){ 
			Chunk temp_chunk = sim.funs.ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer(sim.vars.declarativeModule.DM_Chunk, i);
			if (temp_chunk.Chunk_Name.equals( The_Chunk_Name)){
				sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("DeclarativeModuleFun__Find_DM_Chunk_By_Chunk_Name, found.");
				return sim.funs.ChunkFun__Chunk_Clone (temp_chunk); //suppose each chunk has a unique name
			}
		}

		//if no such chunk name
		//Model.Message ("No chunk with name: " + The_Chunk_Name + " in declarative memory.");
		sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("DeclarativeModuleFun__Find_DM_Chunk_By_Chunk_Name, No chunk with name: " + The_Chunk_Name + " in declarative memory.");
		return new Chunk();
	}
	
	public int DeclarativeModuleFun__Find_The_DM_Chunk_ID_By_Chunk_Name(String the_chunk_name){
		
		Enumeration enum_chunk = Collections.enumeration(sim.vars.declarativeModule.DM_Chunk);
		int i = 0 ;
		while(enum_chunk.hasMoreElements()){
			if (  ((Chunk)enum_chunk.nextElement()).Chunk_Name.equals(  the_chunk_name)  ) return i;
			i++;
		}

		return -1;
	}
	
	public  void DeclarativeModuleFun__Update_Chunk_Presentation(Chunk the_chunk){
		
		//old//Chunk DM_chunk_pointer = ((Chunk)ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer( sim.vars.declarativeModule.DM_Chunk , (int)DeclarativeModuleFun__Find_The_DM_Chunk_ID_By_Chunk_Spec(the_chunk) ));
		Chunk DM_chunk_pointer = ((Chunk)ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer( sim.vars.declarativeModule.DM_Chunk , (int)DeclarativeModuleFun__Find_The_DM_Chunk_ID_By_Chunk_Name(the_chunk.Chunk_Name) ));
		DM_chunk_pointer.Number_Of_Presentations++;
		DM_chunk_pointer.Last_Presentation_Time = GlobalUtilities.round(SimSystem.clock(),3);


		//sim.vars.declarativeModule.DM_Chunk[DeclarativeModuleFun__Find_The_DM_Chunk_ID_By_Chunk_Spec(the_chunk)].Number_Of_Presentations++;

		if (sim.vars.centralParametersModule.ol.equals( "t")){ 
			//just update number, no need to track references
			//temporary track references for development
			//sim.vars.declarativeModule.DM_Chunk[DeclarativeModuleFun__Find_The_DM_Chunk_ID_By_Chunk_Spec(the_chunk)].Presentation_Time_References.addLast (GlobalUtilities.round (SimSystem.clock(), 3) );
		}
		else if (sim.vars.centralParametersModule.ol.equals( "nil"))
		{ 
			DM_chunk_pointer.Presentation_Time_References.addLast ((double) GlobalUtilities.round(SimSystem.clock(),3) );
			//sim.vars.declarativeModule.DM_Chunk[DeclarativeModuleFun__Find_The_DM_Chunk_ID_By_Chunk_Spec(the_chunk)].Presentation_Time_References.addLast (GlobalUtilities.round (SimSystem.clock(), 3) );
		}
		else{ // :ol is a number , references should be the lasted :ol 
			int ol_number = Integer.parseInt(sim.vars.centralParametersModule.ol);
			
			if (ol_number >= DM_chunk_pointer.Number_Of_Presentations){
			//if (ol_number >= sim.vars.declarativeModule.DM_Chunk[DeclarativeModuleFun__Find_The_DM_Chunk_ID_By_Chunk_Spec(the_chunk)].Number_Of_Presentations){
				DM_chunk_pointer.Presentation_Time_References.addLast ((double) GlobalUtilities.round(SimSystem.clock(),3)) ;
				//sim.vars.declarativeModule.DM_Chunk[DeclarativeModuleFun__Find_The_DM_Chunk_ID_By_Chunk_Spec(the_chunk)].Presentation_Time_References.addLast (GlobalUtilities.round (SimSystem.clock(), 3) );
			}
			else{
				DM_chunk_pointer.Presentation_Time_References.removeFirst();
				//sim.vars.declarativeModule.DM_Chunk[DeclarativeModuleFun__Find_The_DM_Chunk_ID_By_Chunk_Spec(the_chunk)].Presentation_Time_References.RemoveFirst();
				DM_chunk_pointer.Presentation_Time_References.addLast ((double) GlobalUtilities.round(SimSystem.clock(),3) );
				//sim.vars.declarativeModule.DM_Chunk[DeclarativeModuleFun__Find_The_DM_Chunk_ID_By_Chunk_Spec(the_chunk)].Presentation_Time_References.addLast (GlobalUtilities.round (SimSystem.clock(), 3) );
			}
		}
	}
	
	public  void DeclarativeModuleFun__Add_DM_Chunk_With_String_Array(String[] The_Chunk_Spec){
		
		// sim.vars.visualization__DM_Chunk_Number?
		
		Chunk temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(The_Chunk_Spec);

		temp_chunk.Creation_Time = GlobalUtilities.round(SimSystem.clock(),3);

		//define this chunk in model Chunks list (not DM_Chunk list) if it is not defined
		if (ChunkFun__Is_Chunk_Name(temp_chunk.Chunk_Name) == false) {
			System.out.println("DeclarativeModuleFun__Add_DM_Chunk_With_String_Array, define this chunk in model Chunks list (not DM_Chunk list) if it is not defined");
			sim.funs.ChunkFun__Define_Chunk(temp_chunk);
			System.out.println("DeclarativeModuleFun__Add_DM_Chunk_With_String_Array, defining chunk finished");
		}

		//only called when no such chunk name in DM
		if ((DeclarativeModuleFun__Find_DM_Chunk_By_Chunk_Name( temp_chunk.Chunk_Name)).Chunk_Name.equals( temp_chunk.Chunk_Name) ) {//already a chunk with the same name in DM
			ProgramUtilitiesFun__Output_Trace_Txt("#|Warning: Invalid chunk definition: "+ temp_chunk.Chunk_Name + " names a chunk which already exists. Definition ignored|#");
			return;
		}


		//sim.vars.declarativeModule.DM_Chunk[sim.vars.declarativeModule.Number_of_Chunks].Creation_Time = GlobalUtilities.round(SimSystem.clock(),3);

		sim.vars.declarativeModule.DM_Chunk.addFirst(temp_chunk);
		sim.vars.visualization__DM_Chunk_Number ++;
		sim.vars.declarativeModule.Number_of_Chunks++;

		DeclarativeModuleFun__Update_Chunk_Presentation(temp_chunk);


	}
	
	public  void DeclarativeModuleFun__Add_DM_Chunk_With_Chunk(Chunk The_Chunk){
		
		//only called when no such chunk name in DM
		//old //if ( sim.funs.DeclarativeModuleFun__Find_The_DM_Chunk_ID_By_Chunk_Spec (The_Chunk) != -1)GlobalUtilities.popUpMessage("DeclarativeModuleFun__Add_DM_Chunk_With_Chunk, try to add a chunk that is already in DM");
		if ((DeclarativeModuleFun__Find_DM_Chunk_By_Chunk_Name( The_Chunk.Chunk_Name)).Chunk_Name.equals( The_Chunk.Chunk_Name) ) { //already a chunk with the same name in DM
			ProgramUtilitiesFun__Output_Trace_Txt("#|Warning: Invalid chunk definition: "+ The_Chunk.Chunk_Name + " names a chunk which already exists. Definition ignored|#");
			return;
		}

		if (The_Chunk.Chunk_Name.equals( "" )){
			The_Chunk.Chunk_Name = 	"DM_chunk "+Integer.toString(sim.vars.declarativeModule.Number_of_Chunks);
		}
		The_Chunk.Creation_Time = GlobalUtilities.round(SimSystem.clock(),3);

		//define this chunk in model Chunks list (not DM_Chunk list) if it is not defined
		if (ChunkFun__Is_Chunk_Name(The_Chunk.Chunk_Name) == false) {
			//System.out.println("DeclarativeModuleFun__Add_DM_Chunk_With_Chunk, defining chunk: " + The_Chunk.Chunk_Name);
			sim.funs.ChunkFun__Define_Chunk(The_Chunk);
			//System.out.println("DeclarativeModuleFun__Add_DM_Chunk_With_Chunk, finished defining chunk. ");
		}

		sim.vars.declarativeModule.DM_Chunk.addFirst ( sim.funs.ChunkFun__Chunk_Clone (The_Chunk) );
		sim.vars.visualization__DM_Chunk_Number ++;
		sim.vars.declarativeModule.Number_of_Chunks++;


		DeclarativeModuleFun__Update_Chunk_Presentation(The_Chunk); // this function will find the DM chunk ID by The_Chunk information

	}
	
	public  double DeclarativeModuleFun__Get_DM_Chunk_Base_Level_Activation(Chunk The_Chunk){
	  
	  
	  if ( sim.vars.declarativeModule.bll.equals( "nil")){ //If :bll is nil then the setting of :ol does not matter and the base-level is a constant value
	    if (!The_Chunk.base_level.equals( "nil")){
	      return  (double) Double.parseDouble(The_Chunk.base_level); //the chunk's :base-level parameter if specified. :base-level overrides :blc
	    }
	    else return sim.vars.declarativeModule.blc; //determined by the :blc parameter 
	  }
	  else{ //If :bll is set to a number, then the setting of :ol determines how the base-level is computed. 
	    double return_value = 0.0;
	    if (sim.vars.centralParametersModule.ol.equals( "t")){ // Optimized Learning 
	      long n; //The number of presentations of chunk i.
	      double L; // The lifetime of chunk i (the time since its creation).
	      double d; //  The decay parameter
	      
	      n = The_Chunk.Number_Of_Presentations;
	      L = GlobalUtilities.round(SimSystem.clock(),3) - The_Chunk.Creation_Time;
	      d = Double.parseDouble(sim.vars.declarativeModule.bll);
	      
	      return_value = Math.log( n / (1-d) ) - d * Math.log( L ) + sim.vars.declarativeModule.blc;
	      
	    }
	    else if (sim.vars.centralParametersModule.ol.equals( "nil")) { //full computation :ol nil
	      long n; //The number of presentations of chunk i.
	      double d; //  The decay parameter
	      n = The_Chunk.Number_Of_Presentations;
	      d = Double.parseDouble(sim.vars.declarativeModule.bll);
	      
	      double sigma = 0;
	      Enumeration Enum = Collections.enumeration(The_Chunk.Presentation_Time_References); 
	      while(Enum.hasMoreElements()){
	        double tj = GlobalUtilities.round(SimSystem.clock(),3) - (double)Enum.nextElement();
	        sigma += Math.pow( Math.max(0.05, tj), -d)  ;
	      }
	      return_value = Math.log( sigma ) + sim.vars.declarativeModule.blc;
	      //GlobalUtilities.popUpMessage(    return_value        );
	    }
	    else  { //:ol is a number
	      int k; //the value of the :ol parameter.
	      long n; //The number of presentations of chunk i.
	      double d; //  The decay parameter
	      double extra_term; // the extra_term
	      k = Integer.parseInt(sim.vars.centralParametersModule.ol);
	      n = The_Chunk.Number_Of_Presentations;
	      d = Double.parseDouble(sim.vars.declarativeModule.bll);
	      
	      double sigma = 0;
	      Enumeration Enum = Collections.enumeration(The_Chunk.Presentation_Time_References);  //numbers of references are controlled by sim.funs.DeclarativeModuleFun__Update_Chunk_Presentation
	      while(Enum.hasMoreElements()){
	        double tj = GlobalUtilities.round(SimSystem.clock(),3) - (double)Enum.nextElement();
	        sigma += Math.pow( Math.max(0.05, tj), -d)  ;
	      }
	      
	      if (n <= k) {
	        extra_term = 0;
	      }
	      else{
	        double tn = GlobalUtilities.round(SimSystem.clock(),3) - The_Chunk.Creation_Time; //the oldest presentation 
	        double tk = GlobalUtilities.round(SimSystem.clock(),3) - The_Chunk.Presentation_Time_References.getFirst()    ;//the oldest presentation in the reference
	        extra_term = (n-k)*( Math.pow( Math.max(0.05, tn), (1-d))-Math.pow( Math.max(0.05, tk), (1-d))) / ((1-d)*(Math.max(0.05, tn) - Math.max(0.05, tk)));
	      }
	      
	      return_value  = Math.log( sigma + extra_term) + sim.vars.declarativeModule.blc;
	      
	      if(sim.vars.printingModule.v.equals( "t")) sim.funs.ProgramUtilitiesFun__Output_Trace_Txt( " ");
	      if(sim.vars.printingModule.v.equals( "t")) sim.funs.ProgramUtilitiesFun__Output_Trace_Txt( "Chunk_Base_Level_Activation, chunk: " + The_Chunk.Chunk_Name + ", base level activation: "  + return_value     );
	      
	      
	    }
	    return (double) return_value;	
	  }


	}
	
	public  LinkedList<String> DeclarativeModuleFun__Get_Chunks_In_Chunk_Slots(Chunk the_chunk){
		
		// get the slot values of chunk names, i.e., marked with CHUNK_..., in the chunk,


		LinkedList<String> return_list = new LinkedList<String>();

		
		Iterator<Entry<String, String>>itrSlot = the_chunk.Slot.entrySet().iterator();
		while ( itrSlot.hasNext() ){  // get every element
		  Entry<String, String> currentEntry = itrSlot.next();
			if(ChunkFun__Is_Chunk_Name( currentEntry.getValue()) ) return_list.addLast( currentEntry.getValue() );
			

		}



		return return_list;

	}
	
	public  LinkedList<String> DeclarativeModuleFun__Get_Retrieved_Chunk_In_Linkedlist(){
		
		Chunk retrieved_chunk = sim.vars.retrievalBuffer.Retrieval_Buffer_Chunk;
		LinkedList<String> return_linkedlist = new LinkedList<String>();

		return_linkedlist.addLast("isa");
		return_linkedlist.addLast(retrieved_chunk.Chunk_Type);

		
		Iterator<Entry<String, String>>itrSlot = retrieved_chunk.Slot.entrySet().iterator();
		while ( itrSlot.hasNext()  ){  // get every element
		  Entry<String, String> currentEntry = itrSlot.next();
		  
			return_linkedlist.addLast( currentEntry.getKey() );
			return_linkedlist.addLast( currentEntry.getValue() );
		}

		/* //chunk string array version
		int i,j;
		for (i = 0; i < 1010; i++){
			if (retrieved_chunk.Slot[i,0].equals( "" ))break;
			for (j = 0 ; j < 2; j ++){
				return_linkedlist.addLast( retrieved_chunk.Slot[i,j] );
			}
		}
		*/

		return return_linkedlist;
	}
	
	public  int DeclarativeModuleFun__Get_Slotsj(String target_chunk_name){
		
		int return_int = 0;

		Enumeration Enum = Collections.enumeration(sim.vars.declarativeModule.DM_Chunk);
		while (Enum.hasMoreElements()){
			Chunk the_chunk = (Chunk) Enum.nextElement();
			
			Iterator<Entry<String, String>>itrSlot = the_chunk.Slot.entrySet().iterator();
			while ( itrSlot.hasNext() ){  // get every element
			  Entry<String, String> currentEntry = itrSlot.next();
				if ( (currentEntry.getValue()).equals( target_chunk_name))
					{
		 				return_int++;
						if(sim.vars.printingModule.v.equals( "t")) sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t\t\tslotsj: "+ target_chunk_name +" is a slot value in Chunk: " + the_chunk.Chunk_Name + ". Match: " + currentEntry.getValue());					
					}
				//else 	if(sim.vars.printingModule.v.equals( "t" )) sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\tslotsj: "+ target_chunk_name +" is NOT a slot value in Chunk: " + the_chunk.Chunk_Name + ". NOT Match: " + (String)myEnumerator.Value);	
			}
		}




		return return_int;
	}
	
	public  int DeclarativeModuleFun__Get_slotsofj(String target_chunk_name, Chunk the_chunk_i){
		
		int return_int = 0;

		Iterator<Entry<String, String>>itrSlot = the_chunk_i.Slot.entrySet().iterator();
		while ( itrSlot.hasNext() ){  // get every element
		  Entry<String, String> currentEntry = itrSlot.next();
			if (( currentEntry.getValue()).equals( target_chunk_name)) return_int++ ;
		}



		return return_int;
	}
	
	public  double DeclarativeModuleFun__Get_DM_Chunk_Spread_Activation(Chunk the_chunk){
		
		if (sim.vars.declarativeModule.mas.equals( "nil")) return (double) 0.0;
		else{
			double the_mas = Double.parseDouble(sim.vars.declarativeModule.mas); //S: The maximum associative strength set with the :mas parameter.
			double total_S = 0.0;
			//add all buffers who have activation > 0 
			LinkedList<Three_Tuple>  tuple_list = new LinkedList<Three_Tuple>  ();
			if (sim.vars.goalBuffer.ga > 0.0){
				Three_Tuple temp_tuple = new Three_Tuple ();
				temp_tuple.Ob1 = "Goal_Buffer";
				temp_tuple.Ob2 = sim.vars.goalBuffer.ga;
				temp_tuple.Ob3 = sim.vars.goalBuffer.Goal_Buffer_Chunk;
				tuple_list.addLast (temp_tuple);
			}
			if (sim.vars.goalBuffer.ga2 > 0.0){
				Three_Tuple temp_tuple = new Three_Tuple ();
				temp_tuple.Ob1 = "Goal_Buffer_2";
				temp_tuple.Ob2 = sim.vars.goalBuffer.ga2;
				temp_tuple.Ob3 = sim.vars.goalBuffer.Goal_Buffer_Chunk_2;
				tuple_list.addLast (temp_tuple);
			}
			if (sim.vars.imaginalBuffer.Imaginal_Activation > 0.0){
				Three_Tuple temp_tuple = new Three_Tuple ();
				temp_tuple.Ob1 = "Imaginal_Buffer";
				temp_tuple.Ob2 = sim.vars.imaginalBuffer.Imaginal_Activation;
				temp_tuple.Ob3 = sim.vars.imaginalBuffer.Imaginal_Buffer_Chunk; 
				tuple_list.addLast (temp_tuple);
			}
			if (sim.vars.retrievalBuffer.Retrieval_Activation > 0.0){
				Three_Tuple temp_tuple = new Three_Tuple ();
				temp_tuple.Ob1 = "Retrieval_Buffer";
				temp_tuple.Ob2 = sim.vars.retrievalBuffer.Retrieval_Activation;
				temp_tuple.Ob3 = sim.vars.retrievalBuffer.Retrieval_Buffer_Chunk; 
				tuple_list.addLast (temp_tuple);
			}
			if (sim.vars.visualLocationBuffer.Visual_Location_Activation > 0.0){
				Three_Tuple temp_tuple = new Three_Tuple ();
				temp_tuple.Ob1 = "Visual_Location_Buffer";
				temp_tuple.Ob2 = sim.vars.visualLocationBuffer.Visual_Location_Activation;
				temp_tuple.Ob3 = sim.vars.visualLocationBuffer.Visual_Location_Buffer_Chunk; 
				tuple_list.addLast (temp_tuple);
			}
			if (sim.vars.visualBuffer.Visual_Activation > 0.0){
				Three_Tuple temp_tuple = new Three_Tuple ();
				temp_tuple.Ob1 = "Visual_Buffer";
				temp_tuple.Ob2 = sim.vars.visualBuffer.Visual_Activation;
				temp_tuple.Ob3 = sim.vars.visualBuffer.Visual_Buffer_Chunk; 
				tuple_list.addLast (temp_tuple);
			}
			if (sim.vars.auralLocationBuffer.Aural_Location_Activation > 0.0){
				Three_Tuple temp_tuple = new Three_Tuple ();
				temp_tuple.Ob1 = "Aural_Location_Buffer";
				temp_tuple.Ob2 = sim.vars.auralLocationBuffer.Aural_Location_Activation;
				temp_tuple.Ob3 = sim.vars.auralLocationBuffer.Aural_Location_Buffer_Chunk; 
				tuple_list.addLast (temp_tuple);
			}
			if (sim.vars.auralBuffer.Aural_Activation > 0.0){
				Three_Tuple temp_tuple = new Three_Tuple ();
				temp_tuple.Ob1 = "Aural_Buffer";
				temp_tuple.Ob2 = sim.vars.auralBuffer.Aural_Activation;
				temp_tuple.Ob3 = sim.vars.auralBuffer.Aural_Buffer_Chunk; 
				tuple_list.addLast (temp_tuple);
			}
			//ToDo: currently don't have imaginal-action-buffer. 	
			//GlobalUtilities.popUpMessage("DeclarativeModuleFun__Get_DM_Chunk_Spread_Activation tuple_list.Count: " +  tuple_list.Count );
			Enumeration enum_tuple = Collections.enumeration(tuple_list);
			while(enum_tuple.hasMoreElements()){ 
				Three_Tuple temp_tuple = (Three_Tuple) enum_tuple.nextElement();
				String buffer_name = (String) temp_tuple.Ob1;
				double activation = (double) temp_tuple.Ob2;
				Chunk buffer_chunk_clone = sim.funs.ChunkFun__Chunk_Clone ((Chunk)temp_tuple.Ob3);
			
				//before 6.0, only goal buffer is considered for spread activation, so is here. when more than one buffer are considered, repeat this for each buffer and add the S together.
				String chunk_name = buffer_chunk_clone.Chunk_Name;
				if (chunk_name.equals( "" )) chunk_name = "[NONE]";
				if(sim.vars.printingModule.v.equals( "t" ) && sim.vars.declarativeModule.act == true)  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\tComputing activation spreading in the " + buffer_name + ", chunk: " + chunk_name);
				double source_activation_in_buffer = activation;
				LinkedList<String> source_list = sim.funs.DeclarativeModuleFun__Get_Chunks_In_Chunk_Slots(buffer_chunk_clone);
				int number_of_sources = source_list.size();
				//GlobalUtilities.popUpMessage("number_of_sources: " + number_of_sources);
				if (number_of_sources == 0){
					//if(sim.vars.printingModule.v.equals( "t" ))  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\tComputing activation spreading for chunk: " + the_chunk.Chunk_Name); 
					if(chunk_name.equals ( "[NONE]")){
						if(sim.vars.printingModule.v.equals( "t" ) && sim.vars.declarativeModule.act == true)  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t  the buffer is empty."); 
					}
					else {
						if(sim.vars.printingModule.v.equals( "t" ) && sim.vars.declarativeModule.act == true)  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t  the buffer chunk does not have any chunk as slot value."); 
					}
					if(sim.vars.printingModule.v.equals( "t" ) && sim.vars.declarativeModule.act == true)  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t  spreading activation from this buffer is: 0"); 
					continue; //otherwise the lines below will have zero as the devisor.
				}
				
				double Wj = source_activation_in_buffer / number_of_sources; // Wkj: This is the amount of activation from source j in buffer k. It is the source activation of buffer k divided by the number of sources j in that buffer.
				//if(sim.vars.printingModule.v.equals( "t" ))  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\tComputing activation spreading for chunk: " + the_chunk.Chunk_Name); 
				if(sim.vars.printingModule.v.equals( "t" ) && sim.vars.declarativeModule.act == true)  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t\tSpreading: " + source_activation_in_buffer + ", between "+ number_of_sources +" sources of activation: " + sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty(sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(source_list))); 
				LinkedList<String> chunks_in_chunk_i = sim.funs.DeclarativeModuleFun__Get_Chunks_In_Chunk_Slots(the_chunk);
				double S = 0.0;
				Enumeration Enum = Collections.enumeration(source_list); //this is j in the ACT-R 6.0 reference manual
				while(Enum.hasMoreElements()){
				  String currentItem = (String) Enum.nextElement();
					if(sim.vars.printingModule.v.equals( "t" ) && sim.vars.declarativeModule.act == true)  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t\tfor chunk: "+ currentItem + " as a slot value of the buffer chunk,");
					double Sj;
					if ( !currentItem.equals( the_chunk.Chunk_Name) && !chunks_in_chunk_i.contains( currentItem ) ) { //If chunks j and i are not the same chunk and j is not in a slot of chunk i: 
						Sj = 0.0;
					}
					else{ //If chunks j and i are the same chunk or chunk j is in a slot of chunk i:
						int slotsj = sim.funs.DeclarativeModuleFun__Get_Slotsj ( currentItem ); //the number of slots in which j is the value across all chunks in DM.
						if(sim.vars.printingModule.v.equals( "t" ) && sim.vars.declarativeModule.act == true)  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t\t\tslotsj: " + slotsj);			
						int slotsofj =  sim.funs.DeclarativeModuleFun__Get_slotsofj( currentItem , the_chunk );    //the number of slots in chunk i which have j as the value (plus 1 when chunk i is chunk j).
						if(sim.vars.printingModule.v.equals( "t" ) && sim.vars.declarativeModule.act == true)  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t\t\tslotsofj: " + slotsofj);
						double fanj = (1.0 + (double)slotsj) / (double)slotsofj ;
						if(sim.vars.printingModule.v.equals( "t" ) && sim.vars.declarativeModule.act == true)  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t\t\tfanj: " + fanj);				
						Sj = the_mas - Math.log(fanj);
			/*
			// this was for debug: 
			Chunk temp = 	DeclarativeModuleFun__Find_DM_Chunk_By_Chunk_Name("CHUNK_goal");		
			ProgramUtilitiesFun__Output_Trace_Txt("Check goal in DM " + temp.Slot[0,0]);
			ProgramUtilitiesFun__Output_Trace_Txt("Check goal in DM " + temp.Slot[0,1]);
			ProgramUtilitiesFun__Output_Trace_Txt("Check goal in DM " + temp.Slot[1,0]);
			ProgramUtilitiesFun__Output_Trace_Txt("Check goal in DM " + temp.Slot[1,1]);
			*/
					}
					if(sim.vars.printingModule.v.equals( "t" ) && sim.vars.declarativeModule.act == true)  		ProgramUtilitiesFun__Output_Trace_Txt("\t\tSpreading activation  "+ Wj*Sj + "\tfrom source "+ currentItem +" level  "+ Wj +" times Sji "+ Sj );
					S +=  Wj * Sj;
				}
				
				if(sim.vars.printingModule.v.equals( "t" ) && sim.vars.declarativeModule.act == true)  	ProgramUtilitiesFun__Output_Trace_Txt("\t  spreading activation from this buffer is: " + S);
				total_S += S;
			}
			
			String show_when_mas_nil = "";
			if(sim.vars.declarativeModule.mas.equals( "nil")) show_when_mas_nil = " (default when spreading activation computation is off) " ;
			
			
			if(sim.vars.printingModule.v.equals( "t" ) && sim.vars.declarativeModule.act == true)  	ProgramUtilitiesFun__Output_Trace_Txt("Total spreading activation from all buffers is: " + total_S + show_when_mas_nil);
			return (double) total_S;
		}




	}
	
	public  double DeclarativeModuleFun__Compute_Retrieval_Time(Chunk The_Chunk){
		
		//if(sim.vars.printingModule.Output_Window_Trace)System.out.println( "DeclarativeModuleFun__Compute_Retrieval_Time: " + The_Chunk.Chunk_Name);

		if (sim.vars.centralParametersModule.esc ==  false){
			return  (double) 0.0;
			/*
			 (schedule-event-relative 
		                                   (if (dm-esc dm)
		                                       (compute-activation-latency dm (chunk-activation best1))
		                                     0)
											*/
		}
		else{ //Enable Subsymbolic Computations 
			double A; // The activation of the chunk which is retrieved.	
			if ( The_Chunk.Chunk_Name.equals( "" ) && The_Chunk.Chunk_Type.equals( "" )){ // no chunk matches the retrieval request
				A = sim.vars.declarativeModule.rt;
			}
			else {  //there is such chunk in DM
				A =  The_Chunk.Activation;
				}
			
			double F = sim.vars.declarativeModule.lf;
			double f = sim.vars.declarativeModule.le;
			
			return  (double) (F * Math.exp ( (-1) * ( f * A) ));
		}
	}
	
	public void DeclarativeModuleFun__Update_Declarative_Finst(){
		
		LinkedList<String> remove_list = new LinkedList<String>();
		Enumeration enum_chunk_name = Collections.enumeration(sim.vars.declarativeModule.Declarative_Retrieved_Finst_Name_List);
		sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("DeclarativeModuleFun__Update_Declarative_Finst, sim.vars.declarativeModule.Declarative_Retrieved_Finst_Name_List number: " + sim.vars.declarativeModule.Declarative_Retrieved_Finst_Name_List.size());
		while( enum_chunk_name.hasMoreElements()){
			String chunk_name = (String)enum_chunk_name.nextElement();
			double last_retrieval_time = (double) sim.vars.declarativeModule.Declarative_Retrieved_Finst_Time_Hashtable.get(chunk_name) ;
			if (GlobalUtilities.round(SimSystem.clock(),3) >= GlobalUtilities.round( (last_retrieval_time + sim.vars.declarativeModule.Declarative_Finst_Span) ,3)) remove_list.addFirst( chunk_name );
		}

		Enumeration remove_name = Collections.enumeration(remove_list);
		while (remove_name.hasMoreElements()){
			String temp_name = (String) remove_name.nextElement();
			sim.vars.declarativeModule.Declarative_Retrieved_Finst_Name_List.remove(temp_name);
			sim.vars.declarativeModule.Declarative_Retrieved_Finst_Time_Hashtable.remove(temp_name);
		} 
		sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("DeclarativeModuleFun__Update_Declarative_Finst, finish.");
	}
	
	public  LinkedList<Integer> DeclarativeModuleFun__Find_Add_Retrieval_Matched_DM_Chunk_IDs_By_Chunk_Spec(Chunk The_Chunk_Spec){
		
	  boolean debug = false;
	  
		//if(sim.vars.printingModule.Output_Window_Trace)System.out.println( "DeclarativeModuleFun__Find_Add_Retrieval_Matched_DM_Chunk_IDs_By_Chunk_Spec: " + The_Chunk_Spec.Chunk_Name);

		DeclarativeModuleFun__Update_Declarative_Finst();

		LinkedList<Integer> return_linkedlist = new LinkedList<Integer> ();
		int i;
		int Matched_Chunk_Number = 0; //how many matched chunk found, and also the index of the next empty index of Matched_Chunk_Index
		if (sim.vars.declarativeModule.Number_of_Chunks < 1){
			//GlobalUtilities.popUpMessage("DeclarativeModuleFun__Find_Add_Retrieval_Matched_DM_Chunk_IDs_By_Chunk_Spec() Error! sim.vars.declarativeModule.Number_of_Chunks < 1");
			if(debug) System.err.println("Error! DeclarativeModuleFun__Find_Add_Retrieval_Matched_DM_Chunk_IDs_By_Chunk_Spec() Error! sim.vars.declarativeModule.Number_of_Chunks < 1");
		  return return_linkedlist;
		}
		
		int[] Matched_Chunk_Index = new int[sim.vars.declarativeModule.Number_of_Chunks]; //at this time, should Add at least 1 DM_CHUNK, sim.vars.declarativeModule.Number_of_Chunks need to > 0

		//name match is another function, because each chunk should have an unique name.

		if (The_Chunk_Spec.Chunk_Type.equals( "nil")){  //the first round is chunk type, ISA match
			//may add later for chunk type is nil
			System.out.println("WARNING! DeclarativeModuleFun__Find_Add_Retrieval_Matched_DM_Chunk_IDs_By_Chunk_Spec has chunk type nil");
			}
		else if (The_Chunk_Spec.Chunk_Type.equals( "" )){
			//may add later for matching any chunk type that is not nil
			System.out.println("WARNING! DeclarativeModuleFun__Find_Add_Retrieval_Matched_DM_Chunk_IDs_By_Chunk_Spec has chunk type empty");
			}
		else {  //matching a specific chunk type , still do this when doing partial matching
			for (i = 0; i < sim.vars.declarativeModule.Number_of_Chunks ; i ++){
			  
			  if(debug) System.out.println("DeclarativeModuleFun__Find_Add_Retrieval_Matched_DM_Chunk_IDs_By_Chunk_Spec sim.funs.ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer(sim.vars.declarativeModule.DM_Chunk, i).Chunk_Type: " + sim.funs.ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer(sim.vars.declarativeModule.DM_Chunk, i).Chunk_Type + ". The_Chunk_Spec.Chunk_Type: " + The_Chunk_Spec.Chunk_Type);
			  
				if (sim.funs.ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer(sim.vars.declarativeModule.DM_Chunk, i).Chunk_Type.equals( The_Chunk_Spec.Chunk_Type )){
				//if (sim.vars.declarativeModule.DM_Chunk[i].Chunk_Type == The_Chunk_Spec.Chunk_Type){
					Matched_Chunk_Index[Matched_Chunk_Number] = i;
					Matched_Chunk_Number++;
				}
			}
			
			if(debug) System.out.println("DeclarativeModuleFun__Find_Add_Retrieval_Matched_DM_Chunk_IDs_By_Chunk_Spec has matched chunk type items: " + Matched_Chunk_Number);
			
		}

		if (Matched_Chunk_Number == 0) return return_linkedlist;	


		int[] Temp_Index;
		int Temp_Index_Current = 0;


		Iterator<Entry<String, String>>itrSlot = The_Chunk_Spec.Slot.entrySet().iterator();
		while ( itrSlot.hasNext() ){  // get every element
		  Entry<String, String> currentEntry = itrSlot.next();
			Temp_Index = new int[Matched_Chunk_Number];
			String the_key = currentEntry.getKey();
      String the_value = currentEntry.getValue() ; 
      
			for (i = 0; i < Matched_Chunk_Number; i++){   //matching chunks survived are recorded in Temp_Index array
				
				if (sim.vars.declarativeModule.mp.equals( "nil")){ //by default, this is the no-partial-matching situation
					if( the_value.length() <= 4 || ( the_value.length() > 4  && !the_value.substring(0,4).equals( "NOT_"))) {	//normal match "arg1 book"
						if (!the_key.substring(0,2).equals( "<=" ) && the_key.substring(0,1).equals( "<") ){ // < test
							System.out.println("DeclarativeModuleFun__Find_Add_Retrieval_Matched_DM_Chunk_IDs_By_Chunk_Spec mp == nil ToDo < test");
						}
						else if (the_key.substring(0,2).equals( "<=")){// <= test
							System.out.println("DeclarativeModuleFun__Find_Add_Retrieval_Matched_DM_Chunk_IDs_By_Chunk_Spec mp == nil ToDo <= test");
						}
						else if (!the_key.substring(0,2).equals( ">=") && the_key.charAt(0) == '>'){ // > test
							System.out.println("DeclarativeModuleFun__Find_Add_Retrieval_Matched_DM_Chunk_IDs_By_Chunk_Spec mp == nil ToDo > test");
						}
						else if (the_key.substring(0,2).equals( ">=")){ // >= test
							System.out.println("DeclarativeModuleFun__Find_Add_Retrieval_Matched_DM_Chunk_IDs_By_Chunk_Spec mp == nil ToDo >= test");
						}
						else if (the_key.substring(0,1).equals ( "-")){ // - test
							System.out.println("DeclarativeModuleFun__Find_Add_Retrieval_Matched_DM_Chunk_IDs_By_Chunk_Spec mp == nil ToDo - test");
						}
						else { // normal =slot_name test
							if(the_key.equals ( ":recently-retrieved")){// :recently-retrieved special match
								String a_DM_chunk_name = sim.funs.ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer(sim.vars.declarativeModule.DM_Chunk,  Matched_Chunk_Index[i] ).Chunk_Name ;
								if( (the_value.equals( "t" ) && sim.vars.declarativeModule.Declarative_Retrieved_Finst_Name_List.contains(a_DM_chunk_name) == true ) ||  (the_value.equals( "nil") && sim.vars.declarativeModule.Declarative_Retrieved_Finst_Name_List.contains(a_DM_chunk_name) == false )){
									Temp_Index[Temp_Index_Current] = Matched_Chunk_Index[i]; //these two lines mean survived
									Temp_Index_Current++;
								}
							}
							else if (the_key.charAt(0) == ':') System.out.println( "DeclarativeModuleFun__Find_Add_Retrieval_Matched_DM_Chunk_IDs_By_Chunk_Spec normal match has undefined key: " +  the_key);
							else if (  ProgramUtilitiesFun__StringsEqualByStringOrDouble(sim.funs.ChunkFun__Get_Chunk_Slot_Value( sim.funs.ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer(sim.vars.declarativeModule.DM_Chunk,  Matched_Chunk_Index[i] ), the_key), the_value) ){
								Temp_Index[Temp_Index_Current] = Matched_Chunk_Index[i];
								Temp_Index_Current++;
							}
						}
					}
					else {//NOT match "arg1 NOT_book" (changed from "-arg1 book") , match !"arg1 book"
					//ToDo: changed this to "-" slot name type
						String new_slot_value = the_value.substring(4, the_value.length());
					//GlobalUtilities.popUpMessage(The_Chunk_Spec.Slot[Slot_Matching_Round, 1].Substring(0,4));
					//GlobalUtilities.popUpMessage(new_slot_value);
						if(the_key.equals ( ":recently-retrieved")){// :recently-retrieved special NOT match
							String a_DM_chunk_name = sim.funs.ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer(sim.vars.declarativeModule.DM_Chunk,  Matched_Chunk_Index[i] ).Chunk_Name ;
							if( (the_value.equals( "t" ) && sim.vars.declarativeModule.Declarative_Retrieved_Finst_Name_List.contains(a_DM_chunk_name) == true ) ||  (the_value.equals( "nil") && sim.vars.declarativeModule.Declarative_Retrieved_Finst_Name_List.contains(a_DM_chunk_name) == false )){
								//match failed.
							}
							else {
								Temp_Index[Temp_Index_Current] = Matched_Chunk_Index[i]; //these two lines mean survived
								Temp_Index_Current++;
							}
						}
						else if (the_key.charAt(0) == ':') System.out.println( "DeclarativeModuleFun__Find_Add_Retrieval_Matched_DM_Chunk_IDs_By_Chunk_Spec NOT match has undefined key: " +  the_key);
						else if (  ProgramUtilitiesFun__StringsEqualByStringOrDouble(sim.funs.ChunkFun__Get_Chunk_Slot_Value( sim.funs.ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer(sim.vars.declarativeModule.DM_Chunk, Matched_Chunk_Index[i] ), the_key), new_slot_value)){
							Temp_Index[Temp_Index_Current] = Matched_Chunk_Index[i];
							Temp_Index_Current++;
						}
					}
				} //end of no-partial-matching
				else if ( sim.funs.ProgramUtilitiesFun__Is_String_Double(sim.vars.declarativeModule.mp) ) { //partial match situation
					if( the_value.length() <= 4 || ( the_value.length() > 4  && !the_value.substring(0,4).equals( "NOT_"))) {	//normal match "arg1 book"
						if (!the_key.substring(0,2).equals( "<=" ) && the_key.substring(0,1).equals( "<") ){ // < test
							System.out.println("DeclarativeModuleFun__Find_Add_Retrieval_Matched_DM_Chunk_IDs_By_Chunk_Spec partial match ToDo < test");
						}
						else if (the_key.substring(0,2).equals( "<=")){// <= test
							System.out.println("DeclarativeModuleFun__Find_Add_Retrieval_Matched_DM_Chunk_IDs_By_Chunk_Spec partial match ToDo <= test");
						}
						else if (!the_key.substring(0,2).equals( ">=" ) && the_key.charAt(0) == '>'){ // > test
							System.out.println("DeclarativeModuleFun__Find_Add_Retrieval_Matched_DM_Chunk_IDs_By_Chunk_Spec partial match ToDo > test");
						}
						else if (the_key.substring(0,2).equals( ">=")){ // >= test
							System.out.println("DeclarativeModuleFun__Find_Add_Retrieval_Matched_DM_Chunk_IDs_By_Chunk_Spec partial match ToDo >= test");
						}
						else if (the_key.substring(0,1).equals ( "-")){ // - test
							System.out.println("DeclarativeModuleFun__Find_Add_Retrieval_Matched_DM_Chunk_IDs_By_Chunk_Spec partial match ToDo - test");
						}
						else { // normal =slot_name test
							if(the_key.equals ( ":recently-retrieved")){// :recently-retrieved special match, also check this in partial matching
								String a_DM_chunk_name = sim.funs.ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer(sim.vars.declarativeModule.DM_Chunk,  Matched_Chunk_Index[i] ).Chunk_Name ;
								if( (the_value.equals( "t" ) && sim.vars.declarativeModule.Declarative_Retrieved_Finst_Name_List.contains(a_DM_chunk_name) == true ) ||  (the_value.equals( "nil") && sim.vars.declarativeModule.Declarative_Retrieved_Finst_Name_List.contains(a_DM_chunk_name) == false )){
									Temp_Index[Temp_Index_Current] = Matched_Chunk_Index[i]; //these two lines mean survived
									Temp_Index_Current++;
								}
							}
							else if (the_key.charAt(0) == ':') System.out.println( "DeclarativeModuleFun__Find_Add_Retrieval_Matched_DM_Chunk_IDs_By_Chunk_Spec normal match has undefined key: " +  the_key);
							else { // in partial matching, pass if slot value is not nil
								//GlobalUtilities.popUpMessage(ChunkFun__Get_Chunk_Slot_Value( sim.funs.ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer(sim.vars.declarativeModule.DM_Chunk,  Matched_Chunk_Index[i] ), the_key));
								if(!ChunkFun__Get_Chunk_Slot_Value(sim.funs.ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer(sim.vars.declarativeModule.DM_Chunk,  Matched_Chunk_Index[i] ), the_key).equals( "nil" ) ){
									Temp_Index[Temp_Index_Current] = Matched_Chunk_Index[i];
									Temp_Index_Current++;
								}
							}
						}	
					}
					else {//NOT match "arg1 NOT_book" (changed from "-arg1 book") , match !"arg1 book"
					//ToDo: changed this to "-"slot name like method
						String new_slot_value = the_value.substring(4, the_value.length());
					//GlobalUtilities.popUpMessage(The_Chunk_Spec.Slot[Slot_Matching_Round, 1].Substring(0,4));
					//GlobalUtilities.popUpMessage(new_slot_value);
						if(the_key.equals ( ":recently-retrieved")){// :recently-retrieved special NOT match, still do this in partial matching
							String a_DM_chunk_name = sim.funs.ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer(sim.vars.declarativeModule.DM_Chunk,  Matched_Chunk_Index[i] ).Chunk_Name ;
							if( (the_value.equals( "t" ) && sim.vars.declarativeModule.Declarative_Retrieved_Finst_Name_List.contains(a_DM_chunk_name) == true ) ||  (the_value.equals( "nil") && sim.vars.declarativeModule.Declarative_Retrieved_Finst_Name_List.contains(a_DM_chunk_name) == false )){
								//match failed.
							}
							else {
								Temp_Index[Temp_Index_Current] = Matched_Chunk_Index[i]; //these two lines mean survived
								Temp_Index_Current++;
							}
						}
						else if (the_key.charAt(0) == ':') System.out.println( "DeclarativeModuleFun__Find_Add_Retrieval_Matched_DM_Chunk_IDs_By_Chunk_Spec NOT match has undefined key: " +  the_key);
						else { //in partial matching,  pass if slot value is not nil
							if(!ChunkFun__Get_Chunk_Slot_Value( sim.funs.ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer(sim.vars.declarativeModule.DM_Chunk,  Matched_Chunk_Index[i] ), the_key).equals( "nil" )){
								Temp_Index[Temp_Index_Current] = Matched_Chunk_Index[i];
								Temp_Index_Current++;
							}
						}
					}
				} //end of partial matching situation
				else System.err.println ("DeclarativeModuleFun__Find_Add_Retrieval_Matched_DM_Chunk_IDs_By_Chunk_Spec has sim.vars.declarativeModule.mp illegal: " + sim.vars.declarativeModule.mp );
			}
			for (i = 0; i < Temp_Index_Current; i++){      //put Temp_Index array into Matched_Chunk_Index array
				Matched_Chunk_Index[i] = Temp_Index[i];
			}
			Matched_Chunk_Number = Temp_Index_Current;
			Temp_Index_Current = 0;
		}


		if(debug) System.out.println("DeclarativeModuleFun__Find_Add_Retrieval_Matched_DM_Chunk_IDs_By_Chunk_Spec has Matched_Chunk_Number: " + Matched_Chunk_Number);
		
		if (Matched_Chunk_Number == 0){
			//return new Chunk();
		  
			return return_linkedlist;
		}	
		else if (Matched_Chunk_Number == 1){
			//Chunk The_Matched_Chunk = new Chunk();
			//The_Matched_Chunk = sim.vars.declarativeModule.DM_Chunk[ Matched_Chunk_Index[0] ];
			//return The_Matched_Chunk;
			return_linkedlist.addLast (Matched_Chunk_Index[0]);
			return return_linkedlist;
		}
		else{
			//Chunk[] Matched_Chunk = new Chunk[Matched_Chunk_Number];
			for (i = 0; i < Matched_Chunk_Number; i++){       //put all matched chunks together in an array of chunks
				//Matched_Chunk[i] = sim.vars.declarativeModule.DM_Chunk[ Matched_Chunk_Index[i] ];
				return_linkedlist.addLast (Matched_Chunk_Index[i]);
			}
			//conflict resolution if multipal chunks are matched will be dealed with in sim.funs.DeclarativeModuleFun__Retrieve_A_Chunk
			//return Matched_Chunk[0];
			//GlobalUtilities.popUpMessage(return_linkedlist.Count);
			return return_linkedlist;
		}
	}
	
	
	public int DeclarativeModuleFun__Find_The_DM_Chunk_ID_By_Chunk_Spec(Chunk The_Chunk_Spec){
		
		//if(sim.vars.printingModule.Output_Window_Trace)System.out.println( "DeclarativeModuleFun__Find_The_DM_Chunk_ID_By_Chunk_Spec: " + The_Chunk_Spec.Chunk_Name);

		DeclarativeModuleFun__Update_Declarative_Finst();

		int i;
		int Matched_Chunk_Number = 0; //how many matched chunk found, and also the index of the next empty index of Matched_Chunk_Index
		if (sim.vars.declarativeModule.Number_of_Chunks < 1){
			//GlobalUtilities.popUpMessage("DeclarativeModuleFun__Find_The_DM_Chunk_ID_By_Chunk_Spec() Error! sim.vars.declarativeModule.Number_of_Chunks < 1");
			return -1;
		}
		int[] Matched_Chunk_Index = new int[sim.vars.declarativeModule.Number_of_Chunks]; //at this time, should Add at least 1 DM_CHUNK, sim.vars.declarativeModule.Number_of_Chunks need to > 0

		//name match is another function, because each chunk should have an unique name.

		if (The_Chunk_Spec.Chunk_Type.equals( "nil")){  //the first round is chunk type, ISA match
			//may add later for chunk type is nil
			ProgramUtilitiesFun__Output_Trace_Txt("DeclarativeModuleFun__Find_The_DM_Chunk_ID_By_Chunk_Spec has chunk type nil");
		}
		else if (The_Chunk_Spec.Chunk_Type.equals( "" )){
			//may add later for matching any chunk type that is not nil
			ProgramUtilitiesFun__Output_Trace_Txt("DeclarativeModuleFun__Find_The_DM_Chunk_ID_By_Chunk_Spec has chunk type empty");
		}
		else {  //matching a specific chunk type 
			ProgramUtilitiesFun__Output_Trace_Txt("DeclarativeModuleFun__Find_The_DM_Chunk_ID_By_Chunk_Spec, matching a specific chunk type , sim.vars.declarativeModule.Number_of_Chunks=" + sim.vars.declarativeModule.Number_of_Chunks);
			for (i = 0; i < sim.vars.declarativeModule.Number_of_Chunks ; i ++){ 		
			if (sim.funs.ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer(sim.vars.declarativeModule.DM_Chunk, i).Chunk_Type.equals( The_Chunk_Spec.Chunk_Type)){
			//if (sim.vars.declarativeModule.DM_Chunk[i].Chunk_Type == The_Chunk_Spec.Chunk_Type){
				Matched_Chunk_Index[Matched_Chunk_Number] = i;
				Matched_Chunk_Number++;
				}
			}
		}

		ProgramUtilitiesFun__Output_Trace_Txt("DeclarativeModuleFun__Find_The_DM_Chunk_ID_By_Chunk_Spec, Matched_Chunk_Number: " + Matched_Chunk_Number);
		if (Matched_Chunk_Number == 0)	return -1;


		int[] Temp_Index;
		int Temp_Index_Current = 0;

		Iterator<Entry<String, String>>itrSlot = The_Chunk_Spec.Slot.entrySet().iterator();
		while ( itrSlot.hasNext() ){  // get every element
		  Entry<String, String> currentEntry = itrSlot.next();
		
			Temp_Index = new int[Matched_Chunk_Number];
			for (i = 0; i < Matched_Chunk_Number; i++){   //matching chunks survived are recorded in Temp_Index array
				if (currentEntry.getValue().length() >= 4 ) { //protection for out of index
					if(!currentEntry.getValue().substring(0,4).equals( "NOT_")){	//normal match "arg1 book"
						if (  ProgramUtilitiesFun__StringsEqualByStringOrDouble(sim.funs.ChunkFun__Get_Chunk_Slot_Value( sim.funs.ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer(sim.vars.declarativeModule.DM_Chunk,  Matched_Chunk_Index[i] ), currentEntry.getKey()), currentEntry.getValue() ) ){
							Temp_Index[Temp_Index_Current] = Matched_Chunk_Index[i];
							Temp_Index_Current++;
						}
					}
				
					else {//NOT match "arg1 NOT_book" (changed from "-arg1 book") , match !"arg1 book"
						String new_slot_value = currentEntry.getValue().substring(4, currentEntry.getValue().length());
						//GlobalUtilities.popUpMessage(The_Chunk_Spec.Slot[Slot_Matching_Round, 1].Substring(0,4));
						//GlobalUtilities.popUpMessage(new_slot_value);
						if ( ! ProgramUtilitiesFun__StringsEqualByStringOrDouble(sim.funs.ChunkFun__Get_Chunk_Slot_Value( sim.funs.ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer(sim.vars.declarativeModule.DM_Chunk, Matched_Chunk_Index[i] ), currentEntry.getKey()), new_slot_value) ){
							Temp_Index[Temp_Index_Current] = Matched_Chunk_Index[i];
							Temp_Index_Current++;
						}
					}
				}
				else{ //normal match "arg1 book"
					if (  ProgramUtilitiesFun__StringsEqualByStringOrDouble(sim.funs.ChunkFun__Get_Chunk_Slot_Value( sim.funs.ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer(sim.vars.declarativeModule.DM_Chunk,  Matched_Chunk_Index[i] ), currentEntry.getKey()), currentEntry.getValue() ) ){
							Temp_Index[Temp_Index_Current] = Matched_Chunk_Index[i];
							Temp_Index_Current++;
					}
				}
			}
			for (i = 0; i < Temp_Index_Current; i++){      //put Temp_Index array into Matched_Chunk_Index array
				Matched_Chunk_Index[i] = Temp_Index[i];
			}
			Matched_Chunk_Number = Temp_Index_Current;
			Temp_Index_Current = 0;
		}


		if (Matched_Chunk_Number == 0) 	return -1;
		else if (Matched_Chunk_Number == 1){
			return Matched_Chunk_Index[0];
		}
		else{
			//Model.Message ("error! sim.funs.DeclarativeModuleFun__Find_The_DM_Chunk_ID_By_Chunk_Spec gets multiple chunks");
			//return -2;
			return Matched_Chunk_Index[0]; //return the first in DM LinkedList<Chunk>, this should be the latest added one, because Add-DM uses AddFirst
		}
	}
	
	public  double DeclarativeModuleFun__Get_DM_Chunk_Partial_Matching_Similarity(String name1, String name2){
		
		String key = name1 + "_" + name2;
		if (sim.vars.declarativeModule.DM_Chunk_Similarity_Table.containsKey(key)) {
			return (double) sim.vars.declarativeModule.DM_Chunk_Similarity_Table.get(key);
		}
		else {
			if(ProgramUtilitiesFun__StringsEqualByStringOrDouble(name1,name2))return sim.vars.declarativeModule.ms;
			else return sim.vars.declarativeModule.md;
		}
	}
	
	public  double DeclarativeModuleFun__Get_DM_Chunk_Partial_Matching_Activation(Chunk the_chunk, Chunk the_request_spec){
		
		if (sim.vars.declarativeModule.mp.equals( "nil")) return (double) 0.0; //no partical matching
		double P = 0.0;
		if(sim.vars.printingModule.v.equals( "t" ) && sim.vars.declarativeModule.act == true)ProgramUtilitiesFun__Output_Trace_Txt("\tComputing partial matching component");
		
		Iterator<Entry<String, String>> itrSlot = the_request_spec.Slot.entrySet().iterator();
		while (itrSlot.hasNext() ){  // get every element in the +retrieval> request specific
		  Entry<String, String> currentEntry = itrSlot.next();
			String the_key = currentEntry.getKey();
			String the_value = currentEntry.getValue(); 
			if (the_key.equals( "isa") || the_key.charAt(0) == ':') continue; //don't compute activation penalty for these slots
			double similarity = 0.0;
			double mismatch_penalty = 0.0; //effective similarity value
			if(sim.vars.printingModule.v.equals( "t" ) && sim.vars.declarativeModule.act == true)ProgramUtilitiesFun__Output_Trace_Txt("\t  comparing slot " + the_key);
			if (the_key.substring(0,1).equals ( "-") || ( the_value.length() > 4  && the_value.substring(0,4).equals ( "NOT_")) ) {
				if (the_key.substring(0,1).equals ( "-") ) System.out.println("DeclarativeModuleFun__Get_DM_Chunk_Partial_Matching_Activation ToDo: NOT request" );
				else {
					//below is the NOT_ method
					/*
					//ACT-R 6.0 
					(cond ((= sim (dm-ms dm))
						(* (dm-mp dm) (dm-md dm)))
						; ACT-R 5 doesn't do this, but
						; it seems like maybe it should
						;((= sim (dm-md dm))
						; (* (dm-mp dm) (dm-ms dm)))
						(t
						(when (dm-act dm)
							(model-output 
							"  negation test with similarity not ms has no effect"))
						0))
					*/
					String new_slot_value = the_value.substring(4, the_value.length()); //the NOT_ method
					String chunk_slot_value = sim.funs.ChunkFun__Get_Chunk_Slot_Value(the_chunk, the_key);
					if(sim.vars.printingModule.v.equals( "t" ) && sim.vars.declarativeModule.act == true)ProgramUtilitiesFun__Output_Trace_Txt("\t\t  Requested: - " + new_slot_value + "    Chunk's slot value:  " +   chunk_slot_value);
					similarity = sim.funs.DeclarativeModuleFun__Get_DM_Chunk_Partial_Matching_Similarity ( new_slot_value , chunk_slot_value);
					if(sim.vars.printingModule.v.equals( "t" ) && sim.vars.declarativeModule.act == true)ProgramUtilitiesFun__Output_Trace_Txt("\t\t  similarity: " + similarity);
					if(similarity == sim.vars.declarativeModule.ms){ //the most similar becomes the most different
						mismatch_penalty = Double.parseDouble( sim.vars.declarativeModule.mp ) * sim.vars.declarativeModule.md;
					}
					else{
						if(sim.vars.printingModule.v.equals( "t" ) && sim.vars.declarativeModule.act == true)ProgramUtilitiesFun__Output_Trace_Txt("\t\t  negation test with similarity not ms has no effect");
						mismatch_penalty = 0.0;
					}
					if(sim.vars.printingModule.v.equals( "t" ) && sim.vars.declarativeModule.act == true)ProgramUtilitiesFun__Output_Trace_Txt("\t\t  effective similarity value is " + mismatch_penalty);
				}
			}
			else{ //supposed to be normal = test, because ACT-R checks other test like > < as : test, and they don't go into partial matching
				String chunk_slot_value = sim.funs.ChunkFun__Get_Chunk_Slot_Value(the_chunk, the_key);
				if(sim.vars.printingModule.v.equals( "t" ) && sim.vars.declarativeModule.act == true)ProgramUtilitiesFun__Output_Trace_Txt("\t\t  Requested: = " + the_value + "    Chunk's slot value:  " +   chunk_slot_value);
				similarity = sim.funs.DeclarativeModuleFun__Get_DM_Chunk_Partial_Matching_Similarity ( the_value , chunk_slot_value);
				if(sim.vars.printingModule.v.equals( "t" ) && sim.vars.declarativeModule.act == true)ProgramUtilitiesFun__Output_Trace_Txt("\t\t  similarity: " + similarity);
				mismatch_penalty = Double.parseDouble( sim.vars.declarativeModule.mp ) * similarity;
				if(sim.vars.printingModule.v.equals( "t" ) && sim.vars.declarativeModule.act == true)ProgramUtilitiesFun__Output_Trace_Txt("\t\t  effective similarity value is " + mismatch_penalty);
			}
			P +=  mismatch_penalty;
		}
		if(sim.vars.printingModule.v.equals( "t" ) && sim.vars.declarativeModule.act == true)ProgramUtilitiesFun__Output_Trace_Txt("Total mismatch penalty: " + P );  
		return (double) P;
	}
	
	public void DeclarativeModuleFun__Place_Declarative_Finst_On(String the_DM_chunk_name){
		
		sim.funs.DeclarativeModuleFun__Update_Declarative_Finst();

		if ( sim.vars.declarativeModule.Declarative_Retrieved_Finst_Name_List.size() < sim.vars.declarativeModule.Declarative_Num_Finsts ){//if Finst table is not yet full
			if(sim.vars.declarativeModule.Declarative_Retrieved_Finst_Name_List.contains(the_DM_chunk_name) == true){ //it is already in the list
				sim.vars.declarativeModule.Declarative_Retrieved_Finst_Name_List.remove(the_DM_chunk_name);
				sim.vars.declarativeModule.Declarative_Retrieved_Finst_Time_Hashtable.remove(the_DM_chunk_name);
			}
			sim.vars.declarativeModule.Declarative_Retrieved_Finst_Name_List.addLast (the_DM_chunk_name);
			sim.vars.declarativeModule.Declarative_Retrieved_Finst_Time_Hashtable.put(the_DM_chunk_name, GlobalUtilities.round(SimSystem.clock(),3)   );
		}
		else if (sim.vars.declarativeModule.Declarative_Retrieved_Finst_Name_List.size() == sim.vars.declarativeModule.Declarative_Num_Finsts) { // finst table is full
			if(sim.vars.declarativeModule.Declarative_Retrieved_Finst_Name_List.contains(the_DM_chunk_name) == true){ //it is already in the list
				sim.vars.declarativeModule.Declarative_Retrieved_Finst_Name_List.remove(the_DM_chunk_name);
				sim.vars.declarativeModule.Declarative_Retrieved_Finst_Time_Hashtable.remove(the_DM_chunk_name);
				sim.vars.declarativeModule.Declarative_Retrieved_Finst_Name_List.addLast (the_DM_chunk_name);
				sim.vars.declarativeModule.Declarative_Retrieved_Finst_Time_Hashtable.put(the_DM_chunk_name, GlobalUtilities.round(SimSystem.clock(),3)   );
			}
			else{//not in the list
				String Obsolete_name = (String)sim.vars.declarativeModule.Declarative_Retrieved_Finst_Name_List.getFirst();
				sim.vars.declarativeModule.Declarative_Retrieved_Finst_Name_List.remove(Obsolete_name);
				sim.vars.declarativeModule.Declarative_Retrieved_Finst_Time_Hashtable.remove(Obsolete_name);
				sim.vars.declarativeModule.Declarative_Retrieved_Finst_Name_List.addLast (the_DM_chunk_name);
				sim.vars.declarativeModule.Declarative_Retrieved_Finst_Time_Hashtable.put(the_DM_chunk_name, GlobalUtilities.round(SimSystem.clock(),3)   );
			}
		}
	}
	
	public boolean DeclarativeModuleFun__Predict_Retrieval_Success( Chunk The_Chunk){
		
		//currently Yes or No fashion

		if (  The_Chunk.Activation > sim.vars.declarativeModule.rt) return true;
		else if (The_Chunk.Activation < sim.vars.declarativeModule.rt) return false;
		else {//deal with later. In fact, when   = Ai, the probability of recall is .5. 
				// but ACT-R 6.0 reference says ":rt (The retrieval threshold) is the minimum activation a chunk must have to be able to be retrieved
			//return false;
			return true;
		}

	}
	
	public  void DeclarativeModuleFun__Print_All_DM_Chunks(){
		
		
		int i;
		ProgramUtilitiesFun__Output_Trace_Txt("");
		ProgramUtilitiesFun__Output_Trace_Txt("Print_All_DM_Chunks at: " + GlobalUtilities.round(SimSystem.clock(),3));
		for ( i = 0 ; i < sim.vars.declarativeModule.Number_of_Chunks; i++ ){
			Chunk temp_Chunk = sim.funs.ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer(sim.vars.declarativeModule.DM_Chunk, i );
			ProgramUtilitiesFun__Output_Trace_Txt("");
			ProgramUtilitiesFun__Output_Trace_Txt("DM Chunk #: " + (i+1) + ", " + temp_Chunk.Chunk_Name + ", Last-Retrieval-Activation: " + temp_Chunk.Activation + ", base_level: " + temp_Chunk.base_level + ", permanent_noise: " +  temp_Chunk.permanent_noise+", creation time: " + temp_Chunk.Creation_Time );
			ProgramUtilitiesFun__Output_Trace_Txt("             , Number_Of_Presentations: " + temp_Chunk.Number_Of_Presentations);
			ProgramUtilitiesFun__Output_Trace_Txt("             , references: " + sim.funs.ProgramUtilitiesFun__LinkedListDouble_To_String(temp_Chunk.Presentation_Time_References));
			ProgramUtilitiesFun__Output_Trace_Txt( "   ISA        " + temp_Chunk.Chunk_Type);
			
			
			Iterator<Entry<String, String>> itrSlot = temp_Chunk.Slot.entrySet().iterator();
			while ( itrSlot.hasNext() ){  // get every element
			  Entry<String, String> currentEntry = itrSlot.next();
				ProgramUtilitiesFun__Output_Trace_Txt( "   " + currentEntry.getKey() + "       " + currentEntry.getValue());
			}

			
			/* //string array version
			Chunk The_Chunk = sim.vars.declarativeModule.DM_Chunk[i];
			int j;
			for (j = 0; (j < 1010 &&  !The_Chunk.Slot[j, 0].equals("") ); j++) {//for Chunk with Slot[1010,2], slot name != ""
				ProgramUtilitiesFun__Output_Trace_Txt( "   " + The_Chunk.Slot[j,0] + "       " + The_Chunk.Slot[j,1]);
			}
			*/
			
		}
		if (i == 0) sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("		DM has no chunk.");
		return;
	}
	
	public  void DeclarativeModuleFun__Print_DM_Activation_Trace(LinkedList<Integer> the_matched_chunk_id, Chunk the_retrieved_chunk){
		
		//currently just print who matched, and who is selected.
		if (the_matched_chunk_id.size() ==0){
			ProgramUtilitiesFun__Output_Trace_Txt("No Chunk matches");
			System.out.println("DeclarativeModuleFun__Print_DM_Activation_Trace, No Chunk matches");
			return;
		}

		Enumeration Enum = Collections.enumeration(the_matched_chunk_id); 
		while(Enum.hasMoreElements()){
			Chunk temp_chunk = sim.funs.ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer(sim.vars.declarativeModule.DM_Chunk, (int)Enum.nextElement());
			ProgramUtilitiesFun__Output_Trace_Txt("Chunk " + temp_chunk.Chunk_Name + " matches, with activation: " + temp_chunk.Activation);
			//ChunkFun__Print_Chunk(temp_chunk);
		}
		ProgramUtilitiesFun__Output_Trace_Txt("");
		ProgramUtilitiesFun__Output_Trace_Txt("The Chunk selected is: " + the_retrieved_chunk.Chunk_Name + ", with activation: "+ the_retrieved_chunk.Activation);
		ProgramUtilitiesFun__Output_Trace_Txt("=================Retrieve a Chunk: End=================");
		ProgramUtilitiesFun__Output_Trace_Txt("");
		if(sim.vars.qn_answer) {
			ProgramUtilitiesFun__Output_QN_Result_Txt("");
			ProgramUtilitiesFun__Output_QN_Result_Txt("The Chunk selected is: " + the_retrieved_chunk.Chunk_Name + ", with activation: "+ the_retrieved_chunk.Activation);
			ProgramUtilitiesFun__Output_QN_Result_Txt("=================Retrieve a Chunk: End=================");
			ProgramUtilitiesFun__Output_QN_Result_Txt("");
		}
		return;



	}
	
	public  LinkedList<Integer> DeclarativeModuleFun__Update_Chunk_Activation(LinkedList<Integer> the_matched_chunk_number, Chunk the_chunk_spec){
		
		int i;
		//only update matched chunks
		if (the_matched_chunk_number.size() == 0 ) System.out.println("DeclarativeModuleFun__Update_Chunk_Activation: the_matched_chunk_number.Count == 0 ");

		//from unit5, group.lisp, it seems need to reverse, 
		//reverse the list in order to match the way of ACT-R
		LinkedList<Integer> reverse_matched_chunk_number_list = new LinkedList<Integer> ();
		Enumeration Enum_reverse = Collections.enumeration(the_matched_chunk_number); 
			while(Enum_reverse.hasMoreElements()){
				i = (int)Enum_reverse.nextElement();
				reverse_matched_chunk_number_list.addFirst (i);
			}
		the_matched_chunk_number = reverse_matched_chunk_number_list;
		//end of reverse

		Enumeration Enum = Collections.enumeration(the_matched_chunk_number); 
			while(Enum.hasMoreElements()){
				i = (int)Enum.nextElement();
				Chunk DM_chunk_pointer = ((Chunk)ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer( sim.vars.declarativeModule.DM_Chunk , i ));
				DM_chunk_pointer.Activation = sim.funs.DeclarativeModuleFun__Compute_DM_Chunk_Activation( DM_chunk_pointer, the_chunk_spec ); //the second parameter is to pass to partial matching activation computation
				//sim.vars.declarativeModule.DM_Chunk[i].Activation = sim.funs.DeclarativeModuleFun__Compute_DM_Chunk_Activation(sim.vars.declarativeModule.DM_Chunk[i]);	
			}		
					
		/*			//old update all method
		for (i = 0; i < sim.vars.declarativeModule.Number_of_Chunks ; i ++){ 		
			sim.vars.declarativeModule.DM_Chunk[i].Activation = sim.funs.DeclarativeModuleFun__Compute_DM_Chunk_Activation(sim.vars.declarativeModule.DM_Chunk[i]);
		}
		*/

		return the_matched_chunk_number;
	}
	
	public  Chunk DeclarativeModuleFun__Retrieve_A_Chunk(LinkedList<Integer> the_matched_chunk_number, Chunk the_chunk_spec){
		
		
		if(sim.vars.printingModule.v.equals( "t" ) && sim.vars.declarativeModule.act == true ) sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("");
		if(sim.vars.printingModule.v.equals( "t" ) && sim.vars.declarativeModule.act == true ) sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("---------------Retrieve a Chunk: Start---------------");
		if(sim.vars.qn_answer) {
			ProgramUtilitiesFun__Output_QN_Result_Txt("");
			ProgramUtilitiesFun__Output_QN_Result_Txt("---------------Retrieve a Chunk: Start---------------");
		}
		
		//ChunkFun__Print_All_Chunks_In_Model(); //debug
		
		
		if (the_matched_chunk_number.size() == 0 ) return new Chunk();

		//update activations
		the_matched_chunk_number = sim.funs.DeclarativeModuleFun__Update_Chunk_Activation(the_matched_chunk_number, the_chunk_spec); //the second parameter is to pass to partial matching activation computation

		//find the max activation chunk
		int max_activation_id = the_matched_chunk_number.getFirst();

		double max_activation =  ((Chunk)ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer (sim.vars.declarativeModule.DM_Chunk, max_activation_id  )).Activation;
		//double max_activation = sim.vars.declarativeModule.DM_Chunk[max_activation_id].Activation;

		LinkedList<String> matched_chunk_output_trace = new LinkedList<String> ();
		Enumeration Enum = Collections.enumeration(the_matched_chunk_number); 
		while(Enum.hasMoreElements()){
			int i = (int)Enum.nextElement();
			Chunk temp_chunk_pointer = ((Chunk)ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer (sim.vars.declarativeModule.DM_Chunk, i ));
			matched_chunk_output_trace.addLast (temp_chunk_pointer.Chunk_Name );
			matched_chunk_output_trace.addLast (Double.toString(temp_chunk_pointer.Activation) );
			matched_chunk_output_trace.addLast (", " );
			
			
			/*
			if ( temp_chunk_pointer.Activation >= max_activation){ //given chunk adding is using AddFirst (not Merge into DM), in a tie situation, >= here will select a later chunk in the list, which is earlier added (same as ACT-R)
			//if ( temp_chunk_pointer.Activation > max_activation){  //given chunk adding is using AddFirst, in a tie situation, > here will select a fronter chunk in the list, which is latest added (not same as ACT-R) 
				max_activation_id = i;
				max_activation = temp_chunk_pointer.Activation;
				//max_activation = sim.vars.declarativeModule.DM_Chunk[i].Activation;
			}
			*/
			if ( temp_chunk_pointer.Activation > max_activation){ 
				max_activation_id = i;
				max_activation = temp_chunk_pointer.Activation;
			}
			else if (temp_chunk_pointer.Activation == max_activation){
				//further compare last presentation time (QN)
				double previous_max_presentation_time = ((Chunk)ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer (sim.vars.declarativeModule.DM_Chunk, max_activation_id )).Last_Presentation_Time;
				double this_max_presentation_time = temp_chunk_pointer.Last_Presentation_Time;
				if ( this_max_presentation_time >= previous_max_presentation_time){
					max_activation_id = i;
					max_activation = temp_chunk_pointer.Activation;
				}
				//else if (this_max_presentation_time == previous_max_presentation_time) GlobalUtilities.popUpMessage("TODO sim.funs.DeclarativeModuleFun__Retrieve_A_Chunk this_max_presentation_time == previous_max_presentation_time");
				
			}
			
		}
		/* //before adding output trace
		IEnumerator Enum = the_matched_chunk_number.GetEnumerator(); 
		while(Enum.MoveNext()){
			int i = (int)Enum.Current;
			if ( ((Chunk)ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer (sim.vars.declarativeModule.DM_Chunk, i )).Activation >= max_activation){ //given chunk adding is using AddFirst, in a tie situation, >= here will select a later chunk in the list, which is earlier added (same as ACT-R)
				max_activation_id = i;
				max_activation = ((Chunk)ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer (sim.vars.declarativeModule.DM_Chunk, i )).Activation;
				//max_activation = sim.vars.declarativeModule.DM_Chunk[i].Activation;
			}
		}
		*/

		//ProgramUtilitiesFun__Output_Trace_Txt( "Retrieve_A_Chunk got matched chunks: " + sim.funs.ProgramUtilitiesFun__LinkedListString_To_String( matched_chunk_output_trace ) ) ;

		if ( max_activation >= sim.vars.declarativeModule.rt){
			return sim.funs.ChunkFun__Chunk_Clone ((Chunk)ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer (sim.vars.declarativeModule.DM_Chunk, max_activation_id ));
			//return sim.funs.ChunkFun__Chunk_Clone (sim.vars.declarativeModule.DM_Chunk[max_activation_id] );
		}
		else{
			//GlobalUtilities.popUpMessage("DeclarativeModuleFun__Retrieve_A_Chunk: max activation chunk "+ sim.vars.declarativeModule.DM_Chunk[max_activation_id].Chunk_Name +" Activation: " + max_activation + " smaller than :rt retrieval threshold");
			ProgramUtilitiesFun__Output_Trace_Txt( "Retrieve_A_Chunk has max_activation : " + max_activation + " < sim.vars.declarativeModule.rt: " +  sim.vars.declarativeModule.rt);
			return new Chunk();
		}


	}
	
	public  void DeclarativeModuleFun__Set_Base_Levels(String the_chunk_name, double the_first_number, String the_creation_time_string){
		
		
		//DeclarativeModuleFun__Print_All_DM_Chunks();//debug

		String creation_time_string = the_creation_time_string;
		int chunk_id = sim.funs.DeclarativeModuleFun__Find_The_DM_Chunk_ID_By_Chunk_Name(the_chunk_name);
		if (chunk_id == -1){
			System.err.println("DeclarativeModuleFun__Set_Base_Levels, the chunk " + the_chunk_name + " does not exist in DM");
			return;
		}

		Chunk temp_chunk_pointer = sim.funs.ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer (sim.vars.declarativeModule.DM_Chunk, chunk_id);
		if(!creation_time_string.equals( "" )){ 
			temp_chunk_pointer.Creation_Time = Double.parseDouble(creation_time_string);
		}//else when creation time is "" by default, don't change the chunk's original creation time.

		if (sim.vars.declarativeModule.bll.equals( "nil")	){ //If :bll is nil then the level provided is used directly as the chunk's base-level. 
			temp_chunk_pointer.base_level = Double.toString(the_first_number); //number is double
		}
		else{
			long reference_count = (long) the_first_number; 
			temp_chunk_pointer.Number_Of_Presentations = reference_count;

			if(sim.vars.centralParametersModule.ol.equals( "t" )){ //optimized learning, do not need to make reference-list
			}
			else if (sim.vars.centralParametersModule.ol.equals( "nil") ){//count every reference
				if (reference_count > 1000) {
					System.out.println("DeclarativeModuleFun__Set_All_Base_Levels has reference_count > 1000 may significantly slow down the model. Try a smaller :ol like 10.");
					return;
				}
				double time_interval = (GlobalUtilities.round(SimSystem.clock(),3) - temp_chunk_pointer.Creation_Time) / reference_count;
				temp_chunk_pointer.Presentation_Time_References.clear(); //remove all previous references because this is a kind of reset
				long i;
				for (i = 0; i < reference_count ; i ++){
					temp_chunk_pointer.Presentation_Time_References.addLast ((double) GlobalUtilities.round (   (temp_chunk_pointer.Creation_Time + i * time_interval) ,3 ) );
				}
			}
			else if (sim.funs.ProgramUtilitiesFun__Is_String_Double(sim.vars.centralParametersModule.ol)){ //count some number of the latest references
				int number_of_tracked_references  = Integer.parseInt ( sim.vars.centralParametersModule.ol );
				if (reference_count > 1000 && number_of_tracked_references > 1000) {
					System.err.println("DeclarativeModuleFun__Set_All_Base_Levels has reference_count > 1000 && number_of_tracked_references > 1000 may significantly slow down the model. Try a smaller :ol like 10.");
					return;
				}
				double time_interval = (GlobalUtilities.round(SimSystem.clock(),3) - temp_chunk_pointer.Creation_Time) / reference_count;
				if(time_interval < 0)System.out.println("DeclarativeModuleFun__Set_All_Base_Levels warning: Creation time set at a future time > the current clock time.");
				temp_chunk_pointer.Presentation_Time_References.clear(); //remove all previous references because this is a kind of reset
				long i;
				if (reference_count > number_of_tracked_references) i = reference_count - number_of_tracked_references;
				else i = 0;
				for ( ; i < reference_count ; i ++){
					temp_chunk_pointer.Presentation_Time_References.addLast ((double) GlobalUtilities.round (   (temp_chunk_pointer.Creation_Time + i * time_interval) ,3) );
				}
			}
			else System.err.println ("DeclarativeModuleFun__Set_All_Base_Levels :ol has an undefined case: " + sim.vars.centralParametersModule.ol);
		}	
				



		//DeclarativeModuleFun__Print_All_DM_Chunks();//debug

	}
	
	public  void DeclarativeModuleFun__Set_All_Base_Levels(String[] The_Key_Value_Pairs){
		
		
		//DeclarativeModuleFun__Print_All_DM_Chunks();//debug
		String reference_count_string;
		String creation_time_string;
		if (The_Key_Value_Pairs.length == 1) {
			reference_count_string = The_Key_Value_Pairs[0] ;
			creation_time_string = ""; //when creation time is "" by default, don't change the chunk's original creation time.
		}
		else if (The_Key_Value_Pairs.length == 2) {
			reference_count_string = The_Key_Value_Pairs[0];
			creation_time_string = The_Key_Value_Pairs[1];
		}
		else {
			System.err.println ("DeclarativeModuleFun__Set_All_Base_Levels needs 2 strings REFERENCE-COUNT and CREATION-TIME. The second can be an empty string. But it is given " + The_Key_Value_Pairs.length + " parameters.");
			return;
		}


		long reference_count = Integer.parseInt(reference_count_string); //note: this is not reference_count but the base level if :bll (base level learning) is nil

		Enumeration enum_chunk = Collections.enumeration(sim.vars.declarativeModule.DM_Chunk);
		while(enum_chunk.hasMoreElements()){
			Chunk temp_chunk_pointer = (Chunk) enum_chunk.nextElement();
			DeclarativeModuleFun__Set_Base_Levels(temp_chunk_pointer.Chunk_Name, reference_count,  creation_time_string );
		}


		//DeclarativeModuleFun__Print_All_DM_Chunks();//debug


	}
	
	public  void DeclarativeModuleFun__Set_Similarities(String name1, String name2, double the_similarity){
		
		int chunk_id = sim.funs.DeclarativeModuleFun__Find_The_DM_Chunk_ID_By_Chunk_Name(name1);
		if (chunk_id == -1){
			System.err.println("DeclarativeModuleFun__Set_Similarities chunk " + name1 + " does not exist in DM");
			return;
		}
		chunk_id = sim.funs.DeclarativeModuleFun__Find_The_DM_Chunk_ID_By_Chunk_Name(name2);
		if (chunk_id == -1){
			System.err.println("DeclarativeModuleFun__Set_Similarities chunk " + name2 + " does not exist in DM");
			return;
		}

		String key1 = name1 + "_" + name2;
		String key2 = name2 + "_" + name1;

		if (sim.vars.declarativeModule.DM_Chunk_Similarity_Table.containsKey(key1)){
			System.out.println("warning: sim.funs.DeclarativeModuleFun__Set_Similarities, the hashtable already has: " + key1);
		}
		if (sim.vars.declarativeModule.DM_Chunk_Similarity_Table.containsKey(key2)){
			System.out.println("warning: sim.funs.DeclarativeModuleFun__Set_Similarities, the hashtable already has: " + key2);
		}
		ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.declarativeModule.DM_Chunk_Similarity_Table, key1, the_similarity);
		ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.declarativeModule.DM_Chunk_Similarity_Table, key2, the_similarity);


	}
	
	public  double DeclarativeModuleFun__Get_DM_Chunk_Noise_Value(Chunk The_Chunk){
		
		// ans.equals( "nil")
		double transient_noise;
		double permanent_noise;

		if (sim.vars.declarativeModule.ans.equals( "nil")){
			transient_noise = 0.0;
		}
		else  transient_noise = sim.funs.ProgramUtilitiesFun__Act_R_Noise( Double.parseDouble(sim.vars.declarativeModule.ans) ); // when ans = 0, noise = 0

		permanent_noise = The_Chunk.permanent_noise; // set by sdp :pas, default is 0.0

		if(sim.vars.printingModule.v.equals( "t" ) && sim.vars.declarativeModule.act == true) sim.funs.ProgramUtilitiesFun__Output_Trace_Txt( "	chunk: " + The_Chunk.Chunk_Name + ", transient_noise: " + transient_noise     );
		if(sim.vars.printingModule.v.equals( "t" ) && sim.vars.declarativeModule.act == true) sim.funs.ProgramUtilitiesFun__Output_Trace_Txt( "	chunk: " + The_Chunk.Chunk_Name + ", permanent_noise: " + permanent_noise     );



		return (double) (transient_noise + permanent_noise) ;
	}
	
	public void DeclarativeModuleFun__Merge_Chunk_Into_DM(Chunk The_Chunk, String the_case){

		//sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("DeclarativeModuleFun__Merge_Chunk_Into_DM begin... for chunk: " + The_Chunk.Chunk_Name);
		//System.out.println("DeclarativeModuleFun__Merge_Chunk_Into_DM begin... for chunk: " + The_Chunk.Chunk_Name);
		
		////*if(sim.vars.printingModule.Output_Window_Trace)*/System.out.println( "DeclarativeModuleFun__Merge_Chunk_Into_DM: " + The_Chunk.Chunk_Name);
		//ChunkFun__Print_Chunk(The_Chunk);

		//merge or not control
		if(the_case.equals( "Aural_Buffer")  && (sim.vars.declarativeModule.Merge_Aural_Buffer_Chunk)==false )return;
		if(the_case.equals( "Aural_Location_Buffer")  && (sim.vars.declarativeModule.Merge_Aural_Location_Buffer_Chunk)==false )return;
		if(the_case.equals( "Goal_Buffer")  && (sim.vars.declarativeModule.Merge_Goal_Buffer_1_Chunk)==false )return;
		if(the_case.equals( "Goal_Buffer_2")  && (sim.vars.declarativeModule.Merge_Goal_Buffer_2_Chunk)==false )return;
		if(the_case.equals( "Visual_Buffer")  && (sim.vars.declarativeModule.Merge_Visual_Buffer_Chunk)==false )return;
		if(the_case.equals( "Visual_Location_Buffer")  && (sim.vars.declarativeModule.Merge_Visual_Location_Buffer_Chunk)==false )return;

		// modified by Yelly:
		// do_no_merge and do_no_rename list initialization is moved to Variables.java to improve performances
		
		//don't merge these, items in this list will not be merged into declarative memory.
//		List<String> do_no_merge = new ArrayList<String> ();
//		do_no_merge.add("visual-location-world3d-driving");		//these are near and far points, assume that they are not stored in DM.
//		do_no_merge.add("visual-location-world3d-driving-criticalelement"); //assume critical elements are stored in DM

		//System.out.println("DeclarativeModule__Merge_Chunk_Into_DM_do_no_merge list: " + sim.vars.DeclarativeModule__Merge_Chunk_Into_DM_do_no_merge);
		if(sim.vars.DeclarativeModule__Merge_Chunk_Into_DM_do_no_merge.contains( The_Chunk.Chunk_Type ) ) return;


//		// for these special ones, do not rename and redefine to control the growing of the chunk number
//		List<String> do_no_rename = new ArrayList<String> ();
//		do_no_rename.add("world3d-driving-criticalelement-vehicle");
//		do_no_rename.add("world3d-driving-criticalelement-sign");
//		do_no_rename.add("world3d-driving-speed");
//		do_no_rename.add("world3d-driving-criticalelement-vehicle-img");
//		do_no_rename.add("world3d-driving-criticalelement-sign-img");
//		do_no_rename.add("world3d-driving-speed-img");
//		do_no_rename.add("visual-location-world3d-driving-criticalelement");
//		do_no_rename.add("visual-location-world3d-driving-speed");

		boolean is_same_chunk_name_in_DM = (DeclarativeModuleFun__Find_DM_Chunk_By_Chunk_Name( The_Chunk.Chunk_Name)).Chunk_Name.equals( The_Chunk.Chunk_Name );
		
		boolean do_no_rename = sim.vars.DeclarativeModule__Merge_Chunk_Into_DM_do_no_rename.contains(The_Chunk.Chunk_Type);
		
		boolean is_same_chunk_type_and_content_in_DM;
		int temp_int = sim.funs.DeclarativeModuleFun__Find_The_DM_Chunk_ID_By_Chunk_Spec (The_Chunk);
		int dm_chunk_id = temp_int;
		if (temp_int == -1) is_same_chunk_type_and_content_in_DM = false;
		else if (temp_int >= 0 && temp_int < sim.vars.declarativeModule.Number_of_Chunks) is_same_chunk_type_and_content_in_DM = true;
		else {
			System.err.println ("DeclarativeModuleFun__Merge_Chunk_Into_DM, dm_chunk_id range Error!");
			return;
		}

		if (!do_no_rename && is_same_chunk_name_in_DM){ 
			//GlobalUtilities.popUpMessage("DeclarativeModuleFun__Merge_Chunk_Into_DM is_same_chunk_name_in_DM == true.  " + The_Chunk.Chunk_Name + " " +  (DeclarativeModuleFun__Find_DM_Chunk_By_Chunk_Name( The_Chunk.Chunk_Name)).Chunk_Name);
			//return;
			
			//rename
			//put Chunk in buffer naming rule: its name is changed into name-j, where j starts from 0. If "name-j" is already a name in the model chunk list, then j++, until it is a new name.
			int j = 0;
			String old_chunk_name = The_Chunk.Chunk_Name;
			String new_chunk_name = old_chunk_name + "-" + Integer.toString(j);
			while(ChunkFun__Is_Chunk_Name(new_chunk_name)){
				j++;
				new_chunk_name = old_chunk_name + "-" + Integer.toString(j);
			}
			The_Chunk.Chunk_Name = new_chunk_name;
			System.out.println("DeclarativeModuleFun__Merge_Chunk_Into_DM, defining chunk: " + The_Chunk.Chunk_Name + ", chunk type: " + The_Chunk.Chunk_Type);
			ChunkFun__Define_Chunk( The_Chunk );
			System.out.println("DeclarativeModuleFun__Merge_Chunk_Into_DM, finished defining chunk.");
			
		}

		//If there is an equivalent chunk in DM, update the presentation of the equivalent DM chunk. . . Also the chunk (in model chunk list) 's DM_Name_Origin should be the name of the equivalent DM chunk.  
		if(is_same_chunk_type_and_content_in_DM == true){
			Chunk chunk_pointer = sim.funs.ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer(sim.vars.declarativeModule.DM_Chunk, dm_chunk_id) ;
			DeclarativeModuleFun__Update_Chunk_Presentation( chunk_pointer );
			
			if(!do_no_rename) {
				String DM_chunk_name = chunk_pointer.Chunk_Name;
				String to_merge_chunk_name = The_Chunk.Chunk_Name;
				if (ChunkFun__Is_Chunk_Name(to_merge_chunk_name)==false)System.err.println("DeclarativeModuleFun__Merge_Chunk_Into_DM sim.funs.ChunkFun__Is_Chunk_Name(to_merge_chunk_name)==false, chunk name: " + to_merge_chunk_name); //this should never happen, because clear-buffer functions just add the chunk into model chunk list and then call this function
				Chunk in_model_list_chunk =  (Chunk) sim.vars.centralParametersModule.Chunks.get(to_merge_chunk_name)  ;
				if (chunk_pointer.DM_Name_Origin.equals( "" ))in_model_list_chunk.DM_Name_Origin = DM_chunk_name;
				else in_model_list_chunk.DM_Name_Origin = chunk_pointer.DM_Name_Origin;
					
				if( the_case.equals( "Imaginal_Buffer")) sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("Merge_Chunk_Into_DM, is_same_chunk_type_and_content_in_DM: " + is_same_chunk_type_and_content_in_DM + ". The_Chunk: " + sim.funs.ChunkFun__Get_Chunk_Contents(The_Chunk)  );
			}
		}
		else{ //no same-content-chunk in DM.
			//sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("DeclarativeModuleFun__Merge_Chunk_Into_DM, no same-content-chunk in DM. for chunk: " + The_Chunk.Chunk_Name +", Add============================================");
			DeclarativeModuleFun__Add_DM_Chunk_With_Chunk(The_Chunk);
			if( the_case.equals( "Imaginal_Buffer")) sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("Merge_Chunk_Into_DM, is_same_chunk_type_and_content_in_DM: " + is_same_chunk_type_and_content_in_DM + ". The_Chunk: " + sim.funs.ChunkFun__Get_Chunk_Contents(The_Chunk)  );
		}

//		sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("DeclarativeModuleFun__Merge_Chunk_Into_DM finish.");
//		sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("DeclarativeModuleFun__Merge_Chunk_Into_DM, number of sim.vars.centralParametersModule.Chunks: " + sim.vars.centralParametersModule.Chunks.size());
		

		/*
		/////////////////////////////////
		//old file 





		//int dm_chunk_id = sim.funs.DeclarativeModuleFun__Find_The_DM_Chunk_ID_By_Chunk_Spec (The_Chunk);

		//GlobalUtilities.popUpMessage("Merge_Chunk_Into_DM chunk name: " + The_Chunk.Chunk_Name);

		//old//if (dm_chunk_id == -1){ //no such chunk in DM
		if(( !DeclarativeModuleFun__Find_DM_Chunk_By_Chunk_Name( The_Chunk.Chunk_Name)).Chunk_Name.equals(The_Chunk.Chunk_Name) ){ //there is no such chunk name in DM

			//old
			//string chunk_name = sim.funs.DeclarativeModuleFun__Get_Name_For_DM_New_Chunk(The_Chunk);
			//The_Chunk.Chunk_Name = chunk_name;
			//GlobalUtilities.popUpMessage("Merge_Chunk_Into_DM jumpped number: " + sim.vars.declarativeModule.Chunk_Name_Number + ". Chunk is: " + The_Chunk.Slot["verb"]);
			//GlobalUtilities.popUpMessage("Merge_Chunk_Into_DM no such chunk in DM that has the same content" );

			//check if there is a chunk with the same name in DM.
			//new way
			if( !the_case.equals("Retrieval_Buffer")){
				if (sim.vars.declarativeModule.Chunk_Name_Number.ContainsKey( The_Chunk.Chunk_Name ) == false){ //the first time to add this chunk
					ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.declarativeModule.Chunk_Name_Number,  The_Chunk.Chunk_Name , 0  );
				}
				else{ // not the first time, this should not happen
					GlobalUtilities.popUpMessage("DeclarativeModuleFun__Merge_Chunk_Into_DM there is no such chunk name in DM case has the_case != Retrieval_Buffer but not the first time.");
					//
					//string Obsolete_name = The_Chunk.Chunk_Name;
					//int temp_number = (int) sim.vars.declarativeModule.Chunk_Name_Number[Obsolete_name];
					//string new_name = Obsolete_name + "-"  + temp_number.ToString();
					//The_Chunk.Chunk_Name = new_name;
		//GlobalUtilities.popUpMessage("Merge_Chunk_Into_DM: The_Chunk.Chunk_Name: " + The_Chunk.Chunk_Name );
					//ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.declarativeModule.Chunk_Name_Number,  Obsolete_name , (temp_number + 1)  );
					//ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.declarativeModule.Chunk_Name_Number,  new_name , 0  );
					//
				}
			}
			else { // retrieval buffer cannot be modified, therefore, chunk name in the retrieval buffer should always be a chunk name in DM
				GlobalUtilities.popUpMessage("DeclarativeModuleFun__Merge_Chunk_Into_DM there is no such chunk name in DM case has the_case == Retrieval_Buffer ");
			}
			
			
			DeclarativeModuleFun__Add_DM_Chunk_With_Chunk(The_Chunk);
			
			
		}
		//old//else if (dm_chunk_id >= 0 && dm_chunk_id < sim.vars.declarativeModule.Number_of_Chunks){ //there is such a chunk content in DM
		else{//there is such a chunk name in DM
			int temp_dm_chunk_id = sim.funs.DeclarativeModuleFun__Find_The_DM_Chunk_ID_By_Chunk_Spec (The_Chunk);
			if(temp_dm_chunk_id  == -1){ //although chunk names are the same, contents changed
				
			}
			else{ //type and other contents are also the same, just update presentation.
				int dm_chunk_id = sim.funs.DeclarativeModuleFun__Find_The_DM_Chunk_ID_By_Chunk_Name (The_Chunk.Chunk_Name);
			//GlobalUtilities.popUpMessage((DeclarativeModuleFun__Find_DM_Chunk_By_Chunk_Name( The_Chunk.Chunk_Name)).Chunk_Name);
			//GlobalUtilities.popUpMessage(dm_chunk_id);
				DeclarativeModuleFun__Update_Chunk_Presentation( sim.funs.ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer(sim.vars.declarativeModule.DM_Chunk, dm_chunk_id) );
				//DeclarativeModuleFun__Update_Chunk_Presentation(sim.vars.declarativeModule.DM_Chunk [dm_chunk_id]);
				//GlobalUtilities.popUpMessage("Merge_Chunk_Into_DM jumpped Chunk is: " + The_Chunk.Slot["verb"]);
				
				//new way
			// GlobalUtilities.popUpMessage("Merge_Chunk_Into_DM: there is such a chunk in DM Chunk_Name: " + The_Chunk.Chunk_Name );
				
				if( !the_case.equals("Retrieval_Buffer")){
			
					if (sim.vars.declarativeModule.Chunk_Name_Number.ContainsKey( The_Chunk.Chunk_Name ) == false){ //the first time to add this chunk
						ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.declarativeModule.Chunk_Name_Number,  The_Chunk.Chunk_Name , 0  );
					}
					else{ // not the first time
						string Obsolete_name = The_Chunk.Chunk_Name;
						int temp_number = (int) sim.vars.declarativeModule.Chunk_Name_Number[Obsolete_name];
						string new_name = Obsolete_name + "-"  + temp_number.ToString();
						The_Chunk.Chunk_Name = new_name;
			//GlobalUtilities.popUpMessage("Merge_Chunk_Into_DM: The_Chunk.Chunk_Name: " + The_Chunk.Chunk_Name );
						ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.declarativeModule.Chunk_Name_Number,  Obsolete_name , (temp_number + 1)  );
						ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.declarativeModule.Chunk_Name_Number,  new_name , 0  );
					}
				}
				//old //sim.vars.declarativeModule.Chunk_Name_Number++;
			}	
		}
		//old // else Model.Message ("DeclarativeModuleFun__Merge_Chunk_Into_DM, dm_chunk_id range Error!");

		*/
	}
	
	public  double DeclarativeModuleFun__Compute_DM_Chunk_Activation(Chunk The_Chunk,Chunk the_request_spec){
		
		double B; //This is the base-level activation and reflects the recency and frequency of use of the chunk. 
		double S; //This is the spreading activation value computed for the chunk which reflects the effect that the contents of the buffers have on the retrieval process.
		double P; //This is the partial matching value computed for the chunk which reflects the degree to which the chunk matches the specification requested.
		double Epsilon; //A noise value with both a transient and permanent component.
		if(sim.vars.printingModule.v.equals( "t" ) && sim.vars.declarativeModule.act == true)  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt(" ");
		if(sim.vars.printingModule.v.equals( "t" ) && sim.vars.declarativeModule.act == true)  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("Computing activation for chunk " + The_Chunk.Chunk_Name);
		//base level B
		if(sim.vars.printingModule.v.equals( "t" ) && sim.vars.declarativeModule.act == true)  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\tComputing base-level");
		B = sim.funs.DeclarativeModuleFun__Get_DM_Chunk_Base_Level_Activation(The_Chunk);
		if(sim.vars.printingModule.v.equals( "t" ) && sim.vars.declarativeModule.act == true)  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("Total base-level: " + B);
		
		//spreading activation value 
		S = sim.funs.DeclarativeModuleFun__Get_DM_Chunk_Spread_Activation(The_Chunk);

		//partial matching value
		P = sim.funs.DeclarativeModuleFun__Get_DM_Chunk_Partial_Matching_Activation(The_Chunk, the_request_spec);

		Epsilon = sim.funs.DeclarativeModuleFun__Get_DM_Chunk_Noise_Value(The_Chunk);
		if(sim.vars.printingModule.v.equals( "t" ) && sim.vars.declarativeModule.act == true)  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("TOTAL Activation for chunk: " + The_Chunk.Chunk_Name + " is : " + (B + S + P + Epsilon) );
		if(sim.vars.printingModule.v.equals( "t" ) && sim.vars.declarativeModule.act == true)  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("last presentation clock time: " + The_Chunk.Last_Presentation_Time);
		if(sim.vars.printingModule.v.equals( "t" ) && sim.vars.declarativeModule.act == true)  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt(" ");
		
		//added by Yelly 
		// output base-level activation for probability computation
		if(sim.vars.qn_answer) {
			sim.funs.ProgramUtilitiesFun__Output_QN_Result_Txt("Computing activation for chunk " + The_Chunk.Chunk_Name +": ");
			sim.funs.ChunkFun__Print_Chunk(The_Chunk);
			sim.funs.ProgramUtilitiesFun__Output_QN_Result_Txt("Total base-level: " + B);
			sim.funs.ProgramUtilitiesFun__Output_QN_Result_Txt("");
			//sim.funs.ChunkFun__Print_All_Chunks_In_Model();
		}

		return (double) (B + S + P + Epsilon);
	}
	
	//DeviceModuleFun
	
public  boolean DeviceModuleFun__Any_Display_Pending(String the_display_name){

		String task_id;
		switch (the_display_name.toLowerCase() ){
			case "visual" : { 
				task_id = "visualdisplay";
				break;
			}
			case "audio" : { 
				task_id = "audiodisplay";
				break;
			}
			default: {
				System.err.println("DeviceModuleFun__Any_Display_Pending has undefined display name: " + the_display_name);
				return false;
			}

		}
		
		if( this.getNumberOfQnactrEntityInServerAndQueue(task_id) > 0 ) return true;
		else return false;
			
	}
	
/**
 * 
 * @param the_content
 * @param the_duration , duration.equals( "" ) means to keep playing the sound without stop, until another clear audicon being called explicitly
 * @param the_content_delay
 * @param the_recode_time
 * @param the_onset_clock_time
 * @param the_location
 * @param the_kind
 */
	public void DeviceModuleFun__Audio_Display_Prepare_Other_Sound(String the_content, String the_duration, double the_content_delay, double the_recode_time, String the_onset_clock_time, String the_location, String the_kind){
		
	
		if(the_onset_clock_time.equals( "" )) the_onset_clock_time = (Double.toString(GlobalUtilities.round(SimSystem.clock(),3))); // by default
		else if (sim.funs.ProgramUtilitiesFun__Is_String_Double(the_onset_clock_time) == false)System.err.println("DeviceModuleFun__Audio_Display_Prepare_Other_Sound error. sim.funs.ProgramUtilitiesFun__Is_String_Double(the_onset_clock_time) == false ");

		if(the_location.equals( "" ) ) the_location = "external" ; // by default
		if(the_kind.equals( "" )) the_kind = "speech" ; //by default

		//make the audio-event chunk first
		Chunk audio_event_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption (  new String[] {"isa", "audio-event", "onset", the_onset_clock_time,  "kind", the_kind , "location" , the_location }  ); 
		ChunkFun__Add_Chunk_Slot_Name_And_Value(audio_event_chunk, ":attended" , "nil" ); //, the audio module maintains a set of finsts which mark items that have been attended. only t and nil, no new.

		//for other sound
		String content_delay = Double.toString(the_content_delay); 
		//double duration = the_duration;
		double recode_time = the_recode_time;
		ChunkFun__Add_Chunk_Slot_Name_And_Value(audio_event_chunk, ":content-delay" ,  content_delay );  //Content delay: The amount of time between a sound's onset and when the content of the sound is accessible to the auditory system. No information can be extracted before this time has passed.
		ChunkFun__Add_Chunk_Slot_Name_And_Value(audio_event_chunk, ":recode-time" ,   Double.toString(recode_time));  //Recode time: The amount of time (after the content is available) that it takes for the auditory system to construct a representation of the sound. 
		ChunkFun__Add_Chunk_Slot_Name_And_Value(audio_event_chunk, ":duration" ,   the_duration );  //	Duration: The amount of time that the sound is present. 

		//define the audio-event chunk
		audio_event_chunk = sim.funs.ChunkFun__Define_Chunk (audio_event_chunk);
		ChunkFun__Set_Chunk_Slot_Value ( (Chunk) sim.vars.centralParametersModule.Chunks.get(audio_event_chunk.Chunk_Name) , "id" , audio_event_chunk.Chunk_Name ); //set audio-event id slot

		//prepare the audio icon chunk
		String event_name = audio_event_chunk.Chunk_Name ;
		Chunk temp_chunk =  sim.funs.ChunkFun__Make_Chunk_From_Descritption( new String[] {"isa", "sound", "kind", the_kind, "content", the_content, "event", event_name} );
		temp_chunk = sim.funs.ChunkFun__Define_Chunk(temp_chunk);

		//schedule the onset of the audicon
		
		Entity Temp_Entity = sim.funs.createEntity( "Audio Display" , "", "Audio Display", "Audio Display Onset", 0.0);
		Temp_Entity.Chunk = sim.funs.ChunkFun__Chunk_Clone(temp_chunk);
		Temp_Entity.Scheduled_Task_Enter_Clock_Time = (double) Double.parseDouble( the_onset_clock_time); 

		//GlobalUtilities.popUpMessage(the_duration);

		if(!the_duration.equals( "" )){	
			if(sim.funs.ProgramUtilitiesFun__Is_String_Double(the_duration) == false)System.out.println("DeviceModuleFun__Audio_Display_Prepare_Other_Sound has Is_String_Number(the_duration) == false ");
			double duration = Double.parseDouble(the_duration);
			if (duration <= 0) System.out.println ("DeviceModuleFun__Audio_Display_Prepare_Other_Sound has duration <= 0");
			//schedule the offset of the audicon
			
			Entity Temp_Entity_2 = sim.funs.createEntity( "Audio Display" , "", "Audio Display", "Audio Display Offset", 0.0);
			//Entity Temp_Entity_2 = new Entity();  
			//Temp_Entity_2.ID = "105"; //Audio Display
			//Temp_Entity_2.Time = (double) SimSystem.clock();
		  //Temp_Entity_2.Tag = Entity_Number; //give it an entity number, init. 1
		  //Entity_Number++;
			//Temp_Entity_2.From = ""; //tag from and to
			//Temp_Entity_2.To = "Audio Display";
			//Temp_Entity_2.Entity_Type = "Audio Display Offset";  
			Temp_Entity_2.Chunk = sim.funs.ChunkFun__Chunk_Clone(temp_chunk);
			Temp_Entity_2.Scheduled_Task_Enter_Clock_Time = (double) ((double) Double.parseDouble( the_onset_clock_time) + duration); 
		} 
		


	}
	
	public  void DeviceModuleFun__Audio_Display_Prepare_Tone_Sound(double the_frequence, double the_duration, String the_onset_clock_time){
		

		if(the_onset_clock_time.equals( "" ))the_onset_clock_time = (Double.toString(GlobalUtilities.round(SimSystem.clock(),3))); //by default
		else if (sim.funs.ProgramUtilitiesFun__Is_String_Double(the_onset_clock_time) == false)System.err.println("DeviceModuleFun__Audio_Display_Prepare_Tone_Sound error. sim.funs.ProgramUtilitiesFun__Is_String_Double(the_onset_clock_time) == false ");

		//make the audio-event chunk first
		Chunk audio_event_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption (  new String[] {"isa", "audio-event", "onset", the_onset_clock_time,  "kind", "tone" , "location" , "external" }  ); 
		ChunkFun__Add_Chunk_Slot_Name_And_Value(audio_event_chunk, ":attended" , "nil" ); //, the audio module maintains a set of finsts which mark items that have been attended. only t and nil, no new.

		//for tone
		String content_delay = Double.toString(sim.vars.audioModule.Tone_Detect_Delay);
		String recode_time = Double.toString(sim.vars.audioModule.Tone_Recode_Delay);
		ChunkFun__Add_Chunk_Slot_Name_And_Value(audio_event_chunk, ":content-delay" ,  content_delay );  //Content delay: The amount of time between a sound's onset and when the content of the sound is accessible to the auditory system. No information can be extracted before this time has passed.
		ChunkFun__Add_Chunk_Slot_Name_And_Value(audio_event_chunk, ":recode-time" ,   recode_time);  //Recode time: The amount of time (after the content is available) that it takes for the auditory system to construct a representation of the sound. 
		ChunkFun__Add_Chunk_Slot_Name_And_Value(audio_event_chunk, ":duration" ,   Double.toString(the_duration));  //	Duration: The amount of time that the sound is present. 


		//define the audio-event chunk
		audio_event_chunk = sim.funs.ChunkFun__Define_Chunk (audio_event_chunk);
		ChunkFun__Set_Chunk_Slot_Value ( (Chunk) sim.vars.centralParametersModule.Chunks.get(audio_event_chunk.Chunk_Name) , "id" , audio_event_chunk.Chunk_Name ); //set audio-event id slot


		//prepare the audio icon chunk
		String event_name = audio_event_chunk.Chunk_Name ;
		Chunk temp_chunk =  sim.funs.ChunkFun__Make_Chunk_From_Descritption( new String[] {"isa", "sound", "kind", "tone", "content", Double.toString(the_frequence), "event", event_name} );
		temp_chunk = sim.funs.ChunkFun__Define_Chunk(temp_chunk);

		//schedule the onset of the audicon
		Entity Temp_Entity = sim.funs.createEntity( "Audio Display" , "Audio Display Schedule", "Audio Display", "Audio Display Onset", 0.0);
		//Entity Temp_Entity = new Entity();  
		//Temp_Entity.ID = "105"; //Audio Display
		//Temp_Entity.Time = (double) SimSystem.clock();
	  // Temp_Entity.Tag = Entity_Number; //give it an entity number, init. 1
	  // Entity_Number++;
		//Temp_Entity.From = "Audio Display Schedule"; //tag from and to
		//Temp_Entity.To = "Audio Display";
		//Temp_Entity.Entity_Type = "Audio Display Onset";  
		Temp_Entity.Chunk = sim.funs.ChunkFun__Chunk_Clone(temp_chunk);
		Temp_Entity.Scheduled_Task_Enter_Clock_Time = (double) Double.parseDouble( the_onset_clock_time); 

		//schedule the offset of the audicon
		Entity Temp_Entity_2 = sim.funs.createEntity( "Audio Display" , "Audio Display Schedule", "Audio Display", "Audio Display Offset", 0.0);
		//Entity Temp_Entity_2 = new Entity();  
		//Temp_Entity_2.ID = "105"; //Audio Display
		//Temp_Entity_2.Time = (double) SimSystem.clock();
	  // Temp_Entity_2.Tag = Entity_Number; //give it an entity number, init. 1
	  // Entity_Number++;
		//Temp_Entity_2.From = "Audio Display Schedule"; //tag from and to
		//Temp_Entity_2.To = "Audio Display";
		//Temp_Entity_2.Entity_Type = "Audio Display Offset";  
		Temp_Entity_2.Chunk = sim.funs.ChunkFun__Chunk_Clone(temp_chunk);
		Temp_Entity_2.Scheduled_Task_Enter_Clock_Time = (double) Double.parseDouble( the_onset_clock_time) + the_duration; 
	}
	
	public  void DeviceModuleFun__Audio_Display_Prepare_Word_Sound(String the_word, String the_onset_clock_time, String the_location){

		if(the_onset_clock_time.equals( "" )) the_onset_clock_time = (Double.toString(GlobalUtilities.round(SimSystem.clock(),3))); // by default
		if (the_location.equals( "" ) ) the_location = "external" ; // by default

		//make the audio-event chunk first
		Chunk audio_event_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption (  new String[] {"isa", "audio-event", "onset", the_onset_clock_time,  "kind", "word" , "location" , the_location }  ); 
		ChunkFun__Add_Chunk_Slot_Name_And_Value(audio_event_chunk, ":attended" , "nil" ); //, the audio module maintains a set of finsts which mark items that have been attended. only t and nil, no new.

		//for word
		String content_delay = Double.toString(sim.vars.audioModule.Digit_Detect_Delay); //currently it seems ACT-R does not do randomize-time
		double duration = SpeechModuleFun__Get_Articulation_Time(the_word);
		//GlobalUtilities.popUpMessage( "DeviceModuleFun__Audio_Display_Prepare_Word_Sound the_word: " + the_word + ", duration: " +duration + ", location: " + the_location);
		double recode_time = Math.max( (duration / 2.0) , (duration - 0.15) );
		ChunkFun__Add_Chunk_Slot_Name_And_Value(audio_event_chunk, ":content-delay" ,  content_delay );  //Content delay: The amount of time between a sound's onset and when the content of the sound is accessible to the auditory system. No information can be extracted before this time has passed.
		ChunkFun__Add_Chunk_Slot_Name_And_Value(audio_event_chunk, ":recode-time" ,   Double.toString(recode_time));  //Recode time: The amount of time (after the content is available) that it takes for the auditory system to construct a representation of the sound. 
		ChunkFun__Add_Chunk_Slot_Name_And_Value(audio_event_chunk, ":duration" ,   Double.toString(duration));  //	Duration: The amount of time that the sound is present. 

		//define the audio-event chunk
		audio_event_chunk = sim.funs.ChunkFun__Define_Chunk (audio_event_chunk);
		ChunkFun__Set_Chunk_Slot_Value ( (Chunk) sim.vars.centralParametersModule.Chunks.get(audio_event_chunk.Chunk_Name) , "id" , audio_event_chunk.Chunk_Name ); //set audio-event id slot

		//prepare the audio icon chunk
		String event_name = audio_event_chunk.Chunk_Name ;
		Chunk temp_chunk =  sim.funs.ChunkFun__Make_Chunk_From_Descritption( new String[] {"isa", "sound", "kind", "word", "content", the_word, "event", event_name, "location" , the_location} );
		temp_chunk = sim.funs.ChunkFun__Define_Chunk(temp_chunk);

		//schedule the onset of the audicon
		Entity Temp_Entity = sim.funs.createEntity( "Audio Display" , "Audio Display Schedule", "Audio Display", "Audio Display Onset", 0.0);
		//Entity Temp_Entity = new Entity();  
		//Temp_Entity.ID = "105"; //Audio Display
		//Temp_Entity.Time = (double) SimSystem.clock();
	  // Temp_Entity.Tag = Entity_Number; //give it an entity number, init. 1
	  // Entity_Number++;
		//Temp_Entity.From = "Audio Display Schedule"; //tag from and to
		//Temp_Entity.To = "Audio Display";
		//Temp_Entity.Entity_Type = "Audio Display Onset";  
		Temp_Entity.Chunk = sim.funs.ChunkFun__Chunk_Clone(temp_chunk);
		Temp_Entity.Scheduled_Task_Enter_Clock_Time = (double) Double.parseDouble( the_onset_clock_time); 

		//the duration cannot be infinite ("") 

		//schedule the offset of the audicon
		Entity Temp_Entity_2 = sim.funs.createEntity( "Audio Display" , "Audio Display Schedule", "Audio Display", "Audio Display Offset", 0.0);
		//Entity Temp_Entity_2 = new Entity();  
		//Temp_Entity_2.ID = "105"; //Audio Display
		//Temp_Entity_2.Time = (double) SimSystem.clock();
	  // Temp_Entity_2.Tag = Entity_Number; //give it an entity number, init. 1
	  // Entity_Number++;
		//Temp_Entity_2.From = "Audio Display Schedule"; //tag from and to
		//Temp_Entity_2.To = "Audio Display";
		//Temp_Entity_2.Entity_Type = "Audio Display Offset";  
		Temp_Entity_2.Chunk = sim.funs.ChunkFun__Chunk_Clone(temp_chunk);
		Temp_Entity_2.Scheduled_Task_Enter_Clock_Time = Double.parseDouble( the_onset_clock_time) + duration; 

	}
	
	public void DeviceModuleFun__Clear_Visual_Display(){
		
		sim.vars.visualDisplay.Visicon.clear();
		sim.vars.visionModule.Visual_Finst_ID_Track.clear();

		sim.vars.visualization__Visual_Display = "";
		
		
		LinkedList<Entity> entities = this.getLinkedListOfQnactrEntityInServerAndQueue("visualdisplay"); //visual display
		for (Entity temp_entity: entities ){ //visual display
			if (temp_entity.Entity_Type.equals( "Visual Display Offset")) {
				System.out.println("TODO: need to test this. trash all Entity.Entity_Type == Visual Display Offset in visual display task node " );  //this will make a difference when display item has an offset trigger in visual display , and then a response trigger a clear of visual display
				temp_entity.Trash = true;
			}
		}


		//Animator, clear visicon comments and images
		if(sim.vars.animatorModule.Show_Animator && QnactrSimulation.taskVisualization2DEnable){
		  Iterator<Entry<String, String>> itr_entries_1 = sim.vars.animatorModule.Visicon_Name_Comment_ID_Table.entrySet().iterator();
			while (itr_entries_1.hasNext()){
			  Entry<String, String> anEntry = itr_entries_1.next();
				String an_id = (String) anEntry.getValue();
				sim.vars.taskVisualization2D.removeObject(an_id);
			}
			sim.vars.animatorModule.Visicon_Name_Comment_ID_Table.clear();
			
			Iterator<Entry<String, String>> itr_entries_2 = sim.vars.animatorModule.Visicon_Name_Image_ID_Table.entrySet().iterator();
			while(itr_entries_2.hasNext()){
			  Entry<String, String> anEntry = itr_entries_2.next();
				String an_id = (String) anEntry.getValue();
				sim.vars.taskVisualization2D.removeObject(an_id);
			}
			sim.vars.animatorModule.Visicon_Name_Image_ID_Table.clear();	
			
		}
	
	}
	
	public  void DeviceModuleFun__Clear_Audio_Display(){

		sim.vars.audioDisplay.Audicon.clear();
		sim.vars.audioDisplay.Ongoing_Sound.clear();

		sim.vars.visualization__Audio_Display = "";

		for (Entity temp_entity : getLinkedListOfQnactrEntityInServerAndQueue("audiodisplay" )){ //audio display
			if (temp_entity.Entity_Type.equals( "Audio Display Offset")) {
				System.out.println("TODO: need to test this. trash all Entity.Entity_Type == Audio Display Offset in audio display task node " );  //this will make a difference when display item has an offset trigger in audio display , and then a response trigger a clear of audio display
				temp_entity.Trash = true;
			}
		}

	}
	
	/**
	 * the result is contingent on the values of sim.vars.deviceModule.Pixcels_Per_Inch and sim.vars.deviceModule.Viewing_Distance
	 * @param the_pixels
	 * @return
	 */
	public  double DeviceModuleFun__Double_Pixels_To_Visual_Angle(double the_pixels){
		
		if( the_pixels < 0 ) {
			GlobalUtilities.popUpMessage("Error! DeviceModuleFun__Double_Pixels_To_Visual_Angle has the_pixels: " + the_pixels);
			return (double) 0.0;
		}
		else if (the_pixels == 0) {
      return (double) 0.0;
    }
		
		if( sim.vars.deviceModule.Pixcels_Per_Inch <= 0 ) {
			System.err.println("Error! DeviceModuleFun__Double_Pixels_To_Visual_Angle has sim.vars.deviceModule.Pixcels_Per_Inch: " + sim.vars.deviceModule.Pixcels_Per_Inch );
			return (double) 0.0;
		}
		if( sim.vars.deviceModule.Viewing_Distance <= 0.0 ) {
			System.err.println("Error! DeviceModuleFun__Double_Pixels_To_Visual_Angle has sim.vars.deviceModule.Viewing_Distance: " + sim.vars.deviceModule.Viewing_Distance );
			return (double) 0.0;
		}

		double inch = (double) the_pixels / (double) sim.vars.deviceModule.Pixcels_Per_Inch ;
		return  (double) (180 *  Math.atan ( inch / sim.vars.deviceModule.Viewing_Distance ) / Math.PI)  ;
	}
	
	public String DeviceModuleFun__Get_Audio_Display(){
		
		String return_string = "";

		Enumeration	enum_Ongoing_Sound = Collections.enumeration(sim.vars.audioDisplay.Ongoing_Sound);
		while(enum_Ongoing_Sound.hasMoreElements()){
			Chunk temp_Ongoing_Sound_chunk = (Chunk)enum_Ongoing_Sound.nextElement();
			String kind = sim.funs.ChunkFun__Get_Chunk_Slot_Value( temp_Ongoing_Sound_chunk, "kind");
			String content = sim.funs.ChunkFun__Get_Chunk_Slot_Value( temp_Ongoing_Sound_chunk, "content");
			
			//String sound_event_name = sim.funs.ChunkFun__Get_Chunk_Slot_Value(temp_Ongoing_Sound_chunk, "event") ;
			//Chunk sound_event_chunk = (Chunk) sim.vars.centralParametersModule.Chunks[sound_event_name];
			
			return_string = return_string + "\n" + kind + ": " + content ;
		}
			
			
		return return_string;
	}
	
	public  int DeviceModuleFun__Get_Pointing_Device_Order(String the_device_name){

		the_device_name = the_device_name.toLowerCase();
		int a;
		switch (the_device_name){
			case "mouse":
				a=0;
				break;
			case "joystick-1":
				a=1;
				break;
			case "joystick-2":
				a=2;
				break;
			default:
				System.err.println ("Error! DeviceModuleFun__Get_Pointing_Device_Order has undefined the_device_name: " + the_device_name);
				a=-1;
				break;
		}
		return a;
	}
	
	public String DeviceModuleFun__Get_Press_Key_Motor_Command_Attribute(String the_key, String attribute_name){
		
		Chunk command = (Chunk) sim.vars.deviceModule.Press_Key_To_Motor_Command_Hashtable.get(the_key);
		if (command.Slot.containsKey(attribute_name) == false){
			System.err.println("Error! DeviceModuleFun__Get_Press_Key_Motor_Command_Attribute has undefined attribute_name name: " + attribute_name);	
			
			return null;
		}
		//System.out.println(ChunkFun__Get_Chunk_Contents(command) + " RETURN: " + (String)command.Slot[attribute_name]);
		return (String)command.Slot.get(attribute_name);
	}
	
	public String DeviceModuleFun__Get_Visual_Display(){
		

String return_string = "";

/*
int i;
for (i=0; i < sim.vars.visualDisplay.Visicon.Count; i++){
	return_string = return_string + "\n" + sim.funs.ChunkFun__Get_Chunk_Slot_Value(sim.vars.visualDisplay.Visicon[i], "value") + " (" + sim.funs.ChunkFun__Get_Chunk_Slot_Value(sim.vars.visualDisplay.Visicon[i], "screen-x") + ", "  + sim.funs.ChunkFun__Get_Chunk_Slot_Value(sim.vars.visualDisplay.Visicon[i], "screen-y") + ")";
}
*/

Enumeration	enum_visicon = Collections.enumeration(sim.vars.visualDisplay.Visicon);
while(enum_visicon.hasMoreElements()){
	Chunk temp_visicon_chunk = (Chunk)enum_visicon.nextElement();
	String value = sim.funs.ChunkFun__Get_Chunk_Slot_Value( temp_visicon_chunk, "value");
	String visual_location_screen_pos = sim.funs.ChunkFun__Get_Chunk_Slot_Value(temp_visicon_chunk, "screen-pos") ;
	Chunk visual_location_chunk = (Chunk) sim.vars.centralParametersModule.Chunks.get(visual_location_screen_pos);
	String x = sim.funs.ChunkFun__Get_Chunk_Slot_Value(visual_location_chunk, "screen-x");
	String y = sim.funs.ChunkFun__Get_Chunk_Slot_Value(visual_location_chunk, "screen-y");
	return_string = return_string + "\n" + value + " (" + x + ", "  + y  + ")";
}
	
	
return return_string;
	}
	
	public  void DeviceModuleFun__Audio_Display_Prepare_Digit_Sound(String the_digit, String the_onset_clock_time){

		if (sim.funs.ProgramUtilitiesFun__Is_String_Double(the_digit) == false) System.err.println("DeviceModuleFun__Audio_Display_Prepare_Digit_Sound error sim.funs.ProgramUtilitiesFun__Is_String_Double(the_digit) == false " );
		if (the_onset_clock_time.equals( "" )) the_onset_clock_time = (Double.toString(GlobalUtilities.round(SimSystem.clock(),3))); // by default
		else if (sim.funs.ProgramUtilitiesFun__Is_String_Double(the_onset_clock_time) == false) System.err.println("DeviceModuleFun__Audio_Display_Prepare_Digit_Sound error. sim.funs.ProgramUtilitiesFun__Is_String_Double(the_onset_clock_time) == false");

		//make the audio-event chunk first
		Chunk audio_event_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption (  new String[] {"isa", "audio-event", "onset", the_onset_clock_time,  "kind", "digit" , "location" , "external" }  ); 
		ChunkFun__Add_Chunk_Slot_Name_And_Value(audio_event_chunk, ":attended" , "nil" ); //, the audio module maintains a set of finsts which mark items that have been attended. only t and nil, no new.

		//for digit
		double the_duration = sim.vars.audioModule.Digit_Duration;
		String content_delay = Double.toString(sim.vars.audioModule.Digit_Detect_Delay);
		String recode_time = Double.toString(sim.vars.audioModule.Digit_Recode_Delay);
		ChunkFun__Add_Chunk_Slot_Name_And_Value(audio_event_chunk, ":content-delay" ,  content_delay );  //Content delay: The amount of time between a sound's onset and when the content of the sound is accessible to the auditory system. No information can be extracted before this time has passed.
		ChunkFun__Add_Chunk_Slot_Name_And_Value(audio_event_chunk, ":recode-time" ,   recode_time);  //Recode time: The amount of time (after the content is available) that it takes for the auditory system to construct a representation of the sound. 
		ChunkFun__Add_Chunk_Slot_Name_And_Value(audio_event_chunk, ":duration" ,   Double.toString(the_duration));  //	Duration: The amount of time that the sound is present. 

		//define the audio-event chunk
		audio_event_chunk = sim.funs.ChunkFun__Define_Chunk (audio_event_chunk);
		ChunkFun__Set_Chunk_Slot_Value ( (Chunk) sim.vars.centralParametersModule.Chunks.get(audio_event_chunk.Chunk_Name) , "id" , audio_event_chunk.Chunk_Name ); //set audio-event id slot

		//prepare the audio icon chunk
		String event_name = audio_event_chunk.Chunk_Name ;
		Chunk temp_chunk =  sim.funs.ChunkFun__Make_Chunk_From_Descritption( new String[] {"isa", "sound", "kind", "digit", "content", the_digit, "event", event_name} );
		temp_chunk = sim.funs.ChunkFun__Define_Chunk(temp_chunk);

		//schedule the onset of the audicon
		Entity Temp_Entity = sim.funs.createEntity( "Audio Display" , "Audio Display Schedule", "Audio Display", "Audio Display Onset", 0.0);
		//Entity Temp_Entity = new Entity();  
		//Temp_Entity.ID = "105"; //Audio Display
		//Temp_Entity.Time = (double) SimSystem.clock();
		// Temp_Entity.Tag = Entity_Number; //give it an entity number, init. 1
		// Entity_Number++;
		//Temp_Entity.From = "Audio Display Schedule"; //tag from and to
		//Temp_Entity.To = "Audio Display";
		//Temp_Entity.Entity_Type = "Audio Display Onset";  
		Temp_Entity.Chunk = sim.funs.ChunkFun__Chunk_Clone(temp_chunk);
		Temp_Entity.Scheduled_Task_Enter_Clock_Time = (double) Double.parseDouble( the_onset_clock_time); 

		//schedule the offset of the audicon
		Entity Temp_Entity_2 = sim.funs.createEntity( "Audio Display" , "Audio Display Schedule", "Audio Display", "Audio Display Offset", 0.0);
		//Entity Temp_Entity_2 = new Entity();  
		//Temp_Entity_2.ID = "105"; //Audio Display
		//Temp_Entity_2.Time = (double) SimSystem.clock();
		// Temp_Entity_2.Tag = Entity_Number; //give it an entity number, init. 1
		// Entity_Number++;
		//Temp_Entity_2.From = "Audio Display Schedule"; //tag from and to
		//Temp_Entity_2.To = "Audio Display";
		//Temp_Entity_2.Entity_Type = "Audio Display Offset";  
		Temp_Entity_2.Chunk = sim.funs.ChunkFun__Chunk_Clone(temp_chunk);
		Temp_Entity_2.Scheduled_Task_Enter_Clock_Time = (double) Double.parseDouble( the_onset_clock_time) + the_duration; 

	}
	
	public  void DeviceModuleFun__Initialize_Device_Interface_Hashtables(){
		
		//(defmethod populate-key-to-command-ht ((ht hash-table)) //map a keyboard key to a motor command
		//see ACT-R reference manual. The press-key request is essentially a programming convenience for typing.  It assumes that the model's hands are in the home positions and translates from the specified key to either a punch or a peck-recoil request as needed to press that key.
		Chunk temp_chunk = new Chunk();
		temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(  sim.funs.ProgramUtilitiesFun__String_To_StringArray("isa punch hand left finger thumb ")  );
			sim.vars.deviceModule.Press_Key_To_Motor_Command_Hashtable.put( "space"   , temp_chunk  );
		temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(  sim.funs.ProgramUtilitiesFun__String_To_StringArray("isa  peck-recoil hand left finger pinkie r 2.24 theta -2.03")  );
			sim.vars.deviceModule.Press_Key_To_Motor_Command_Hashtable.put( "backquote"   , temp_chunk  );
		temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(  sim.funs.ProgramUtilitiesFun__String_To_StringArray("isa  peck-recoil hand left finger pinkie r 1.41 theta -2.36")  );
			sim.vars.deviceModule.Press_Key_To_Motor_Command_Hashtable.put( "tab"   , temp_chunk  );
		temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(  sim.funs.ProgramUtilitiesFun__String_To_StringArray("isa  peck-recoil hand left finger pinkie r 2 theta -1.57")  );
			sim.vars.deviceModule.Press_Key_To_Motor_Command_Hashtable.put( "1"   , temp_chunk  );
		temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(  sim.funs.ProgramUtilitiesFun__String_To_StringArray("isa  peck-recoil hand left finger pinkie r 1 theta -1.57")  );
			sim.vars.deviceModule.Press_Key_To_Motor_Command_Hashtable.put( "q"   , temp_chunk  );
		temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(  sim.funs.ProgramUtilitiesFun__String_To_StringArray("isa  punch hand left finger pinkie")  );
			sim.vars.deviceModule.Press_Key_To_Motor_Command_Hashtable.put( "a"   , temp_chunk  );
		temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(  sim.funs.ProgramUtilitiesFun__String_To_StringArray("isa  peck-recoil hand left finger pinkie r 1 theta 1.57")  );
			sim.vars.deviceModule.Press_Key_To_Motor_Command_Hashtable.put( "z"   , temp_chunk  );
		temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(  sim.funs.ProgramUtilitiesFun__String_To_StringArray("isa  peck-recoil hand left finger ring r 2 theta -1.57")  );
			sim.vars.deviceModule.Press_Key_To_Motor_Command_Hashtable.put( "2"   , temp_chunk  );
		temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(  sim.funs.ProgramUtilitiesFun__String_To_StringArray("isa  peck-recoil hand left finger ring r 1 theta -1.57")  );
			sim.vars.deviceModule.Press_Key_To_Motor_Command_Hashtable.put( "w"   , temp_chunk  );
		temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(  sim.funs.ProgramUtilitiesFun__String_To_StringArray("isa  punch hand left finger ring")  );
			sim.vars.deviceModule.Press_Key_To_Motor_Command_Hashtable.put( "s"   , temp_chunk  );
		temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(  sim.funs.ProgramUtilitiesFun__String_To_StringArray("isa  peck-recoil hand left finger ring r 1 theta 1.57")  );
			sim.vars.deviceModule.Press_Key_To_Motor_Command_Hashtable.put( "x"   , temp_chunk  );
		temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(  sim.funs.ProgramUtilitiesFun__String_To_StringArray("isa  peck-recoil hand left finger middle r 2 theta -1.57")  );
			sim.vars.deviceModule.Press_Key_To_Motor_Command_Hashtable.put( "3"   , temp_chunk  );
		temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(  sim.funs.ProgramUtilitiesFun__String_To_StringArray("isa  peck-recoil hand left finger middle r 1 theta -1.57")  );
			sim.vars.deviceModule.Press_Key_To_Motor_Command_Hashtable.put( "e"   , temp_chunk  );
		temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(  sim.funs.ProgramUtilitiesFun__String_To_StringArray("isa  punch hand left finger middle")  );
			sim.vars.deviceModule.Press_Key_To_Motor_Command_Hashtable.put( "d"   , temp_chunk  );
		temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(  sim.funs.ProgramUtilitiesFun__String_To_StringArray("isa  peck-recoil hand left finger middle r 1 theta 1.57")  );
			sim.vars.deviceModule.Press_Key_To_Motor_Command_Hashtable.put( "c"   , temp_chunk  );
		temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(  sim.funs.ProgramUtilitiesFun__String_To_StringArray("isa  peck-recoil hand left finger index r 2 theta -1.57")  );
			sim.vars.deviceModule.Press_Key_To_Motor_Command_Hashtable.put( "4"   , temp_chunk  );
		temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(  sim.funs.ProgramUtilitiesFun__String_To_StringArray("isa  peck-recoil hand left finger index r 1 theta -1.57")  );
			sim.vars.deviceModule.Press_Key_To_Motor_Command_Hashtable.put( "r"   , temp_chunk  );
		temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(  sim.funs.ProgramUtilitiesFun__String_To_StringArray("isa  punch hand left finger index")  );
			sim.vars.deviceModule.Press_Key_To_Motor_Command_Hashtable.put( "f"   , temp_chunk  );
		temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(  sim.funs.ProgramUtilitiesFun__String_To_StringArray("isa  peck-recoil hand left finger index r 1 theta 1.57")  );
			sim.vars.deviceModule.Press_Key_To_Motor_Command_Hashtable.put( "v"   , temp_chunk  );
		temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(  sim.funs.ProgramUtilitiesFun__String_To_StringArray("isa  peck-recoil hand left finger index r 2.24 theta -1.11")  );
			sim.vars.deviceModule.Press_Key_To_Motor_Command_Hashtable.put( "5"   , temp_chunk  );
		temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(  sim.funs.ProgramUtilitiesFun__String_To_StringArray("isa  peck-recoil hand left finger index r 1.41 theta -0.79")  );
			sim.vars.deviceModule.Press_Key_To_Motor_Command_Hashtable.put( "t"   , temp_chunk  );
		temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(  sim.funs.ProgramUtilitiesFun__String_To_StringArray("isa  peck-recoil hand left finger index r 1 theta 0")  );
			sim.vars.deviceModule.Press_Key_To_Motor_Command_Hashtable.put( "g"   , temp_chunk  );
		temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(  sim.funs.ProgramUtilitiesFun__String_To_StringArray("isa  peck-recoil hand left finger index r 1.41 theta 0.79")  );
			sim.vars.deviceModule.Press_Key_To_Motor_Command_Hashtable.put( "b"   , temp_chunk  );
		temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(  sim.funs.ProgramUtilitiesFun__String_To_StringArray("isa  peck-recoil hand right finger index r 2.24 theta -2.03")  );
			sim.vars.deviceModule.Press_Key_To_Motor_Command_Hashtable.put( "6"   , temp_chunk  );
		temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(  sim.funs.ProgramUtilitiesFun__String_To_StringArray("isa  peck-recoil hand right finger index r 1.41 theta -2.36")  );
			sim.vars.deviceModule.Press_Key_To_Motor_Command_Hashtable.put( "y"   , temp_chunk  );
		temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(  sim.funs.ProgramUtilitiesFun__String_To_StringArray("isa  peck-recoil hand right finger index r 1 theta 3.14")  );
			sim.vars.deviceModule.Press_Key_To_Motor_Command_Hashtable.put( "h"   , temp_chunk  );
		temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(  sim.funs.ProgramUtilitiesFun__String_To_StringArray("isa  peck-recoil hand right finger index r 1.41 theta 2.36")  );
			sim.vars.deviceModule.Press_Key_To_Motor_Command_Hashtable.put( "n"   , temp_chunk  );
		temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(  sim.funs.ProgramUtilitiesFun__String_To_StringArray("isa  peck-recoil hand right finger index r 2 theta -1.57")  );
			sim.vars.deviceModule.Press_Key_To_Motor_Command_Hashtable.put( "7"   , temp_chunk  );
		temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(  sim.funs.ProgramUtilitiesFun__String_To_StringArray("isa  peck-recoil hand right finger index r 1 theta -1.57")  );
			sim.vars.deviceModule.Press_Key_To_Motor_Command_Hashtable.put( "u"   , temp_chunk  );
		temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(  sim.funs.ProgramUtilitiesFun__String_To_StringArray("isa  punch hand right finger index")  );
			sim.vars.deviceModule.Press_Key_To_Motor_Command_Hashtable.put( "j"   , temp_chunk  );
		temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(  sim.funs.ProgramUtilitiesFun__String_To_StringArray("isa  peck-recoil hand right finger index r 1 theta 1.57")  );
			sim.vars.deviceModule.Press_Key_To_Motor_Command_Hashtable.put( "m"   , temp_chunk  );
		temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(  sim.funs.ProgramUtilitiesFun__String_To_StringArray("isa  peck-recoil hand right finger middle r 2 theta -1.57")  );
			sim.vars.deviceModule.Press_Key_To_Motor_Command_Hashtable.put( "8"   , temp_chunk  );
		temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(  sim.funs.ProgramUtilitiesFun__String_To_StringArray("isa  peck-recoil hand right finger middle r 1 theta -1.57")  );
			sim.vars.deviceModule.Press_Key_To_Motor_Command_Hashtable.put( "i"   , temp_chunk  );
		temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(  sim.funs.ProgramUtilitiesFun__String_To_StringArray("isa  punch hand right finger middle")  );
			sim.vars.deviceModule.Press_Key_To_Motor_Command_Hashtable.put( "k"   , temp_chunk  );
		temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(  sim.funs.ProgramUtilitiesFun__String_To_StringArray("isa  peck-recoil hand right finger middle r 1 theta 1.57")  );
			sim.vars.deviceModule.Press_Key_To_Motor_Command_Hashtable.put( "comma"   , temp_chunk  );
		temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(  sim.funs.ProgramUtilitiesFun__String_To_StringArray("isa  peck-recoil hand right finger ring r 2 theta -1.57")  );
			sim.vars.deviceModule.Press_Key_To_Motor_Command_Hashtable.put( "9"   , temp_chunk  );
		temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(  sim.funs.ProgramUtilitiesFun__String_To_StringArray("isa  peck-recoil hand right finger ring r 1 theta -1.57")  );
			sim.vars.deviceModule.Press_Key_To_Motor_Command_Hashtable.put( "o"   , temp_chunk  );
		temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(  sim.funs.ProgramUtilitiesFun__String_To_StringArray("isa  punch hand right finger ring")  );
			sim.vars.deviceModule.Press_Key_To_Motor_Command_Hashtable.put( "l"   , temp_chunk  );
		temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(  sim.funs.ProgramUtilitiesFun__String_To_StringArray("isa  peck-recoil hand right finger ring r 1 theta 1.57")  );
			sim.vars.deviceModule.Press_Key_To_Motor_Command_Hashtable.put( "period"   , temp_chunk  );
		temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(  sim.funs.ProgramUtilitiesFun__String_To_StringArray("isa  peck-recoil hand right finger pinkie r 2 theta -1.57")  );
			sim.vars.deviceModule.Press_Key_To_Motor_Command_Hashtable.put( "0"   , temp_chunk  );
		temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(  sim.funs.ProgramUtilitiesFun__String_To_StringArray("isa  peck-recoil hand right finger pinkie r 1 theta -1.57")  );
			sim.vars.deviceModule.Press_Key_To_Motor_Command_Hashtable.put( "p"   , temp_chunk  );
		temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(  sim.funs.ProgramUtilitiesFun__String_To_StringArray("isa  punch hand right finger pinkie")  );
			sim.vars.deviceModule.Press_Key_To_Motor_Command_Hashtable.put( "semicolon"   , temp_chunk  );
		temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(  sim.funs.ProgramUtilitiesFun__String_To_StringArray("isa  peck-recoil hand right finger pinkie r 1 theta 1.57")  );
			sim.vars.deviceModule.Press_Key_To_Motor_Command_Hashtable.put( "slash"   , temp_chunk  );
		temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(  sim.funs.ProgramUtilitiesFun__String_To_StringArray("isa  peck-recoil hand right finger pinkie r 2.24 theta -1.11")  );
			sim.vars.deviceModule.Press_Key_To_Motor_Command_Hashtable.put( "hyphen"   , temp_chunk  );
		temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(  sim.funs.ProgramUtilitiesFun__String_To_StringArray("isa  peck-recoil hand right finger pinkie r 2.24 theta -1.11")  );
			sim.vars.deviceModule.Press_Key_To_Motor_Command_Hashtable.put( "-"   , temp_chunk  );
		temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(  sim.funs.ProgramUtilitiesFun__String_To_StringArray("isa  peck-recoil hand right finger pinkie r 1.41 theta -0.78")  );
			sim.vars.deviceModule.Press_Key_To_Motor_Command_Hashtable.put( "["   , temp_chunk  );
		temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(  sim.funs.ProgramUtilitiesFun__String_To_StringArray("isa  peck-recoil hand right finger pinkie r 1 theta 0")  );
			sim.vars.deviceModule.Press_Key_To_Motor_Command_Hashtable.put( "quote"   , temp_chunk  );
		temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(  sim.funs.ProgramUtilitiesFun__String_To_StringArray("isa  peck-recoil hand right finger pinkie r 2 theta 0")  );
			sim.vars.deviceModule.Press_Key_To_Motor_Command_Hashtable.put( "return"   , temp_chunk  );
			

		//(defmethod populate-key-to-loc-ht ((ht hash-table))
		//see ACT-R reference manual motor module, physical world
		// function key row
		Two_Tuple temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 0; temp_tuple.Ob2 = 0; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "escape", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 2; temp_tuple.Ob2 = 0; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "f1", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 3; temp_tuple.Ob2 = 0; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "f2", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 4; temp_tuple.Ob2 = 0; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "f3", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 5; temp_tuple.Ob2 = 0; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "f4", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 7; temp_tuple.Ob2 = 0; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "f5", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 8; temp_tuple.Ob2 = 0; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "f6", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 9; temp_tuple.Ob2 = 0; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "f7", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 10; temp_tuple.Ob2 = 0; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "f8", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 12; temp_tuple.Ob2 = 0; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "f9", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 13; temp_tuple.Ob2 = 0; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "f10", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 14; temp_tuple.Ob2 = 0; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "f11", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 15; temp_tuple.Ob2 = 0; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "f12", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 17; temp_tuple.Ob2 = 0; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "f13", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 18; temp_tuple.Ob2 = 0; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "f14", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 19; temp_tuple.Ob2 = 0; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "f15", temp_tuple);
			
		// numeric key row	
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 0; temp_tuple.Ob2 = 2; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "backquote", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 1; temp_tuple.Ob2 = 2; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "1", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 2; temp_tuple.Ob2 = 2; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "2", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 3; temp_tuple.Ob2 = 2; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "3", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 4; temp_tuple.Ob2 = 2; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "4", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 5; temp_tuple.Ob2 = 2; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "5", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 6; temp_tuple.Ob2 = 2; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "6", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 7; temp_tuple.Ob2 = 2; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "7", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 8; temp_tuple.Ob2 = 2; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "8", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 9; temp_tuple.Ob2 = 2; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "9", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 10; temp_tuple.Ob2 = 2; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "0", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 11; temp_tuple.Ob2 = 2; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "-", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 11; temp_tuple.Ob2 = 2; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "hyphen", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 12; temp_tuple.Ob2 = 2; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "=", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 13; temp_tuple.Ob2 = 2; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "delete", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 15; temp_tuple.Ob2 = 2; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "help", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 16; temp_tuple.Ob2 = 2; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "home", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 17; temp_tuple.Ob2 = 2; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "pageup", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 19; temp_tuple.Ob2 = 2; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "clear", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 20; temp_tuple.Ob2 = 2; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "keypad=", temp_tuple); //	ACT-R originally: sim.vars.deviceModule.Key_To_Location_Hashtable.put( "=", temp_tuple); 
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 21; temp_tuple.Ob2 = 2; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "keypad/", temp_tuple); //	ACT-R originally:	sim.vars.deviceModule.Key_To_Location_Hashtable.put( "/", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 22; temp_tuple.Ob2 = 2; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "*", temp_tuple);
			
		//QWERTY row
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 0; temp_tuple.Ob2 = 3; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "tab", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 1; temp_tuple.Ob2 = 3; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "q", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 2; temp_tuple.Ob2 = 3; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "w", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 3; temp_tuple.Ob2 = 3; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "e", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 4; temp_tuple.Ob2 = 3; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "r", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 5; temp_tuple.Ob2 = 3; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "t", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 6; temp_tuple.Ob2 = 3; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "y", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 7; temp_tuple.Ob2 = 3; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "u", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 8; temp_tuple.Ob2 = 3; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "i", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 9; temp_tuple.Ob2 = 3; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "o", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 10; temp_tuple.Ob2 = 3; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "p", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 11; temp_tuple.Ob2 = 3; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "[", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 12; temp_tuple.Ob2 = 3; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "]", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 13; temp_tuple.Ob2 = 3; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "backslash", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 15; temp_tuple.Ob2 = 3; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "forward-delete", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 16; temp_tuple.Ob2 = 3; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "end", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 17; temp_tuple.Ob2 = 3; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "page-up", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 19; temp_tuple.Ob2 = 3; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "keypad-7", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 20; temp_tuple.Ob2 = 3; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "keypad-8", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 21; temp_tuple.Ob2 = 3; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "keypad-9", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 22; temp_tuple.Ob2 = 3; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "keypad-hyphen", temp_tuple);
			
		//"A" row
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 0; temp_tuple.Ob2 = 4; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "caps-lock", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 1; temp_tuple.Ob2 = 4; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "a", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 2; temp_tuple.Ob2 = 4; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "s", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 3; temp_tuple.Ob2 = 4; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "d", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 4; temp_tuple.Ob2 = 4; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "f", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 5; temp_tuple.Ob2 = 4; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "g", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 6; temp_tuple.Ob2 = 4; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "h", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 7; temp_tuple.Ob2 = 4; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "j", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 8; temp_tuple.Ob2 = 4; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "k", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 9; temp_tuple.Ob2 = 4; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "l", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 10; temp_tuple.Ob2 = 4; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "semicolon", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 11; temp_tuple.Ob2 = 4; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "quote", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 12; temp_tuple.Ob2 = 4; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "return", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 19; temp_tuple.Ob2 = 4; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "keypad-4", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 20; temp_tuple.Ob2 = 4; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "keypad-5", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 21; temp_tuple.Ob2 = 4; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "keypad-6", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 22; temp_tuple.Ob2 = 4; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "keypad-plus", temp_tuple);

		//"Z" row
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 0; temp_tuple.Ob2 = 5; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "shift", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 1; temp_tuple.Ob2 = 5; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "z", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 2; temp_tuple.Ob2 = 5; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "x", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 3; temp_tuple.Ob2 = 5; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "c", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 4; temp_tuple.Ob2 = 5; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "v", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 5; temp_tuple.Ob2 = 5; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "b", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 6; temp_tuple.Ob2 = 5; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "n", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 7; temp_tuple.Ob2 = 5; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "m", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 8; temp_tuple.Ob2 = 5; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "comma", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 9; temp_tuple.Ob2 = 5; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "period", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 9; temp_tuple.Ob2 = 5; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "dot", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 10; temp_tuple.Ob2 = 5; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "/", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 11; temp_tuple.Ob2 = 5; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "right-shift", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 16; temp_tuple.Ob2 = 5; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "up-arrow", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 19; temp_tuple.Ob2 = 5; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "keypad-1", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 20; temp_tuple.Ob2 = 5; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "keypad-2", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 21; temp_tuple.Ob2 = 5; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "keypad-3", temp_tuple);
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 22; temp_tuple.Ob2 = 5; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "keypad-enter", temp_tuple);
			
		//space bar row
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 0; temp_tuple.Ob2 = 6; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "left-control", temp_tuple);	
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 1; temp_tuple.Ob2 = 6; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "left-option", temp_tuple);	
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 2; temp_tuple.Ob2 = 6; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "left-command", temp_tuple);	
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 3; temp_tuple.Ob2 = 6; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "spc1", temp_tuple);	//ACT-R orginally just use "spc", but it sets multiple mapping for "spc"
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 4; temp_tuple.Ob2 = 6; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "spc2", temp_tuple);	//ACT-R orginally just use "spc", but it sets multiple mapping for "spc"
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 5; temp_tuple.Ob2 = 6; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "space", temp_tuple);	//ACT-R orginally just use "spc", but it sets multiple mapping for "spc"
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 6; temp_tuple.Ob2 = 6; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "spc4", temp_tuple);	//ACT-R orginally just use "spc", but it sets multiple mapping for "spc"
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 7; temp_tuple.Ob2 = 6; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "spc5", temp_tuple);	//ACT-R orginally just use "spc", but it sets multiple mapping for "spc"
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 8; temp_tuple.Ob2 = 6; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "spc6", temp_tuple);	//ACT-R orginally just use "spc", but it sets multiple mapping for "spc"
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 9; temp_tuple.Ob2 = 6; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "spc7", temp_tuple);	//ACT-R orginally just use "spc", but it sets multiple mapping for "spc"
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 10; temp_tuple.Ob2 = 6; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "spc8", temp_tuple);	//ACT-R orginally just use "spc", but it sets multiple mapping for "spc"
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 11; temp_tuple.Ob2 = 6; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "right-command", temp_tuple);	
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 12; temp_tuple.Ob2 = 6; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "right-option", temp_tuple);	
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 13; temp_tuple.Ob2 = 6; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "right-control", temp_tuple);	
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 15; temp_tuple.Ob2 = 6; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "left-arrow", temp_tuple);	
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 16; temp_tuple.Ob2 = 6; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "down-arrow", temp_tuple);	
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 17; temp_tuple.Ob2 = 6; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "right-arrow", temp_tuple);	
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 19; temp_tuple.Ob2 = 6; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "keypad-0", temp_tuple);	
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 21; temp_tuple.Ob2 = 6; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "keypad-period", temp_tuple);	
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 22; temp_tuple.Ob2 = 6; 
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "enter", temp_tuple);	


		//right hand mouse related
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 28; temp_tuple.Ob2 = 2; 	
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "mouse-L", temp_tuple);		//right index
			
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 27; temp_tuple.Ob2 = 4; 	
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "mouse-1", temp_tuple);		//right thumb	

		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 29; temp_tuple.Ob2 = 2; 	
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "mouse-R", temp_tuple);		//right middle
			
		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 30; temp_tuple.Ob2 = 2; 	
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "mouse-4", temp_tuple);		//right ring

		temp_tuple = new Two_Tuple(); temp_tuple.Ob1 = 31; temp_tuple.Ob2 = 2; 	
			sim.vars.deviceModule.Key_To_Location_Hashtable.put( "mouse-5", temp_tuple);		//right pinkie
		
	}

	public String DeviceModuleFun__Keyboard_Location_To_Key(int the_x, int the_y){
		
		
	  Iterator<Entry<String, Two_Tuple>> itrTable = sim.vars.deviceModule.Key_To_Location_Hashtable.entrySet().iterator();
		while ( itrTable.hasNext()){
		  Entry<String, Two_Tuple> currentEntry = itrTable.next();
			String key = (String)currentEntry.getKey();
			Two_Tuple temp_tuple = (Two_Tuple) currentEntry.getValue();
			int temp_x = (int) temp_tuple.Ob1;
			int temp_y = (int) temp_tuple.Ob2;
			if (temp_x == the_x && temp_y == the_y ){
				return key;
			}
		}	
		System.err.println("DeviceModuleFun__Keyboard_Location_To_Key has undefined keyboard location x: " + the_x + ", y: " + the_y );
		return null;
	}

	public  int DeviceModuleFun__Visual_Angle_To_Pixels(double the_visual_angle){
		
		if( the_visual_angle <= 0 ) {
			System.err.println("Error! DeviceModuleFun__Visual_Angle_To_Pixels has the_visual_angle: " + the_visual_angle);
			return 0;
		}
		if( sim.vars.deviceModule.Pixcels_Per_Inch <= 0 ) {
			System.err.println("Error! DeviceModuleFun__Visual_Angle_To_Pixels has sim.vars.deviceModule.Pixcels_Per_Inch: " + sim.vars.deviceModule.Pixcels_Per_Inch );
			return 0;
		}
		if( sim.vars.deviceModule.Viewing_Distance <= 0.0 ) {
			System.err.println("Error! DeviceModuleFun__Visual_Angle_To_Pixels has sim.vars.deviceModule.Viewing_Distance: " + sim.vars.deviceModule.Viewing_Distance );
			return 0;
		}

		double inch_on_screen = sim.vars.deviceModule.Viewing_Distance * Math.tan( the_visual_angle / 180 * Math.PI );
		return  (GlobalUtilities.round( ( inch_on_screen * sim.vars.deviceModule.Pixcels_Per_Inch ),0 )).intValue();
	}

	public  void DeviceModuleFun__Visual_Display_Prepare_Clear_Visual_Display(double timer){

		//send an entity to visual display
	  Entity Temp_Entity = sim.funs.createEntity( "Visual Display" , "", "Visual Display", "Clear Visual Display", 0.0);
		//Entity Temp_Entity = new Entity();  
		//Temp_Entity.ID = "103"; //Visual Display
		//Temp_Entity.Time = (double) SimSystem.clock();
	  // Temp_Entity.Tag = Entity_Number; //give it an entity number, init. 1
	  // Entity_Number++;
		//Temp_Entity.From = ""; //tag from and to
		//Temp_Entity.To = "Visual Display";
		//Temp_Entity.Entity_Type = "Clear Visual Display";  
		Temp_Entity.Scheduled_Task_Enter_Clock_Time = SimSystem.clock() + timer; 
	}

	public  String DeviceModuleFun__Visual_Display_Prepare_Line(int item_ID_num, boolean if_onset_clear, boolean if_offset_clear, int the_start_point_x, int the_start_point_y, int the_end_point_x, int the_end_point_y, String the_onset_clock_time, String the_duration, String the_color){
		//ACT-R uwi.lisp
		/*
		(defmethod make-line-for-rpm-window ((wind rpm-virtual-window) start-pt end-pt &optional (color 'black))
		  (make-instance 'v-liner
		    :color color
		    :x-pos (first start-pt)
		    :y-pos (second start-pt)
		    :width (first end-pt)
		    :height (second end-pt)))
		*/

		//GlobalUtilities.popUpMessage("DeviceModuleFun__Visual_Display_Prepare_Line");

		//prepare a line visicon 
		if(the_onset_clock_time.equals( "" )) the_onset_clock_time = (Double.toString(GlobalUtilities.round(SimSystem.clock(),3))); // by default
		else if (sim.funs.ProgramUtilitiesFun__Is_String_Double(the_onset_clock_time) == false)System.err.println("Error! DeviceModuleFun__Visual_Display_Prepare_Line error. sim.funs.ProgramUtilitiesFun__Is_String_Double(the_onset_clock_time) == false ");
		else if ( GlobalUtilities.round( Double.parseDouble( the_onset_clock_time),3 ) < GlobalUtilities.round(SimSystem.clock(),3) ) System.err.println("Error! DeviceModuleFun__Visual_Display_Prepare_Line error. Double.valueOf( the_onset_clock_time) < Clock ");
			
		if(the_color.equals( "" )) the_color = "black"; // by default


		/* //visual location definition for a line object in ACT-R 6.0 device.lisp
		(defmethod build-vis-locs-for ((lnr v-liner) (vis-mod vision-module))
		  "Convert the view to a feature to be placed into the visual icon"
		  
		  (let ((f (cond ((loc-chunks lnr)
		                  (mod-chunk-fct (loc-chunks lnr) `(color ,(color lnr)
		                                                    screen-x ,(floor (/ (+ (x-pos lnr) (width lnr)) 2))
		                                                    screen-y ,(floor (/ (+ (y-pos lnr) (height lnr)) 2))
		                                                    width ,(abs (- (x-pos lnr) (width lnr)))
		                                                    height ,(abs (- (y-pos lnr) (height lnr))))))
		                 (t
		                  (setf (loc-chunks lnr) (car (define-chunks-fct `((isa visual-location
		                                                                        color ,(color lnr)
		                                                                        value line
		                                                                        kind line
		                                                                        screen-x ,(floor (/ (+ (x-pos lnr) (width lnr)) 2))
		                                                                        screen-y ,(floor (/ (+ (y-pos lnr) (height lnr)) 2))
		                                                                        width ,(abs (- (x-pos lnr) (width lnr)))
		                                                                        height ,(abs (- (y-pos lnr) (height lnr))))))))))))
		    (setf (chunk-visual-object f) lnr)
		    f))
			
		*/


		//some ACT-R default attributes that currently cannot be customized. 
		String kind = "line";
		String value = "line";
		int height = Math.abs( the_start_point_y - the_end_point_y ); //the height difference between the start point and the end point
		int width  = Math.abs( the_start_point_x - the_end_point_x ); //the horizontal difference between the start point and the end point
		int the_x = (int) Math.floor( (   the_start_point_x  +  the_end_point_x ) / 2.0 ) ;
		int the_y = (int) Math.floor( (   the_start_point_y  +  the_end_point_y ) / 2.0 ) ;

		// other slots of a visual-location chunk should be automatically filled with value "nil"

		//make the visual-location chunk first
		Chunk visual_location_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption (  new String[] {"isa", "visual-location", "screen-x", Integer.toString(the_x),  "screen-y", Integer.toString(the_y),  "kind", kind,  "color", the_color,  "value", value,  "height", Integer.toString(height), "width", Integer.toString(width) } );   
		ChunkFun__Add_Chunk_Slot_Name_And_Value(visual_location_chunk, ":attended" , "new" ); 

		//define the visual-location chunk
		visual_location_chunk = sim.funs.ChunkFun__Define_Chunk (visual_location_chunk);

		//prepare the visicon chunk
		String screen_pos = visual_location_chunk.Chunk_Name ;
		Chunk temp_chunk =  sim.funs.ChunkFun__Make_Chunk_From_Descritption( new String[] {"isa", "line", "value", value, "color", the_color, "screen-pos", screen_pos  , "height", Integer.toString(height), "width", Integer.toString(width) , "end1-x" , Integer.toString(the_start_point_x) ,  "end1-y", Integer.toString(the_start_point_y) , "end2-x", Integer.toString(the_end_point_x) , "end2-y", Integer.toString(the_end_point_y) } ); 
		//check whether to clear visicon
		if (if_onset_clear) sim.funs.ChunkFun__Add_Chunk_Slot_Name_And_Value(temp_chunk, ":onset-clear" , "t" );
		if (if_offset_clear) sim.funs.ChunkFun__Add_Chunk_Slot_Name_And_Value(temp_chunk, ":offset-clear" , "t" );
		temp_chunk = sim.funs.ChunkFun__Define_Chunk(temp_chunk);

		String item_ID = "item-" + item_ID_num;
		if ( ! sim.vars.visualDisplay.Visicon_Names_Associated_With_A_Display_Item_ID.containsKey( item_ID ) ) {
			LinkedList<String> temp_list = new LinkedList<String> ();
			temp_list.addLast ( temp_chunk.Chunk_Name);
			sim.vars.visualDisplay.Visicon_Names_Associated_With_A_Display_Item_ID.put( item_ID, temp_list );
		}
		else {
		  ((LinkedList<String>)sim.vars.visualDisplay.Visicon_Names_Associated_With_A_Display_Item_ID.get(item_ID)).clear();
      ((LinkedList<String>)sim.vars.visualDisplay.Visicon_Names_Associated_With_A_Display_Item_ID.get(item_ID)).addLast(temp_chunk.Chunk_Name);
      
//			LinkedList<String> tempList=new LinkedList<String>();
//			tempList.add((String) sim.vars.visualDisplay.Visicon_Names_Associated_With_A_Display_Item_ID.get(item_ID));
//			tempList.clear();
//			tempList.add((String) sim.vars.visualDisplay.Visicon_Names_Associated_With_A_Display_Item_ID.get(item_ID));
//			tempList.addLast(temp_chunk.Chunk_Name);
		}


		//schedule the onset of the visicon
		Entity Temp_Entity = sim.funs.createEntity( "Visual Display" , "", "Visual Display", "Visual Display Onset", 0.0);
		//Entity Temp_Entity = new Entity();  
		//Temp_Entity.ID = "103"; //Visual Display
		//Temp_Entity.Time = (double) SimSystem.clock();
		// Temp_Entity.Tag = Entity_Number; //give it an entity number, init. 1
		// Entity_Number++;
		//Temp_Entity.From = ""; //tag from and to
		//Temp_Entity.To = "Visual Display";
		//Temp_Entity.Entity_Type = "Visual Display Onset";  
		Temp_Entity.Chunk = sim.funs.ChunkFun__Chunk_Clone(temp_chunk);
		Temp_Entity.Scheduled_Task_Enter_Clock_Time = (double) Double.parseDouble( the_onset_clock_time); 

		if(!the_duration.equals( "")){	
		//TODO // if(sim.funs.ProgramUtilitiesFun__Is_String_Double(the_duration) == false)GlobalUtilities.popUpMessage("DeviceModuleFun__Visual_Display_Prepare_Line has Is_String_Number(the_duration) == false ");
			double duration = Double.parseDouble(the_duration);
			if (duration <= 0) System.out.println ("DeviceModuleFun__Visual_Display_Prepare_Line has duration <= 0");

			//schedule the offset of the visicon
			Entity Temp_Entity_2 = sim.funs.createEntity( "Visual Display" , "", "Visual Display", "Visual Display Offset", 0.0);
			//Entity Temp_Entity_2 = new Entity();  
			//Temp_Entity_2.ID = "103"; //Visual Display
			//Temp_Entity_2.Time = (double) SimSystem.clock();
		  // Temp_Entity_2.Tag = Entity_Number; //give it an entity number, init. 1
		  // Entity_Number++;
			//Temp_Entity_2.From = ""; //tag from and to
			//Temp_Entity_2.To = "Visual Display";
			//Temp_Entity_2.Entity_Type = "Visual Display Offset";  
			Temp_Entity_2.Chunk = sim.funs.ChunkFun__Chunk_Clone(temp_chunk);
			Temp_Entity_2.Scheduled_Task_Enter_Clock_Time = (double) (Double.parseDouble( the_onset_clock_time) + duration); 
		
		} 
		// duration.equals( "" ) means to keep displaying without stop, until another clear command being called explicitly
		//GlobalUtilities.popUpMessage("DeviceModuleFun__Visual_Display_Prepare_Line DONE the_onset_clock_time: " + the_onset_clock_time);

		return temp_chunk.Chunk_Name; //return the visicon name
	}

	public  void DeviceModuleFun__Visual_Display_Prepare_Oval(int item_ID_num, boolean if_onset_clear, boolean if_offset_clear, int the_x, int the_y, String the_onset_clock_time, String the_duration, String the_color, int width, int height, String value){
		//GlobalUtilities.popUpMessage("DeviceModuleFun__Visual_Display_Prepare_Oval");


		if(the_onset_clock_time.equals( "" )) the_onset_clock_time = (Double.toString(GlobalUtilities.round(SimSystem.clock(),3))); // by default
		else if (sim.funs.ProgramUtilitiesFun__Is_String_Double(the_onset_clock_time) == false)System.err.println("DeviceModuleFun__Visual_Display_Prepare_Oval error. sim.funs.ProgramUtilitiesFun__Is_String_Double(the_onset_clock_time) == false ");
		else if ( GlobalUtilities.round( Double.parseDouble( the_onset_clock_time),3 ) < GlobalUtilities.round(SimSystem.clock(),3) ) System.out.println("Error! DeviceModuleFun__Visual_Display_Prepare_Oval error. Double.valueOf( the_onset_clock_time) < Clock. the_onset_clock_time: "+ Double.parseDouble( the_onset_clock_time) + ", Clock: " + SimSystem.clock() );

		if(the_color.equals( "" )) the_color = "gray"; // button color is gray by default
		//some ACT-R default attributes that currently cannot be customized.  see (defmethod build-vis-locs-for ((self button-vdi) (vis-mod vision-module)) in ACT-R device.lisp
		double distance = 0.0; //ToDo: need computation rule in ACT-R
		String kind = "oval";
		//value directly use input 

		double size = 0.0; //ToDo: need computation rule in ACT-R

		//make the visual-location chunk for the oval (button), use the_color for color
		Chunk visual_location_chunk_button = sim.funs.ChunkFun__Make_Chunk_From_Descritption (  new String[] {"isa", "visual-location", "screen-x", Integer.toString(the_x),  "screen-y", Integer.toString(the_y),  "distance", Double.toString(distance), "kind", kind,  "color", the_color,  "value", value,  "height", Integer.toString(height), "width", Integer.toString(width), "size", Double.toString(size) } );  
		ChunkFun__Add_Chunk_Slot_Name_And_Value(visual_location_chunk_button, ":attended" , "new" ); 
		//define the visual-location chunk
		visual_location_chunk_button = sim.funs.ChunkFun__Define_Chunk (visual_location_chunk_button);
		//prepare the visicon chunk for button
		String screen_pos_button = visual_location_chunk_button.Chunk_Name ;
		Chunk temp_chunk_button =  sim.funs.ChunkFun__Make_Chunk_From_Descritption( new String[] {"isa", "oval", "value", value , "color", the_color, "screen-pos", screen_pos_button} ); 
		//check whether to clear visicon
		if (if_onset_clear) sim.funs.ChunkFun__Add_Chunk_Slot_Name_And_Value(temp_chunk_button, ":onset-clear" , "t" );
		if (if_offset_clear) sim.funs.ChunkFun__Add_Chunk_Slot_Name_And_Value(temp_chunk_button, ":offset-clear" , "t" );
		
		temp_chunk_button = sim.funs.ChunkFun__Define_Chunk(temp_chunk_button);

		String item_ID = "item-" + item_ID_num;
		if ( ! sim.vars.visualDisplay.Visicon_Names_Associated_With_A_Display_Item_ID.containsKey( item_ID ) ) {
			LinkedList<String> temp_list = new LinkedList<String> ();
			temp_list.addLast ( temp_chunk_button.Chunk_Name);
			sim.vars.visualDisplay.Visicon_Names_Associated_With_A_Display_Item_ID.put	( item_ID, temp_list );
		}
		else {
		  ((LinkedList<String>)sim.vars.visualDisplay.Visicon_Names_Associated_With_A_Display_Item_ID.get(item_ID)).clear();
      ((LinkedList<String>)sim.vars.visualDisplay.Visicon_Names_Associated_With_A_Display_Item_ID.get(item_ID)).addLast(temp_chunk_button.Chunk_Name);

		}

		//schedule the onset of the visicon
		Entity Temp_Entity = sim.funs.createEntity( "Visual Display" , "", "Visual Display", "Visual Display Onset", 0.0);
		//Entity Temp_Entity = new Entity();  
		//Temp_Entity.ID = "103"; //Visual Display
		//Temp_Entity.Time = (double) SimSystem.clock();
	 // Temp_Entity.Tag = Entity_Number; //give it an entity number, init. 1
	 // 	Entity_Number++;
		//Temp_Entity.From = ""; //tag from and to
		//Temp_Entity.To = "Visual Display";
		//Temp_Entity.Entity_Type = "Visual Display Onset";  
		Temp_Entity.Chunk = sim.funs.ChunkFun__Chunk_Clone(temp_chunk_button);
		Temp_Entity.Scheduled_Task_Enter_Clock_Time = (double) Double.parseDouble( the_onset_clock_time); 

		if(!the_duration.equals( "")){	
			if(sim.funs.ProgramUtilitiesFun__Is_String_Double(the_duration) == false)System.out.println("DeviceModuleFun__Visual_Display_Prepare_Oval has Is_String_Number(the_duration) == false ");
			double duration =  Double.parseDouble(the_duration);
			if (duration <= 0) Double.parseDouble ("DeviceModuleFun__Visual_Display_Prepare_Oval has duration <= 0");

			//schedule the offset of the visicon
			Entity Temp_Entity_2 = sim.funs.createEntity( "Visual Display" , "", "Visual Display", "Visual Display Offset", 0.0);
			//Entity Temp_Entity_2 = new Entity();  
			//Temp_Entity_2.ID = "103"; //Visual Display
			//Temp_Entity_2.Time = (double) SimSystem.clock();
		  // 	Temp_Entity_2.Tag = Entity_Number; //give it an entity number, init. 1
		  // 	Entity_Number++;
			//Temp_Entity_2.From = ""; //tag from and to
			//Temp_Entity_2.To = "Visual Display";
			//Temp_Entity_2.Entity_Type = "Visual Display Offset";  
			Temp_Entity_2.Chunk = sim.funs.ChunkFun__Chunk_Clone(temp_chunk_button);
			Temp_Entity_2.Scheduled_Task_Enter_Clock_Time = (double) ((double) Double.parseDouble( the_onset_clock_time) + duration); 
		} 
		// duration.equals( "" ) means to keep displaying without stop, until another clear command being called explicitly
		//GlobalUtilities.popUpMessage("DeviceModuleFun__Visual_Display_Prepare_Oval DONE the_onset_clock_time: " + the_onset_clock_time);


	}

	public  void DeviceModuleFun__Visual_Display_Prepare_Text(int item_ID_num, boolean if_onset_clear, boolean if_offset_clear, String the_text, int the_x, int the_y, String the_onset_clock_time, String the_duration, String the_color, int width, int height){

		//GlobalUtilities.popUpMessage("DeviceModuleFun__Visual_Display_Prepare_Text");

		//System.out.println("DeviceModuleFun__Visual_Display_Prepare_Text 1: " + the_text + " , length: " + the_text.Length);

		//prepare a text visicon 
		if(the_text.equals( "" )) {
			System.out.println("WARNING! DeviceModuleFun__Visual_Display_Prepare_Text has the_text == empty, this must mean to just schedule an onset or offset clear without adding any visicon");
		}
		else{
			if (the_text.charAt(0) != '\"') the_text = "\"" + the_text; //e.g., "tails", if no quote, add two quotation marks "\"tails\""
			if (the_text.charAt(the_text.length()-1) != '\"')  the_text = the_text + "\"";
		}

		the_text = sim.funs.ProgramUtilitiesFun__String_Parser_Escape_Sequence (the_text);

		//System.out.println("DeviceModuleFun__Visual_Display_Prepare_Text 2: " + the_text + " , length: " + the_text.Length);

		if(the_onset_clock_time.equals( "" )) the_onset_clock_time = (Double.toString(GlobalUtilities.round(SimSystem.clock(),3))); // by default
		else if (sim.funs.ProgramUtilitiesFun__Is_String_Double(the_onset_clock_time) == false)System.err.println("DeviceModuleFun__Visual_Display_Prepare_Text error. sim.funs.ProgramUtilitiesFun__Is_String_Double(the_onset_clock_time) == false ");
		else if ( GlobalUtilities.round( Double.parseDouble( the_onset_clock_time),3 ) < GlobalUtilities.round(SimSystem.clock(),3) ) System.err.println("Error! DeviceModuleFun__Visual_Display_Prepare_Text error. Double.valueOf( the_onset_clock_time) < Clock ");


		if(the_color.equals( "" )) the_color = "black"; // by default

		//some ACT-R default attributes that currently cannot be customized. 
		double distance = 0.0; //ToDo: need computation rule in ACT-R
		String kind = "text";
		String value = "text";
		//int width = 7; 
		//int height = 11;  use input value
		double size = 0.0; //ToDo: need computation rule in ACT-R

		//make the visual-location chunk first
		Chunk visual_location_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption (  new String[] {"isa", "visual-location", "screen-x", Integer.toString(the_x),  "screen-y", Integer.toString(the_y),  "distance", Double.toString(distance), "kind", kind,  "color", the_color,  "value", value,  "height", Integer.toString(height), "width", Integer.toString(width), "size", Double.toString(size) } );   // "screen-x", the_x,  "screen-y", the_y,  is a simple way but not the ACT-R way. ToDo: figure how ACT-R set the coordinates.
		ChunkFun__Add_Chunk_Slot_Name_And_Value(visual_location_chunk, ":attended" , "new" ); 

		//define the visual-location chunk
		visual_location_chunk = sim.funs.ChunkFun__Define_Chunk (visual_location_chunk);

		//prepare the visicon chunk
		String screen_pos = visual_location_chunk.Chunk_Name ;
		Chunk temp_chunk =  sim.funs.ChunkFun__Make_Chunk_From_Descritption( new String[] {"isa", "text", "value", the_text, "color", the_color, "screen-pos", screen_pos} ); //ToDo: more parameter settings may be added in the function later
		//check whether to clear visicon
		if (if_onset_clear) sim.funs.ChunkFun__Add_Chunk_Slot_Name_And_Value(temp_chunk, ":onset-clear" , "t" );
		if (if_offset_clear) sim.funs.ChunkFun__Add_Chunk_Slot_Name_And_Value(temp_chunk, ":offset-clear" , "t" );
		temp_chunk = sim.funs.ChunkFun__Define_Chunk(temp_chunk);

		String item_ID = "item-" + item_ID_num;
		if ( ! sim.vars.visualDisplay.Visicon_Names_Associated_With_A_Display_Item_ID.containsKey( item_ID ) ) {
			LinkedList<String> temp_list = new LinkedList<String> ();
			temp_list.addLast ( temp_chunk.Chunk_Name);
			sim.vars.visualDisplay.Visicon_Names_Associated_With_A_Display_Item_ID.put	( item_ID, temp_list );
		}
		else {
		  
		    ((LinkedList<String>)sim.vars.visualDisplay.Visicon_Names_Associated_With_A_Display_Item_ID.get(item_ID)).clear();
		    ((LinkedList<String>)sim.vars.visualDisplay.Visicon_Names_Associated_With_A_Display_Item_ID.get(item_ID)).addLast(temp_chunk.Chunk_Name);

		}

		//schedule the onset of the visicon
		Entity Temp_Entity = sim.funs.createEntity( "Visual Display" , "", "Visual Display", "Visual Display Onset", 0.0);
		//Entity Temp_Entity = new Entity();  
		//Temp_Entity.ID = "103"; //Visual Display
		//Temp_Entity.Time = (double) SimSystem.clock();
		// Temp_Entity.Tag = Entity_Number; //give it an entity number, init. 1
	 // Entity_Number++;
		//Temp_Entity.From = ""; //tag from and to
		//Temp_Entity.To = "Visual Display";
		//Temp_Entity.Entity_Type = "Visual Display Onset";  
		Temp_Entity.Chunk = sim.funs.ChunkFun__Chunk_Clone(temp_chunk);
		Temp_Entity.Scheduled_Task_Enter_Clock_Time = Double.parseDouble( the_onset_clock_time); 

		if(!the_duration.equals( "")){	
			if(sim.funs.ProgramUtilitiesFun__Is_String_Double(the_duration) == false)System.out.print("DeviceModuleFun__Visual_Display_Prepare_Text has Is_String_Number(the_duration) == false ");
			double duration =  Double.parseDouble(the_duration);
			if (duration <= 0) System.out.print ("DeviceModuleFun__Visual_Display_Prepare_Text has duration <= 0");

			//schedule the offset of the visicon
			Entity Temp_Entity_2 = sim.funs.createEntity( "Visual Display" , "", "Visual Display", "Visual Display Offset", 0.0);
			//Entity Temp_Entity_2 = new Entity();  
			//Temp_Entity_2.ID = "103"; //Visual Display
			//Temp_Entity_2.Time = (double) SimSystem.clock();
		// Temp_Entity_2.Tag = Entity_Number; //give it an entity number, init. 1
		// Entity_Number++;
			//Temp_Entity_2.From = ""; //tag from and to
			//Temp_Entity_2.To = "Visual Display";
			//Temp_Entity_2.Entity_Type = "Visual Display Offset";  
			Temp_Entity_2.Chunk = sim.funs.ChunkFun__Chunk_Clone(temp_chunk);
			Temp_Entity_2.Scheduled_Task_Enter_Clock_Time = (double) ((double) Double.parseDouble( the_onset_clock_time) + duration); 
		} 
		// duration.equals( "" ) means to keep displaying without stop, until another clear command being called explicitly
		//GlobalUtilities.popUpMessage("DeviceModuleFun__Visual_Display_Prepare_Text DONE the_onset_clock_time: " + the_onset_clock_time);

	}

	public  void DeviceModuleFun__Visual_Display_Prepare_Text_Button(int item_ID_num, boolean if_onset_clear, boolean if_offset_clear, String the_text, int the_x, int the_y, String the_onset_clock_time, String the_duration, String the_color, String the_button_color, int the_width, int the_height){
		
		//GlobalUtilities.popUpMessage("DeviceModuleFun__Visual_Display_Prepare_Text_Button");

		/* 
		if(the_text.equals( "" )) {
			//this is to add a blank button
			the_text = " " ;  // this way will still create a Text object on the screen
		}
		else{
			if (the_text[0] != '\"') the_text = "\"" + the_text; //e.g., "tails", if no quote, add two quotation marks "\"tails\""
			if (the_text[the_text.Length-1] != '\"')  the_text = the_text + "\"";
		}
		*/
		if (the_text.charAt(0) != '\"') the_text = "\"" + the_text; //e.g., "tails", if no quote, add two quotation marks "\"tails\""
		if (the_text.charAt(the_text.length()-1) != '\"')  the_text = the_text + "\"";

		//first, add an oval
		int width = the_width ;
		int height = the_height;

		DeviceModuleFun__Visual_Display_Prepare_Oval (item_ID_num, if_onset_clear, if_offset_clear, the_x, the_y, the_onset_clock_time, the_duration, the_button_color, width , height,  the_text) ;

		//second, add a text at the same place, but with another visual-location chunk. the_text is changed.
		//prepare a text visicon 

		if(!the_text.equals( "\"\"")) { //this way will not create a Text object.
			DeviceModuleFun__Visual_Display_Prepare_Text (item_ID_num, if_onset_clear, if_offset_clear, the_text, the_x, the_y, the_onset_clock_time, the_duration, the_color, width, height ); //text color
		}
	}

	public  void DeviceModuleFun__Visual_Display_Remove_Item_By_Visicon_Name(String the_visicon_name, double time_delay){

		if(the_visicon_name.equals( "" )) {
			System.out.println("WARNING! DeviceModuleFun__Visual_Display_Remove_Item_By_Visicon_Name has empty the_visicon_name");
			return;
		}

		if ( time_delay < 0) {
			System.err.println("Error! DeviceModuleFun__Visual_Display_Remove_Item_By_Visicon_Name has time_delay < 0: " + time_delay);
			return;

		}

		//schedule the offset of the visicon
		Entity Temp_Entity_2 = sim.funs.createEntity( "Visual Display" , "", "Visual Display", "Visual Display Offset", 0.0);
		//Entity Temp_Entity_2 = new Entity();  
		//Temp_Entity_2.ID = "103"; //Visual Display
		//Temp_Entity_2.Time = (double) SimSystem.clock();
		// Temp_Entity_2.Tag = Entity_Number; //give it an entity number, init. 1
		// Entity_Number++;
		//Temp_Entity_2.From = ""; //tag from and to
		//Temp_Entity_2.To = "Visual Display";
		//Temp_Entity_2.Entity_Type = "Visual Display Offset";  
		Temp_Entity_2.Chunk.Chunk_Name =  the_visicon_name; // tell visual display ending effect which visicon to offset
		Temp_Entity_2.Scheduled_Task_Enter_Clock_Time = SimSystem.clock() + time_delay; 
	}

	public  void DeviceModuleFun__Visual_World3D_Add_Object(String the_world3d_id){

		//schedule the onset of the visicon
	  Entity Temp_Entity = sim.funs.createEntity( "Visual Display" , the_world3d_id, "Visual Display", "Visual World3D Onset", 0.0);
		//Entity Temp_Entity = new Entity();  
		//Temp_Entity.ID = "103"; //Visual Display
		//Temp_Entity.Time = (double) SimSystem.clock();
// Temp_Entity.Tag = Entity_Number; //give it an entity number, init. 1
// Entity_Number++;
		//Temp_Entity.From = the_world3d_id; //use From to pass World3D ID
		//Temp_Entity.To = "Visual Display";
		//Temp_Entity.Entity_Type = "Visual World3D Onset";  
		Temp_Entity.Scheduled_Task_Enter_Clock_Time = SimSystem.clock(); 
	}

	public  void DeviceModuleFun__Visual_World3D_Remove_Object(String the_world3d_id){

		//schedule the offset of the visicon
	  Entity Temp_Entity_2 = sim.funs.createEntity( "Visual Display" , the_world3d_id, "Visual Display", "Visual World3D Offset", 0.0);
		//Entity Temp_Entity_2 = new Entity();  
		//Temp_Entity_2.ID = "103"; //Visual Display
		//Temp_Entity_2.Time = (double) SimSystem.clock();
/// Temp_Entity_2.Tag = Entity_Number; //give it an entity number, init. 1
/// Entity_Number++;
		//Temp_Entity_2.From = the_world3d_id; //use From to pass World3D ID
		//Temp_Entity_2.To = "Visual Display";
		//Temp_Entity_2.Entity_Type = "Visual World3D Offset";  
		Temp_Entity_2.Scheduled_Task_Enter_Clock_Time = SimSystem.clock() ; 
	}
	
//	FrameworkFun

	public  void FrameworkFun__Clear_Retrieval_Buffer_And_Reset_Declarative_Module_State(){

		sim.vars.retrievalBuffer.Empty = true;
		sim.vars.retrievalBuffer.Retrieval_Buffer_Chunk = new Chunk();

		sim.vars.declarativeModule.Declarative_Retrieved_Finst_Name_List.clear();
		sim.vars.declarativeModule.Declarative_Retrieved_Finst_Time_Hashtable.clear();
		sim.vars.declarativeModule.State_Error = false;
		sim.vars.declarativeModule.State_Free = true;


		//trash any entity in the retrieval buffer and the declarative module.
		String [] task_id_array = new String [] {"declarativemodule", "retrievalbuffer"}; //"6", "7"
		LinkedList<String> task_id_list = sim.funs.ProgramUtilitiesFun__StringArray_To_LinkedList_String (task_id_array);
		for (String temp_id: task_id_list) {
		  
		  for (Entity temp_entity: this.getLinkedListOfQnactrEntityInServerAndQueue(temp_id)){ 
		    temp_entity.Entity_Type = "trash";
		    temp_entity.Trash = true;
		  }
		  
		}
	}

	public  String FrameworkFun__New_Name_Simple_Stem_Plus_Number(String the_name){

		//input "a_name", output "a_nameNUMBER" where NUMBER is an int from 0.
		String new_name = "";

		if ( sim.vars.programGlobalVar__New_Name_Simple_Count.containsKey(the_name) == false ){ //not in the count hashtable
			new_name = the_name + "0";
			ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.programGlobalVar__New_Name_Simple_Count, the_name, 1);
		}
		else {
			int number = (int) sim.vars.programGlobalVar__New_Name_Simple_Count.get( the_name );
			new_name = the_name + Integer.toString(number);
			ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.programGlobalVar__New_Name_Simple_Count, the_name, number++ );
		}

		if (ChunkFun__Is_Chunk_Name(new_name)){ //rename the new_name if it is already used by some chunk in the model.
			int i = (int) sim.vars.programGlobalVar__New_Name_Simple_Count .get( the_name );
			String new_chunk_name = the_name + Integer.toString(i);
			while(ChunkFun__Is_Chunk_Name(new_chunk_name)){
				i++;
				new_chunk_name = the_name + Integer.toString(i);
			}
			new_name = new_chunk_name;
			ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.programGlobalVar__New_Name_Simple_Count, the_name, i++ );
		}


		return new_name;
	}
		
	public  void FrameworkFun__ReInitialize_Declarative_Module(){
	  
	  // Model.Find
	 
	  
	  //first, clear and reset declarative module and buffer, 
	  //simulation chunks and chunk types unchanged
	  //clear and reset declarative module
	  sim.vars.declarativeModule.Declarative_Retrieved_Finst_Name_List = new LinkedList<String>();
	  sim.vars.declarativeModule.Declarative_Retrieved_Finst_Time_Hashtable = new  Hashtable();
	  sim.vars.declarativeModule.DM_Chunk =  new LinkedList<Chunk>();
	  sim.vars.declarativeModule.DM_Chunk_Similarity_Table =  new Hashtable();
	  sim.vars.declarativeModule.Number_of_Chunks = 0;
	  sim.vars.declarativeModule.State_Error = false;
	  sim.vars.declarativeModule.State_Free = true;
	  
	  //clear and reset retrieval buffer
	  sim.vars.retrievalBuffer.Empty = true;
	  sim.vars.retrievalBuffer.Retrieval_Buffer_Chunk = new Chunk();
	  
	  
	  //trash any entity in the retrieval buffer and the declarative module.
	  String [] task_id_array = new String [] {"declarativemodule", "retrievalbuffer"}; //"6", "7"
	  LinkedList<String> task_id_list = sim.funs.ProgramUtilitiesFun__StringArray_To_LinkedList_String (task_id_array);
	  for (String temp_id: task_id_list) {
 
			for (Entity temp_entity: this.getLinkedListOfQnactrEntityInServerAndQueue(temp_id)){ 
				temp_entity.Entity_Type = "trash";
				temp_entity.Trash = true;
			}
	     
	    
	  }
	  
	  //second, reload model specification
	  //add DM chunks

		for ( LinkedList<String> an_add_dm_input_entry: sim.vars.programGlobalVar__DeclarativeModule_Add_DM_Input_List){
			Chunk temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(an_add_dm_input_entry));
			DeclarativeModuleFun__Add_DM_Chunk_With_Chunk(temp_chunk);
		}

	  
	  
	  //sdp
	  for ( LinkedList<String> a_list:  sim.vars.programGlobalVar__DeclarativeModule_Sdp_Input){
	    sim.funs.ParametersFun__Declarative_Module_Sdp ( sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(a_list)  );
	  }
	  
	  
	  //set all base levels //should be called only once, so do not use LinkedList of parameters.
	  if( sim.vars.programGlobalVar__DeclarativeModule_Set_All_Base_Levels_Input.size() > 0 ) {
	    sim.funs.DeclarativeModuleFun__Set_All_Base_Levels ( sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(sim.vars.programGlobalVar__DeclarativeModule_Set_All_Base_Levels_Input)  );
	  }
	  
	  //set base levels
	  for (Three_Tuple a_tuple : sim.vars.programGlobalVar__DeclarativeModule_Set_Base_Levels_Input){
	    sim.funs.DeclarativeModuleFun__Set_Base_Levels( (String) a_tuple.Ob1 , (double)a_tuple.Ob2, (String) a_tuple.Ob3);
	  }
	  
	  
	  //set similarities
	  for (Three_Tuple a_tuple: sim.vars.programGlobalVar__DeclarativeModule_Set_Similarities_Input){
	    sim.funs.DeclarativeModuleFun__Set_Similarities( (String) a_tuple.Ob1 , (String) a_tuple.Ob2, (double) a_tuple.Ob3  );
	  }
	  
	  
	  
	  //may be more functions added here
	  
	}
	
	public  void FrameworkFun__ReInitialize_Goal_1(){
	  sim.vars.goalBuffer.Goal_Buffer_Chunk = new Chunk();
	  FrameworkFun__ReInitialize_Goal_1_Focus();
	}
	
	public  void FrameworkFun__ReInitialize_Goal_1_Focus(){
	  
	  String chunk_name_1 = sim.vars.programGlobalVar__IntentionalModule_Initial_Goal_Focus_Chunk_Name ;
	  if(!chunk_name_1.equals( "" )){
	    Chunk temp_chunk_1 = sim.funs.DeclarativeModuleFun__Find_DM_Chunk_By_Chunk_Name(chunk_name_1);
	    if (!temp_chunk_1.Chunk_Name.equals(chunk_name_1)) System.out.println("FrameworkFun__ReInitialize_Goal_Focus' chunk name_1 is not in Declarative Memory : chunk_name_1" + chunk_name_1);
	    ProductionModuleFun__Goal_Focus(temp_chunk_1);
	  }
	}
	
	public  void FrameworkFun__ReInitialize_Goal_Focus(){
	  
	 
	  String chunk_name_1 = sim.vars.programGlobalVar__IntentionalModule_Initial_Goal_Focus_Chunk_Name ;
	  if(!chunk_name_1.equals( "" )){
	    Chunk temp_chunk_1 = sim.funs.DeclarativeModuleFun__Find_DM_Chunk_By_Chunk_Name(chunk_name_1);
	    if ( !temp_chunk_1.Chunk_Name.equals(chunk_name_1)) System.out.println("FrameworkFun__ReInitialize_Goal_Focus' chunk name_1 is not in Declarative Memory : chunk_name_1" + chunk_name_1);
	    ProductionModuleFun__Goal_Focus(temp_chunk_1);
	  }
	  
	  String chunk_name_2 = sim.vars.programGlobalVar__IntentionalModule_Initial_Goal_2_Focus_Chunk_Name ;
	  if(!chunk_name_2.equals( "" )){
	    Chunk temp_chunk_2 = sim.funs.DeclarativeModuleFun__Find_DM_Chunk_By_Chunk_Name(chunk_name_2);
	    if (!temp_chunk_2.Chunk_Name.equals(chunk_name_2)) System.out.println("FrameworkFun__ReInitialize_Goal_Focus' chunk name_2 is not in Declarative Memory : chunk_nam_2" + chunk_name_2);
	    ProductionModuleFun__Goal_2_Focus(temp_chunk_2);
	  }
	  
	  //ToDO maybe more goal buffers
	}
	
	public  void FrameworkFun__ReInitialize_Intentional_Module(){
	  //sim.vars.intentionalModule.Obsolete_Active_Goal_Chunk_Name_For_Goal_Adaptation = "";
	  sim.vars.goalBuffer.Goal_Buffer_Chunk = new Chunk();
	  sim.vars.goalBuffer.Goal_Buffer_Chunk_2 = new Chunk();
	  FrameworkFun__ReInitialize_Goal_Focus();  //will do both goal> and goal-2>
	}
	
	public  void FrameworkFun__ReInitialize_Production_Modules(){
	  
	  ////////////////////////////////////////////////////////////////////////////
	  //production rules, clear,
	  sim.vars.productionModule.Goal_Thread_Order_List_For_Threaded_Cognition = new LinkedList<String>();
	  sim.vars.productionModule.PG_C_Since_Last_Flag_Selected_Rule_Name = new LinkedList<String>();
	  sim.vars.productionModule.PG_C_Since_Last_Flag_Selected_Rule_Time = new LinkedList<Double>();
	  sim.vars.productionModule.Production_Rules = new LinkedList<Production_Rule>();
	  sim.vars.productionModule.Rule_Number = 0;
	  sim.vars.productionModule.Rule_Process_Goal_Buffer_Table = new Hashtable();
	  sim.vars.productionModule.Since_Last_Reward_Selected_Rule_Name = new LinkedList<String>();
	  sim.vars.productionModule.Since_Last_Reward_Selected_Rule_Time = new LinkedList<Double>();
	  //GlobalUtilities.popUpMessage("FrameworkFun__ReInitialize_Production_Modules");
	  //production rules, re-initialize
	  for ( LinkedList<String> a_list:  sim.vars.programGlobalVar__ProductionModule_P_Rules_Definition_Input){
	    ProductionModuleFun__Add_Production_Rule ( sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(a_list) );
	  }
	  
	  
	  
	  
	  ////////////////////////////////////////////////////////////////////////////
	  //production compilation, clear,
	  sim.vars.productionCompilationModule.Last_Fired_Rule_Name = "";
	  sim.vars.productionCompilationModule.Last_Rule_Fired_Time = 0.0;
	  sim.vars.productionCompilationModule.Number_Of_New_Rules = 0;
	  
	  //production compilation, re-initialize
	  //currently nothing here
	  
	  
	  ////////////////////////////////////////////////////////////////////////////
	  //production utility, clear,
	  if( sim.vars.utilityModule.utility_Computation_Method.equals( "PG-C")){
	    sim.vars.utilityModule.pg_c =  new Hashtable();
	    sim.vars.utilityModule.PG_C_c =  new Hashtable();
	    sim.vars.utilityModule.PG_C_effort_rule_firing_time = new Hashtable();
	    sim.vars.utilityModule.PG_C_efforts_for_cost_calculation = new Hashtable();
	    sim.vars.utilityModule.PG_C_failure_flags = new Hashtable();
	    sim.vars.utilityModule.PG_C_failures_num_for_each_rule = new Hashtable();
	    sim.vars.utilityModule.PG_C_p  = new Hashtable();
	    sim.vars.utilityModule.PG_C_prior_c = new Hashtable();
	    sim.vars.utilityModule.PG_C_prior_p = new Hashtable();
	    sim.vars.utilityModule.PG_C_success_flags  = new Hashtable();
	    sim.vars.utilityModule.PG_C_successes_num_for_each_rule  = new Hashtable();
	    sim.vars.utilityModule.PG_C_value  = new Hashtable();
	  }
	  else if( sim.vars.utilityModule.utility_Computation_Method.equals( "temporal-difference-reinforcement")){
	    //since every rule has its name as a key in .reward, do not use these: //sim.vars.utilityModule.reward  = new Hashtable();	//sim.vars.utilityModule.reward.Clear();
	    LinkedList<String> key_list = sim.funs.ProgramUtilitiesFun__Hashtable_To_LinkedListString( sim.vars.utilityModule.reward ,"key" );
	    for(String a_key: key_list){
	      sim.funs.ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.reward, a_key, "" );
	    }
	  }
	  
	  //the below two lines should be removed, because the above has reintialized U_N_Without_Noise and utility for each production rule. in C# it seems that by default, it can get 0 out of Hashtable <String, Integer> if no such key is used as input key. 
//	  sim.vars.utilityModule.U_N_Without_Noise  = new Hashtable();
//	  sim.vars.utilityModule.utility = new Hashtable();
	  
	  
	  
	  
	  //production utility, re-initialize
	  for( LinkedList<String> a_list:  sim.vars.programGlobalVar__ProductionModule_Spp_Input){
	    ParametersFun__UtilityModule_Spp ( sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(a_list)  );
	  }
	}
	
	public  void FrameworkFun__Reset_All_Modules(){
	  FrameworkFun__Reset_PM_Module("vision");
	  FrameworkFun__Reset_PM_Module("audio");
	  FrameworkFun__Reset_PM_Module("motor");
	  FrameworkFun__Reset_PM_Module("speech");
	  
	  FrameworkFun__ReInitialize_Declarative_Module(); // declarative, chunks, buffer
	  FrameworkFun__ReInitialize_Production_Modules( ); // prodution, rules, remove compiled rules, reset utilities. That is, production module, production compilation module, and utility module
	  FrameworkFun__ReInitialize_Intentional_Module(); //goal buffers, goal-focus
	  
	  FrameworkFun__Reset_Imaginary_Module( );
	  
	  DeviceModuleFun__Clear_Visual_Display();
	  DeviceModuleFun__Clear_Audio_Display();
	  //may add more modules
	}
	
	public  void FrameworkFun__Reset_Imaginary_Module(){
	  sim.vars.imaginaryModule.State_Error = false;
	  sim.vars.imaginaryModule.State_Free = true;
	  
	  sim.vars.imaginalBuffer.Empty = true;
	  sim.vars.imaginalBuffer.Imaginal_Buffer_Chunk = new Chunk();
	}
	
	public  void FrameworkFun__Reset_PM_Module(String the_module_name){
	
	  switch (the_module_name.toLowerCase()) {
	    case "audio":{
	      //audio module
	      sim.vars.audioModule.Buffer_Stuffing_Just_Selected_Attended_Nil_Aural_Location_Names.clear();
	      sim.vars.audioModule.Audicon_Decay_Time_Tracking_Table.clear();
	      sim.vars.audioModule.State_Error = false;
	      sim.vars.audioModule.State_Free = true;
	      sim.vars.audioModule.State_Preparation_Free = true;
	      
	      //aural buffer
	      sim.vars.auralBuffer.Aural_Buffer_Chunk = new Chunk();
	      
	      //aural location buffer
	      sim.vars.auralLocationBuffer.Aural_Location_Buffer_Chunk = new Chunk();
	      sim.vars.auralLocationBuffer.Empty	= true;
	      
	      DeviceModuleFun__Clear_Audio_Display();
	      //currently just so much to reset, check Audio_Module Audio_Buffer object definition
	      break;
	    }
	    case "speech": {
	      sim.vars.speechModule.Execution_Free = true;
	      sim.vars.speechModule.Last_Command = new Chunk();
	      sim.vars.speechModule.Preparation_Free = true;
	      sim.vars.speechModule.Processor_Free = true;
	      sim.vars.speechModule.State_Free = true;
	      
	      sim.vars.vocalBuffer.Vocal_Buffer_Chunk = new Chunk();
	      
	      break;
	    }
	    case "motor": {
	      sim.vars.motorModule.Execution_Free = true;
	      sim.vars.motorModule.Last_Command = new Chunk();
	      sim.vars.motorModule.Preparation_Free = true;
	      sim.vars.motorModule.Processor_Free = true;
	      sim.vars.motorModule.State_Free = true;
	      
	      sim.vars.manualBuffer.Manual_Buffer_Chunk = new Chunk();
	      
	      sim.vars.deviceModule.Mouse_Cursor_Screen_X = sim.vars.deviceModule.Mouse_Cursor_Initial_Screen_X;
	      sim.vars.deviceModule.Mouse_Cursor_Screen_Y = sim.vars.deviceModule.Mouse_Cursor_Initial_Screen_Y;
	      
	      
	      // ToDo add set hand location if sgp can do that.
	      if( sim.vars.programGlobalVar__MotorModule_Start_Hand_At_Mouse ) {
	        MotorModuleFun__Start_Hand_At_Mouse();
	      }
	      else if(sim.vars.programGlobalVar__MotorModule_Start_Right_Hand_At_Touch_Screen || sim.vars.programGlobalVar__MotorModule_Start_Left_Hand_At_Touch_Screen) {
	    	  System.out.println("TODO sim.vars.programGlobalVar__MotorModule_Start_Right_Hand_At_Touch_Screen t in FrameworkFun__Reset_PM_Module");
	      }
	      else { //by default, start hands at keyboard home position
	        MotorModuleFun__Home_Hands();
	      }
	      break;
	    }
	    
	    case "vision":{
	      //module
	      sim.vars.visionModule.Buffer_Stuffing_Just_Selected_Attended_Nil_Visual_Location_Names.clear();
	      VisionModuleFun__Clear_Last_Attended_Info();
	      sim.vars.visionModule.State_Error = false;
	      sim.vars.visionModule.State_Free = true;
	      sim.vars.visionModule.State_Preparation_Free = true;
	      sim.vars.visionModule.Visual_Finst_ID_Track.clear();
	      
	      //visual buffer
	      sim.vars.visualBuffer.Visual_Buffer_Chunk = new Chunk();
	      
	      //visual location buffer
	      sim.vars.visualLocationBuffer.Empty = true;
	      sim.vars.visualLocationBuffer.Requested = false;
	      sim.vars.visualLocationBuffer.State_Error = false;
	      sim.vars.visualLocationBuffer.State_Free = true;
	      sim.vars.visualLocationBuffer.Unrequested = false;
	      sim.vars.visualLocationBuffer.Visual_Location_Buffer_Chunk = new Chunk();
	      
	      //currently just so much to reset, check Vision_Module, visual buffer, and visual location object definitions
	      break;
	    }
	    
	    case "": {
	      System.out.println("FrameworkFun_Reset_PM_Module has empty module name");
	      break;
	    }
	    default:{
	      System.out.println("FrameworkFun_Reset_PM_Module has undefined module name: " + the_module_name);
	      break;
	    }
	  }
	}	
	
	//LispFun
	
	public  String LispFun__Evaluate_A_List (String input_string){
	  
	  // 	Animator3D 
	  //Simulation 
	  //Do_Accelerate
	  
	  String[] input_array = sim.funs.ProgramUtilitiesFun__String_To_StringArray( input_string );   // e.g., ( = ( + 1 2 ) ( - 2 3 ) ) , variables like =num should have been substituted
	  if (input_array.length == 0 ) {
	    System.err.println ( "Error! LispFun__Evaluate_A_List has an empty input: __" + input_string + "__" );
	    return null;
	  }
	  
	  //substitue t with true and nil with false. change boolean keyword to C#
	  for( int i = 0 ; i < input_array.length ; i ++ ) {
	    if( input_array[i].toLowerCase().equals( "t" )) input_array[i] = "true";
	    else if ( input_array[i].toLowerCase().equals( "nil") ) input_array[i] = "false";
	  }
	  
	  //if goes here, means that .length() > 0
	  String return_string;
	  if ( !input_array[0].equals( "(" )){ //first String is not a "("
	    if ( input_array.length > 1){ //error
	      System.err.println( "Error! LispFun__Evaluate_A_List has an invalid input: " + input_string ) ;
	      return null;
	    }
	    else{ // input_array.length() == 1
	      return_string = input_array[0];
	    }
	  }
	  else { // the first String is a "("
	    if ( input_array.length == 2 ||  !input_array[ input_array.length - 1 ].equals( ")") ) { //error
	      System.err.println( "Error! LispFun__Evaluate_A_List has an invalid input: " + input_string ) ;
	      return null;
	    }
	    else{ // has a valid input with function (format standard), like ( + 1 ( + 1 1 ) ) or ( = 1 2 )
	      LinkedList<String> content_list = sim.funs.ProgramUtilitiesFun__StringArray_To_LinkedList_String (input_array);
	      content_list.removeFirst(); //remove (
	      String function_name = content_list.getFirst();  //get function name like +
	      content_list.removeFirst(); //remove function name like +
	      content_list.removeLast();  //remove )
	      //have the content (function parameters) like    1 ( + 1 1 )
	      switch ( function_name ){
	        //the following functions apply to 0 and only 0 parameters
	        
	        case "get-clock-time":
	        {
	          if ( content_list.size() != 0 ) {
	            System.err.println("Error! LispFun__Evaluate_A_List " + function_name + "  function must have 0 parameter, not: " + input_string );
	            return null;
	          }
	          
	          double time = SimSystem.clock();
	          String timeStr = Double.toString(time);
	          return timeStr;

	        }			
	        
	        case "unity-tangtang-get-enemy-distance":
	        {
	          if ( content_list.size() != 0 ) {
	            System.err.println("Error! LispFun__Evaluate_A_List " + function_name + "  function must have 0 parameter, not: " + input_string );
	            return null;
	          }
	          
	          if( sim.vars.world3DTemplate.Method_Object == null || !(sim.vars.world3DTemplate.Method_Object instanceof UnityJavaUdp)) {
		            System.err.println ("Error! LispFun__Evaluate_A_List. unity-tangtang-get-enemy-distance sim.vars.world3DTemplate.Method_Object == null || !(sim.vars.world3DTemplate.Method_Object is UnityJavaUdp)");
		            return null;
		      }
	          
	          double dist =  (double) ((UnityJavaUdp)sim.vars.world3DTemplate.Method_Object).sdreceive.b1;
	        		  
	          String distStr = Double.toString(dist);
	          return distStr;
	        }		
	        
	        case "world3d-driving-get-velocity":
	        {
	          if ( content_list.size() != 0 ) {
	            System.err.println("Error! LispFun__Evaluate_A_List " + function_name + "  function must have 0 parameter, not: " + input_string );
	            return null;
	          }
	          if( sim.vars.world3DTemplate.Method_Object == null || !(sim.vars.world3DTemplate.Method_Object instanceof World3D_Template_Driving_Method)) {
	            System.err.println ("Error! LispFun__Evaluate_A_List. driving-get-velocity sim.vars.world3DTemplate.Method_Object == null || !(sim.vars.world3DTemplate.Method_Object is World3D_Template_Driving_Method)");
//
	            return "";
	          }
	          
	          if (sim.vars.programGlobalVar__Use_Predefined_Model_Setup.equals( "model_drive_opends" )){
        		  World3D_Template_Driving_Method the_method = null;
	              if(sim.vars.world3DTemplate.Method_Object != null && sim.vars.world3DTemplate.Method_Object instanceof World3D_Template_Driving_Method) the_method = sim.funs.TaskTemplateFun__Get_World3D_Driving_Method_Object();      
	              return Double.toString( the_method.getOpenDSPercept().speed );
	          }
	          else if (sim.vars.programGlobalVar__Use_Predefined_Model_Setup.equals( "model_drive_torcs" )){
        		  World3D_Template_Driving_Method the_method = null;
	              if(sim.vars.world3DTemplate.Method_Object != null && sim.vars.world3DTemplate.Method_Object instanceof World3D_Template_Driving_Method) the_method = sim.funs.TaskTemplateFun__Get_World3D_Driving_Method_Object();      
	              return Double.toString( the_method.getTorcsPercept().speed );
	          }
	          else {
		          World3D_DriverCar the_driver_car = ((World3D_DriverCar)sim.vars.world3DTemplate.World.Objects.get(  ((World3D_Template_Driving_Method)sim.vars.world3DTemplate.Method_Object).DriverCar_World3D_ID  ));
		          return Double.toString(the_driver_car.Vehicle_Basic.Speed);
	          }
	        }
	        
	        case "world3d-driving-choosing-viewarea":
	        {
		          if ( content_list.size() != 0 ) {
			            System.err.println("Error! LispFun__Evaluate_A_List " + function_name + "  function must have 0 parameter, not: " + input_string );
			            return null;
			          }
			          if( sim.vars.world3DTemplate.Method_Object == null || !(sim.vars.world3DTemplate.Method_Object instanceof World3D_Template_Driving_Method)) {
			            System.err.println ("Error! LispFun__Evaluate_A_List. driving-get-velocity sim.vars.world3DTemplate.Method_Object == null || !(sim.vars.world3DTemplate.Method_Object is World3D_Template_Driving_Method)");
		//
			            return "";
			          }
			          
			          if (sim.vars.programGlobalVar__Use_Predefined_Model_Setup.equals( "model_drive_opends" )){
		        		  World3D_Template_Driving_Method the_method = null;
			              if(sim.vars.world3DTemplate.Method_Object != null && sim.vars.world3DTemplate.Method_Object instanceof World3D_Template_Driving_Method) the_method = sim.funs.TaskTemplateFun__Get_World3D_Driving_Method_Object();      
			              return the_method.chooseViewArea();
			          }
			          else {
				          return null;
			          }
	        }
	        
	        case "start-qn-answer":{
	        	World3D_Template_Driving_Method the_method = null;
	        	if(sim.vars.world3DTemplate.Method_Object != null && sim.vars.world3DTemplate.Method_Object instanceof World3D_Template_Driving_Method) the_method = sim.funs.TaskTemplateFun__Get_World3D_Driving_Method_Object();      
            
	        	if(the_method.qn_answer_switch) {
	        		sim.vars.qn_answer = true;
	        		the_method.qn_answer_switch = false;
	        		return "true";
	        	}
	        	else {
	        		sim.vars.qn_answer = false;
		        	return "false";
	        	}
	        }
	        
	        case "decide-report":{
	        	World3D_Template_Driving_Method the_method = null;
	        	if(sim.vars.world3DTemplate.Method_Object != null && sim.vars.world3DTemplate.Method_Object instanceof World3D_Template_Driving_Method) the_method = sim.funs.TaskTemplateFun__Get_World3D_Driving_Method_Object();      
            
	        	if(sim.vars.qn_answer) {
	        		return "\"recalling-sign\"";
	        	}
	        	else {
		        	return "\"attending-near\"";
	        	}
	        }
	        
//	        case "stop-qn-answer":{
//	        	sim.vars.qn_answer = false;
//	        }
	        
	        //the following functions apply to 1 and only 1 number
	        case "abs":
	        case "not":	
	        case "tracking-control-get-percept":
	        case "get-string-length":
	        case "get-string-length-no-tail-space":
	        case "add-quotation-marks":
	        case "remove-quotation-marks":
	        case "unity-tangtang-update-status":
	        case "world3d-driving-report-criticalelement-sign":
	        case "world3d-driving-report-criticalelement-vehicle":
	        case "world3d-driving-recall-criticalelement-sign":
	        case "world3d-driving-recall-criticalelement-vehicle":
	        case "world3d-driving-recall-speed":
	        case "world3d-driving-report-speed":
	        { //accept only 1 parameter.
	          if ( content_list.size() < 1 ) { //nothing there, error
	            System.err.println("Error! LispFun__Evaluate_A_List " + function_name + "  function must have 1 parameter, not: " + input_string );
	            return null;
	          }
	          String para_1;
	          if( !content_list.getFirst().equals( "(" ) ) { //para_1 is not a list,  
	            para_1 = content_list.getFirst();
	            content_list.removeFirst(); //remove para_1
	          }
	          else { //para_1 is a list, e.g., content_list = ( + 1 2 )   
	            LinkedList<String> next_level_eval_content_list = sim.funs.ParametersFun__Remove_A_List_From_Initialization_Lists  ( content_list ); //e.g., after this, next_level_eval_content_list =  + 1 2 , content_list = ( + 2 3 )
	            next_level_eval_content_list.addFirst ( "(" );
	            next_level_eval_content_list.addLast  ( ")" );
	            para_1 = LispFun__Evaluate_A_List (  sim.funs.ProgramUtilitiesFun__LinkedListString_To_String ( next_level_eval_content_list )  );
	          }
	          
	          //now there must be nothing left in content_list
	          if ( content_list.size() != 0 ) {
	            System.err.println("Error! LispFun__Evaluate_A_List " + function_name + "  function must have 1 parameter, not: " + input_string );
	            return null;
	          }
	          
	          
	          
	          switch ( function_name ){
	            case "abs": {
	              //para 1 must be a number
	              if( sim.funs.ProgramUtilitiesFun__Is_String_Double ( para_1 ) == false ) {
	                System.err.println("Error! LispFun__Evaluate_A_List " + function_name + "  para_1 must be a number, not: " + para_1 );
	                return null;
	              }
	              
	              return_string = Double.toString((  Math.abs ( Double.parseDouble (para_1) ) ));
	              break;
	            }
	            
	            case "not": {
	              //System.out.println("_"+ para_1.ToLower() + "_");
	              if( para_1.toLowerCase().equals( "t" )) para_1 = "true";
	              else if ( para_1.toLowerCase().equals( "nil") ) para_1 = "false";
	              
	              if( para_1.toLowerCase().equals( "false" )) return_string = "true";
	              else return_string = "false";
	              
	              break;
	            }
	            
	            case "tracking-control-get-percept": {
	              return_string = TaskTemplateFun__World3D_Tracking_Control_Get_Percept( para_1 );
	              
	              break;
	            }
	            case "get-string-length":
	            {
	            	return_string = Integer.toString(para_1.length());
	            	break;
	            }
	            case "get-string-length-no-tail-space":
	            {
	            	//if the last char of the string is " ", return length() - 1, otherwise, return length.	            	
	            	String lastChar = para_1.substring(para_1.length()-1);
	            	if(lastChar.equals(" ")) 
	            		 return_string = Integer.toString(para_1.length() - 1);
	            	else return_string = Integer.toString(para_1.length());
	            	break;
	            }
	            case "add-quotation-marks":
	            {
	            //	if (para_1.equals("t")||para_1.equals("nil"))return_string = para_1;
	            //	else return_string = "\"" + para_1 + "\"";
	            	
	            	return_string = "\"" + para_1 + "\"";
	            	
	            	break;
	            }
	            case "remove-quotation-marks":
	            {
	            	if(para_1.substring(0, 1).equals("\"") ) para_1 = para_1.substring(1);
	            	if(para_1.substring(para_1.length()-1).equals("\"")) para_1 = para_1.substring(0, para_1.length() - 1);
	            	return_string = para_1;
	            	break;
	            }
	            case "unity-tangtang-update-status":
	            {
	            	//para 1 must be an int number (1,2,3)
		              if( sim.funs.ProgramUtilitiesFun__Is_String_Int ( para_1 ) == false ) {
		                System.err.println("Error! LispFun__Evaluate_A_List " + function_name + "  para_1 must be an int number, not: " + para_1 );
		                return null;
		              }
		              
		              if( sim.vars.world3DTemplate.Method_Object == null || !(sim.vars.world3DTemplate.Method_Object instanceof UnityJavaUdp)) {
				            System.err.println ("Error! LispFun__Evaluate_A_List. unity-tangtang-get-enemy-distance sim.vars.world3DTemplate.Method_Object == null || !(sim.vars.world3DTemplate.Method_Object is UnityJavaUdp)");
				            return null;
				      }
			          
			          ((UnityJavaUdp)sim.vars.world3DTemplate.Method_Object).sdsend.a1 = Integer.parseInt(para_1);
			          
		              return null;
		              //break;
	            }

	            case "world3d-driving-report-speed":
	            {
	            	System.out.println("The model is looking at the speed:" + para_1);
		              return null;
	            }
	            case "world3d-driving-report-criticalelement-sign":
	            {
	            	System.out.println("The model is looking at a sign with content:" + para_1);
		              return null;
	            }
	            case "world3d-driving-report-criticalelement-vehicle":
	            {
	            	System.out.println("The model is looking at a vehicle with color:" + para_1);
		              return null;
	            }
	            case "world3d-driving-recall-criticalelement-sign":
	            {
	            	if(para_1.toLowerCase().equals("false")) System.out.println("The model couldn't recall a sign");
	            	else System.out.println("The model recalls a sign with content:" + para_1);
		              return null;
	            }
	            case "world3d-driving-recall-criticalelement-vehicle":
	            {
	            	if(para_1.toLowerCase().equals("false")) System.out.println("The model couldn't recall a vehicle");
	            	else System.out.println("The model recalls a vehicle with color:" + para_1);
		              return null;
	            }
	            case "world3d-driving-recall-speed":
	            {
	            	if(para_1.toLowerCase().equals("false")) System.out.println("The model couldn't recall the speed");
	            	else System.out.println("The model recalls the current speed as:" + para_1);
		              return null;
	            }
	            
	            default:{
	              System.err.println("Error! LispFun__Evaluate_A_List has undefined function name inside the 1 parameter number function group: " + function_name);
	              return null;
	              //break;
	            }
	          }
	          break;
	        }
	        
	        //the following functions apply to 2 and only 2 numbers
	        case "+": 
	        case "-": 
	        case "*": 
	        case "/": 
	        case "=":
	        case "/=":  //not equal
	        case ">":
	        case "<":
	        case ">=":
	        case "<=":
	        case "combine-two-strings-with-quotation-marks":
	        case "tracking-control-get-manual-joystick-value":
	        case "tracking-control-get-manual-joystick-duration":
	        case "get-char-from-string":
	        case "get-tail-from-string":	
	        
	        { //although Lisp accepts more than 2 parameters, here the number of parameters must be 2.
	          if ( content_list.size() < 2 ) {
	            System.err.println("Error! LispFun__Evaluate_A_List " + function_name + "  function must have 2 parameters, not: " + input_string );
	            return null;
	          }
	          String para_1;
	          if( !content_list.getFirst().equals( "(" ) ) { //para_1 is not a list,  
	            para_1 = content_list.getFirst();
	            content_list.removeFirst(); //remove para_1
	          }
	          else { //para_1 is a list, e.g., content_list = ( + 1 2 )    ( + 2 3 )
	            LinkedList<String> next_level_eval_content_list = sim.funs.ParametersFun__Remove_A_List_From_Initialization_Lists  ( content_list ); //e.g., after this, next_level_eval_content_list =  + 1 2 , content_list = ( + 2 3 )
	            next_level_eval_content_list.addFirst ( "(" );
	            next_level_eval_content_list.addLast  ( ")" );
	            para_1 = LispFun__Evaluate_A_List (  sim.funs.ProgramUtilitiesFun__LinkedListString_To_String ( next_level_eval_content_list )  );
	          }
	          
	          //now content_list contains String only for para_2 if there is any String
	          if ( content_list.size() == 0 ) {
	            System.err.println("Error! LispFun__Evaluate_A_List " + function_name + "  function must have 2 parameters, not: " + input_string );
	            return null;
	          }
	          String para_2;
	          if( !content_list.getFirst().equals( "(" )) { //para_2 is not a list,  
	            para_2 = content_list.getFirst();
	            content_list.removeFirst(); //remove para_2
	          }
	          else { //para_2 is a list, e.g., content_list =  ( + 2 3 )
	            LinkedList<String> next_level_eval_content_list = sim.funs.ParametersFun__Remove_A_List_From_Initialization_Lists  ( content_list ); //e.g., after this, next_level_eval_content_list =  + 2 3 , content_list = empty
	            next_level_eval_content_list.addFirst ( "(" );
	            next_level_eval_content_list.addLast  ( ")" );
	            para_2 = LispFun__Evaluate_A_List (  sim.funs.ProgramUtilitiesFun__LinkedListString_To_String ( next_level_eval_content_list )  );
	          }
	          
	          //now there must be nothing left in content_list
	          if ( content_list.size() != 0 ) {
	            System.err.println("Error! LispFun__Evaluate_A_List " + function_name + "  function must have 2 parameters, not: " + input_string );
	            return null;
	          }
	          
	          
	          
	          switch ( function_name ){
	            case "+": {
	              //para 1 and 2 must be numbers
	              if( sim.funs.ProgramUtilitiesFun__Is_String_Double ( para_1 ) == false ) {
	                System.err.println("Error! LispFun__Evaluate_A_List " + function_name + "  para_1 must be a number, not: " + para_1 );
	                return null;
	              }
	              if( sim.funs.ProgramUtilitiesFun__Is_String_Double ( para_2 ) == false ) {
	                System.err.println("Error! LispFun__Evaluate_A_List " + function_name + "  para_2 must be a number, not: " + para_2 );
	                return null;
	              }
	              return_string = Double.toString( Double.parseDouble (para_1) + Double.parseDouble (para_2) );
	              break;
	            }
	            case "-": {
	              //para 1 and 2 must be numbers
	              if( sim.funs.ProgramUtilitiesFun__Is_String_Double ( para_1 ) == false ) {
	                System.err.println("Error! LispFun__Evaluate_A_List " + function_name + "  para_1 must be a number, not: " + para_1 );
	                return null;
	              }
	              if( sim.funs.ProgramUtilitiesFun__Is_String_Double ( para_2 ) == false ) {
	                System.err.println("Error! LispFun__Evaluate_A_List " + function_name + "  para_2 must be a number, not: " + para_2 );
	                return null;
	              }
	              return_string = Double.toString(Double.parseDouble (para_1) - Double.parseDouble (para_2) );
	              break;
	            }
	            case "*": {
	              //para 1 and 2 must be numbers
	              if( sim.funs.ProgramUtilitiesFun__Is_String_Double ( para_1 ) == false ) {
	                System.err.println("Error! LispFun__Evaluate_A_List " + function_name + "  para_1 must be a number, not: " + para_1 );
	                return null;
	              }
	              if( sim.funs.ProgramUtilitiesFun__Is_String_Double ( para_2 ) == false ) {
	                System.err.println("Error! LispFun__Evaluate_A_List " + function_name + "  para_2 must be a number, not: " + para_2 );
	                return null;
	              }
	              return_string = Double.toString( Double.parseDouble (para_1) * Double.parseDouble (para_2) );
	              break;
	            }
	            case "/": {
	              //para 1 and 2 must be numbers
	              if( sim.funs.ProgramUtilitiesFun__Is_String_Double ( para_1 ) == false ) {
	                System.err.println("Error! LispFun__Evaluate_A_List " + function_name + "  para_1 must be a number, not: " + para_1 );
	                return null;
	              }
	              if( sim.funs.ProgramUtilitiesFun__Is_String_Double ( para_2 ) == false ) {
	                System.err.println("Error! LispFun__Evaluate_A_List " + function_name + "  para_2 must be a number, not: " + para_2 );
	                return null;
	              }
	              return_string = Double.toString( Double.parseDouble (para_1) / Double.parseDouble (para_2) );
	              break;
	            }
	            case "=":{
	              //para 1 and 2 must be numbers
	              if( sim.funs.ProgramUtilitiesFun__Is_String_Double ( para_1 ) == false ) {
	                System.err.println("Error! LispFun__Evaluate_A_List " + function_name + "  para_1 must be a number, not: " + para_1 );
	                return null;
	              }
	              if( sim.funs.ProgramUtilitiesFun__Is_String_Double ( para_2 ) == false ) {
	                System.err.println("Error! LispFun__Evaluate_A_List " + function_name + "  para_2 must be a number, not: " + para_2 );
	                return null;
	              }
	              if (Double.parseDouble (para_1) == Double.parseDouble (para_2)){
	                return_string="true";
	              }
	              else{
	                return_string = "false";
	              }
	              break;
	            }
	            case "/=":  {//not equal
	              //para 1 and 2 must be numbers
	              if( sim.funs.ProgramUtilitiesFun__Is_String_Double ( para_1 ) == false ) {
	                System.err.println("Error! LispFun__Evaluate_A_List " + function_name + "  para_1 must be a number, not: " + para_1 );
	                return null;
	              }
	              if( sim.funs.ProgramUtilitiesFun__Is_String_Double ( para_2 ) == false ) {
	                System.err.println("Error! LispFun__Evaluate_A_List " + function_name + "  para_2 must be a number, not: " + para_2 );
	                return null;
	              }
	              if (Double.parseDouble (para_1) != Double.parseDouble (para_2)){
	                return_string="true";
	              }
	              else{
	                return_string = "false";
	              }
	              break;
	            }
	            case ">":{
	              //para 1 and 2 must be numbers
	              if( sim.funs.ProgramUtilitiesFun__Is_String_Double ( para_1 ) == false ) {
	                System.err.println("Error! LispFun__Evaluate_A_List " + function_name + "  para_1 must be a number, not: " + para_1 );
	                return null;
	              }
	              if( sim.funs.ProgramUtilitiesFun__Is_String_Double ( para_2 ) == false ) {
	                System.err.println("Error! LispFun__Evaluate_A_List " + function_name + "  para_2 must be a number, not: " + para_2 );
	                return null;
	              }
	              if (Double.parseDouble (para_1) > Double.parseDouble (para_2)){
	                return_string="true";
	              }
	              else{
	                return_string = "false";
	              }
	              break;
	            }
	            case "<":{
	              //para 1 and 2 must be numbers
	              if( sim.funs.ProgramUtilitiesFun__Is_String_Double ( para_1 ) == false ) {
	                System.err.println("Error! LispFun__Evaluate_A_List " + function_name + "  para_1 must be a number, not: " + para_1 );
	                return null;
	              }
	              if( sim.funs.ProgramUtilitiesFun__Is_String_Double ( para_2 ) == false ) {
	                System.err.println("Error! LispFun__Evaluate_A_List " + function_name + "  para_2 must be a number, not: " + para_2 );
	                return null;
	              }
	              if (Double.parseDouble (para_1) < Double.parseDouble (para_2)){
	                return_string="true";
	              }
	              else{
	                return_string = "false";
	              }
	              break;
	            }
	            case ">=":{
	              //para 1 and 2 must be numbers
	              if( sim.funs.ProgramUtilitiesFun__Is_String_Double ( para_1 ) == false ) {
	                System.err.println("Error! LispFun__Evaluate_A_List " + function_name + "  para_1 must be a number, not: " + para_1 );
	                return null;
	              }
	              if( sim.funs.ProgramUtilitiesFun__Is_String_Double ( para_2 ) == false ) {
	                System.err.println("Error! LispFun__Evaluate_A_List " + function_name + "  para_2 must be a number, not: " + para_2 );
	                return null;
	              }
	              if (Double.parseDouble (para_1) >= Double.parseDouble (para_2)){
	                return_string="true";
	              }
	              else{
	                return_string = "false";
	              }
	              break;
	            }
	            case "<=":{
	              //para 1 and 2 must be numbers
	              if( sim.funs.ProgramUtilitiesFun__Is_String_Double ( para_1 ) == false ) {
	                System.err.println("Error! LispFun__Evaluate_A_List " + function_name + "  para_1 must be a number, not: " + para_1 );
	                return null;
	              }
	              if( sim.funs.ProgramUtilitiesFun__Is_String_Double ( para_2 ) == false ) {
	                System.err.println("Error! LispFun__Evaluate_A_List " + function_name + "  para_2 must be a number, not: " + para_2 );
	                return null;
	              }
	              if (Double.parseDouble (para_1) <= Double.parseDouble (para_2)){
	                return_string="true";
	              }
	              else{
	                return_string = "false";
	              }
	              break;
	            }
	            case "combine-two-strings-with-quotation-marks": {
	            	//remove quotation marks from both inputs
	            	para_1 = para_1.substring(1, para_1.length() - 1);
	            	para_2 = para_2.substring(1, para_2.length() - 1);
	            	
	            	return_string = "\"" + para_1 + para_2 + "\"";
	            	
	            	break;	
	            }
	            case "tracking-control-get-manual-joystick-value":{
	              
	              return_string = TaskTemplateFun__World3D_Tracking_Control_Get_Manual_Joystick_Value ( para_1, para_2 );
	              break;	
	            }
	            case "tracking-control-get-manual-joystick-duration":{
	              return_string = TaskTemplateFun__World3D_Tracking_Control_Get_Manual_Joystick_Duration ( para_1, para_2 );
	              break;
	            }
	            case "get-char-from-string": //e.g., (get-char-from-string  =letters 1), if =letters is case, then return c
	            {
	            	//return the i th character from a string
	            	int para_2Int = Integer.parseInt(para_2);
	            	if (para_2Int > para_1.length()) return_string = "nil"; 
	            	else return_string = para_1.substring( para_2Int - 1, para_2Int);	            	
	            	break;
	            }
	            case "get-tail-from-string": // return a substring from the ith char to the end; 
	            	//e.g., (get-tail-from-string  =letters 2), if =letters is case, then return ase.
	            {	            	
	            	int para_2Int = Integer.parseInt(para_2);
	            	if (para_2Int > para_1.length()) return_string = "nil"; 
	            	else return_string = para_1.substring( para_2Int - 1, para_1.length());	            	
	            	break;	            	
	            }

	            default:{
	              System.err.println("Error! LispFun__Evaluate_A_List has undefined function name inside the two parameter number function group: " + function_name);
	              return null;
	            }  
	          }
	          break;
	        }
	        
	        //LispFun  six double functions
	        //the following functions apply to 6 and only 6 double numbers
	        case "world3d-driving-accelerate-brake": 
	          //case "world3d-driving-speed-control":
	        { // here the number of parameters must be 6. include potential ( ) cases, parameters should be at least 6
	          int number_of_parameters = 6;
	          double[] para = new double[number_of_parameters]; //from 0 to number_of_parameters -1
	          if ( content_list.size() < number_of_parameters ) {
	            System.err.println("Error! LispFun__Evaluate_A_List " + function_name + "  function must have " + number_of_parameters + " parameters, not: " + input_string );
	            return null;
	          }
	          
	          int i = 0;
	          for( i = 0; i < number_of_parameters; i++){
	            if( !content_list.getFirst().equals( "(" ) ) { //para_i is not a list,  
	              String value_string = content_list.getFirst();
	              if( sim.funs.ProgramUtilitiesFun__Is_String_Double ( value_string ) == false ) {
	                System.err.println("Error! LispFun__Evaluate_A_List " + function_name + "  parameter " + Integer.toString((i+1)) + "  must be a number, not: " + value_string );
	                return null;
	              }
	              para[i] = Double.parseDouble(value_string);
	              content_list.removeFirst(); //remove para_i
	            }
	            else { //para_i is a list, e.g., content_list = ( + 1 2 )    ( + 2 3 )
	              LinkedList<String> next_level_eval_content_list = sim.funs.ParametersFun__Remove_A_List_From_Initialization_Lists  ( content_list ); //e.g., after this, next_level_eval_content_list =  + 1 2 , content_list = ( + 2 3 )
	              next_level_eval_content_list.addFirst ( "(" );
	              next_level_eval_content_list.addLast  ( ")" );
	              String value_string = LispFun__Evaluate_A_List (  sim.funs.ProgramUtilitiesFun__LinkedListString_To_String ( next_level_eval_content_list )  );
	              if( sim.funs.ProgramUtilitiesFun__Is_String_Double ( value_string ) == false ) {
	                System.err.println("Error! LispFun__Evaluate_A_List " + function_name + "  parameter " + Integer.toString(i+1) + "  must be a number, not: " + value_string );
	                return null;
	              }
	              para[i] = Double.parseDouble(value_string);
	            }
	            
	            if ( (i + 1) < number_of_parameters && content_list.size() == 0 ) {
	              System.err.println("Error! LispFun__Evaluate_A_List " + function_name + "  function must have " + number_of_parameters + " parameters, not: " + input_string );
	              return null;
	            }
	          }
	          
	          //now there must be nothing left in content_list
	          if ( content_list.size() != 0 ) {
	            System.err.println("Error! LispFun__Evaluate_A_List " + function_name + "  function must have " + number_of_parameters + " parameters, not: " + input_string );
	            return null;
	          }
	          
	          switch ( function_name ){
	            case "world3d-driving-accelerate-brake": { // !eval! (do-accelerate =fthw =dthw =dt)  in Salvucci's model
	              if( sim.vars.world3DTemplate.Method_Object == null || !(sim.vars.world3DTemplate.Method_Object instanceof World3D_Template_Driving_Method)) {
	                System.err.println ("Error! LispFun Eval sim.vars.world3DTemplate.Method_Object == null || !(sim.vars.world3DTemplate.Method_Object is World3D_Template_Driving_Method)");

	                return "";
	              }
	              
	              World3D_Template_Driving_Method the_driving_method = (World3D_Template_Driving_Method) sim.vars.world3DTemplate.Method_Object;
	              //here 1 for old, 2 for new.
	              double far_distance_1 = para[0];
	              double far_distance_2 = para[1];
	              double speed_1 = para[2];
	              double speed_2 = para[3];
	              double time_1 = para[4];
	              double time_2 = para[5];
	              
	              //int ii = 0;
	              //for(ii = 0; ii < 6; ii ++) System.out.println("para " + ii + ": " + para[ii]  );
	              
	              double far_point_time_head_way_1 = the_driving_method.Get_Far_Time_Head_Way(far_distance_1, speed_1);
	              double far_point_time_head_way_2 = the_driving_method.Get_Far_Time_Head_Way(far_distance_2, speed_2);
	              double delta_time_head_way = far_point_time_head_way_2  -  far_point_time_head_way_1; //new - old
	              double delta_time = time_2 - time_1;
	              
	              //the_driving_method.Do_Accelerate( 4.0, 0.0, 0.15);
	              the_driving_method.sim = sim;
	              the_driving_method.Do_Accelerate( far_point_time_head_way_2, delta_time_head_way, delta_time); // !eval! (do-accelerate =fthw =dthw =dt)
	              
	              
	              
	              if(sim.vars.animator3DModule.Show_Animator3D){
	                //TODO
	                System.out.println("TODO, LispFun__Evaluate_A_List needs Animator3D");
//	                Animator3D.SetCommentText(14, "Far_THW (s): " + Double.toString(GlobalUtilities.round(far_point_time_head_way_2)));
	              }
	              
	              //return_string = 
	              
	              return null; //no return

	            } //end of "world3d-driving-accelerate-brake"
	            
	            
	            default:{
	              System.err.println("Error! LispFun__Evaluate_A_List has undefined function name inside the " + number_of_parameters + " parameter number function group: " + function_name);
	              return null;
	            }
	          }
	          
	        } //end of six double parameters
	        
            case "replace-space-in-string": //replace space chars in a string using the specified char
            	//e.g., (replace-space-in-stringg  =letters  _ ), if =letters is "test ", then return "test_".
            {
            	//first, call ProgramUtilitiesFun__Combine_Quotation_In_LinkedList_String
            	content_list = sim.funs.ProgramUtilitiesFun__Combine_Quotation_In_LinkedList_String(content_list);
            	
            	  String para_1;
	  	          if( !content_list.getFirst().equals( "(" ) ) { //para_1 is not a list,  
	  	            para_1 = content_list.getFirst();
	  	            content_list.removeFirst(); //remove para_1
	  	          }
	  	          else { //para_1 is a list, e.g., content_list = ( + 1 2 )    ( + 2 3 )
	  	            LinkedList<String> next_level_eval_content_list = sim.funs.ParametersFun__Remove_A_List_From_Initialization_Lists  ( content_list ); //e.g., after this, next_level_eval_content_list =  + 1 2 , content_list = ( + 2 3 )
	  	            next_level_eval_content_list.addFirst ( "(" );
	  	            next_level_eval_content_list.addLast  ( ")" );
	  	            para_1 = LispFun__Evaluate_A_List (  sim.funs.ProgramUtilitiesFun__LinkedListString_To_String ( next_level_eval_content_list )  );
	  	          }
	  	          
	  	          //now content_list contains String only for para_2 if there is any String
	  	          if ( content_list.size() == 0 ) {
	  	            System.err.println("Error! LispFun__Evaluate_A_List " + function_name + "  function must have 2 parameters, not: " + input_string );
	  	            return null;
	  	          }
	  	          String para_2;
	  	          if( !content_list.getFirst().equals( "(" )) { //para_2 is not a list,  
	  	            para_2 = content_list.getFirst();
	  	            content_list.removeFirst(); //remove para_2
	  	          }
	  	          else { //para_2 is a list, e.g., content_list =  ( + 2 3 )
	  	            LinkedList<String> next_level_eval_content_list = sim.funs.ParametersFun__Remove_A_List_From_Initialization_Lists  ( content_list ); //e.g., after this, next_level_eval_content_list =  + 2 3 , content_list = empty
	  	            next_level_eval_content_list.addFirst ( "(" );
	  	            next_level_eval_content_list.addLast  ( ")" );
	  	            para_2 = LispFun__Evaluate_A_List (  sim.funs.ProgramUtilitiesFun__LinkedListString_To_String ( next_level_eval_content_list )  );
	  	          }
	  	          
	  	          //now there must be nothing left in content_list
	  	          if ( content_list.size() != 0 ) {
	  	            System.err.println("Error! LispFun__Evaluate_A_List " + function_name + "  function must have 2 parameters, not: " + input_string );
	  	            return null;
	  	          }
            	return_string = para_1.replaceAll(" ", para_2);	    
            	
            	break;
            }  //end of replace-space-in-string
            
	        default: {
	          System.err.println ("Error! LispFun__Evaluate_A_List has an invalid input: " + input_string + " because of undefined function name: " + function_name  );
	          return null; 
	          //break; // no need
	        }
	      }
	      
	      
	    }
	    
	  }
	  
	  
	  
	  
	  return_string = return_string.toLowerCase();
	  //substitute back, true to t and false to nil. change boolean keyword from c# to Lisp
	  if( return_string.equals( "true")) return_string = "t";
	  else if ( return_string.equals( "false" ) ) return_string = "nil";
	  
	  
	  return return_string;
	}
	
	//MotorModuleFun
	
	public  void MotorModuleFun__Add_Item_To_Control_Motor_Release_Queue(String request_type, Chunk entity_chunk)
	{

	  switch(request_type){	
	    case "world3d-sp-driving-control-manual-joystick":{
	      
	      //if an entity has been in the queue for the same type of motor command and the same dimension, trash the entity.
	      String target_chunk_type = entity_chunk.Chunk_Type;
	      String target_axis = sim.funs.ChunkFun__Get_Chunk_Slot_Value(entity_chunk, "axis");
	      
	      for(Entity an_entity : this.getLinkedListOfQnactrEntityInServerAndQueue("controlmotorreleasequeue")){
	        if ( an_entity.Trash == false && an_entity.Chunk.Chunk_Type == target_chunk_type){
	          String axis = ChunkFun__Get_Chunk_Slot_Value(entity_chunk, "axis");
	          if( axis == target_axis) an_entity.Trash = true;
	        }
	      }
	      
	      //send an entity to track when to release the press.
	      Entity Temp_Entity = sim.funs.createEntity( "Control Motor Release Queue" , "Control Motor", "Control Motor Release Queue", "Track Motor Release", 0.0);
	      //Entity Temp_Entity = new Entity();  
	      //Temp_Entity.ID = "224"; //Control Motor Release Queue
	      //Temp_Entity.Time = (double) SimSystem.clock();
	      //Temp_Entity.Tag = Entity_Number; //give it an entity number, init. 1
	      //Entity_Number++;
	      //Temp_Entity.From = "Control Motor"; //tag from and to
	      //Temp_Entity.To = "Control Motor Release Queue";
	      //Temp_Entity.Entity_Type = "Track Motor Release";   
	      Temp_Entity.Chunk = sim.funs.ChunkFun__Chunk_Clone(entity_chunk);
	      
	      break;
	    }
	    default:{
	      System.err.println("Error! MotorModuleFun__Add_Item_To_Control_Motor_Release_Queue has undefined case request_type: " + request_type);
	      break;	
	    }
	  }
	}
	
	public  Two_Tuple MotorModuleFun__Add_Move_Cursor_Noise(int target_location_x_in_pixel, int target_location_y_in_pixel, double approaching_width_in_visual_angle_degree){
	  Two_Tuple return_tuple = new Two_Tuple ();
	  if(sim.vars.motorModule.Cursor_Noise == false) {
	    return_tuple.Ob1 = target_location_x_in_pixel;
	    return_tuple.Ob2 = target_location_y_in_pixel;
	    return return_tuple ;
	  }
	  else{
	    int target_width_in_approaching_direction_in_pixel = DeviceModuleFun__Visual_Angle_To_Pixels ( (double) approaching_width_in_visual_angle_degree );
	    
	    if( target_width_in_approaching_direction_in_pixel == 0){
	      return_tuple.Ob1 = target_location_x_in_pixel;
	      return_tuple.Ob2 = target_location_y_in_pixel;
	      return return_tuple ;
	    }
	    else {
	      //for shooting tasks	//double polar_r_in_pixel = sim.funs.ProgramUtilitiesFun__Act_R_Noise( 18 );	// (act-r-noise (/ pixw 7.8)) //ACT-R use 7.8  //
	      double polar_r_in_pixel = sim.funs.ProgramUtilitiesFun__Act_R_Noise(target_width_in_approaching_direction_in_pixel / 7.8 );
	      double polar_theta = sim.funs.ProgramUtilitiesFun__Act_R_Noise( Math.PI ) ;
	      return sim.funs.ProgramUtilitiesFun__Polar_Move_XY (target_location_x_in_pixel, target_location_y_in_pixel, (double) polar_r_in_pixel,  (double) polar_theta);
	    }
	  }
	}
	
	public double MotorModuleFun__Compute_Execution_Time(Chunk the_chunk_spec){
	  if (the_chunk_spec.Chunk_Type.equals( "world3d-driving-two-point-visual-manual-steer")) return (double) 0.0;
	  
	  String command_type = the_chunk_spec.Chunk_Type;
	  double value;
	  switch(MotorModuleFun__Motor_Request_Type_To_Motor_Computation_Type(command_type) ){
	    case "punch":{ 
	      /* 
	(defmethod compute-exec-time ((mtr-mod motor-module) (self punch))
	(+ (init-time mtr-mod) (key-closure-time 
	;DAN
	;(device-interface *mp*))))
	(current-device-interface))))
	       */
	      value = sim.vars.deviceModule.Key_Closure_Time;  //init-time not counted here, because the returned time here is the duration of the movement only
	      break;
	    }
	    case "peck-recoil":{ 
	      /* 
	(defmethod compute-exec-time ((mtr-mod motor-module) (self peck-recoil))
	(setf (move-time self)
	(max (burst-time mtr-mod)
	(fitts mtr-mod (peck-fitts-coeff mtr-mod) (r self))))   ; 99.06.18
	(+ (init-time mtr-mod)
	(max (burst-time mtr-mod) 
	(rand-time (move-time self)))))
	       */
	      
	      String r = sim.funs.ChunkFun__Get_Chunk_Slot_Value(the_chunk_spec, "r");
	      double move_time =	Math.max(sim.vars.motorModule.Motor_Burst_Time ,  MotorModuleFun__Fitts_Law(sim.vars.motorModule.Peck_Fitts_Coeff, r, ""    )  ); //"" for w default
	      value =  Math.max(sim.vars.motorModule.Motor_Burst_Time , sim.funs.ProgramUtilitiesFun__Rand_Time ((double) move_time) ); //init-time not counted here, because the returned time here is the duration of the movement only
	      
	      //obsolete method without using rand-time:
	      //return  Math.Max(sim.vars.motorModule.Motor_Burst_Time ,  MotorModuleFun__Fitts_Law(sim.vars.motorModule.Peck_Fitts_Coeff, r, ""    )  ); //"" for w default
	      
	      break;
	    }
	    case "tap":{ 
		      /*//as in ACT-Touch
		(defmethod compute-exec-time ((mtr-mod motor-module) (self tap))
  (+ (init-time mtr-mod)                       //init-time not counted here, because the returned time here is the duration of the movement only
     (max (burst-time mtr-mod)
          (rand-time (fitts mtr-mod 
;; borrow peck's "b" coefficient, although really should just be 0
                            (peck-fitts-coeff mtr-mod) 
;; get the current device's index-z		// z is the height from the touch screen surface to the finger in the air
                            (index-z (current-device)))))))
		       */
		      int zPx = 72; 
		      //as in ACT-Touch (2013), it is confirmed that ACT-Touch mistook the unit as pixel for Fitts Law, they were using 72 degree visual angle rather than 72 pixel. 
		      // ACT-Touch tap takes 463 ms.
		      // double fitts_time = coef * Math.log( (d_double / w_double + 0.5) ) / Math.log(2.0);
		      //                   = 0.075 * Math.log( (72 / 1 + 0.5) ) / Math.log(2.0) = 0.463  (it is exactly the way of using 72 as visual angle in degree, which was wrong)
		      
		      String z =   Double.toString( sim.funs.DeviceModuleFun__Double_Pixels_To_Visual_Angle ((double) zPx) ); // the correct way is to convert pixel to visual angle degree
		      
		      // System.out.println("z: " + z); when zPx = 72, at default viewing distance, 15.0; //inch, z = 3.814 visual angle degree
		      
		      double move_time = MotorModuleFun__Fitts_Law(sim.vars.motorModule.Peck_Fitts_Coeff, z, ""    ) ; //"" for w default
		      
		      //System.out.println("move_time: " + move_time);  // using default :peck-fitts-coeff  0.075, movement time = 0.158
		      
		      value =  Math.max(sim.vars.motorModule.Motor_Burst_Time , sim.funs.ProgramUtilitiesFun__Rand_Time ((double) move_time) ); //init-time not counted here, because the returned time here is the duration of the movement only
		      
		      
		      break;
		 }
	    
	    case "cursor-ply":{
	      /*
	(defmethod compute-exec-time :before ((mtr-mod motor-module) 
	(self cursor-ply))
	(setf (fitts-coeff self) 
	(* (expt-coerced 2 (control-order self)) (fitts-coeff self))))
	       */
	      //first assign different coefficients for different devices
	      double fitts_coeff = sim.vars.motorModule.Mouse_Fitts_Coeff; 
	      String device = sim.funs.ChunkFun__Get_Chunk_Slot_Value(the_chunk_spec, "device");
	      int control_order = DeviceModuleFun__Get_Pointing_Device_Order ( device );
	      fitts_coeff = Math.pow( 2, control_order ) * fitts_coeff ;
	      
	      //then
	      /*
	(defmethod compute-exec-time ((mtr-mod motor-module) (self ply))
	(+ (init-time mtr-mod)
	(rand-time (fitts mtr-mod (fitts-coeff self) (r self)
	(target-width self)))))
	       */
	      
	      Chunk hand_finger_r_theta_chunk = MotorModuleFun__Motor_Request_Chunk_To_Motor_Computation_Chunk( the_chunk_spec );
	      String r = sim.funs.ChunkFun__Get_Chunk_Slot_Value(hand_finger_r_theta_chunk, "r"); //in visual angle degree.
	      String theta = sim.funs.ChunkFun__Get_Chunk_Slot_Value(hand_finger_r_theta_chunk, "theta" );
	      
	      //get target width for "cursor-ply" type ;; (approach-width feat (vtheta r-theta))
	      //first, need to get height and width of the target in pixel. 
	      String object_string = sim.funs.ChunkFun__Get_Chunk_Slot_Value(the_chunk_spec, "object");
	      String loc_string    = sim.funs.ChunkFun__Get_Chunk_Slot_Value(the_chunk_spec, "loc");
	      String screen_pos;
	      if( (object_string.equals( "nil") && loc_string.equals( "nil" ) )  ) { // ACT-R first use the visual object to get the screen-location, if no visual object (visicon) specified in the move-cursor request, use the specified visual-location, if no visual-location, return error.   ACT-R 6.0 motor.lisp: ";; always refer back to the visicon chunks if possible"
	        System.err.println ( "Error! MotorModuleFun__Compute_Execution_Time the_chunk_spec must move to an object (preferred) or a location, but OBJ: " + object_string + ", and LOC: " +loc_string);
	        return (double) 0.0;
	      }	
	      else if (!object_string.equals( "nil" )){ //no mater what loc_string is , use the visual icon chunk
	        if( sim.vars.centralParametersModule.Chunks.containsKey (object_string) == false ) {
	          System.err.println("Error! MotorModuleFun__Compute_Execution_Time has sim.vars.centralParametersModule.Chunks.ContainsKey (object_string) == false: " + object_string);
	          return (double) 0.0;
	        }
	        else{
	          Chunk visual_icon_chunk_pointer = (Chunk) sim.vars.centralParametersModule.Chunks.get(object_string);
	          screen_pos = sim.funs.ChunkFun__Get_Chunk_Slot_Value(visual_icon_chunk_pointer, "screen-pos" );
	        }
	      }
	      else {	// object_string.equals( "nil")  && !loc_string.equals("nil")
	        screen_pos = loc_string;
	      }
	      
	      if( sim.vars.centralParametersModule.Chunks.containsKey (screen_pos) == false ) {
	        System.err.println("Error! MotorModuleFun__Compute_Execution_Time after object_string has sim.vars.centralParametersModule.Chunks.ContainsKey (screen_pos) == false: " + screen_pos);
	        return (double) 0.0;
	      }
	      Chunk visual_location_chunk_pointer = (Chunk) sim.vars.centralParametersModule.Chunks.get(screen_pos);
	      String target_width_in_pixel = sim.funs.ChunkFun__Get_Chunk_Slot_Value( visual_location_chunk_pointer, "width" );
	      String target_height_in_pixel = sim.funs.ChunkFun__Get_Chunk_Slot_Value( visual_location_chunk_pointer, "height" );
	      //then compute appoach w in the fitts law	
	      if( !ProgramUtilitiesFun__Is_String_Double(theta) ) {
	        System.err.println ("Error! MotorModuleFun__Compute_Execution_Time after object_string has !ProgramUtilitiesFun__Is_String_Double(theta), theta: "+ theta );
	        return (double) 0.0;
	      }
	      double approaching_angle_in_radian = Double.parseDouble(theta );
	      
	      double approch_w_in_visual_angle_degree =  sim.funs.ProgramUtilitiesFun__Approach_Width( Integer.parseInt( target_width_in_pixel),  Integer.parseInt(target_height_in_pixel), (double) approaching_angle_in_radian );
	      
	      double fitts_movement_time = MotorModuleFun__Fitts_Law((double) fitts_coeff, r, Double.toString(approch_w_in_visual_angle_degree) );
	      
	      String target_loc_x_in_pixel = sim.funs.ChunkFun__Get_Chunk_Slot_Value( visual_location_chunk_pointer, "screen-x" );
	      String target_loc_y_in_pixel = sim.funs.ChunkFun__Get_Chunk_Slot_Value( visual_location_chunk_pointer, "screen-y" );
	      sim.funs.ChunkFun__Add_Chunk_Slot_Name_And_Value( the_chunk_spec, "target_loc_x_in_pixel", target_loc_x_in_pixel);
	      sim.funs.ChunkFun__Add_Chunk_Slot_Name_And_Value( the_chunk_spec, "target_loc_y_in_pixel", target_loc_y_in_pixel);
	      sim.funs.ChunkFun__Add_Chunk_Slot_Name_And_Value( the_chunk_spec, "approaching_width_in_visual_angle_degree", Double.toString(approch_w_in_visual_angle_degree) );
	      
//	      GlobalUtilities.popUpMessage("MotorModuleFun__Compute_Execution_Time uses fitts_coeff: " + fitts_coeff + ", r: " +  r + ", theta: " + theta + ", target-width" + approch_w_in_visual_angle_degree + ", coords (" + target_loc_x_in_pixel + " " + target_loc_y_in_pixel + ") ,  control-order: " + control_order + ". fitts_movement_time: " + fitts_movement_time);
	      
	      value =  sim.funs.ProgramUtilitiesFun__Rand_Time( (double) fitts_movement_time ) ; ////init-time not counted here, because the returned time here is the duration of the movement only
	      break;
	    }
	    
	    case "hand-ply":
	    case "ply":
	    {
	      //then
	      /*
	(defmethod compute-exec-time ((mtr-mod motor-module) (self ply))
	(+ (init-time mtr-mod)
	(rand-time (fitts mtr-mod (fitts-coeff self) (r self)
	(target-width self)))))
	       */
	      
	      Chunk hand_finger_r_theta_chunk = MotorModuleFun__Motor_Request_Chunk_To_Motor_Computation_Chunk( the_chunk_spec );
	      String r = sim.funs.ChunkFun__Get_Chunk_Slot_Value(hand_finger_r_theta_chunk, "r"); //in visual angle degree.
	      String theta = sim.funs.ChunkFun__Get_Chunk_Slot_Value(hand_finger_r_theta_chunk, "theta" );
	      
	      //get target width for "ply" type ;; (approach-width feat (vtheta r-theta))
	      //first, need to get height and width of the target in pixel. 
	      String object_string = sim.funs.ChunkFun__Get_Chunk_Slot_Value(the_chunk_spec, "object");
	      String loc_string    = sim.funs.ChunkFun__Get_Chunk_Slot_Value(the_chunk_spec, "loc");
	      String screen_pos;
	      if( (object_string.equals( "nil") && loc_string.equals( "nil" ) )  ) { // ACT-R first use the visual object to get the screen-location, if no visual object (visicon) specified in the move-hand-touch request, use the specified visual-location, if no visual-location, return error.   ACT-R 6.0 motor.lisp: ";; always refer back to the visicon chunks if possible"
	        System.err.println ( "Error! MotorModuleFun__Compute_Execution_Time the_chunk_spec must move to an object (preferred) or a location, but OBJ: " + object_string + ", and LOC: " +loc_string);
	        return (double) 0.0;
	      }	
	      else if (!object_string.equals( "nil" )){ //no mater what loc_string is , use the visual icon chunk
	        if( sim.vars.centralParametersModule.Chunks.containsKey (object_string) == false ) {
	          System.err.println("Error! MotorModuleFun__Compute_Execution_Time has sim.vars.centralParametersModule.Chunks.ContainsKey (object_string) == false: " + object_string);
	          return (double) 0.0;
	        }
	        else{
	          Chunk visual_icon_chunk_pointer = (Chunk) sim.vars.centralParametersModule.Chunks.get(object_string);
	          screen_pos = sim.funs.ChunkFun__Get_Chunk_Slot_Value(visual_icon_chunk_pointer, "screen-pos" );
	        }
	      }
	      else {	// object_string.equals( "nil")  && !loc_string.equals("nil")
	        screen_pos = loc_string;
	      }
	      
	      if( sim.vars.centralParametersModule.Chunks.containsKey (screen_pos) == false ) {
	        System.err.println("Error! MotorModuleFun__Compute_Execution_Time after object_string has sim.vars.centralParametersModule.Chunks.ContainsKey (screen_pos) == false: " + screen_pos);
	        return (double) 0.0;
	      }
	      Chunk visual_location_chunk_pointer = (Chunk) sim.vars.centralParametersModule.Chunks.get(screen_pos);
	      String target_width_in_pixel = sim.funs.ChunkFun__Get_Chunk_Slot_Value( visual_location_chunk_pointer, "width" );
	      String target_height_in_pixel = sim.funs.ChunkFun__Get_Chunk_Slot_Value( visual_location_chunk_pointer, "height" );
	      //then compute appoach w in the fitts law	
	      if( !ProgramUtilitiesFun__Is_String_Double(theta) ) {
	        System.err.println ("Error! MotorModuleFun__Compute_Execution_Time after object_string has !ProgramUtilitiesFun__Is_String_Double(theta), theta: "+ theta );
	        return (double) 0.0;
	      }
	      double approaching_angle_in_radian = Double.parseDouble(theta );
	      
	      double approch_w_in_visual_angle_degree =  sim.funs.ProgramUtilitiesFun__Approach_Width( Integer.parseInt( target_width_in_pixel),  Integer.parseInt(target_height_in_pixel), (double) approaching_angle_in_radian );
	      
	      
	      //////////////////
	      double fitts_coeff = sim.vars.motorModule.Mouse_Fitts_Coeff;  // TODO mouse Fitts' coeff is used in ACT-Touch
	      //////////////////
	      
	      
	      double fitts_movement_time = MotorModuleFun__Fitts_Law((double) fitts_coeff, r, Double.toString(approch_w_in_visual_angle_degree) );
	      
	      String target_loc_x_in_pixel = sim.funs.ChunkFun__Get_Chunk_Slot_Value( visual_location_chunk_pointer, "screen-x" );
	      String target_loc_y_in_pixel = sim.funs.ChunkFun__Get_Chunk_Slot_Value( visual_location_chunk_pointer, "screen-y" );
	      sim.funs.ChunkFun__Add_Chunk_Slot_Name_And_Value( the_chunk_spec, "target_loc_x_in_pixel", target_loc_x_in_pixel);
	      sim.funs.ChunkFun__Add_Chunk_Slot_Name_And_Value( the_chunk_spec, "target_loc_y_in_pixel", target_loc_y_in_pixel);
	      sim.funs.ChunkFun__Add_Chunk_Slot_Name_And_Value( the_chunk_spec, "approaching_width_in_visual_angle_degree", Double.toString(approch_w_in_visual_angle_degree) );
	      
//	    	      GlobalUtilities.popUpMessage("MotorModuleFun__Compute_Execution_Time uses fitts_coeff: " + fitts_coeff + ", r: " +  r + ", theta: " + theta + ", target-width" + approch_w_in_visual_angle_degree + ", coords (" + target_loc_x_in_pixel + " " + target_loc_y_in_pixel + ") ,  control-order: " + control_order + ". fitts_movement_time: " + fitts_movement_time);
	      
	      value =  sim.funs.ProgramUtilitiesFun__Rand_Time( (double) fitts_movement_time ) ; ////init-time not counted here, because the returned time here is the duration of the movement only
	      

	      break;
	    }
	    case "":{
	      System.out.println("MotorModuleFun__Compute_Execution_Time has an empty ISA command type.");
	      value =  (double) 0.0;
	      break;
	    }
	    default: {
	      System.out.println("MotorModuleFun__Compute_Execution_Time has undefined command_type case: " + command_type);
	      value =  (double) 0.0;
	      break;
	    }
	    
	  }
	  
	  return value;
	}
	
	public double MotorModuleFun__Compute_Finish_Time(Chunk the_chunk_spec, Entity entity){
	  if (the_chunk_spec.Chunk_Type.equals( "world3d-driving-two-point-visual-manual-steer")) return (double) 0.0;
	  
	  String command_type = the_chunk_spec.Chunk_Type;
	  if( !entity.Chunk.Slot.containsKey("motor_execution_time") ){
	    System.err.println("Error! MotorModuleFun__Compute_Finish_Time need a chunk with motor_execution_time already computed." );
	    SimSystem.abort();
	  }
	  double exec_time = Double.parseDouble( sim.funs.ChunkFun__Get_Chunk_Slot_Value( entity.Chunk, "motor_execution_time") );
	  double return_duration = 0.0;
	  switch(command_type){
	    case "punch":
	    { 
	      /* 
	(defmethod compute-finish-time ((mtr-mod motor-module) (self punch))
	(+ (init-time mtr-mod) (* 2 (burst-time mtr-mod))))
	       */
	      return_duration =  sim.vars.motorModule.Motor_Burst_Time * 2.0;
	      break;
	    }
	    case "tap":
	    {
	    	return_duration =  exec_time + sim.vars.motorModule.Motor_Burst_Time ; //as ACT-Touch (2013)
	    }
	    case "peck-recoil":{ 
	      /* 
	(defmethod compute-finish-time ((mtr-mod motor-module) (self peck-recoil))
	(+ (exec-time self) (burst-time mtr-mod)
	(max (burst-time mtr-mod)
	(rand-time (move-time self)))))
	       */
	      
	      return_duration =  exec_time + sim.vars.motorModule.Motor_Burst_Time + Math.max( sim.vars.motorModule.Motor_Burst_Time,   sim.funs.ProgramUtilitiesFun__Rand_Time ((double) exec_time) ); //since here finish time also excludes initialization time, just use execution time in the computation
	      break;
	    }
	    case "move-cursor":  //move cursor to a visual icon chunk (visicon) or a visual location.
	    case "move-hand-touch":
	      //here may add other styles
	    { //the common method
	      /*
	(defmethod compute-finish-time ((module pm-module) (mvmt movement-style))
	"Return the finish time of the movement."
	(+ (burst-time module) (exec-time mvmt)))
	       */
	      
	      return_duration =   sim.vars.motorModule.Motor_Burst_Time + exec_time; //since here finish time also excludes initialization time, just use execution time in the computation
	      
	      break;
	    }
	    case "":{
	      System.out.println("MotorModuleFun__Compute_Finish_Time has an empty ISA command type.");
	      break;
	    }
	    default: {
	      System.out.println("MotorModuleFun__Compute_Finish_Time has undefined command_type case: " + command_type);
	      break;
	    }	
	  }
	  if (return_duration < exec_time ) System.err.println("Error! MotorModuleFun__Compute_Finish_Time: " + return_duration + " < exec_time: " + exec_time);
	  
	  return (double) return_duration ;
	}
	
	public void MotorModuleFun__Compute_Incremental_Mouse_Moves(Chunk request){
	  // produce intermediate mouse moves for incremental mouse movement
	  // act-r version at motor.lisp:651
	  // get execution time
	  // add init time to execution time because the incremental mouse moves will start during initiation time
	  double init_time = 0;
	  if(request.Slot.containsKey("motor_initiation_time") ) { //use customized time
	    init_time = Double.parseDouble( sim.funs.ChunkFun__Get_Chunk_Slot_Value( request, "motor_initiation_time" ) );
	  } else {
	    init_time = sim.vars.motorModule.Motor_Initiation_Time; //ACT-R reference manual: The first 50 ms (by default) of the movement is movement initiation. 
	  }
	  double d = Double.parseDouble((String)request.Slot.get("motor_execution_time")) + init_time;
	  double steptime;
	  // try to parse flag as number, otherwise, default to 0.05
	  // get r and theta
	  Chunk computation_chunk = MotorModuleFun__Motor_Request_Chunk_To_Motor_Computation_Chunk(request);
	  request.Slot.put("r", computation_chunk.Slot.get("r"));
	  request.Slot.put("theta", computation_chunk.Slot.get("theta"));
	  try {
	    steptime=Double.parseDouble(sim.vars.motorModule.Incremental_Mouse_Moves);
	  }
	  catch (NumberFormatException nfe){
	    steptime = 0.05;
	  }
	  // calculate number of steps
	  int nsteps = Math.max(1, (int)Math.floor(d / steptime));
	  // get start position
	  // TODO make sure this is actually where cursor location is kept
	  int startposx = sim.vars.deviceModule.Mouse_Cursor_Screen_X;
	  int startposy = sim.vars.deviceModule.Mouse_Cursor_Screen_Y;
	  double curdist = 0;
	  // only compute intermediate steps if total number is more than 1
	  if(nsteps > 1) {
	    List<Two_Tuple> px_moves = new ArrayList<Two_Tuple>(nsteps);
	    for(int idx = 0; idx < nsteps; idx++) {
	      // calculate next distance
	      // TODO check that r is in the chunk
	      curdist = (double) MotorModuleFun__Min_Jerk_Dist( (double)((idx+1) * steptime), Float.parseFloat((String)request.Slot.get("r")),  (double) d);
	      
	      // get the move
	      // TODO check that theta is in the chunk
	      // TODO I did not write polar_move_xy. need to check correctness
	      Two_Tuple px_move = sim.funs.ProgramUtilitiesFun__Polar_Move_XY(startposx, startposy, DeviceModuleFun__Visual_Angle_To_Pixels((double)curdist), Float.parseFloat((String)request.Slot.get("theta")));
	      // add to list
	      px_moves.add(px_move);
	    }
	    // store moves in the entity chunk
	    
	    System.out.println("TODO MotorModuleFun__Compute_Incremental_Mouse_Moves. normally only strings are in chunks. ");
	    // TODO normally only strings are in chunks. is this a problem?
	    //request.Slot.put("incremental-movements", px_moves);
	    // TODO set incremental times
	    //request.Slot.put("steptime", steptime);
	  }
	}
	
	public double MotorModuleFun__Compute_Preparation_Time(Chunk the_chunk_spec){
	  if (the_chunk_spec.Chunk_Type.equals( "world3d-driving-two-point-visual-manual-steer")) return (double) 0.0;
	  
	  String motor_command_style_in_terms_of_computation = MotorModuleFun__Motor_Request_Type_To_Motor_Computation_Type( the_chunk_spec.Chunk_Type);
	  
	  //(or (null (last-prep module))        (not (eq (style-name mvmt) (style-name (last-prep module)))))  
	  if(sim.vars.motorModule.Last_Command.Chunk_Type.equals( "" )  ||  (  !MotorModuleFun__Motor_Computation_Type_To_Style_Name(motor_command_style_in_terms_of_computation).equals(  MotorModuleFun__Motor_Computation_Type_To_Style_Name(MotorModuleFun__Motor_Request_Type_To_Motor_Computation_Type(sim.vars.motorModule.Last_Command.Chunk_Type))  )) ){
	    //(* (feat-prep-time module) (num-to-prepare mvmt))
	    int num_to_prepare = MotorModuleFun__Get_Motor_Request_Num_To_Prepare( the_chunk_spec );
	    return (double) (sim.vars.motorModule.Motor_Feature_Prep_Time * num_to_prepare);
	  }
	  else{ 
	    //(* (feat-prep-time module) (feat-differences mvmt (last-prep module)))
	    int feat_differences = MotorModuleFun__Get_Feature_Differences_For_A_Motor_Request( sim.vars.motorModule.Last_Command, the_chunk_spec );
	    return (double) (sim.vars.motorModule.Motor_Feature_Prep_Time * (double)feat_differences);
	  }
	  
	  /*//obsolete version
	//(or (null (last-prep module))        (not (eq (style-name mvmt) (style-name (last-prep module)))))  //style same actually means the two motor commands have the same slot names
	if(sim.vars.motorModule.Last_Command.Chunk_Type.equals( "" )  ||  !ProgramUtilitiesFun__LinkedListString_Equal( (LinkedList<String>)sim.vars.centralParametersModule.Chunk_Types_Description[the_chunk_spec.Chunk_Type] , (LinkedList<String>)sim.vars.centralParametersModule.Chunk_Types_Description[sim.vars.motorModule.Last_Command.Chunk_Type]) ){
	//(* (feat-prep-time module) (num-to-prepare mvmt))
	int num_to_prepare = 1 + the_chunk_spec.Slot.Count; //see defmethod num-to-prepare in general-pm.lisp
	return sim.vars.motorModule.Motor_Feature_Prep_Time * (double)num_to_prepare;
	}
	else{ 
	//(* (feat-prep-time module) (feat-differences mvmt (last-prep module)))
	int feat_differences = MotorModuleFun__Get_Feature_Differences_For_A_Motor_Request( sim.vars.motorModule.Last_Command, the_chunk_spec );
	return sim.vars.motorModule.Motor_Feature_Prep_Time * (double)feat_differences;
	}
	   */
	  
	}
	
	
	/**
	 * input coefficient, d (distance between start point and the target point, unit in visual angle degree), w (width of the target (in the direction of approaching), unit in visual angle degree). e.g., if approaching from left to right to a rectangle, w is the width of the rectangle. if approaching from up to down to a rectangle, w is the height of the rectangle. 

//motor.lisp
;;; FITTS      [Function]
;;; Date        : 97.02.14, delta 99.06.18
;;; Description : Return Fitts law time for a given coefficient and distance,
;;;             : optionally supplying the target width (default is 1)

(defgeneric fitts (mtr-mod coef d &optional w)
  (:documentation  "Fitts law time for movement"))

(defmethod fitts ((mtr-mod motor-module) coef d &optional (w 1.0))
  (when (or (zerop w) (minusp w))
    (print-warning "Fitts time computation received a negative or zero width - assuming 1 pixel wide.")
    (setf w (pm-pixels-to-angle 1)))
  (max (min-fitts-time mtr-mod)         ; 99.06.18
       (* coef (log-coerced (+ (/ d w) 0.5) 2))))
       
       
       this is the default ACT-R Fitts' Law function.
       
       double fitts_time = coef * Math.log( (d_double / w_double + 0.5) ) / Math.log(2.0);
       
	 * @param coef
	 * @param w, in the unit of visual angle degree, 1.0 by default
	 * @param d, also in the unit of visual angle degree
	 * 
	 * as long as w and d are in the same unit, it is OK. so the time result does not depend on Device_Module.Pixcels_Per_Inch = 72; and Viewing_Distance = 15.0; //inch (by default)
	 * 
	 * @return
	 */
	public  double MotorModuleFun__Fitts_Law(double coef, String d, String w){
	  double w_double;
	  if(w.equals( "" )){ //default value
	    w_double = sim.vars.motorModule.Default_Target_Width;  //default is 1.0 degree of visual angle.
	  }
	  else w_double  = Double.parseDouble(w);
	  
	  if (w_double <= 0) {
	    sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("#|Warning: Fitts time computation received a negative or zero width - assuming 1 pixel wide (convert to visual angle degree for the Fitts_Law function) .|#");
	    // w_double = DeviceModuleFun__Obsolete_Int_Pixels_To_Visual_Angle( 1 );  //Int alternative version
	    w_double = DeviceModuleFun__Double_Pixels_To_Visual_Angle ((double) 1.0); //double ACT-R version
	  }
	  double d_double =  Double.parseDouble(d);
	  double fitts_time = coef * Math.log( (d_double / w_double + 0.5) ) / Math.log(2.0);
	  
	  //GlobalUtilities.popUpMessage("fitts_time: " + fitts_time + ", coef: " + coef + ", d_double: " + d_double + ", w_double: " + w_double + ", Math.log( (d_double / w_double + 0.5) ) / Math.log(2.0): " + Math.log( (d_double / w_double + 0.5) ) / Math.log(2.0) + ". (d_double / w_double + 0.5): " + (d_double / w_double + 0.5) + ", Math.log( (d_double / w_double + 0.5) ): " + Math.log( (d_double / w_double + 0.5) ) + ", Math.log(2.0): " + Math.log(2.0) + ". Math.log(2): " + Math.log(2));
	  
	  return (double) Math.max(sim.vars.motorModule.Min_Fitts_Time , fitts_time);
	}
	
	public  int MotorModuleFun__Get_Feature_Differences_For_A_Motor_Request(Chunk the_chunk1, Chunk the_chunk2){
	  String basic_style_name_1 = MotorModuleFun__Motor_Request_Type_To_Basic_Style_Name(the_chunk1.Chunk_Type ) ;
	  String basic_style_name_2 = MotorModuleFun__Motor_Request_Type_To_Basic_Style_Name(the_chunk2.Chunk_Type ) ;

	  if (!basic_style_name_1.equals(basic_style_name_2)){
	    System.err.println("MotorModuleFun__Get_Feature_Differences_For_A_Motor_Request error. The two inputs have different motor command basic_style_name: " + basic_style_name_1 + " and " + basic_style_name_2);
	    return -1;
	  }
	  
	  
	  switch( basic_style_name_1 ) {
	    case "hand_finger_style":
	    {
	      //hand finger style
	      /* //motor.lisp
	(defmethod feat-differences ((p1 punch) (p2 punch))
	(cond ((not (eq (hand p1) (hand p2))) 2)
	((not (eq (finger p1) (finger p2))) 1)
	(t 0)))
	       */
	      
	      //this must be PUNCH style, which the motor request chunk is just the same as the motor computation chunk, so no need to change the chunk
	      if( !sim.funs.ChunkFun__Get_Chunk_Slot_Value(the_chunk1, "hand").equals(sim.funs.ChunkFun__Get_Chunk_Slot_Value(the_chunk2, "hand") )) return 2;
	      if( !sim.funs.ChunkFun__Get_Chunk_Slot_Value(the_chunk1, "finger").equals( sim.funs.ChunkFun__Get_Chunk_Slot_Value(the_chunk2, "finger")) ) return 1;
	      return 0;

	    }
	    case "hand_finger_r_theta_style":
	    {
	      //hand finger r theta style.
	      /* //motor.lisp
	(defmethod feat-differences ((m1 hfrt-movement) (m2 hfrt-movement))
	(let ((maxfeats (num-possible-feats m1)))
	(cond ((not (eq (hand m1) (hand m2))) (1- maxfeats))
	((not (eq (finger m1) (finger m2))) (- maxfeats 2))
	(t
	(let ((nfeats 0))
	(unless (distance= (r m1) (r m2)) (incf nfeats))
	(unless (direction= (theta m1) (theta m2)) (incf nfeats))
	nfeats)))))
	       */
	      
	      
	      int maxfeats = MotorModuleFun__Get_Num_Possible_Features(the_chunk1);
	      
	      //here the motor request chunk may be different from the chunk that is actually used for motor computation , e.g.,  +manual> isa move-cursor, which is in fact ISA cursor-ply hand "right" finger ":dummy" r 2 theta 2.15
	      the_chunk1 = MotorModuleFun__Motor_Request_Chunk_To_Motor_Computation_Chunk (the_chunk1);
	      the_chunk2 = MotorModuleFun__Motor_Request_Chunk_To_Motor_Computation_Chunk (the_chunk2);
	      
	      if( !sim.funs.ChunkFun__Get_Chunk_Slot_Value(the_chunk1, "hand").equals(sim.funs.ChunkFun__Get_Chunk_Slot_Value(the_chunk2, "hand") )) return maxfeats - 1;
	      if( !sim.funs.ChunkFun__Get_Chunk_Slot_Value(the_chunk1, "finger").equals(sim.funs.ChunkFun__Get_Chunk_Slot_Value(the_chunk2, "finger") )) return maxfeats - 2;
	      int nfeats = 0;
	      
	      double r1 =  Double.parseDouble ( sim.funs.ChunkFun__Get_Chunk_Slot_Value(the_chunk1, "r") );
	      double r2 =  Double.parseDouble ( sim.funs.ChunkFun__Get_Chunk_Slot_Value(the_chunk2, "r") );
	      boolean distance_equal;
	      if(2.0 > Math.abs(r1 - r2) ) distance_equal = true;
	      // this is 2.0 visual angle degree
	      else distance_equal = false; 
	      
	      
	      double theta1 =  Double.parseDouble ( sim.funs.ChunkFun__Get_Chunk_Slot_Value(the_chunk1, "theta") );
	      double theta2 =  Double.parseDouble ( sim.funs.ChunkFun__Get_Chunk_Slot_Value(the_chunk2, "theta") );		
	      boolean direction_equal;
	      
	      if ( (sim.vars.centralParametersModule.Pi / 4)  >  Math.abs( theta1 -  theta2)  ) direction_equal = true;
	      else direction_equal = false;
	      
	      if(!distance_equal) nfeats++;
	      if(!direction_equal) nfeats++;
	      return nfeats;	
	      
	      /* //motor.lisp
	(defun distance= (d1 d2)
	"Two distances are not equal if they are more than two degrees apart."
	(when (and d1 d2)
	(> 2.0 (abs (- d1 d2)))))
	       */
	      
	      
	      /* //motor.lisp
	(defun direction= (d1 d2)
	"Two directions are not equal if they are more than pi/4 apart."
	(when (and d1 d2)
	(> (/ pi 4) (abs (- d1 d2)))))
	       */

	    }
	    default :
	    {
	      System.err.println("Error! MotorModuleFun__Get_Feature_Differences_For_A_Motor_Request has undefined: basic_style_name_1" + basic_style_name_1 );
	      return -1;

	    }
	  }	
	  
	 
	}
	
	public Two_Tuple MotorModuleFun__Get_Finger_Resting_Location(String hand_string, String finger_string){
	  Two_Tuple return_tuple = new Two_Tuple();
	  Motor_Module_Hand hand_ob = new Motor_Module_Hand();
	  if(hand_string.toLowerCase().equals( "right")) hand_ob = sim.vars.motorModule.Right_Hand;
	  else if (hand_string.toLowerCase().equals( "left")) hand_ob = sim.vars.motorModule.Left_Hand;
	  else {
	    System.err.println ("Error! MotorModuleFun__Get_Finger_Resting_Location has undefined hand_string: " + hand_string);
	  }
	  int hand_x = (int) hand_ob.Location.Ob1;
	  int hand_y = (int) hand_ob.Location.Ob2;
	  int finger_offset_x = (int) ((Two_Tuple)hand_ob.Finger_Location_Offsets.get(finger_string)).Ob1;
	  int finger_offset_y = (int) ((Two_Tuple)hand_ob.Finger_Location_Offsets.get(finger_string)).Ob2;
	  return_tuple.Ob1 = hand_x + finger_offset_x;
	  return_tuple.Ob2 = hand_y + finger_offset_y;
	  
	  return return_tuple;
	}
	
	
	public Motor_Module_Hand MotorModuleFun__Get_Hand_From_Hand_String(String hand_string){
		Motor_Module_Hand hand = null;
	    if (hand_string.equals("left")) hand = sim.vars.motorModule.Left_Hand;
	    else if (hand_string.equals("right")) hand = sim.vars.motorModule.Right_Hand;
	    else System.err.println( "Error! MotorModuleFun__Get_Hand_From_Hand_String had undefined hand_string: " + hand_string );
		return hand;
	}
	
	public  int MotorModuleFun__Get_Motor_Request_Num_To_Prepare(Chunk the_chunk_spec){
	  //obsolete: int num_to_prepare = 1 + the_chunk_spec.Slot.Count; //see defmethod num-to-prepare in general-pm.lisp
	  String motor_command_style_in_terms_of_computation = MotorModuleFun__Motor_Request_Type_To_Motor_Computation_Type( the_chunk_spec.Chunk_Type);
	  
	  //omit the nil slot value case, because any valid motor request should not have any slot value nil.
	  int slot_numbers_not_dummy;
	  switch ( motor_command_style_in_terms_of_computation ){
	    case "punch": //(defStyle punch () hand finger)
	    case "tap": 
	    {
	      slot_numbers_not_dummy = 2;
	      break;
	    }
	    case "hfrt-movement": 
	    case "peck":
	    case "peck-recoil":
	    {  //(defStyle hfrt-movement () hand finger r theta)
	      slot_numbers_not_dummy = 4;
	      break; 
	    }
	    case "ply":			//(defStyle hfrt-movement () hand finger r theta) with //(NIL :DUMMY NIL NIL)   finger :DUMMY
	    case "hand-ply":	//(defStyle hfrt-movement () hand finger r theta) with //(NIL :DUMMY NIL NIL)   finger :DUMMY
	    case "cursor-ply":  //(defStyle hfrt-movement () hand finger r theta) with //(NIL :DUMMY NIL NIL)   finger :DUMMY , hand :Right is fixed but OK
	    { 
	      slot_numbers_not_dummy = 3;
	      break;
	    }
	    default:
	    {
	      System.err.println( "Error! MotorModuleFun__Get_Motor_Request_Num_To_Prepare had undefined motor_command_style_in_terms_of_computation: " + motor_command_style_in_terms_of_computation );
	      return -999;
	      
	    }
	  }
	  
	  return 1 + slot_numbers_not_dummy;
	}
	
	public int MotorModuleFun__Get_Move_Hand_Touch_Latest_Move_To_Location_X(Motor_Module_Hand hand){
		
		if ( hand.Latest_Move_To_Location.Ob1.equals("")){
			//initial, use hand location
			hand.Latest_Move_To_Location.Ob1 = hand.Location.Ob1;
		}
		return (int) hand.Latest_Move_To_Location.Ob1;
		
	}
	
	public int MotorModuleFun__Get_Move_Hand_Touch_Latest_Move_To_Location_Y(Motor_Module_Hand hand){
		
		if ( hand.Latest_Move_To_Location.Ob2.equals("")){
			//initial, use hand location
			hand.Latest_Move_To_Location.Ob2 = hand.Location.Ob2;
		}
		return (int) hand.Latest_Move_To_Location.Ob2;
		
	}
	
	public  int MotorModuleFun__Get_Num_Possible_Features(Chunk the_chunk_spec){
	  //general.lisp
	  //(defmethod num-possible-feats ((mvmt movement-style))
	  //  (1+ (length (feature-slots mvmt))))
	  
	  int return_int = ((LinkedList<String>)sim.vars.centralParametersModule.Chunk_Types_Description.get(the_chunk_spec.Chunk_Type)).size() + 1;
	  
	  
	  //motor.lisp
	  //(defmethod num-possible-feats :around ((self ply))
	  //  (- (call-next-method) 1))
	  String motor_computation_type = MotorModuleFun__Motor_Request_Type_To_Motor_Computation_Type ( the_chunk_spec.Chunk_Type) ;
	  if ( motor_computation_type.equals( "ply") || motor_computation_type.equals( "hand-ply")  ||  motor_computation_type.equals( "cursor-ply" )        ){
	    return_int--;
	  }
	  
	  return return_int;
	}
	
	public int MotorModuleFun__Get_Request_Resource_Needed(Chunk the_request_chunk, String the_resource_name){
	  
	  String request_type = the_request_chunk.Chunk_Type;
	  int value;
	  switch(request_type){
	    case "press-key":
	    {
	      String hand = DeviceModuleFun__Get_Press_Key_Motor_Command_Attribute(ChunkFun__Get_Chunk_Slot_Value(the_request_chunk, "key"), "hand");
	      //System.out.println(hand);			
	      if(hand.equals( "left") && the_resource_name.equals( "Execution_Resource_Left_Hand")) {
	        value =  1;
	      }
	      else if(hand.equals( "right") && the_resource_name.equals( "Execution_Resource_Right_Hand")){
	        value = 1;
	      }
	      else {
	        value = 0;
	      }
	      
	      break;
	    }
	    case "punch":
	    case "tap":
	    case "click-mouse":
	    case "move-cursor":
	    case "move-hand-touch":
	    case "world3d-driving-two-point-visual-manual-steer":	
	    case "world3d-sp-driving-control-manual-joystick":
	    case "clear":
	    { 
	      //ToDo
	      value = 0;
	      break;
	    }
	    case "customized-manual-action":
	    { 
	      String customized_action_name = sim.funs.ChunkFun__Get_Chunk_Slot_Value(the_request_chunk, "name");
	      
	      if(customized_action_name.equals( "left-foot-press") && the_resource_name.equals( "Execution_Resource_Left_Foot")) {
	        value = 1;
	      }
	      else if(customized_action_name.equals( "right-foot-press") && the_resource_name.equals( "Execution_Resource_Right_Foot")){
	        value = 1;
	      }
	      else {
	        value = 0;
	      }
	      
	      break;
	    }
	    
	    case "":{
	      System.out.println("MotorModuleFun__Get_Request_Resource_Needed has an empty ISA command type.");
	      value = 0;
	      break;
	    }
	    default: {
	      System.out.println("MotorModuleFun__Get_Request_Resource_Needed has undefine case: " + request_type);
	      value = 0;
	      break;
	    }	
	  }
	  return value;
	}
	
	public  void MotorModuleFun__Home_Hands(){
	  sim.vars.motorModule.Right_Hand.Location = sim.funs.ProgramUtilitiesFun__Make_Two_Tuple(7 , 4);
	  sim.vars.motorModule.Left_Hand.Location  = sim.funs.ProgramUtilitiesFun__Make_Two_Tuple(4 , 4);
	  
	  
	  sim.vars.motorModule.Left_Hand.Object_Type_In_Hand = "keyboard";
	  sim.vars.motorModule.Right_Hand.Object_Type_In_Hand = "keyboard";
	}

  /**
   * this is used to assign digram frequency
   * used in transcription typing model
   * 
   * source: http://soukoreff.com/academic/bit95.tables.html
   * Linguistic Digram Frequency Tables
   * include 26 letters and space
   * William Soukoreff and Scott MacKenzie
   * The principal table (Figure 1) from our paper Theoretical upper and lower bounds on typing speed using a stylus and a soft keyboard (1995, Behaviour & Information Technology, 14, 370-379) provides digram frequencies for all of the common letter pairs including the space character. The table was generated using the data provided by Mayzner and Tresselt (1965, Tables of single-letter and digram frequency counts for various word-length and letter-position combinations, Psychonomic Monograph Supplements, 1(2), 13-32).
   * 
   */
  public void MotorModuleFun__Initialize_Digram_Frequency_Table(){
    sim.vars.motorModule.Digram_Frequency_Table.put( "a__a" ,2 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "a__b" ,144 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "a__c" ,308 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "a__d" ,382 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "a__e" ,1 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "a__f" ,67 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "a__g" ,138 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "a__h" ,9 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "a__i" ,322 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "a__j" ,7 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "a__k" ,146 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "a__l" ,664 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "a__m" ,177 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "a__n" ,1576 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "a__o" ,1 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "a__p" ,100 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "a__q" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "a__r" ,802 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "a__s" ,683 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "a__t" ,785 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "a__u" ,87 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "a__v" ,233 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "a__w" ,57 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "a__x" ,14 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "a__y" ,319 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "a__z" ,12 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "a__space" ,50 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "b__a" ,136 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "b__b" ,14 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "b__c" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "b__d" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "b__e" ,415 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "b__f" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "b__g" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "b__h" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "b__i" ,78 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "b__j" ,18 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "b__k" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "b__l" ,98 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "b__m" ,1 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "b__n" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "b__o" ,240 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "b__p" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "b__q" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "b__r" ,88 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "b__s" ,15 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "b__t" ,7 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "b__u" ,256 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "b__v" ,1 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "b__w" ,1 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "b__x" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "b__y" ,13 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "b__z" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "b__space" ,36 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "c__a" ,368 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "c__b" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "c__c" ,13 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "c__d" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "c__e" ,285 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "c__f" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "c__g" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "c__h" ,412 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "c__i" ,67 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "c__j" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "c__k" ,178 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "c__l" ,108 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "c__m" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "c__n" ,1 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "c__o" ,298 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "c__p" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "c__q" ,1 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "c__r" ,71 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "c__s" ,7 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "c__t" ,154 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "c__u" ,34 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "c__v" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "c__w" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "c__x" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "c__y" ,9 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "c__z" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "c__space" ,47 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "d__a" ,106 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "d__b" ,1 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "d__c" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "d__d" ,37 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "d__e" ,375 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "d__f" ,3 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "d__g" ,19 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "d__h" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "d__i" ,148 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "d__j" ,1 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "d__k" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "d__l" ,22 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "d__m" ,1 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "d__n" ,2 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "d__o" ,137 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "d__p" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "d__q" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "d__r" ,83 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "d__s" ,95 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "d__t" ,3 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "d__u" ,52 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "d__v" ,5 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "d__w" ,2 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "d__x" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "d__y" ,51 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "d__z" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "d__space" ,2627 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "e__a" ,670 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "e__b" ,8 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "e__c" ,181 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "e__d" ,767 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "e__e" ,470 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "e__f" ,103 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "e__g" ,46 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "e__h" ,15 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "e__i" ,127 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "e__j" ,1 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "e__k" ,35 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "e__l" ,332 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "e__m" ,187 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "e__n" ,799 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "e__o" ,44 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "e__p" ,90 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "e__q" ,9 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "e__r" ,1314 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "e__s" ,630 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "e__t" ,316 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "e__u" ,8 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "e__v" ,172 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "e__w" ,106 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "e__x" ,87 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "e__y" ,189 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "e__z" ,2 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "e__space" ,4904 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "f__a" ,145 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "f__b" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "f__c" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "f__d" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "f__e" ,154 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "f__f" ,86 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "f__g" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "f__h" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "f__i" ,205 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "f__j" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "f__k" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "f__l" ,69 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "f__m" ,3 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "f__n" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "f__o" ,429 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "f__p" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "f__q" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "f__r" ,188 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "f__s" ,4 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "f__t" ,102 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "f__u" ,62 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "f__v" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "f__w" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "f__x" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "f__y" ,4 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "f__z" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "f__space" ,110 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "g__a" ,94 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "g__b" ,1 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "g__c" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "g__d" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "g__e" ,289 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "g__f" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "g__g" ,19 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "g__h" ,288 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "g__i" ,96 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "g__j" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "g__k" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "g__l" ,55 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "g__m" ,1 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "g__n" ,31 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "g__o" ,135 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "g__p" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "g__q" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "g__r" ,98 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "g__s" ,42 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "g__t" ,6 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "g__u" ,57 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "g__v" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "g__w" ,1 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "g__x" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "g__y" ,2 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "g__z" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "g__space" ,686 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "h__a" ,1164 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "h__b" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "h__c" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "h__d" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "h__e" ,3155 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "h__f" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "h__g" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "h__h" ,1 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "h__i" ,824 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "h__j" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "h__k" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "h__l" ,5 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "h__m" ,1 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "h__n" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "h__o" ,487 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "h__p" ,2 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "h__q" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "h__r" ,91 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "h__s" ,8 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "h__t" ,165 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "h__u" ,75 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "h__v" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "h__w" ,8 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "h__x" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "h__y" ,32 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "h__z" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "h__space" ,715 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "i__a" ,23 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "i__b" ,7 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "i__c" ,304 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "i__d" ,260 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "i__e" ,189 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "i__f" ,56 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "i__g" ,233 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "i__h" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "i__i" ,1 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "i__j" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "i__k" ,86 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "i__l" ,324 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "i__m" ,255 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "i__n" ,1110 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "i__o" ,88 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "i__p" ,42 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "i__q" ,2 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "i__r" ,272 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "i__s" ,484 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "i__t" ,558 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "i__u" ,5 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "i__v" ,165 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "i__w" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "i__x" ,15 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "i__y" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "i__z" ,18 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "i__space" ,4 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "j__a" ,2 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "j__b" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "j__c" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "j__d" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "j__e" ,31 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "j__f" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "j__g" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "j__h" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "j__i" ,9 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "j__j" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "j__k" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "j__l" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "j__m" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "j__n" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "j__o" ,41 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "j__p" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "j__q" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "j__r" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "j__s" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "j__t" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "j__u" ,56 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "j__v" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "j__w" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "j__x" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "j__y" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "j__z" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "j__space" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "k__a" ,2 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "k__b" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "k__c" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "k__d" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "k__e" ,337 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "k__f" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "k__g" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "k__h" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "k__i" ,127 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "k__j" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "k__k" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "k__l" ,10 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "k__m" ,1 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "k__n" ,82 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "k__o" ,3 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "k__p" ,1 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "k__q" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "k__r" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "k__s" ,50 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "k__t" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "k__u" ,3 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "k__v" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "k__w" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "k__x" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "k__y" ,8 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "k__z" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "k__space" ,309 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "l__a" ,332 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "l__b" ,4 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "l__c" ,6 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "l__d" ,289 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "l__e" ,591 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "l__f" ,59 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "l__g" ,7 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "l__h" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "l__i" ,390 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "l__j" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "l__k" ,38 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "l__l" ,546 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "l__m" ,30 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "l__n" ,1 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "l__o" ,344 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "l__p" ,34 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "l__q" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "l__r" ,11 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "l__s" ,121 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "l__t" ,74 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "l__u" ,81 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "l__v" ,17 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "l__w" ,19 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "l__x" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "l__y" ,276 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "l__z" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "l__space" ,630 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "m__a" ,394 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "m__b" ,50 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "m__c" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "m__d" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "m__e" ,530 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "m__f" ,6 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "m__g" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "m__h" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "m__i" ,165 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "m__j" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "m__k" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "m__l" ,4 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "m__m" ,28 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "m__n" ,4 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "m__o" ,289 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "m__p" ,77 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "m__q" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "m__r" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "m__s" ,53 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "m__t" ,2 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "m__u" ,85 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "m__v" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "m__w" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "m__x" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "m__y" ,19 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "m__z" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "m__space" ,454 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "n__a" ,100 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "n__b" ,2 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "n__c" ,98 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "n__d" ,1213 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "n__e" ,512 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "n__f" ,5 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "n__g" ,771 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "n__h" ,5 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "n__i" ,135 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "n__j" ,8 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "n__k" ,63 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "n__l" ,80 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "n__m" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "n__n" ,54 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "n__o" ,349 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "n__p" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "n__q" ,3 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "n__r" ,2 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "n__s" ,148 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "n__t" ,378 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "n__u" ,49 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "n__v" ,3 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "n__w" ,2 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "n__x" ,2 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "n__y" ,115 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "n__z" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "n__space" ,1152 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "o__a" ,65 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "o__b" ,67 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "o__c" ,61 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "o__d" ,119 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "o__e" ,34 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "o__f" ,80 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "o__g" ,9 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "o__h" ,1 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "o__i" ,88 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "o__j" ,3 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "o__k" ,123 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "o__l" ,218 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "o__m" ,417 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "o__n" ,598 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "o__o" ,336 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "o__p" ,138 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "o__q" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "o__r" ,812 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "o__s" ,195 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "o__t" ,415 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "o__u" ,1115 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "o__v" ,136 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "o__w" ,398 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "o__x" ,2 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "o__y" ,47 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "o__z" ,5 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "o__space" ,294 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "p__a" ,142 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "p__b" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "p__c" ,1 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "p__d" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "p__e" ,280 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "p__f" ,1 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "p__g" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "p__h" ,24 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "p__i" ,97 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "p__j" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "p__k" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "p__l" ,169 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "p__m" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "p__n" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "p__o" ,149 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "p__p" ,64 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "p__q" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "p__r" ,110 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "p__s" ,48 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "p__t" ,40 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "p__u" ,68 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "p__v" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "p__w" ,3 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "p__x" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "p__y" ,14 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "p__z" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "p__space" ,127 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "q__a" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "q__b" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "q__c" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "q__d" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "q__e" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "q__f" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "q__g" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "q__h" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "q__i" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "q__j" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "q__k" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "q__l" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "q__m" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "q__n" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "q__o" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "q__p" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "q__q" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "q__r" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "q__s" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "q__t" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "q__u" ,66 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "q__v" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "q__w" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "q__x" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "q__y" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "q__z" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "q__space" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "r__a" ,289 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "r__b" ,10 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "r__c" ,22 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "r__d" ,133 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "r__e" ,1139 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "r__f" ,13 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "r__g" ,59 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "r__h" ,21 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "r__i" ,309 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "r__j" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "r__k" ,53 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "r__l" ,71 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "r__m" ,65 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "r__n" ,106 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "r__o" ,504 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "r__p" ,9 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "r__q" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "r__r" ,69 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "r__s" ,318 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "r__t" ,190 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "r__u" ,89 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "r__v" ,22 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "r__w" ,5 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "r__x" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "r__y" ,145 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "r__z" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "r__space" ,1483 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "s__a" ,196 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "s__b" ,9 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "s__c" ,47 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "s__d" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "s__e" ,626 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "s__f" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "s__g" ,1 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "s__h" ,328 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "s__i" ,214 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "s__j" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "s__k" ,57 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "s__l" ,48 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "s__m" ,31 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "s__n" ,16 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "s__o" ,213 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "s__p" ,107 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "s__q" ,8 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "s__r" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "s__s" ,168 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "s__t" ,754 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "s__u" ,175 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "s__v" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "s__w" ,32 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "s__x" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "s__y" ,34 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "s__z" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "s__space" ,2228 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "t__a" ,259 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "t__b" ,2 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "t__c" ,31 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "t__d" ,1 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "t__e" ,583 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "t__f" ,1 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "t__g" ,2 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "t__h" ,3774 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "t__i" ,252 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "t__j" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "t__k" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "t__l" ,75 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "t__m" ,1 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "t__n" ,2 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "t__o" ,331 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "t__p" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "t__q" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "t__r" ,187 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "t__s" ,209 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "t__t" ,154 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "t__u" ,132 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "t__v" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "t__w" ,84 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "t__x" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "t__y" ,121 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "t__z" ,1 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "t__space" ,2343 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "u__a" ,45 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "u__b" ,53 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "u__c" ,114 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "u__d" ,48 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "u__e" ,71 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "u__f" ,10 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "u__g" ,148 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "u__h" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "u__i" ,65 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "u__j" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "u__k" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "u__l" ,247 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "u__m" ,87 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "u__n" ,278 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "u__o" ,3 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "u__p" ,49 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "u__q" ,1 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "u__r" ,402 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "u__s" ,299 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "u__t" ,492 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "u__u" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "u__v" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "u__w" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "u__x" ,1 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "u__y" ,7 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "u__z" ,3 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "u__space" ,255 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "v__a" ,27 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "v__b" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "v__c" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "v__d" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "v__e" ,683 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "v__f" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "v__g" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "v__h" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "v__i" ,109 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "v__j" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "v__k" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "v__l" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "v__m" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "v__n" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "v__o" ,33 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "v__p" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "v__q" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "v__r" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "v__s" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "v__t" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "v__u" ,1 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "v__v" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "v__w" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "v__x" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "v__y" ,11 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "v__z" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "v__space" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "w__a" ,595 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "w__b" ,3 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "w__c" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "w__d" ,6 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "w__e" ,285 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "w__f" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "w__g" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "w__h" ,472 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "w__i" ,374 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "w__j" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "w__k" ,1 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "w__l" ,12 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "w__m" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "w__n" ,103 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "w__o" ,264 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "w__p" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "w__q" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "w__r" ,35 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "w__s" ,21 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "w__t" ,4 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "w__u" ,2 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "w__v" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "w__w" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "w__x" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "w__y" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "w__z" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "w__space" ,326 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "x__a" ,17 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "x__b" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "x__c" ,9 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "x__d" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "x__e" ,9 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "x__f" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "x__g" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "x__h" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "x__i" ,10 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "x__j" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "x__k" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "x__l" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "x__m" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "x__n" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "x__o" ,1 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "x__p" ,22 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "x__q" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "x__r" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "x__s" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "x__t" ,23 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "x__u" ,8 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "x__v" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "x__w" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "x__x" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "x__y" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "x__z" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "x__space" ,21 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "y__a" ,11 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "y__b" ,10 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "y__c" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "y__d" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "y__e" ,152 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "y__f" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "y__g" ,1 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "y__h" ,1 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "y__i" ,32 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "y__j" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "y__k" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "y__l" ,7 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "y__m" ,1 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "y__n" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "y__o" ,339 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "y__p" ,16 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "y__q" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "y__r" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "y__s" ,81 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "y__t" ,2 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "y__u" ,1 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "y__v" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "y__w" ,2 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "y__x" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "y__y" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "y__z" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "y__space" ,1171 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "z__a" ,3 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "z__b" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "z__c" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "z__d" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "z__e" ,26 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "z__f" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "z__g" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "z__h" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "z__i" ,2 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "z__j" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "z__k" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "z__l" ,4 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "z__m" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "z__n" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "z__o" ,2 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "z__p" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "z__q" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "z__r" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "z__s" ,3 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "z__t" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "z__u" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "z__v" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "z__w" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "z__x" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "z__y" ,3 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "z__z" ,9 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "z__space" ,2 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "space__a" ,1882 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "space__b" ,1033 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "space__c" ,864 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "space__d" ,515 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "space__e" ,423 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "space__f" ,1059 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "space__g" ,453 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "space__h" ,1388 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "space__i" ,237 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "space__j" ,93 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "space__k" ,152 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "space__l" ,717 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "space__m" ,876 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "space__n" ,478 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "space__o" ,721 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "space__p" ,588 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "space__q" ,42 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "space__r" ,494 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "space__s" ,1596 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "space__t" ,3912 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "space__u" ,134 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "space__v" ,116 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "space__w" ,1787 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "space__x" ,0 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "space__y" ,436 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "space__z" ,2 / 107199.0);
    sim.vars.motorModule.Digram_Frequency_Table.put( "space__space" ,0 / 107199.0);
    
  }

	public  double MotorModuleFun__Min_Jerk_Dist(double tm,double a,double d){
	  if(tm >= d) return a;
	  if(tm < 0) {
	    System.err.println("Error! MotorModuleFun__Min_Jerk_Dist Negative time passed to MINJERK-DIST");
	    
	  }
	  if(tm == 0) return 0;
	  if(d <= 0) return 0;
	  double td = tm / d;
	  return (double) (a * ((10 * Math.pow(td, 3)) + (-15 * Math.pow(td, 4)) +(6 * Math.pow(td, 5))));
	}
	
	public  String MotorModuleFun__Motor_Computation_Type_To_Style_Name(String Motor_Computation_Type){
	  String style_name ;
	  switch ( Motor_Computation_Type ) {
	    case "punch":
	    case "tap":
	    case "hfrt-movement":
	    case "peck":
	    case "ply":
	    {
	      style_name = ":" + Motor_Computation_Type;
	      break;
	    }
	    case "peck-recoil":
	    {
	      style_name = ":peck";
	      break;
	    }
	    case "hand-ply":
	    case "cursor-ply":
	    {
	      style_name = ":ply";
	      break;
	    }
	    case "steering":{
	      style_name = ":steering";	
	      break;
	    }
	    case "customized-manual-action":{
	      style_name = ":customized-manual-action";	
	      break;
	    }
	    default:
	    {
	      System.err.println("Error! MotorModuleFun__Motor_Computation_Type_To_Style_Name has undefined Motor_Computation_Type: " + Motor_Computation_Type);
	      style_name = "NULL";
	      break;
	    }
	  }
	  return style_name;
	}
	
	public Chunk MotorModuleFun__Motor_Request_Chunk_To_Motor_Computation_Chunk(Chunk the_motor_request_chunk){
	  
	  if(the_motor_request_chunk.Motor_Computation_Chunk != null) return the_motor_request_chunk.Motor_Computation_Chunk; 
		
	  Chunk value;
	  switch ( the_motor_request_chunk.Chunk_Type ){
	    case "punch":
	    case "peck-recoil":
	    { //no change cases
	      value = the_motor_request_chunk ;
	      break;
	    }
	    case "move-cursor":
	    {
	      String object_string = sim.funs.ChunkFun__Get_Chunk_Slot_Value(the_motor_request_chunk, "object");
	      String loc_string    = sim.funs.ChunkFun__Get_Chunk_Slot_Value(the_motor_request_chunk, "loc");
	      String screen_pos;
	      if( (object_string.equals( "nil") && loc_string.equals( "nil" ) )  ) { // ACT-R first use the visual object to get the screen-location, if no visual object (visicon) specified in the move-cursor request, use the specified visual-location, if no visual-location, return error.   ACT-R 6.0 motor.lisp: ";; always refer back to the visicon chunks if possible"
	        System.err.println ( "Error! MotorModuleFun__Motor_Request_Chunk_To_Motor_Computation_Chunk move-cursor must move to an object (preferred) or a location, but OBJ: " + object_string + ", and LOC: " +loc_string);
	        return null;
	      }	
	      else if (!object_string.equals("nil")){ //no mater what loc_string is , use the visual icon chunk
	        if( sim.vars.centralParametersModule.Chunks.containsKey (object_string) == false ) {
	          System.err.println("Error! MotorModuleFun__Motor_Request_Chunk_To_Motor_Computation_Chunk has sim.vars.centralParametersModule.Chunks.ContainsKey (object_string) == false: " + object_string);
	          return null;
	        }
	        else{
	          Chunk visual_icon_chunk_pointer = (Chunk) sim.vars.centralParametersModule.Chunks.get(object_string);
	          screen_pos = sim.funs.ChunkFun__Get_Chunk_Slot_Value(visual_icon_chunk_pointer, "screen-pos" );
	        }
	      }
	      else {	// object_string.equals( "nil")  && !loc_string.equals( "nil")
	        screen_pos = loc_string;
	      }
	      
	      if( sim.vars.centralParametersModule.Chunks.containsKey (screen_pos) == false ) {
	        System.err.println("Error! MotorModuleFun__Motor_Request_Chunk_To_Motor_Computation_Chunk after object_string has sim.vars.centralParametersModule.Chunks.ContainsKey (screen_pos) == false: " + screen_pos);
	        return null;
	      }
	      Chunk visual_location_chunk_pointer = (Chunk) sim.vars.centralParametersModule.Chunks.get(screen_pos);
	      String screen_x = sim.funs.ChunkFun__Get_Chunk_Slot_Value( visual_location_chunk_pointer, "screen-x" );
	      String screen_y = sim.funs.ChunkFun__Get_Chunk_Slot_Value( visual_location_chunk_pointer, "screen-y" );
	      
	      //TODO, this version does not support queued movement planning before the previous one is finished. 
	      Two_Tuple r_in_pixel_and_theta_in_radian = sim.funs.ProgramUtilitiesFun__XY_To_Polar(sim.vars.deviceModule.Mouse_Cursor_Screen_X, sim.vars.deviceModule.Mouse_Cursor_Screen_Y, Integer.parseInt(screen_x ), Integer.parseInt(screen_y ) );
	      
	      
	      //double r_in_visual_angle = DeviceModuleFun__Obsolete_Int_Pixels_To_Visual_Angle( (int)GlobalUtilities.round((double) r_in_pixel_and_theta_in_radian.Ob1, 0) ); //Int alternative version
	      double r_in_visual_angle = DeviceModuleFun__Double_Pixels_To_Visual_Angle( (double) r_in_pixel_and_theta_in_radian.Ob1 ); //ACT-R version
	      
	      value = sim.funs.ChunkFun__Make_Chunk_From_Descritption(  new String[] {"isa", "peck" , "hand",  "right",  "finger" , ":dummy" , "r" ,  Double.toString(r_in_visual_angle), "theta", (Double.toString((double) r_in_pixel_and_theta_in_radian.Ob2)) }  );
	      //NOTE: here use "peck" type as the more general case of "hand finger r theta" type, because hfrt does not has its chunk defined in ACT-R
	      
	      break;
	    }
	    case "move-hand-touch": //just move the hand on the touch screen, no tap action
	    {
	      String object_string = sim.funs.ChunkFun__Get_Chunk_Slot_Value(the_motor_request_chunk, "object");
	      String loc_string    = sim.funs.ChunkFun__Get_Chunk_Slot_Value(the_motor_request_chunk, "loc");
	      String hand_string    = sim.funs.ChunkFun__Get_Chunk_Slot_Value(the_motor_request_chunk, "hand");
	      String screen_pos;
	      if( (object_string.equals( "nil") && loc_string.equals( "nil" ) )  ) { // ACT-R first use the visual object to get the screen-location, if no visual object (visicon) specified in the move-hand-touch request, use the specified visual-location, if no visual-location, return error.   ACT-R 6.0 motor.lisp: ";; always refer back to the visicon chunks if possible"
	        System.err.println ( "Error! MotorModuleFun__Motor_Request_Chunk_To_Motor_Computation_Chunk move-hand-touch must move to an object (preferred) or a location, but OBJ: " + object_string + ", and LOC: " +loc_string);
	        return null;
	      }	
	      else if (!object_string.equals("nil")){ //no mater what loc_string is , use the visual icon chunk
	        if( sim.vars.centralParametersModule.Chunks.containsKey (object_string) == false ) {
	          System.err.println("Error! MotorModuleFun__Motor_Request_Chunk_To_Motor_Computation_Chunk move-hand-touch has sim.vars.centralParametersModule.Chunks.ContainsKey (object_string) == false: " + object_string);
	          return null;
	        }
	        else{
	          Chunk visual_icon_chunk_pointer = (Chunk) sim.vars.centralParametersModule.Chunks.get(object_string);
	          screen_pos = sim.funs.ChunkFun__Get_Chunk_Slot_Value(visual_icon_chunk_pointer, "screen-pos" );
	        }
	      }
	      else {	// object_string.equals( "nil")  && !loc_string.equals( "nil")
	        screen_pos = loc_string;
	      }
	      
	      if( sim.vars.centralParametersModule.Chunks.containsKey (screen_pos) == false ) {
	        System.err.println("Error! MotorModuleFun__Motor_Request_Chunk_To_Motor_Computation_Chunk move-hand-touch after object_string has sim.vars.centralParametersModule.Chunks.ContainsKey (screen_pos) == false: " + screen_pos);
	        return null;
	      }
	      Chunk visual_location_chunk_pointer = (Chunk) sim.vars.centralParametersModule.Chunks.get(screen_pos);
	      String screen_x = sim.funs.ChunkFun__Get_Chunk_Slot_Value( visual_location_chunk_pointer, "screen-x" );
	      String screen_y = sim.funs.ChunkFun__Get_Chunk_Slot_Value( visual_location_chunk_pointer, "screen-y" );
	      
	      
	      Motor_Module_Hand hand = MotorModuleFun__Get_Hand_From_Hand_String(hand_string);
	      
	      int fromX = sim.funs.MotorModuleFun__Get_Move_Hand_Touch_Latest_Move_To_Location_X(hand); // (int)hand.Location.Ob1
	      int fromY = sim.funs.MotorModuleFun__Get_Move_Hand_Touch_Latest_Move_To_Location_Y(hand); // (int)hand.Location.Ob2
	      
	      Two_Tuple r_in_pixel_and_theta_in_radian = sim.funs.ProgramUtilitiesFun__XY_To_Polar(fromX , fromY , Integer.parseInt(screen_x ), Integer.parseInt(screen_y ) );
	      
	      double r_in_visual_angle = DeviceModuleFun__Double_Pixels_To_Visual_Angle( (double) r_in_pixel_and_theta_in_radian.Ob1 ); //ACT-R version
	      
	      value = sim.funs.ChunkFun__Make_Chunk_From_Descritption(  new String[] {"isa", "peck" , "hand",  hand_string,  "finger" , ":dummy" , "r" ,  Double.toString(r_in_visual_angle), "theta", (Double.toString((double) r_in_pixel_and_theta_in_radian.Ob2)) }  );
	      
	      //NOTE: here use "peck" type as the more general case of "hand finger r theta" type, because hfrt does not has its chunk defined in ACT-R
	      
	      //update the Latest_Move_To_Location
	      hand.Latest_Move_To_Location.Ob1 = Integer.parseInt(screen_x );
	      hand.Latest_Move_To_Location.Ob2 = Integer.parseInt(screen_y );
	      
	      break;
	    }
	    default:
	    {
	      System.err.println( "Error! MotorModuleFun__Motor_Request_Chunk_To_Motor_Computation_Chunk has undefined command_type_in_terms_of_add_motor_request : " + the_motor_request_chunk.Chunk_Type);
	      value = null;
	      break;
	    }
	  }
	  
	  the_motor_request_chunk.Motor_Computation_Chunk = value;
	  return value;
	}
	
	public void MotorModuleFun__Motor_Request_Type_Letters_To_Press_Keys(Chunk the_request_chunk){
	  
	  if (!sim.vars.motorModule.Motor_Output_Sequence_Required) sim.vars.motorModule.Motor_Output_Sequence_Required = true;
	  if(!sim.vars.motorModule.Is_Typing_Letters)sim.vars.motorModule.Is_Typing_Letters = true;
	  
	  String letters = sim.funs.ChunkFun__Get_Chunk_Slot_Value( the_request_chunk, "letters" );
	  if (letters.charAt(0) == '\"') letters = letters.substring(1);
	  if (letters.charAt(letters.length()-1) == '\"') letters = letters.substring(0, letters.length()-1);
	  int num_of_letters = letters.length();
	  Entity[] Temp_Entity = new Entity[num_of_letters];  
	  //System.out.println("MotorModuleFun__Motor_Request_Type_Letters_To_Press_Keys " + letters + " " + num_of_letters);
	  int i;
	  for ( i = 0; i < num_of_letters ; i++){
	    Temp_Entity[i] = sim.funs.createEntity( "Entity Direct Cast Delay" , "Execution", "Motor Module", "Add Manual", 0.0);
	    //Temp_Entity[i] = new Entity();
	    //Temp_Entity[i].Time = (double) SimSystem.clock();;
	    //Temp_Entity[i].Tag = Entity_Number; //give it an entity number, init. 1
	    //Entity_Number++;
	    //Temp_Entity[i].From = "Execution"; //tag from and to
	    //Temp_Entity[i].To = "Motor Module";
	    //Temp_Entity[i].Entity_Type = "Add Manual";	
	    //Temp_Entity[i].ID = "101"; //send to Entity Direct Cast Delay, to allow delay
	  }
	  
	  
	  String dividing_method = "by_letters" ;// "by_letters" "by_digrams"
	  
	  
	  if(dividing_method.equals( "by_letters")){
	    for ( i = 0; i < num_of_letters ; i++){
	      //Temp_Entity[i].Direct_Cast_Delay = 0.0; //0.0 by default
	      String a_letter = "\"" + letters.substring(i,1+i) + "\"" ;
	      if (letters.substring(i,1+i).equals( " ")) a_letter = "space";
	      if (letters.substring(i,1+i).equals( "\n")) a_letter = "return";
	      // currently ignore other special characters like " ' , .
	      Temp_Entity[i].Chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption ( new String[]{ "isa", "press-key" , "key", a_letter  } ); 
	      
	    }
	  }
	  else if (dividing_method.equals( "by_digrams")){
	    //TODO
	  }
	  else System.err.println("Error! MotorModuleFun__Motor_Request_Type_Letters_To_Press_Keys has undefined dividing_method: " + dividing_method);
	  
	}
	
	public  String MotorModuleFun__Motor_Request_Type_To_Basic_Style_Name(String command_type_in_terms_of_add_motor_request){
	  String returnString;
	  switch ( command_type_in_terms_of_add_motor_request ){
	    case "punch":
	    case "tap":	      
	    {
	      returnString="hand_finger_style" ;
	      break;
	    }
	    case "peck-recoil":
	    case "move-cursor":
	    case "move-hand-touch":
	      
	    {
	      returnString="hand_finger_r_theta_style";
	      break;
	    }
	    default:
	    {
	      System.err.println( "Error! MotorModuleFun__Motor_Request_Type_To_Basic_Style_Name has undefined command_type_in_terms_of_add_motor_request : " + command_type_in_terms_of_add_motor_request);
	      returnString= "NULL" ;
	      break;
	    }
	  }
	  return returnString;
	  
	}
	
	public  String MotorModuleFun__Motor_Request_Type_To_Motor_Computation_Type(String command_type_in_terms_of_add_motor_request){
	  String motor_command_style_in_terms_of_computation;
	  switch ( command_type_in_terms_of_add_motor_request ){
	    case "punch":
	    case "tap":	
	    case "peck-recoil":
	    {
	      motor_command_style_in_terms_of_computation = command_type_in_terms_of_add_motor_request ;
	      break;
	    }
	    case "move-cursor":
	    {
	      motor_command_style_in_terms_of_computation = "cursor-ply";
	      break;
	    }
	    case "move-hand-touch":
	    {
	      motor_command_style_in_terms_of_computation = "hand-ply";
	      break;
	    }	    
	    case "world3d-driving-two-point-visual-manual-steer":
	    {
	      motor_command_style_in_terms_of_computation = "steering";
	      break;
	    }
	    case "customized-manual-action":
	    {
	      
	      motor_command_style_in_terms_of_computation = "customized-manual-action";
	      break;
	    }
	    default:
	    {
	      System.err.println( "Error! MotorModuleFun__Motor_Request_Type_To_Motor_Computation_Type has undefined command_type_in_terms_of_add_motor_request : " + command_type_in_terms_of_add_motor_request);
	      motor_command_style_in_terms_of_computation = "NULL" ;
	      break;
	    }
	  }
	  return motor_command_style_in_terms_of_computation;
	}
	
	public  double MotorModuleFun__Obsolete_Get_Motor_Finger_Return_Home_Time(Chunk The_Chunk_Spec){
	  double return_value = 0.0;
	  
	  if (The_Chunk_Spec.Chunk_Type.equals( "press-key")){
	    if ( MotorModuleFun__Obsolete_Motor_Key_Home_Position_P (ChunkFun__Get_Chunk_Slot_Value( The_Chunk_Spec, "key"))){ //home position
	      return_value = 0.09;
	    }
	    else return_value = 0.15; //other position,Need more evidence. ACT-R may not allow all other position
	  }
	  return (double) return_value;
	}
	
	public  double MotorModuleFun__Obsolete_Get_Motor_Keypress_Time(Chunk The_Chunk_Spec){
	  double return_value = 0.0;
	  
	  if (The_Chunk_Spec.Chunk_Type.equals( "press-key")){
	    if ( MotorModuleFun__Obsolete_Motor_Key_Home_Position_P (ChunkFun__Get_Chunk_Slot_Value( The_Chunk_Spec, "key"))){ //home position
	      return_value = 0.01;
	    }
	    else return_value = 0.10; //other position,Need more evidence. ACT-R may not allow all other position
	  }
	  return (double) return_value;
	}
	
	public  double MotorModuleFun__Obsolete_Get_Motor_Preparation_Time(Chunk The_Chunk_Spec){
	  double return_value = 0.0;
	  
	  if (The_Chunk_Spec.Chunk_Type.equals( "press-key")){
	    if ( MotorModuleFun__Obsolete_Motor_Key_Home_Position_P (ChunkFun__Get_Chunk_Slot_Value( The_Chunk_Spec, "key"))){ //home position
	      return_value = 0.150;
	    }
	    else return_value = 0.250; //other position,Need more evidence. ACT-R may not allow all other position
	  }
	  return (double) return_value;
	}
	
	public  boolean MotorModuleFun__Obsolete_Motor_Key_Home_Position_P(String The_Key){
	  if(The_Key.equals( "A") || The_Key.equals( "S") || The_Key.equals( "D" )|| The_Key.equals( "F") || The_Key.equals( "J") || The_Key.equals( "K") || The_Key.equals( "L") )return true;
	  else return false;
	}
	
	/**
	 * 
	 * @param hand_name
	 * @param location_x in the unit of keyboard key when hand at mouse; in the unit of pixel when hand at touch screen
	 * @param location_y in the unit of keyboard key when hand at mouse; in the unit of pixel when hand at touch screen
	 */
	public  void MotorModuleFun__Set_Hand_Location(String hand_name, int location_x, int location_y){
	  if(hand_name.toLowerCase().equals( "right")){
	    sim.vars.motorModule.Right_Hand.Location = sim.funs.ProgramUtilitiesFun__Make_Two_Tuple(location_x , location_y);
	  }
	  else if (hand_name.toLowerCase().equals( "left")){
	    sim.vars.motorModule.Left_Hand.Location  = sim.funs.ProgramUtilitiesFun__Make_Two_Tuple(location_x , location_y);
	  }
	  else System.out.println("MotorModuleFun__Set_Hand_Location has undefined hand name: " + hand_name);
	}
	
	public void MotorModuleFun__Start_Hand_At_Mouse(){

	  //in fact, this is start left hand at keyboard home position, and start right hand at mouse.
	  MotorModuleFun__Home_Hands(); //position both hand to keyboard
	  
	  //position right hand to mouse
	  sim.vars.motorModule.Right_Hand.Location = sim.funs.ProgramUtilitiesFun__Make_Two_Tuple(28 , 2); // this is in unit of keyboard keys.
	  sim.vars.motorModule.Right_Hand.Object_Type_In_Hand = "mouse";
	  
	  //show animator if needed
	  if(sim.vars.animatorModule.Show_Animator && QnactrSimulation.taskVisualization2DEnable){
	    sim.vars.taskVisualization2D.showObject(sim.vars.taskVisualization2D.mouseCursorID);  //	    Animator.ShowImage ("501");  //show the mouse cursor //	    Animator.MoveImageToTop ("501");
	  }
	}
	
	
	public double MotorModuleFun__Typing_Motor_Time_Offset(double original_time, String key){
	  double N_total = sim.vars.motorModule.Typing_Learning_N_Total; // 100000 ; // 15000000; 
	  double A = original_time * 0.43;
	  double B = original_time;
	  double alpha = 0.001;  //Heathcote et al. 2000
	  
	  String first_char = sim.vars.motorModule.Typing_Data_Last_Pressed_Key;
	  
	  if (first_char.equals( "" )) return original_time;
	  
	  String second_char = key;
	  String look_up_key =  first_char + "__" + second_char;
	  if(sim.vars.motorModule.Digram_Frequency_Table.containsKey(look_up_key) == false) return original_time;
	  
	  double digram_frequency = (double) sim.vars.motorModule.Digram_Frequency_Table.get(look_up_key);
	  
	  //digram_frequency = 0;
	  
	  double N = N_total * digram_frequency;
	  double return_time = A + B * Math.exp( -1.0 * alpha * N );
	  
	  //System.out.println("MotorModuleFun__Typing_Motor_Time_Offset: " + look_up_key  + ", " + original_time + " -> " + return_time);
	  //aaa_temp_double = aaa_temp_double + return_time - original_time;
	  //System.out.println( aaa_temp_double );
	  
	  return (double) return_time;
	}
	
	//MultitaskingFun
	
	public  double MultitaskingFun__Compute_Goal_Adaptation_Offset_For_A_Rule(LinkedList<String> the_rule_processed_goal_buffer_chunk_name_list){
	  
	  
	  //override 
	  //return 0.0;
	  
	  
	  LinkedList <Double> offset_results = new LinkedList <Double> ();
	  Iterator a_processed_goal_buffer_chunk_name=the_rule_processed_goal_buffer_chunk_name_list.iterator();
	  while (a_processed_goal_buffer_chunk_name.hasNext()) {
	    
	    
	    
	    //testing method, old method consider only one active goal thread. If a rule want to process the active thread, the rule get utility offset. Otherwise, no utility offset.
	    String active_goal_chunk_name = sim.vars.intentionalModule.Obsolete_Active_Goal_Chunk_Name_For_Goal_Adaptation;
	    //GlobalUtilities.popUpMessage(active_goal_chunk_name);
	    if (active_goal_chunk_name.equals( "" ) ) {
	      offset_results.addLast (0.0);
	      continue;
	    }
	    
	    if (a_processed_goal_buffer_chunk_name.next().equals( active_goal_chunk_name)){ //a rule wants to process the active goal, so give it an adaptation offset
	      /*
	Goal adaptation offset equation adopted from Altmann and Gray 2008, equation 1: base-level activation of task code = ln ( 2 x encoding-cycles /  (T ^ 0.5) )
	let adaptation-level = ln (2 x encoding-cycles), adaptation-level-prime = 2 x encoding-cycles, adaptation-rate substitute 0.5, using log rule, the equation 1 becomes:  adaptation utility offset = ln ( adaptation-level-prime /  (T ^ adaptation-rate) )   [to confuse people] =   adaptation-level -  adaptation-rate x ln (T)     [to explain the fact]. This offset could be > 0 at first, but will be < 0 with larger T. T is the duration of the current activate goal thread has been activated. T >= 0.05 s because a production firing cycle is 0.05 s. In fact, T = 0.05 x K, K = 1, 2, 3, ... .
	       */
	      
	      double activated_time = GlobalUtilities.round(SimSystem.clock(),3) - sim.vars.intentionalModule.Obsolete_Active_Goal_Chunk_Activated_Clock_Time_For_Adaptation;
	      //GlobalUtilities.popUpMessage(GlobalUtilities.round(SimSystem.clock(), 3) + " " + activated_time);
	      if (activated_time == 0.0) return (double) 0.0;
	      else {
	        double adaptation_level_prime = 1.25;
	        double adaptation_rate = 0.09;
	        double goal_adaptation_offset = Math.log( adaptation_level_prime /  ( Math.pow( activated_time , adaptation_rate )) ) ; // adaptation utility offset = ln ( adaptation-level-prime /  (T ^ adaptation-rate) ) 
	        //GlobalUtilities.popUpMessage( goal_adaptation_offset );
	        offset_results.addLast ( goal_adaptation_offset) ;
	        continue;
	      }
	    }
	    else{ // the rule will not process the active goal
	      //currently just use zero offset, but ToDo: this may be more complicated like to gradually come to zero with time, from whatever the last used adaptation offset
	      offset_results.addLast (0.0);
	      continue;
	    }
	    
	    
	  }
	  
	  return (double) sim.funs.ProgramUtilitiesFun__LinkedListDouble_Get_Sum( offset_results );
	}
	
	public  String MultitaskingFun__Compute_Goal_Thread_Utility_Offset(Production_Rule the_rule, LinkedList<Production_Rule> the_matched_rules){
	  boolean debug_flag = false;
	  
	  /*
	//debug
	if(the_matched_rules.Count ==2 && ((Production_Rule) the_matched_rules.First.Value).Rule_Name.equals( "retrieve-instruction-fact")  && ((Production_Rule) the_matched_rules.Last.Value).Rule_Name.equals( "retrieve-instruction-fact" ) ){
	Production_Rule rule1 = ((Production_Rule) the_matched_rules.First.Value);
	Production_Rule rule2 = ((Production_Rule) the_matched_rules.Last.Value);
	GlobalUtilities.popUpMessage("MultitaskingFun__Compute_Goal_Thread_Utility_Offset rule1 for: " + rule1.Condition_Part_Goal_X_Reference + " rule2 for : " + rule2.Condition_Part_Goal_X_Reference);
	debug_flag = true;
	}
	   */
	  
	  
	  
	  
	  String the_rule_name = the_rule.Rule_Name;
	  LinkedList<String>  matched_rule_names = new LinkedList<String> ();
	  LinkedList<String> processed_goal_buffer_name_list = sim.funs.ProgramUtilitiesFun__LinkedListString_Clone (  (LinkedList<String>) sim.vars.productionModule.Rule_Process_Goal_Buffer_Table.get(the_rule_name) );
	  //=goal-x> does not count as processed goal or goal-2, so need the below extra lines to help =goal-x
	  if (!the_rule.Condition_Part_Goal_X_Reference.equals( "" )) {
	    String goal_buffer_name = the_rule.Condition_Part_Goal_X_Reference;
	    if (processed_goal_buffer_name_list.contains(goal_buffer_name)==false)	processed_goal_buffer_name_list.addLast(goal_buffer_name);
	  }
	  if(processed_goal_buffer_name_list.size() == 0) {
	    //GlobalUtilities.popUpMessage("Compute_Goal_Thread_Utility_Offset has processed_goal_buffer_name_list.Count == 0");
	    return "0.0"; //processed no goal buffer
	  }
	  LinkedList<String> the_rule_processed_goal_buffer_chunk_name_list = new LinkedList<String>(); // if the rule has only one of =goal =goal-2 or =goal-x in the condition, it process only one goal. however, if it has both =goal and =goal-2, (or one =goal-x which is bound to a different goal buffer), the rule may process more than one goal, though may not be allow in theory
	  
	  //get all goal chunk names that could be processed by all the matched rules in a linked list
	  LinkedList<String> all_possible_processed_goal_chunk_names = new LinkedList<String>();
	  Enumeration enum_rules = Collections.enumeration(the_matched_rules);
	  while(	enum_rules.hasMoreElements()){
	    Production_Rule a_matched_rule = ((Production_Rule)enum_rules.nextElement()) ;
	    String a_matched_rule_name = a_matched_rule.Rule_Name;	
	    matched_rule_names.addLast(a_matched_rule_name);
	    
	    //get processed goal buffer name from predefined list for each rule (e.g, if a rule has =goal in its condition, =goal should be added in the list when the rule is first added into the rule pool)
	    LinkedList<String> temp_processed_goal_buffer_name_list = sim.funs.ProgramUtilitiesFun__LinkedListString_Clone ( (LinkedList<String>) sim.vars.productionModule.Rule_Process_Goal_Buffer_Table.get(a_matched_rule_name) );
	    //=goal-x> does not count as processed goal or goal-2, so need the below extra lines to help =goal-x
	    //Model.Message	("MultitaskingFun__Compute_Goal_Thread_Utility_Offset. 1  temp_processed_goal_buffer_name_list.Count: " + temp_processed_goal_buffer_name_list.Count + " " + sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty(sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(temp_processed_goal_buffer_name_list)));
	    
	    //debug
	    //if(temp_processed_goal_buffer_name_list.Contains("goal-2") ) GlobalUtilities.popUpMessage("MultitaskingFun__Compute_Goal_Thread_Utility_Offset has original goal-2 from " + a_matched_rule_name);
	    
	    //get processed buffer name for =goal-x in condition
	    if (!a_matched_rule.Condition_Part_Goal_X_Reference.equals( "" )){
	      String goal_buffer_name = a_matched_rule.Condition_Part_Goal_X_Reference;
	      if (temp_processed_goal_buffer_name_list.contains(goal_buffer_name)==false)   temp_processed_goal_buffer_name_list.addLast(goal_buffer_name);
	    }
	    
	    //debug
	    if(temp_processed_goal_buffer_name_list.size() > 2)	System.out.println("MultitaskingFun__Compute_Goal_Thread_Utility_Offset. 2 temp_processed_goal_buffer_name_list.Count: " + temp_processed_goal_buffer_name_list.size() + " " + sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty(sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(temp_processed_goal_buffer_name_list)));  //currently there are only goal and goal-2, so count should not > 2
	    
	    //get goal chunk names
	    Enumeration enum_goal_buffers = Collections.enumeration(temp_processed_goal_buffer_name_list);
	    while(enum_goal_buffers.hasMoreElements()){
	      String temp_goal_buffer_name = (String) enum_goal_buffers.nextElement();
	      switch (temp_goal_buffer_name){
	        case "goal":{
	          String buffer_chunk_name = sim.vars.goalBuffer.Goal_Buffer_Chunk.Chunk_Name;
	          if (buffer_chunk_name.equals( "" )) {
	            
	            //GlobalUtilities.popUpMessage("MultitaskingFun__Compute_Goal_Thread_Utility_Offset has case goal buffer_chunk_name == empty" );
	            break;
	          }
	          if ( all_possible_processed_goal_chunk_names.contains(buffer_chunk_name) == false) all_possible_processed_goal_chunk_names.addLast(buffer_chunk_name);
	          if ((a_matched_rule_name + a_matched_rule.Condition_Part_Goal_X_Reference).equals(the_rule_name + the_rule.Condition_Part_Goal_X_Reference) && the_rule_processed_goal_buffer_chunk_name_list.contains(buffer_chunk_name) == false) the_rule_processed_goal_buffer_chunk_name_list.addLast(buffer_chunk_name);
	          break;
	        }
	        case "goal-2":{
	          String buffer_chunk_name = sim.vars.goalBuffer.Goal_Buffer_Chunk_2.Chunk_Name;
	          if (buffer_chunk_name.equals( "" )){
	            System.out.println("MultitaskingFun__Compute_Goal_Thread_Utility_Offset has case goal-2 buffer_chunk_name == empty for rule: " + a_matched_rule_name );
	            ProductionModuleFun__Print_A_Production(a_matched_rule);
	          }
	          if (all_possible_processed_goal_chunk_names.contains(buffer_chunk_name) == false) all_possible_processed_goal_chunk_names.addLast(buffer_chunk_name);
	          if ((a_matched_rule_name + a_matched_rule.Condition_Part_Goal_X_Reference).equals(the_rule_name + the_rule.Condition_Part_Goal_X_Reference) && the_rule_processed_goal_buffer_chunk_name_list.contains(buffer_chunk_name) == false) the_rule_processed_goal_buffer_chunk_name_list.addLast(buffer_chunk_name);
	          break;
	        }
	        default:{
	          System.out.println("MultitaskingFun__Compute_Goal_Thread_Utility_Offset has undefined temp_goal_buffer_name: " + temp_goal_buffer_name);
	          break;
	        }
	      }
	      
	      //ToDo: early break; if(sim.funs.ProgramUtilitiesFun__LinkedListString_Equal(,))
	    }
	  }
	  
	  //safe check
	  if(all_possible_processed_goal_chunk_names.size() > sim.vars.productionModule.Goal_Thread_Order_List_For_Threaded_Cognition.size()) 
	  {
	    System.out.println(" MultitaskingFun__Compute_Goal_Thread_Utility_Offset has all_possible_processed_goal_chunk_names.Count > sim.vars.productionModule.Goal_Thread_Order_List_For_Threaded_Cognition.Count for rule: " + the_rule_name + " vs. " + sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty(sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(matched_rule_names)));
	    System.out.println(all_possible_processed_goal_chunk_names.size()+ "all_possible_processed_goal_chunk_names: " + sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty(sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(all_possible_processed_goal_chunk_names)));
	    System.out.println(sim.vars.productionModule.Goal_Thread_Order_List_For_Threaded_Cognition.size() + "sim.vars.productionModule.Goal_Thread_Order_List_For_Threaded_Cognition: " + sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty(sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(sim.vars.productionModule.Goal_Thread_Order_List_For_Threaded_Cognition) ));
	  }
	  
	  //get the goal chunk name that is the earliest in the goal thread list and is included in the all_possible_processed_goal_chunk_names
	  //earliest in the list means not being processed for the longest time.
	  String the_earliest_goal_thread_name = "";
	  Enumeration enum_goal_threads = Collections.enumeration(sim.vars.productionModule.Goal_Thread_Order_List_For_Threaded_Cognition);
	  while(enum_goal_threads.hasMoreElements()){
	    String a_goal_chunk_name = (String)enum_goal_threads.nextElement();
	    if (all_possible_processed_goal_chunk_names.contains(a_goal_chunk_name)) {
	      the_earliest_goal_thread_name = a_goal_chunk_name;
	      break;
	    }
	  }
	  //if (the_earliest_goal_thread_name.equals( "" )) GlobalUtilities.popUpMessage("Compute_Goal_Thread_Utility_Offset has the_earliest_goal_thread_name == empty");
	  //debug
	  if (debug_flag) {
	    System.out.println("Goal_Thread_Order_List_For_Threaded_Cognition " + sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty(sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(sim.vars.productionModule.Goal_Thread_Order_List_For_Threaded_Cognition )) );
	    System.out.println("the_earliest_goal_thread_name: " + the_earliest_goal_thread_name );
	  }
	  
	  
	  String which_method_to_use = sim.vars.intentionalModule.Multitasking_Schedule_Method; //set in Event Set_QN_Parameters
	  if (which_method_to_use.equals( "goal-adaptation")){	//goal adaptation method:
	    /* //now take multiple processed goal thread as taking the sum of the multiple offsets
	if (the_rule_processed_goal_buffer_chunk_name_list.Count > 1) {
	GlobalUtilities.popUpMessage("Compute_Goal_Thread_Utility_Offset has the_rule_processed_goal_buffer_chunk_name_list.Count > 1 for rule: " + the_rule_name + ". check the utility offset algorithm when a rule processes multiple goals. Should process only one task in a production rule");
	return "nil";
	}
	else {
	string rule_processed_goal_buffer_name = (String) the_rule_processed_goal_buffer_chunk_name_list.First.Value;
	double return_value = MultitaskingFun__Compute_A_Goal_Thread_Adaptation(rule_processed_goal_buffer_name);
	return return_value.ToString();
	}
	     */
	    double return_value = MultitaskingFun__Compute_Goal_Adaptation_Offset_For_A_Rule (the_rule_processed_goal_buffer_chunk_name_list);
	    return Double.toString(return_value);
	    
	  }
	  else if (which_method_to_use.equals( "threaded-cognition")){	//ACT-R 6.0 v1.4 Threaded Cognition method: the rule is: if this rule processed the the_earliest_goal_thread_name (it could also processed other goal at the same time, but currently do not give it more priority for this. ToDo: this is a research question), return 0.0, otherwise return -999.0
	    if(sim.vars.productionModule.Focus_One_Goal_Name.equals( "" )){	
	      // longest waited task goal get priority
	      //GlobalUtilities.popUpMessage("the_earliest_goal_thread_name: " + the_earliest_goal_thread_name);
	      //Two_Tuple return_tuple = new Two_Tuple();
	      if (debug_flag) {
	        System.out.println("the_rule_processed_goal_buffer_chunk_name_list: " + sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty(sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(the_rule_processed_goal_buffer_chunk_name_list)));
	      }
	      if(the_rule_processed_goal_buffer_chunk_name_list.contains(the_earliest_goal_thread_name)){
	        //return_tuple.Ob1 = "0.0";
	        if (debug_flag) System.out.println(the_rule.Rule_Name + the_rule.Condition_Part_Goal_X_Reference +" got offset 0.0" );
	        return "0.0";
	      }
	      else{
	        //return_tuple.Ob1 = "-999.000";
	        if (debug_flag) System.out.println(the_rule.Rule_Name + the_rule.Condition_Part_Goal_X_Reference +" got offset -999.000" );
	        return "-999.000";
	      }
	      //return return_tuple;
	    }
	    else{
	      //Focus_One_Goal get priority
	      //GlobalUtilities.popUpMessage("MultitaskingFun__Compute_Goal_Thread_Utility_Offset todo");
	      sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("MultitaskingFun__Compute_Goal_Thread_Utility_Offset todo");
	      return "0.0";
	      /*
	GlobalUtilities.popUpMessage("MultitaskingFun__Compute_Goal_Thread_Utility_Offset give priority to: " + sim.vars.productionModule.Focus_One_Goal_Name);
	if(the_rule_processed_goal_buffer_chunk_name_list.Contains(sim.vars.productionModule.Focus_One_Goal_Name) )
	{
	//if (debug_flag) 
	GlobalUtilities.popUpMessage(the_rule.Rule_Name + the_rule.Condition_Part_Goal_X_Reference +" got offset 0.0" );
	return "0.0";
	}
	else{
	//return_tuple.Ob1 = "-999.000";
	//if (debug_flag) 
	GlobalUtilities.popUpMessage(the_rule.Rule_Name + the_rule.Condition_Part_Goal_X_Reference +" got offset -999.000" );
	return "-999.000";
	}
	       */
	      
	    }
	    
	  }
	  else if (!which_method_to_use.equals( "" ) ) { // undefined method
	    System.out.println("Compute_Goal_Thread_Utility_Offset has undefined method name: " + which_method_to_use );
	    return "nil";
	  }
	  else return "0.0"; // ACT-R before threaded cognition
	  
	  
	  /*
	//UUA utility urgency availability method
	Two_Tuple return_tuple = new Two_Tuple();
	if (the_rule_processed_goal_buffer_chunk_name_list.Count > 1)GlobalUtilities.popUpMessage("Compute_Goal_Thread_Utility_Offset has the_rule_processed_goal_buffer_chunk_name_list.Count > 1, check the utility offset algorithm when a rule processes multiple goals");
	double sum_urgency = 0.0;
	double sum_availability = 0.0;
	foreach (string rule_processed_goal_buffer_name in the_rule_processed_goal_buffer_chunk_name_list) {
	sum_urgency += ProductionModuleFun__Obsolete_Compute_A_Goal_Thread_Urgency(rule_processed_goal_buffer_name); //here rule_processed_goal_buffer_name means goal buffer chunk name
	// sum_availability += ProductionModuleFun__Obsolete_Compute_A_Goal_Thread_Urgency(rule_processed_goal_buffer_name);
	}
	return_tuple.Ob1 = sum_urgency.ToString(); // use sum urgency as the urgency associated with the rule ToDo: research question when a rule process multiple goal threads
	//return_tuple.Ob2 = (sum_availability / the_rule_processed_goal_buffer_chunk_name_list.Count ).ToString(); //use average availability. ToDo: Research question when a rule process multiple goal threads
	   */
	  
	  
	  
	  
	}
	
	public  boolean MultitaskingFun__Does_Condition_Part_Have_Equal_Goal_X_Test(Production_Rule the_rule){
	  String [] key_word_list = new String [] {"=goal-x>" };
	  LinkedList<String> the_rule_spec_list = sim.funs.ProgramUtilitiesFun__StringArray_To_LinkedList_String ( ProductionModuleFun__Get_Rule_Descriptors_From_Production_Rule(the_rule) );
	  for (int t=0; t< key_word_list.length; t++) {
	    String key_word=key_word_list[t];
	    if ( the_rule_spec_list.contains( key_word) ) {
	      //GlobalUtilities.popUpMessage( The_Rule_Spec[1] );
	      return true;
	    }
	  }
	  return false;
	}
	
	public  double MultitaskingFun__Obsolete_Compute_A_Goal_Thread_Adaptation(String the_goal_chunk_name){
	  
	  String active_goal_chunk_name = sim.vars.intentionalModule.Obsolete_Active_Goal_Chunk_Name_For_Goal_Adaptation;
	  //GlobalUtilities.popUpMessage(active_goal_chunk_name);
	  if (active_goal_chunk_name.equals( "" ) ) return (double) 0.0;
	  
	  if (the_goal_chunk_name.equals( active_goal_chunk_name)){ //a rule wants to process the active goal, so give it an adaptation offset
	    double activated_time = GlobalUtilities.round(SimSystem.clock(),3) - sim.vars.intentionalModule.Obsolete_Active_Goal_Chunk_Activated_Clock_Time_For_Adaptation;
	    //GlobalUtilities.popUpMessage(GlobalUtilities.round(SimSystem.clock(), 3) + " " + activated_time);
	    if (activated_time == 0.0) return (double) 0.0;
	    else {
	      double adaptation_level_prime = 0.1;
	      double adaptation_rate = 0.5;
	      double goal_adaptation_offset = Math.log( adaptation_level_prime /  ( Math.pow( activated_time , adaptation_rate )) ) ; // adaptation utility offset = ln ( adaptation-level-prime /  (T ^ adaptation-rate) ) 
	      //GlobalUtilities.popUpMessage( goal_adaptation_offset );
	      return (double) goal_adaptation_offset;
	    }
	  }
	  else{ // the rule will not process the active goal
	    //currently just use zero offset, but ToDo: this may be more complicated like to gradually come to zero with time, from whatever the last used adaptation offset
	    return (double) 0.0;
	  }
	}
	
	public  String MultitaskingFun__Obsolete_Get_Origin_Counterpart_Name_For_A_Multitasking_Rule(Production_Rule the_rule){
	  
	  
	  String [] the_rule_descriptor = ProductionModuleFun__Get_Rule_Descriptors_From_Production_Rule(the_rule);
	  Hashtable subst = new Hashtable();
	  subst.put ( "=goal-2>" , "=goal>" ); //may add more keyword pairs here
	  
	  String [] the_rule_descriptor_subst = sim.funs.ProgramUtilitiesFun__Subst_String_Array(the_rule_descriptor, subst);
	  LinkedList<String> temp_list = sim.funs.ProgramUtilitiesFun__StringArray_To_LinkedList_String(the_rule_descriptor_subst);
	  temp_list.removeFirst(); //remove p
	  temp_list.removeFirst(); //remove rule_name
	  
	  String [] the_rule_descriptor_subst_pure = sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(temp_list);
	  String to_match = sim.funs.ProgramUtilitiesFun__StringArray_To_String_Stop_If_Empty(the_rule_descriptor_subst_pure);
	  
	  for (Production_Rule rule : sim.vars.productionModule.Production_Rules){
	    LinkedList<String> temp_list_2 = sim.funs.ProgramUtilitiesFun__StringArray_To_LinkedList_String( ProductionModuleFun__Get_Rule_Descriptors_From_Production_Rule(rule) );
	    temp_list_2.removeFirst(); //remove p
	    temp_list_2.removeFirst(); //remove rule_name
	    String a_rule_to_match = sim.funs.ProgramUtilitiesFun__StringArray_To_String_Stop_If_Empty(sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(temp_list_2));
	    if ( a_rule_to_match.equals( to_match) ){
	      return rule.Rule_Name; //suppose there is only one origin in the rule pool.
	    }
	  }
	  return "";
	}
	
	public  boolean MultitaskingFun__Obsolete_Is_Rule_For_Multitasking(String[] The_Rule_Spec){
	  String [] key_word_list = new String [] {"=goal-2>" };
	  LinkedList<String> the_rule_spec_list = sim.funs.ProgramUtilitiesFun__StringArray_To_LinkedList_String ( The_Rule_Spec );
	  for (int y=0; y< key_word_list.length; y++) {
	    String key_word=key_word_list[y];
	    if ( the_rule_spec_list.contains( key_word) ) {
	      //GlobalUtilities.popUpMessage( The_Rule_Spec[1] );
	      return true;
	    }
	  }
	  return false;
	  
	}
	
	public  boolean MultitaskingFun__Obsolete_Is_Rule_Name_For_Multitasking(String the_rule_name){
	  //just the name method, may have problem when a new rule involving =goal-2> is composed.
	  
	  String key_word = "_goal-2_"; //may be different keyword later.
	  
	  
	  if (the_rule_name.length() >= key_word.length() &&  the_rule_name.substring(the_rule_name.length()- key_word.length() , the_rule_name.length()).equals( key_word)){
	    //GlobalUtilities.popUpMessage(the_rule_name);
	    return true;
	  }
	  else { 
	    //GlobalUtilities.popUpMessage(the_rule_name);
	    return false;
	  }
	  
	}
	
	//NetworkDetailsVisualizationFun
	
	public void NetworkDetailsVisualizationFun__Get_Audicon(){
	  	  
	  if(  sim.vars.network_Details_Visualization_Module.Show_Network_Details_Visualization == false ) return;
	  
	  sim.vars.visualization__Audicon = "";
	  for( Chunk an_audicon_chunk : sim.vars.audioDisplay.Audicon){
	    String aural_location_event_name = sim.funs.ChunkFun__Get_Chunk_Slot_Value(an_audicon_chunk, "event") ;
	    Chunk aural_location_chunk = (Chunk) sim.vars.centralParametersModule.Chunks.get(aural_location_event_name);
	    sim.vars.visualization__Audicon += "\n__________";
	    sim.vars.visualization__Audicon  += sim.funs.ChunkFun__Get_Chunk_Contents ( an_audicon_chunk );
	    sim.vars.visualization__Audicon  += "\nAt aural location event: " + sim.funs.ChunkFun__Get_Chunk_Contents (aural_location_chunk);
	    if(sim.vars.audioModule.Buffer_Stuffing_Just_Selected_Attended_Nil_Aural_Location_Names.contains( aural_location_chunk.Chunk_Name)){
	      sim.vars.visualization__Audicon += "\nis Buffer_Stuffing_Just_Selected_Attended_Nil_Aural_Location_Names";
	    }
	    sim.vars.visualization__Audicon  += "\n";
	  }
	}
	
	public void NetworkDetailsVisualizationFun__Get_Aural_Buffer_Contents(){
	  
	  // sim.vars.visualization__Aural_Buffer_Contents?
	  
	  if(  sim.vars.network_Details_Visualization_Module.Show_Network_Details_Visualization == false ) return;
	  
	  sim.vars.visualization__Aural_Buffer_Contents	   = "";
	  sim.vars.visualization__Aural_Buffer_Contents	 += "\n__________";
	  sim.vars.visualization__Aural_Buffer_Contents	+= sim.funs.ChunkFun__Get_Chunk_Contents ( sim.vars.auralBuffer.Aural_Buffer_Chunk );
	  sim.vars.visualization__Aural_Buffer_Contents	 += "\n";
	}
	
	public void NetworkDetailsVisualizationFun__Get_Aural_Location_Buffer_Contents(){
	  
	  // sim.vars.visualization__Aural_Location_Buffer_Contents
	  
	  if(  sim.vars.network_Details_Visualization_Module.Show_Network_Details_Visualization == false ) return;
	  
	  sim.vars.visualization__Aural_Location_Buffer_Contents	   = "";
	  sim.vars.visualization__Aural_Location_Buffer_Contents	 += "\n__________";
	  sim.vars.visualization__Aural_Location_Buffer_Contents	+= sim.funs.ChunkFun__Get_Chunk_Contents ( sim.vars.auralLocationBuffer.Aural_Location_Buffer_Chunk );
	  sim.vars.visualization__Aural_Location_Buffer_Contents   += "\n";
	}
	
	public void NetworkDetailsVisualizationFun__Get_Goal_Buffer_2_Contents(){
	  
	  // sim.vars.visualization__Goal_Buffer_2_Contents
	  
	  if(  sim.vars.network_Details_Visualization_Module.Show_Network_Details_Visualization == false ) return;
	  
	  sim.vars.visualization__Goal_Buffer_2_Contents = "";
	  sim.vars.visualization__Goal_Buffer_2_Contents += "\n__________";
	  sim.vars.visualization__Goal_Buffer_2_Contents += sim.funs.ChunkFun__Get_Chunk_Contents ( sim.vars.goalBuffer.Goal_Buffer_Chunk_2 );
	  sim.vars.visualization__Goal_Buffer_2_Contents += "\n";
	}
	
	public void NetworkDetailsVisualizationFun__Get_Goal_Buffer_Contents(){
	  
	  // sim.vars.visualization__Goal_Buffer_Contents
	  
	  if(  sim.vars.network_Details_Visualization_Module.Show_Network_Details_Visualization == false ) return;
	  
	  sim.vars.visualization__Goal_Buffer_Contents  = "";
	  sim.vars.visualization__Goal_Buffer_Contents += "\n__________";
	  sim.vars.visualization__Goal_Buffer_Contents += sim.funs.ChunkFun__Get_Chunk_Contents ( sim.vars.goalBuffer.Goal_Buffer_Chunk );
	  sim.vars.visualization__Goal_Buffer_Contents += "\n";
	}
	
	public void NetworkDetailsVisualizationFun__Get_Imaginal_Buffer_Contents(){
	  
	  // sim.vars.visualization__Imaginal_Buffer_Contents
	  
	  if(  sim.vars.network_Details_Visualization_Module.Show_Network_Details_Visualization == false ) return;
	  
	  sim.vars.visualization__Imaginal_Buffer_Contents  = "";
	  sim.vars.visualization__Imaginal_Buffer_Contents += "\n__________";
	  sim.vars.visualization__Imaginal_Buffer_Contents += sim.funs.ChunkFun__Get_Chunk_Contents ( sim.vars.imaginalBuffer.Imaginal_Buffer_Chunk );
	  sim.vars.visualization__Imaginal_Buffer_Contents += "\n";
	}
	
	public void NetworkDetailsVisualizationFun__Get_Motor_Details(){

	  if(  sim.vars.network_Details_Visualization_Module.Show_Network_Details_Visualization == false ) return;
	  List<String> key_names = new ArrayList<String>();
	  key_names.add("motor_preparation_time");
	  key_names.add("motor_execution_time");
	  key_names.add("motor_finish_time");
	  
	  String preparation_details = "";
	  LinkedList<Entity> entitiesMP = this.getLinkedListOfQnactrEntityInServerAndQueue("motorpreparation");
	  Iterator<Entity> itr_entitiesMP = entitiesMP.iterator();
	  while(itr_entitiesMP.hasNext()){
	    Entity temp_ent = itr_entitiesMP.next();
	    preparation_details += temp_ent.Chunk.Chunk_Type + "   ";
	    for (String key: temp_ent.Chunk.Slot.keySet()){
	      if(!key_names.contains(key)){
	        preparation_details += key + " " + temp_ent.Chunk.Slot.get(key) + "  ";
	      }
	    }
	    preparation_details += "\n" + "preparation takes time: " + temp_ent.Chunk.Slot.get("motor_preparation_time") + "\n";
	  }
	  
	  
	  String initiation_details = "";
	  LinkedList<Entity> entitiesMI = this.getLinkedListOfQnactrEntityInServerAndQueue("motorinitiation");
    Iterator<Entity> itr_entitiesMI = entitiesMI.iterator();
    while(itr_entitiesMI.hasNext()){
      Entity temp_ent = itr_entitiesMI.next();
	    initiation_details += temp_ent.Chunk.Chunk_Type + "   ";
	    for(String key: temp_ent.Chunk.Slot.keySet()){
	      if(!key_names.contains(key)){
	        initiation_details += key + " " + temp_ent.Chunk.Slot.get(key) + "  ";
	      }
	    }
	    initiation_details += "\n" + "initiation takes time: " + sim.vars.motorModule.Motor_Initiation_Time + "\n"; //as in Node 23
	  }
	  
	  String execution_details = "";
	  LinkedList<Entity> entitiesME = this.getLinkedListOfQnactrEntityInServerAndQueue("motorexecution");
    Iterator<Entity> itr_entitiesME = entitiesME.iterator();
    while(itr_entitiesME.hasNext()){
      Entity temp_ent = itr_entitiesME.next();
	    execution_details += temp_ent.Chunk.Chunk_Type + "   ";
	    for(String key: temp_ent.Chunk.Slot.keySet()){
	      if(!key_names.contains(key)){
	        execution_details += key + " " + temp_ent.Chunk.Slot.get(key) + "  ";
	      }
	    }
	    execution_details += "\n" + "motor  finishing  takes  time: " + temp_ent.Chunk.Slot.get("motor_finish_time");
	    execution_details += "\n" + "motor cool down takes time: " + temp_ent.Chunk.Slot.get("motor_execution_time") + "\n";
	  }
	  
	  sim.vars.visualization__Motor_Details  = "";
	  sim.vars.visualization__Motor_Details += "\nMotor Preparation: \n";
	  sim.vars.visualization__Motor_Details += preparation_details;
	  
	  sim.vars.visualization__Motor_Details += "\nMotor Initiation: \n";
	  sim.vars.visualization__Motor_Details += initiation_details;
	  
	  sim.vars.visualization__Motor_Details += "\nMotor Execution: \n";
	  sim.vars.visualization__Motor_Details += execution_details;
	  sim.vars.visualization__Motor_Details += "\n";
	  
	  sim.vars.visualization__Motor_Details += "\nLast Prepared:\n";
	  sim.vars.visualization__Motor_Details += sim.funs.ChunkFun__Get_Chunk_Contents(sim.vars.motorModule.Last_Prep);
	  sim.vars.visualization__Motor_Details += "\n";
	  
	  sim.vars.visualization__Motor_Details += "\nLast Command:\n";
	  sim.vars.visualization__Motor_Details += sim.vars.motorModule.Last_Command_Chunk_Type;
	  sim.vars.visualization__Motor_Details += "\n";
	}
	
	public void NetworkDetailsVisualizationFun__Get_Retrieval_Buffer_Contents(){
	  
	  // sim.vars.visualization__Retrieval_Buffer_Contents
	  
	  if(  sim.vars.network_Details_Visualization_Module.Show_Network_Details_Visualization == false ) return;
	  
	  sim.vars.visualization__Retrieval_Buffer_Contents  = "";
	  sim.vars.visualization__Retrieval_Buffer_Contents += "\n__________";
	  sim.vars.visualization__Retrieval_Buffer_Contents += sim.funs.ChunkFun__Get_Chunk_Contents ( sim.vars.retrievalBuffer.Retrieval_Buffer_Chunk );
	  sim.vars.visualization__Retrieval_Buffer_Contents += "\n";
	}
	
	public void NetworkDetailsVisualizationFun__Get_Speech_Details(){

	  if(  sim.vars.network_Details_Visualization_Module.Show_Network_Details_Visualization == false ) return;
	  List<String> key_names = new ArrayList<String>();
	  //key_names.Add("motor_preparation_time");
	  //key_names.Add("motor_execution_time");
	  //key_names.Add("motor_finish_time");
	  
	  String preparation_details = "";
	  LinkedList<Entity> entitiesSP = this.getLinkedListOfQnactrEntityInServerAndQueue("speechpreparation");
    Iterator<Entity> itr_entitiesSP = entitiesSP.iterator();
    while(itr_entitiesSP.hasNext()){
      Entity temp_ent = itr_entitiesSP.next();
      preparation_details += temp_ent.Chunk.Chunk_Type + "   ";
	    for(String key: temp_ent.Chunk.Slot.keySet()){
	      if(!key_names.contains(key)){
	        preparation_details += key + " " + temp_ent.Chunk.Slot.get(key) + "  ";
	      }
	    }
	    preparation_details += "\n" ;//here may add time info
	  }
	  
	  
	  String initiation_details = "";
	  LinkedList<Entity> entitiesSI = this.getLinkedListOfQnactrEntityInServerAndQueue("speechinitiation");
    Iterator<Entity> itr_entitiesSI = entitiesSI.iterator();
    while(itr_entitiesSI.hasNext()){
      Entity temp_ent = itr_entitiesSI.next();
	    initiation_details += temp_ent.Chunk.Chunk_Type + "   ";
	    for(String key: temp_ent.Chunk.Slot.keySet()){
	      if(!key_names.contains(key)){
	        initiation_details += key + " " + temp_ent.Chunk.Slot.get(key) + "  ";
	      }
	    }
	    initiation_details += "\n" + "initiation takes time: " + sim.vars.speechModule.Speech_Initiation_Time + "\n"; //as in Node 33
	  }
	  
	  String execution_details = "";
	  LinkedList<Entity> entitiesSE = this.getLinkedListOfQnactrEntityInServerAndQueue("speechexecution");
    Iterator<Entity> itr_entitiesSE = entitiesSE.iterator();
    while(itr_entitiesSE.hasNext()){
      Entity temp_ent = itr_entitiesSE.next();
	    execution_details += temp_ent.Chunk.Chunk_Type + "   ";
	    for(String key: temp_ent.Chunk.Slot.keySet()){
	      if(!key_names.contains(key)){
	        execution_details += key + " " + temp_ent.Chunk.Slot.get(key) + "  ";
	      }
	    }
	    //				execution_details += "\n" + "motor  finishing  takes  time: " + temp_ent.Chunk.Slot["motor_finish_time"];
	    //				execution_details += "\n" + "motor cool down takes time: " + temp_ent.Chunk.Slot["motor_execution_time"] + "\n";
	  }
	  
	  sim.vars.visualization__Speech_Details  = "";
	  sim.vars.visualization__Speech_Details += "\nSpeech Preparation: \n";
	  sim.vars.visualization__Speech_Details += preparation_details;
	  
	  sim.vars.visualization__Speech_Details += "\nSpeech Initiation: \n";
	  sim.vars.visualization__Speech_Details += initiation_details;
	  
	  sim.vars.visualization__Speech_Details += "\nSpeech Execution: \n";
	  sim.vars.visualization__Speech_Details += execution_details;
	  sim.vars.visualization__Speech_Details += "\n";
	}
	
	public void NetworkDetailsVisualizationFun__Get_Temporal_Buffer_Contents(){

	  if(  sim.vars.network_Details_Visualization_Module.Show_Network_Details_Visualization == false ) return;
	  
	  sim.vars.visualization__Temporal_Buffer_Contents   = "";
	  sim.vars.visualization__Temporal_Buffer_Contents  += "\n__________";
	  sim.vars.visualization__Temporal_Buffer_Contents  += sim.funs.ChunkFun__Get_Chunk_Contents (sim.vars.temporalBuffer.Temporal_Buffer_Chunk );
	  sim.vars.visualization__Temporal_Buffer_Contents  += "\n";
	}
	
	public void NetworkDetailsVisualizationFun__Get_Visicon(){

	  if(  sim.vars.network_Details_Visualization_Module.Show_Network_Details_Visualization == false ) return;
	  
	  sim.vars.visualization__Visicon = "";
	  for( Chunk a_visicon_chunk: sim.vars.visualDisplay.Visicon){
	    String visual_location_screen_pos = sim.funs.ChunkFun__Get_Chunk_Slot_Value(a_visicon_chunk, "screen-pos") ;
	    Chunk visual_location_chunk = (Chunk) sim.vars.centralParametersModule.Chunks.get(visual_location_screen_pos);
	    
	    sim.vars.visualization__Visicon += "\n__________";
	    sim.vars.visualization__Visicon += sim.funs.ChunkFun__Get_Chunk_Contents ( a_visicon_chunk );
	    sim.vars.visualization__Visicon += "\nAt visual location: " + sim.funs.ChunkFun__Get_Chunk_Contents (visual_location_chunk);
	    if(sim.vars.visionModule.Buffer_Stuffing_Just_Selected_Attended_Nil_Visual_Location_Names.contains( visual_location_chunk.Chunk_Name)){
	      sim.vars.visualization__Visicon += "\nis Buffer_Stuffing_Just_Selected_Attended_Nil_Visual_Location_Names";
	    }
	    sim.vars.visualization__Visicon += "\n";
	  }

	}
	
	public void NetworkDetailsVisualizationFun__Get_Visual_Buffer_Contents(){

	  if(  sim.vars.network_Details_Visualization_Module.Show_Network_Details_Visualization == false ) return;
	  
	  sim.vars.visualization__Visual_Buffer_Contents   = "";
	  sim.vars.visualization__Visual_Buffer_Contents  += "\n__________";
	  sim.vars.visualization__Visual_Buffer_Contents  += sim.funs.ChunkFun__Get_Chunk_Contents ( sim.vars.visualBuffer.Visual_Buffer_Chunk );
	  sim.vars.visualization__Visual_Buffer_Contents   += "\n";
	}
	
	public void NetworkDetailsVisualizationFun__Get_Visual_Location_Buffer_Contents(){
	  
	  if(  sim.vars.network_Details_Visualization_Module.Show_Network_Details_Visualization == false ) return;
	  
	  sim.vars.visualization__Visual_Location_Buffer_Contents   = "";
	  sim.vars.visualization__Visual_Location_Buffer_Contents  += "\n__________";
	  sim.vars.visualization__Visual_Location_Buffer_Contents  += sim.funs.ChunkFun__Get_Chunk_Contents (sim.vars.visualLocationBuffer.Visual_Location_Buffer_Chunk );
	  sim.vars.visualization__Visual_Location_Buffer_Contents  += "\n";
	}	
	
	//	ParametersFun

	public  LinkedList<String> ParametersFun__Load_ACTR_Model_Into_Lines(){

	  //1. each original line in a string. linked these lines in a linkedlist
	  LinkedList<String> return_list = new LinkedList<String>();
	  int i=1; //line number
	  //int empty_lines = 0; //track continuously empty lines
	  boolean comment_area_open = false; // track (false)  #|   (true)  |#   (false)   area comment
	  
	  String line = null;
    try
    {
      while ((line = sim.files.QN_ACTR_Model_Initialization.reader.readLine()) != null) {
        String temp_line = line;
             
        temp_line = sim.funs.ProgramUtilitiesFun__String_Remove_Space_And_Tab_From_The_Beginning(temp_line);
        if(comment_area_open){ //when the comment area is open
          //close the comment area
          if(temp_line.length() >= 2){ //play it safe
            if(temp_line.substring(0, 2).equals( "|#") ){ //close comment area
              comment_area_open = false;
              temp_line = temp_line.substring(2); //remove the first two "|#", the rest of the line may be informative
              temp_line = sim.funs.ProgramUtilitiesFun__String_Remove_Space_And_Tab_From_The_Beginning(temp_line); //remove potential spaces and tabs
            }
            else if (temp_line.substring(0, 2).equals( "#|")){//double open error
              System.err.println("Error! ParametersFun__Load_ACTR_Model_Into_Lines temp_line.Substring(0, 2) == #| double open error. Line: " + temp_line);
              return null;
            }
            else{//keep it open and skip this line
              i++;
              continue; //go to the next line
            }
          }
          else {//temp_line.Length = 0 or 1, keep it open and skip this line
            i++;
            continue; //go to the next line
          }
        }
        
        if(!temp_line.equals( "" ) ){ //this may be an informative line, need to think about ; and |#
        
          //change a line into lower case except for letters in quotations. e.g.,  :TEXt ( "B" )  ->   :text ( "B" )
          boolean quotation_area_open = false; // track (false)  "   (true)  "   (false)   quotation area 
          String new_temp_line = "";
          
          for (int ichar = 0; ichar < temp_line.length(); ichar++) {
            char a_char = temp_line.charAt(ichar);
            if( a_char == '\"' ) quotation_area_open = !quotation_area_open; 
            if(quotation_area_open == false ) new_temp_line = new_temp_line + Character.toString(a_char).toLowerCase();
            else new_temp_line = new_temp_line + Character.toString(a_char);   //outside "" -> ToLower,  inside "" -> unchanged
          }
          
          if (quotation_area_open) System.err.println( "Error! ParametersFun__Load_ACTR_Model_Into_Lines has a line ends with quotation area open: " + temp_line); //each line must have quotation marks closed
          temp_line = new_temp_line;
          //old temp_line = temp_line.ToLower();  //change all Initialization codes to lowercase
          
          
          //ignore chars after that the ';' comment
          int j;
          for(j = 0; j < temp_line.length() ; j++){
            if(temp_line.charAt(j) == ';')break;
          }
          temp_line = temp_line.substring(0, j);
          
          if(!temp_line.equals( "" )){ //this may be an informative line, need to think about |#
            if(temp_line.length() >= 2){ //play it safe
              if(temp_line.substring(0, 2).equals( "#|" )){ //open comment area
                comment_area_open = true;
                i++;
                continue; //go to the next line
              }
            }
            if(!temp_line.equals( "\n" )){ 
              return_list.addLast( temp_line );  // this the the line not in a comment area, without space and ; comments
              //System.out.println(temp_line);
            }
          }
        }
        i++;
        
      }
    } catch (IOException e)
    {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }    
    
	  
	  if(comment_area_open == true) System.err.println("ParametersFun__Load_ACTR_Model_Into_Lines Error. comment_area_open == true At the end.");
	  
	  return return_list;
	}
	
	public  void ParametersFun__Load_QN_ACTR_Model_Initialization(){
	  
	  //this function loads original ACT-R code that defined a user-specified task model from a text file
	  //QN_ACTR_Model_Initialization.txt copies the "(define-model" part from an ACT-R model.lisp
	  
	  LinkedList<String> lines_without_comments = sim.funs.ParametersFun__Load_ACTR_Model_Into_Lines(); //load each line that is not commented out into the list, without beginning spaces nor commented out parts. //also check for #| |# comment syntax error
	  
	  //debug:
	  //GlobalUtilities.popUpMessage(sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty(sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(lines_without_comments)));
	  
	  LinkedList<String> standard_lists = sim.funs.ParametersFun__Standardize_ACTR_Model_Lines( lines_without_comments ); //can catch some ACT-R "quick-and-dirty" conditions and actions that are not included in QN (!something!); separate (word word); check ( ) syntax error; change - arg (ACT-R format) into -arg (QN format); separate one line into multiple strings if needed.
	  
	  //debug:
	  //GlobalUtilities.popUpMessage(sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty(sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(standard_lists)));
	  
	  standard_lists = sim.funs.ParametersFun__Substitute_Experiment_Specifics_Conditions(standard_lists);
	  //debug:
	  //GlobalUtilities.popUpMessage(sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty(sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(standard_lists)));
	  
	  
	  //get each group of source code, switch case depending on the head string, like sgp, p, spp, or other undefined errors.
	  LinkedList<String> a_list = sim.funs.ParametersFun__Remove_A_List_From_Initialization_Lists (standard_lists);
	  while(a_list != null){
	    //debug:
	    //GlobalUtilities.popUpMessage(sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty(sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(a_list)));
	    //GlobalUtilities.popUpMessage(sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty(sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(standard_lists)));
	    
	    String function_name = (String) a_list.get(0);
	    switch(function_name){
	      
	      
	      case "add-dm":	{ //add chunks to model chunk list and declarative memory.
	        //GlobalUtilities.popUpMessage(sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty(sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(adding_chunk_names)));			
	        a_list.removeFirst(); //remove "add-dm"
	        LinkedList<String> adding_chunk_names = sim.funs.ParametersFun__Get_Add_DM_Adding_Chunk_Names(  a_list  ); //ProgramUtilitiesFun__LinkedListString_Clone inside the function
	        //GlobalUtilities.popUpMessage(sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty(sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(a_list)));
	        
	        LinkedList<String> temp_list = sim.funs.ParametersFun__Remove_A_List_From_Initialization_Lists (  a_list  );
	        while(temp_list != null){
	          //GlobalUtilities.popUpMessage(sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty(sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(a_list)));
	          
	          //first check if the temp_list contains any to be added chunk name
	          boolean contains_a_name = false;
	          for(String a_to_be_added_chunk_name: adding_chunk_names){
	            LinkedList<String> temp_list_clone = sim.funs.ProgramUtilitiesFun__LinkedListString_Clone (temp_list);
	            String a_chunk_name = temp_list_clone.get(0);
	            temp_list_clone.removeFirst();
	            if( temp_list_clone.contains( a_to_be_added_chunk_name ) ) {
	              if (a_to_be_added_chunk_name.equals( a_chunk_name)) {
	                //add-dm has a_to_be_added_chunk_name  == a_chunk_name 
	                //keep contains_a_name = false will be OK.
	              }
	              else{
	                contains_a_name = true;
	                break;
	              }
	            }
	          }
	          
	          if(contains_a_name){ //delay adding the chunk
	            temp_list.addFirst( "(" );
	            temp_list.addLast ( ")" );
	            sim.funs.ProgramUtilitiesFun__LinkedListString_Append ( a_list, temp_list );
	          }
	          else{ //adding the chunk now
	            sim.vars.programGlobalVar__DeclarativeModule_Add_DM_Input_List.addLast(   sim.funs.ProgramUtilitiesFun__LinkedListString_Clone( temp_list )   ); //for reset DM
	            //GlobalUtilities.popUpMessage(sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty(sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(temp_list)));
	            temp_list = sim.funs.ProgramUtilitiesFun__Combine_Quotation_In_LinkedList_String (temp_list);
	            
	            Chunk temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(temp_list));
	            sim.funs.DeclarativeModuleFun__Add_DM_Chunk_With_Chunk(temp_chunk);
	            
	            //GlobalUtilities.popUpMessage(sim.funs.ProgramUtilitiesFun__LinkedListString_To_String_Show_Empty(temp_list));
	          }
	          
	          //start the next chunk adding
	          adding_chunk_names = sim.funs.ParametersFun__Get_Add_DM_Adding_Chunk_Names(  a_list  ); //ProgramUtilitiesFun__LinkedListString_Clone inside the function
	          temp_list = sim.funs.ParametersFun__Remove_A_List_From_Initialization_Lists (a_list);
	        }
	        
	        break;
	      }
	      /* //obsolete add-dm before trying to solve the problem:    in ACT-R,  as long as an atom is used as a chunk name, no matter it appears early or late in add-dm, it will not be automatically defined as a default chunk. ACTR-QN currently cannot do this, so a user must first define chunks that will be used in other chunk definition.
					case "add-dm":	{ //add chunks to model chunk list and declarative memory.

			//GlobalUtilities.popUpMessage(sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty(sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(a_list)));
						a_list.RemoveFirst(); //remove "add-dm"
						LinkedList<String> temp_list = sim.funs.ParametersFun__Remove_A_List_From_Initialization_Lists (  a_list  );
						while(temp_list != null){
							sim.vars.programGlobalVar__DeclarativeModule_Add_DM_Input_List.addLast(   sim.funs.ProgramUtilitiesFun__LinkedListString_Clone( temp_list )   ); //for reset DM
							
			//GlobalUtilities.popUpMessage(sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty(sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(temp_list)));
							Chunk temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(temp_list));
							DeclarativeModuleFun__Add_DM_Chunk_With_Chunk(temp_chunk);
							temp_list = sim.funs.ParametersFun__Remove_A_List_From_Initialization_Lists (a_list);
						}
						
					break;
					}
	       */
	      
	      case "add_other_car_to_world3d":	{ 
	        a_list.removeFirst(); //remove the function name, leave all the parameters
	        TaskTemplateFun__Add_Other_Car_To_World3D( a_list  );
	        break;
	      }
	      
	      case "add_road_to_world3d":	{ 
	        a_list.removeFirst(); //remove the function name, leave all the parameters
	        TaskTemplateFun__Add_Road_To_World3D( a_list  );
	        break;
	      }
	      
	      
//	      case "add_trials_from_single_discrete_task_visual_display_template":	{ //define the task/experiment that is performed by the model.
//	        a_list.removeFirst(); //remove the function name, leave all the parameters
//	        TaskTemplateFun__Obsolete_Add_Trials_From_Single_Discrete_Task_Visual_Display_Template( a_list  );
//	        break;
//	      }
	      
	      
	      case "add_trials_from_discrete_display_feedback_two_stages_method":	{ //define the task/experiment that is performed by the model.
	        a_list.removeFirst(); //remove the function name, leave all the parameters
	        TaskTemplateFun__Add_Trials_From_discrete_display_feedback_two_stages_method( a_list  );
	        break;
	      }
	      
	      /*
					case "add_trial_response_collection_from_keyboard_single_key_per_trial_template":	{ //define the task/experiment that is performed by the model.
						a_list.RemoveFirst(); //remove the function name, leave all the parameters
						TaskTemplateFun__Obsolete_Add_Trial_Response_Collection_From_Keyboard_Single_Key_Per_Trial_Template( a_list  );
					break;
					}
	       */
	      
	      case "chunk-type":	{
	        //GlobalUtilities.popUpMessage("ToDo: ParametersFun__Load_QN_ACTR_Model_Initialization add chunk-type defining function");
	        a_list.removeFirst(); //remove chunk-type
	        sim.funs.ChunkFun__Add_Chunk_Type(a_list);
	        break;
	      }
	      case "goal-focus":	{
	        a_list.removeFirst(); //remove "goal-focus"
	        String chunk_name = (String) a_list.get(0);
	        sim.vars.programGlobalVar__IntentionalModule_Initial_Goal_Focus_Chunk_Name = chunk_name; //for reset/re-initialize goal focus //not using List because goal-focus should be called only once
	        Chunk temp_chunk = sim.funs.DeclarativeModuleFun__Find_DM_Chunk_By_Chunk_Name(chunk_name);
	        if (!temp_chunk.Chunk_Name.equals(chunk_name)) System.out.println("ParametersFun__Load_QN_ACTR_Model_Initialization goal-focus's first parameter is not a chunk name in Declarative Memory.");
	        ProductionModuleFun__Goal_Focus(temp_chunk);
	        
	        
	        break;
	      }
	      case "goal-2-focus":	{
	        a_list.removeFirst(); //remove "goal-2-focus"
	        String chunk_name = (String) a_list.getFirst();
	        sim.vars.programGlobalVar__IntentionalModule_Initial_Goal_2_Focus_Chunk_Name = chunk_name; //for reset/re-initialize goal-2 focus //not using List because goal-focus should be called only once
	        Chunk temp_chunk = sim.funs.DeclarativeModuleFun__Find_DM_Chunk_By_Chunk_Name(chunk_name);
	        if (!temp_chunk.Chunk_Name.equals(chunk_name)) System.out.println("ParametersFun__Load_QN_ACTR_Model_Initialization goal-2-focus's first parameter is not a chunk name in Declarative Memory.");
	        ProductionModuleFun__Goal_2_Focus(temp_chunk);
	        break;
	      }
	      case "p":	{
	        sim.vars.programGlobalVar__ProductionModule_P_Rules_Definition_Input.addLast( a_list );
	        ProductionModuleFun__Add_Production_Rule ( sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(a_list) );
	        break;
	      }
	      case "sdp":	{ 
	        a_list.removeFirst(); //remove sdp, leave all the parameters
	        
	        sim.vars.programGlobalVar__DeclarativeModule_Sdp_Input.addLast( a_list );
	        
	        sim.funs.ParametersFun__Declarative_Module_Sdp ( sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(a_list)  );
	        break;
	      }
	      case "set-all-base-levels":	{ //set-all-base-levels REFERENCE-COUNT CREATION-TIME
	        a_list.removeFirst(); //remove set-all-base-levels, leave all the parameters
	        
	        sim.vars.programGlobalVar__DeclarativeModule_Set_All_Base_Levels_Input = sim.funs.ProgramUtilitiesFun__LinkedListString_Clone( a_list );
	        
	        sim.funs.DeclarativeModuleFun__Set_All_Base_Levels ( sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(a_list)  );
	        break;
	      }
	      case "set-base-levels":	{ 
	        a_list.removeFirst(); //remove set-base-levels
	        LinkedList<String> temp_list = sim.funs.ParametersFun__Remove_A_List_From_Initialization_Lists (a_list);
	        while(temp_list != null){
	          //GlobalUtilities.popUpMessage(sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty(sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(temp_list)));
	          if (temp_list.size() < 2 || temp_list.size() > 3)System.out.println("set-base-levels must have two or three parameters. DM chunk name, first number, and creation time (optional)");
	          else{
	            String creation_time = ""; //no creation time change by default
	            if (temp_list.size() == 3) creation_time = (String) temp_list.getLast();
	            String chunk_name = (String) temp_list.getFirst();
	            temp_list.removeFirst();
	            String first_number = (String) temp_list.getFirst();
	            
	            //for reset DM 
	            Three_Tuple temp_tuple = new Three_Tuple();
	            temp_tuple.Ob1 = chunk_name;
	            temp_tuple.Ob2 = Double.parseDouble(first_number);
	            temp_tuple.Ob3 = creation_time;
	            sim.vars.programGlobalVar__DeclarativeModule_Set_Base_Levels_Input.addLast( temp_tuple);
	            
	            sim.funs.DeclarativeModuleFun__Set_Base_Levels(chunk_name , Double.parseDouble(first_number) , creation_time );
	          }
	          
	          temp_list = sim.funs.ParametersFun__Remove_A_List_From_Initialization_Lists (a_list);
	        }
	        break;
	      }
	      case "set-similarities":	{ 
	        a_list.removeFirst(); //remove similarities
	        LinkedList<String> temp_list = sim.funs.ParametersFun__Remove_A_List_From_Initialization_Lists (a_list);
	        while(temp_list != null){
	          //GlobalUtilities.popUpMessage(sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty(sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(temp_list)));
	          if (temp_list.size() != 3)System.out.println("set-similarities must have three parameters. DM chunk name1, name2, and similarity");
	          else{
	            String name1 = (String) temp_list.getFirst();
	            temp_list.removeFirst();
	            String name2 = (String) temp_list.getFirst();
	            String similarity_string = (String) temp_list.getLast() ;
	            if (sim.funs.ProgramUtilitiesFun__Is_String_Double (similarity_string) == false) System.out.println("set-similarities must have the third parameter as a double number for similarity: " + similarity_string);
	            double similarity = Double.parseDouble(similarity_string );
	            
	            //for reset DM
	            Three_Tuple temp_tuple = new Three_Tuple();
	            temp_tuple.Ob1 = name1;
	            temp_tuple.Ob2 = name2;
	            temp_tuple.Ob3 = similarity;
	            sim.vars.programGlobalVar__DeclarativeModule_Set_Similarities_Input.addLast( temp_tuple );
	            
	            sim.funs.DeclarativeModuleFun__Set_Similarities(name1, name2, similarity);
	          }
	          temp_list = sim.funs.ParametersFun__Remove_A_List_From_Initialization_Lists (a_list);
	        }
	        break;
	      }
	      
	      
	      
	      
	      
	      case "set_world3d_driving_method":	{ 
	        a_list.removeFirst(); //remove the function name, leave all the parameters
	        TaskTemplateFun__Set_World3D_Driving_Method ( a_list  );
	        break;
	      }		
	      
	      case "set_parameter_who_drive":	{ 
	        a_list.removeFirst(); //remove the function name, leave all the parameters
	        
	        World3D_Template_Driving_Method the_method = TaskTemplateFun__Get_World3D_Driving_Method_Object();
	        if(the_method == null )System.out.println("WARNING! set_parameter_who_drive is called before any World3D_Template_Driving_Method is defined.");
	        else the_method.Who_Drive = a_list.getFirst();
	        break;
	      }	
	      
	      case "set_docking_target_location":	{ 
	        a_list.removeFirst(); //remove the function name, leave all the parameters
	        String all_parameters = sim.funs.ProgramUtilitiesFun__LinkedListString_To_String_Show_Empty(a_list);
	        String loc_X = a_list.getFirst();
	        a_list.removeFirst();
	        String loc_Y = a_list.getFirst();
	        a_list.removeFirst();
	        String loc_Z = a_list.getFirst();
	        if (sim.funs.ProgramUtilitiesFun__Is_String_Double (loc_X) == false) {
	          System.err.println("Error! set_docking_target_location need all parameters to be double numbers rather than: " + all_parameters);
	          break;
	        }
	        sim.vars.spaceDrivingVar__Target_Initiatial_Location_And_Rotation.Ob1 = Double.parseDouble(loc_X);  //in cm
	        sim.vars.spaceDrivingVar__Target_Initiatial_Location_And_Rotation.Ob2 = Double.parseDouble(loc_Y);
	        sim.vars.spaceDrivingVar__Target_Initiatial_Location_And_Rotation.Ob3 = Double.parseDouble(loc_Z);
	        
	        //currently don't have rotation setup
	        sim.vars.spaceDrivingVar__Target_Initiatial_Location_And_Rotation.Ob4 = 0.0;  // in degree
	        sim.vars.spaceDrivingVar__Target_Initiatial_Location_And_Rotation.Ob5 = 0.0;
	        sim.vars.spaceDrivingVar__Target_Initiatial_Location_And_Rotation.Ob6 = 0.0; 
	        break;
	      }
	      
	      case "set_self_initial_location_and_rotation":	{ 
	        a_list.removeFirst(); //remove the function name, leave all the parameters
	        String all_parameters = sim.funs.ProgramUtilitiesFun__LinkedListString_To_String_Show_Empty(a_list);
	        String loc_X = a_list.getFirst();
	        a_list.removeFirst();
	        String loc_Y = a_list.getFirst();
	        a_list.removeFirst();
	        String loc_Z = a_list.getFirst();
	        a_list.removeFirst();
	        String Pitch = a_list.getFirst();
	        a_list.removeFirst();
	        String Yaw = a_list.getFirst();
	        a_list.removeFirst();
	        String Roll = a_list.getFirst();
	        
	        if (sim.funs.ProgramUtilitiesFun__Is_String_Double (loc_X) == false) {
	          System.out.println("Error! set_self_initial_location_and_rotation need all parameters to be double numbers rather than: " + all_parameters);
	          break;
	        }
	        
	        sim.vars.spaceDrivingVar__Self_Initiatial_Location_And_Rotation.Ob1 = Double.parseDouble(loc_X);  //in cm
	        sim.vars.spaceDrivingVar__Self_Initiatial_Location_And_Rotation.Ob2 = Double.parseDouble(loc_Y);
	        sim.vars.spaceDrivingVar__Self_Initiatial_Location_And_Rotation.Ob3 = Double.parseDouble(loc_Z);
	        
	        sim.vars.spaceDrivingVar__Self_Initiatial_Location_And_Rotation.Ob4 = Double.parseDouble(Pitch);  // in degree
	        sim.vars.spaceDrivingVar__Self_Initiatial_Location_And_Rotation.Ob5 = Double.parseDouble(Yaw);
	        sim.vars.spaceDrivingVar__Self_Initiatial_Location_And_Rotation.Ob6 = Double.parseDouble(Roll); 
	        
	        break;
	      }
	      
	      case "sgp":	{ //set general parameters
	        a_list.removeFirst(); //remove sgp, leave all the parameters
	        sim.funs.ParametersFun__General_Sgp ( sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(a_list)  );
	        break;
	      }
	      case "spp":	{ //set production parameters
	        a_list.removeFirst(); //remove spp, leave all the parameters
	        sim.vars.programGlobalVar__ProductionModule_Spp_Input.addLast( a_list );
	        sim.funs.ParametersFun__UtilityModule_Spp ( sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(a_list)  );
	        break;
	      }
	      case "start-hand-at-mouse": {
	        sim.vars.programGlobalVar__MotorModule_Start_Hand_At_Mouse = true; 
	        MotorModuleFun__Start_Hand_At_Mouse();
	        break;
	      }
	      
	      case "start-right-hand-at-touch-screenxy": {
		        sim.vars.programGlobalVar__MotorModule_Start_Right_Hand_At_Touch_Screen = true;
		        sim.vars.motorModule.Right_Hand.Object_Type_In_Hand = "touchscreen";
	    	  	a_list.removeFirst(); //remove "start-right-hand-at-touch-screen"
		        int pixelLocX  =  Integer.parseInt( (String) a_list.get(0) );
		        a_list.removeFirst(); //remove X number
		        int pixelLocY  =  Integer.parseInt( (String) a_list.get(0) );
		        MotorModuleFun__Set_Hand_Location("right", pixelLocX, pixelLocY);
		        break;
		  }
	      
	      case "start-left-hand-at-touch-screenxy": {
		        sim.vars.programGlobalVar__MotorModule_Start_Left_Hand_At_Touch_Screen = true;
		        sim.vars.motorModule.Left_Hand.Object_Type_In_Hand = "touchscreen";
	    	  	a_list.removeFirst(); //remove "start-left-hand-at-touch-screen"
		        int pixelLocX  =  Integer.parseInt( (String) a_list.get(0) );
		        a_list.removeFirst(); //remove X number
		        int pixelLocY  =  Integer.parseInt( (String) a_list.get(0) );
		        MotorModuleFun__Set_Hand_Location("left", pixelLocX, pixelLocY);
		        break;
		  }
	      
	      case "use_predefined_model_setup":	{
	        a_list.removeFirst(); //remove "goal-focus"
	        String setup_name = (String) a_list.getFirst();
	        sim.vars.programGlobalVar__Use_Predefined_Model_Setup = setup_name;
	        TaskTemplateFun__Initialize_Predefined_Model_Setup();
	        break;
	      }
	      case "use_task_dbt_template":	{ //define the task/experiment that is performed by the model.
	        a_list.removeFirst(); //remove the function name, leave all the parameters
	        TaskTemplateFun__Use_Task_DBT_Template ( a_list  );
	        break;
	      }
	      
	      case "use_world3d_template":	{ 
	        a_list.removeFirst(); //remove the function name, leave all the parameters
	        TaskTemplateFun__Use_World3D_Template ( a_list  );
	        break;
	      }
	      
	      
	      default:	{
	        if(sim.vars.printingModule.Popout_Message) System.out.println ("WARNING! ParametersFun__Load_QN_ACTR_Model_Initialization. The function_name is undefined: " + function_name + ". And the line is ignored: " + sim.funs.ProgramUtilitiesFun__LinkedListString_To_String(a_list) );
	        break;
	      }
	    }
	    
	    a_list = sim.funs.ParametersFun__Remove_A_List_From_Initialization_Lists (standard_lists);
	  }
	  
	  //debug:
	  //DeclarativeModuleFun__Print_All_DM_Chunks();
	  //ProductionModuleFun__Print_All_Productions();
	  
	}
	


	public  LinkedList<String> ParametersFun__Remove_A_List_From_Initialization_Lists(LinkedList<String> the_standard_lists){
	  
	  if( the_standard_lists.size() == 0 ) return null;
	  if( !the_standard_lists.getFirst().equals("(") ){ //since count != 0, this is guarenteed.
	    System.err.println("Error! ParametersFun__Remove_A_List_From_Initialization_Lists , (String) the_standard_lists.First.Value != (, but " + (String) the_standard_lists.getFirst());
	    return null;
	  }
	  LinkedList<String> return_list = new LinkedList<String> ();
	  the_standard_lists.removeFirst(); //remove "("
	  int open_left_parenthesis = 1; //tracking ( ) correspondence
	  while(open_left_parenthesis != 0){ //may move to the end of the list. Parenthesis match is guranteed by ParametersFun__Standardize_ACTR_Model_Lines
	    String a_string = (String) the_standard_lists.getFirst();
	    if (a_string.equals( "(")) open_left_parenthesis++;
	    else if (a_string.equals( ")")) open_left_parenthesis--;
	    else {} //do nothing
	    return_list.addLast( a_string );
	    the_standard_lists.removeFirst();
	  }
	  return_list.removeLast(); //remove the one more ) added last.
	  
	  
	  
	  
	  return return_list;
	}
	
	public  LinkedList<String> ParametersFun__Standardize_ACTR_Model_Lines(LinkedList<String> the_lines_without_comments){
	  
	  //System.out.println("ParametersFun__Standardize_ACTR_Model_Lines ln: " + the_lines_without_comments.getFirst());
	  
	  LinkedList<String> return_list = new LinkedList<String>();
	  Enumeration<String> enum_lines = Collections.enumeration(the_lines_without_comments);
	  while(enum_lines.hasMoreElements()){ //each line
	    String a_line = (String) enum_lines.nextElement();
	    
	    //System.out.println("ParametersFun__Standardize_ACTR_Model_Lines ln: " + a_line);
	    
	    
	    //let them go
	    /*
				if(a_line[0] == '!'){ //catch !output! such ACT-R conditions and actions; 
					GlobalUtilities.popUpMessage("ParametersFun__Standardize_ACTR_Model_Lines has ! ACT-R functions that is omitted in QN: " + a_line );
					continue; //go to the next line
				}
	     */
	    
	    LinkedList<String> temp_list =  sim.funs.ProgramUtilitiesFun__StringArray_To_LinkedList_String(sim.funs.ProgramUtilitiesFun__String_To_StringArray(a_line));
	    Enumeration<String> enum_string = Collections.enumeration(temp_list);
	    while(enum_string.hasMoreElements()){ //each string in a line
	      String a_string = (String)enum_string.nextElement();
	      if(a_string.contains("(") || a_string.contains(")")  ){ // add safety space in front and after each ( and )
	        String temp_string = "";
	        for(int v=0; v< a_string.length(); v++){
	          char a_char = a_string.charAt(v);
	          if(a_char == '(' || a_char == ')'){
	            temp_string = temp_string + ' ' + a_char + ' '; //string + char = string
	          }
	          else{
	            temp_string = temp_string + a_char;
	          }
	        }
	        a_string = temp_string;
	      }
	      return_list =    sim.funs.ProgramUtilitiesFun__LinkedListString_Append(     return_list,  sim.funs.ProgramUtilitiesFun__StringArray_To_LinkedList_String( sim.funs.ProgramUtilitiesFun__String_To_StringArray(a_string) ) );  //separate (word word) into (  word word  ); 
	    }
	  }
	  
	  //check ( ) syntax error; 
	  Enumeration<String> return_list_enum = Collections.enumeration(return_list);
	  int open_left_parenthesis = 0; //tracking ( ) correspondence
	  while(return_list_enum.hasMoreElements()){
	    String a_string = (String) return_list_enum.nextElement();
	    if (a_string.equals( "(")) open_left_parenthesis++;
	    else if (a_string.equals( ")")) open_left_parenthesis--;
	    else {} //do nothing
	    
	    if (open_left_parenthesis < 0) { 
	      System.err.println("ParametersFun__Standardize_ACTR_Model_Lines Error. One ) is not preceded by a ( " );
	      break;
	    }
	  }
	  if (open_left_parenthesis > 0) { 
	    System.err.println("ParametersFun__Standardize_ACTR_Model_Lines Error. " + open_left_parenthesis + " open left parentheses are not closed");
	  } // open_left_parenthesis < 0 cases are handled above in the while loop.
	  
	  /*
			//old problemtic
			IEnumerator return_list_enum = return_list.GetEnumerator();
			string last_case = ""; //tracking ( ) correspondence
			while(return_list_enum.MoveNext()){
				string a_string = (String) return_list_enum.Current;
				if(last_case.equals( "" )){
					if (a_string.equals( ")" ) ) GlobalUtilities.popUpMessage("ParametersFun__Standardize_ACTR_Model_Lines Error. Missing a '(' before ')' ");
					if (a_string.equals( "("))last_case= "(";
				}
				else if(last_case.equals( "(")){
					if (a_string.equals( "(")) GlobalUtilities.popUpMessage("ParametersFun__Standardize_ACTR_Model_Lines Error. Missing a ')' before '(' ");
					if (a_string.equals( ")") )last_case= "";
				}
				else GlobalUtilities.popUpMessage("ParametersFun__Standardize_ACTR_Model_Lines last_case error: " + last_case);
			}
	   */
	  
	  
	  
	  
	  //new method
	  //change - arg (ACT-R format) into -arg (QN format);  "-", "<", "<=", ">", ">="
	  String the_previous_string = "";
	  boolean inside_a_production_rule_definition = false;
	  boolean inside_a_bang_name_bang_definition = false;
	  int open_in_p_left_parenthesis = -1; //tracking ( p ..( ...) . ) correspondence
	  LinkedList<String> special_test_cases = sim.funs.ProgramUtilitiesFun__StringArray_To_LinkedList_String(new String[] { "-", "<", "<=", ">", ">="  } );
	  
	  //System.out.println("ParametersFun__Standardize_ACTR_Model_Lines return_list: " + return_list.size());
	  
	  //LinkedList<String> temp_node = return_list;
	  
	  if(return_list == null || return_list.size() == 0 || return_list.getFirst() == null) {
	    System.err.println("Error! Cannot find or load the QN_ACTR_Model_Initialization.txt");
	    SimSystem.abort();
	  }
	  
	  for(int v = 0; v < return_list.size(); v++){
	    if (return_list.get(v)!= null){
	      String a_string = (String) return_list.get(v);
	      if ( the_previous_string.equals( "(" ) && a_string.equals( "p" ))  {
	        inside_a_production_rule_definition = true;
	        open_in_p_left_parenthesis = 1;
	      }
	      else if ( inside_a_production_rule_definition &&  a_string.equals( "(" )) open_in_p_left_parenthesis ++;
	      else if ( inside_a_production_rule_definition &&  a_string.equals( ")")) open_in_p_left_parenthesis --;
	      
	      if ( inside_a_production_rule_definition && open_in_p_left_parenthesis == 0 ){
	        inside_a_production_rule_definition = false;
	        open_in_p_left_parenthesis = -1;
	        inside_a_bang_name_bang_definition = false;
	      }
	      
	      //if ( inside_a_production_rule_definition ) return_list.Value = a_string.ToUpper(); //a test, success
	      if ( inside_a_production_rule_definition && a_string.charAt(0) == '!' ) inside_a_bang_name_bang_definition = true;
	      if ( inside_a_production_rule_definition && inside_a_bang_name_bang_definition &&  ( a_string.equals( "==>") || (a_string.length() >= 3 && a_string.charAt(a_string.length()-1) == '>') ) ){
	        //out of !name! when reaching ==> or =goal> like keywords
	        inside_a_bang_name_bang_definition = false;
	      }
	      
	      if ( inside_a_production_rule_definition && !inside_a_bang_name_bang_definition ) { 
	        
	        //System.out.println("ParametersFun__Standardize_ACTR_Model_Lines return_list, the_previous_string and a_string: " + the_previous_string + ", " + a_string);
	        
	        if( special_test_cases.contains(the_previous_string ) ){
	          return_list.set (v, the_previous_string + a_string); 
	          return_list.remove( v-1 );  // v-1 is index
	        }
	      }
	      
	      the_previous_string = a_string;
	    }
	    
	    //actually, don't have to change .x to 0.x, because when convert to doulbe .x will become 0.x
	    /*
			double test = System.Double.valueOf("  .4  ");
			Model.Message (test);
	     */
	    
	    /*
			//standardize decimal .x to 0.x
			LinkedList<String> return_list_2 = new LinkedList<String>();
			return_list_enum = return_list.GetEnumerator();
			while(return_list_enum.MoveNext()){
				string a_string = (String) return_list_enum.Current;
				if(a_string[0] == '.') a_string = "0" + a_string;
				return_list_2.addLast (a_string);
			}
	     */
	  }
	  
	  //System.out.println("ParametersFun__Standardize_ACTR_Model_Lines return_list: " + sim.funs.ProgramUtilitiesFun__LinkedListString_To_String_Show_Empty (return_list ) );
	  
	  return return_list;
	}
		
	public  LinkedList<String> ParametersFun__Substitute_Experiment_Specifics_Conditions(LinkedList<String> input_list){
	  
	  
	  //TODO Plugin_Functions
	  System.out.println("TODO Plugin_Functions ParametersFun__Substitute_Experiment_Specifics_Conditions");
	  return input_list; // temp
	  
	  
//	  LinkedList<String> return_string_list = new LinkedList<String>();
//	  
//	  for(String a_string: input_list){
//	    String a_return_string = a_string;
//	    if(a_string.length() >= 5 && a_string.substring(0,5).equals( "*sub*")){
//	      String key = a_string.substring(5);
//	      
////	      a_return_string = Plugin_Functions.Substitute_Experiment_Specifics_Conditions(key);
//	      
//	      if(a_return_string.length() >= "*list_by_quote*".length() && a_return_string.substring(0,"*list_by_quote*".length()).equals( "*list_by_quote*")){
//	        String list_in_string = a_return_string.substring("*list_by_quote*".length());
//	        LinkedList<String> the_list = sim.funs.ProgramUtilitiesFun__String_To_LinkedListString_By_Quote(list_in_string);
//	        for ( String new_string: the_list){
//	          return_string_list.addLast( new_string );
//	        }
//	      }
//	      else return_string_list.addLast(a_return_string);
//	    }
//	    else return_string_list.addLast(a_return_string);
//	  }
//	  return return_string_list;
	  
	}
	
	public  void ParametersFun__UtilityModule_Spp(String[] the_string_array){
	  int i;
	  LinkedList<Three_Tuple> parameter_list = new LinkedList<Three_Tuple>();
	  //make a list of all the spp details
	  for (i = 0; i < the_string_array.length; i++){
	    //GlobalUtilities.popUpMessage(the_string_array[i].Substring(0,1) );
	    if (!the_string_array[i].substring(0,1).equals( ":")){ //three parameter version. for the specific rule
	      Three_Tuple temp_tuple = new  Three_Tuple();
	      temp_tuple.Ob1 = the_string_array[i];
	      i++;
	      if(i >= the_string_array.length){
	        System.out.println("ParametersFun__UtilityModule_Spp has i >= the_string_array.Length");
	        return;
	      }
	      temp_tuple.Ob2 = the_string_array[i];
	      i++;
	      if(i >= the_string_array.length){
	        System.out.println("ParametersFun__UtilityModule_Spp has i >= the_string_array.Length");
	        return;
	      }
	      temp_tuple.Ob3 = the_string_array[i];
	      parameter_list.addLast (temp_tuple);		
	    }
	    else {//two parameters version, for all rules
	      String key = the_string_array[i];
	      i++;
	      if(i >= the_string_array.length){
	        System.out.println("ParametersFun__UtilityModule_Spp has i >= the_string_array.Length");
	        return;
	      }
	      String value = the_string_array[i];
	      //need to set the key and value for each rule
	      for (Production_Rule temp_rule: sim.vars.productionModule.Production_Rules) {
	        String rule_name = temp_rule.Rule_Name;
	        Three_Tuple temp_tuple = new  Three_Tuple();
	        temp_tuple.Ob1 = rule_name;
	        temp_tuple.Ob2 = key;
	        temp_tuple.Ob3 = value;
	        parameter_list.addLast (temp_tuple);
	      }
	    }
	  }
	  
	  
	  /*
				if(the_string_array.Length != 3) {
					GlobalUtilities.popUpMessage("ToDo: ParametersFun__UtilityModule_Spp input array length != 3 " );
				}
	   */
	  for (Three_Tuple temp_tuple: parameter_list) {	
	    String the_rule_name = (String)temp_tuple.Ob1;
	    String The_Key = (String)temp_tuple.Ob2;
	    String The_Value = (String)temp_tuple.Ob3;
	    
	    switch(The_Key){
	      case ":at":{
	        if (!sim.vars.utilityModule.utility_Computation_Method.equals( "temporal-difference-reinforcement")) System.out.println("Warning: spp " + The_Key + " needs sim.vars.utilityModule.utility_Computation_Method == \"temporal-difference-reinforcement\" ");
	        if( !ProgramUtilitiesFun__Is_String_Double( The_Value ) ) System.err.println("Error! ParametersFun__UtilityModule_Spp needs The_Key: " + The_Key + " to be a double rather than: " + The_Value   );
	        (ProductionModuleFun__Find_Production_Rule_Pointer_By_Rule_Name(the_rule_name)).Action_Time =  (double) Double.parseDouble( The_Value );
	        break;
	      }
	      case ":c":{
	        if (!sim.vars.utilityModule.utility_Computation_Method.equals("PG-C")) System.out.println("Warning: spp " + The_Key + " needs sim.vars.utilityModule.utility_Computation_Method == \"PG-C\" ");
	        sim.funs.ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.PG_C_c, the_rule_name, The_Value);
	        break;
	      }
	      case ":efforts":{
	        if (!sim.vars.utilityModule.utility_Computation_Method.equals("PG-C")) System.out.println("Warning: spp " + The_Key + " needs sim.vars.utilityModule.utility_Computation_Method == \"PG-C\" ");
	        sim.funs.ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.PG_C_efforts_for_cost_calculation, the_rule_name, The_Value );
	        break;
	      }
	      case ":effort":{
	        if (!sim.vars.utilityModule.utility_Computation_Method.equals("PG-C")) System.out.println("Warning: spp " + The_Key + " needs sim.vars.utilityModule.utility_Computation_Method == \"PG-C\" ");
	        sim.funs.ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.PG_C_effort_rule_firing_time, the_rule_name, The_Value );
	        break;
	      }
	      case ":failures":{
	        if (!sim.vars.utilityModule.utility_Computation_Method.equals("PG-C")) System.out.println("Warning: spp " + The_Key + " needs sim.vars.utilityModule.utility_Computation_Method == \"PG-C\" ");
	        sim.funs.ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.PG_C_failures_num_for_each_rule, the_rule_name, The_Value );
	        break;
	      }
	      case ":reward":{
	        if (!sim.vars.utilityModule.utility_Computation_Method.equals( "temporal-difference-reinforcement")) System.out.println("Warning: spp " + The_Key + " needs sim.vars.utilityModule.utility_Computation_Method == \"temporal-difference-reinforcement\" ");
	        if(sim.vars.utilityModule.ul == true){
	          sim.funs.ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.reward, the_rule_name, The_Value);
	        }
	        else{
	          System.out.println("ParametersFun__UtilityModule_Spp #|Warning: PARAMETER REWARD CAN ONLY BE SET WHEN UL IS T. |# (spp" + the_rule_name + " " + The_Key + " " + The_Value + ") is ignored." );
	        }
	        break;
	      }
	      case ":success":{
	        if (!sim.vars.utilityModule.utility_Computation_Method.equals("PG-C")) System.out.println("Warning: spp " + The_Key + " needs sim.vars.utilityModule.utility_Computation_Method == \"PG-C\" ");
	        sim.funs.ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.PG_C_success_flags, the_rule_name, null );
	        break;
	      }
	      case ":successes":{
	        if (!sim.vars.utilityModule.utility_Computation_Method.equals("PG-C")) System.out.println("Warning: spp " + The_Key + " needs sim.vars.utilityModule.utility_Computation_Method == \"PG-C\" ");
	        sim.funs.ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.PG_C_successes_num_for_each_rule, the_rule_name, The_Value );
	        break;
	      }
	      case ":u":{
	        sim.funs.ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.U_N_Without_Noise, the_rule_name, The_Value);
	        break;
	      }
	      
	      default:{
	        System.err.println("ParametersFun__UtilityModule_Spp has undefined case: " + The_Key);
	        break;
	      }
	    }
	    //currently don't have other key
	  }
	}
	
	public  void ParametersFun__Declarative_Module_Sdp(String[] the_string_array){
	  int i;
	  LinkedList<Three_Tuple> parameter_list = new LinkedList<Three_Tuple>();
	  //make a list of all the sdp details
	  for (i = 0; i < the_string_array.length; i++){
	    //GlobalUtilities.popUpMessage(the_string_array[i].Substring(0,1) );
	    if (!the_string_array[i].substring(0,1).equals( ":" )){ //three parameter version. for the specific DM chunk
	      Three_Tuple temp_tuple = new  Three_Tuple();
	      temp_tuple.Ob1 = the_string_array[i];
	      i++;
	      if(i >= the_string_array.length){
	        System.out.println("ParametersFun__Declarative_Module_Sdp has i >= the_string_array.Length");
	        return;
	      }
	      temp_tuple.Ob2 = the_string_array[i];
	      i++;
	      if(i >= the_string_array.length){
	        System.out.println("ParametersFun__Declarative_Module_Sdp has i >= the_string_array.Length");
	        return;
	      }
	      temp_tuple.Ob3 = the_string_array[i];
	      parameter_list.addLast (temp_tuple);		
	    }
	    else {//two parameters version, for all DM chunks
	      String key = the_string_array[i];
	      i++;
	      if(i >= the_string_array.length){
	        System.out.println("ParametersFun__Declarative_Module_Sdp has i >= the_string_array.Length");
	        return;
	      }
	      String value = the_string_array[i];
	      //need to set the key and value for each DM chunk
	      for (Chunk temp_chunk: sim.vars.declarativeModule.DM_Chunk) {
	        String chunk_name = temp_chunk.Chunk_Name;
	        Three_Tuple temp_tuple = new  Three_Tuple();
	        temp_tuple.Ob1 = chunk_name;
	        temp_tuple.Ob2 = key;
	        temp_tuple.Ob3 = value;
	        parameter_list.addLast (temp_tuple);
	      }
	    }
	  }
	  
	  
	  
	  for (Three_Tuple temp_tuple: parameter_list) {	
	    String the_chunk_name = (String)temp_tuple.Ob1;
	    String The_Key = (String)temp_tuple.Ob2;
	    String The_Value = (String)temp_tuple.Ob3;
	    int chunk_id = DeclarativeModuleFun__Find_The_DM_Chunk_ID_By_Chunk_Name(the_chunk_name);
	    Chunk temp_chunk_pointer = new Chunk();
	    if (chunk_id < 0 ) {
	      System.err.println("ParametersFun__Declarative_Module_Sdp has chunk_id < 0 ");
	      continue;
	    }
	    else {
	      temp_chunk_pointer = sim.funs.ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer( sim.vars.declarativeModule.DM_Chunk, chunk_id);
	    }
	    
	    switch(The_Key){
	      case ":creation-time":{ 
	        /*
						(:creation-time
			              (cond ((and (numberp value) (<= value (mp-time)))
			                     (setf (chunk-creation-time chunk) value))
			                    (t
			                     (print-warning
			                      "CHUNK CREATION-TIME MUST BE SET TO A NUMBER LESS THAN OR EQUAL TO THE CURRENT TIME.")
			                     :error)))
	         */
	        double temp_value = Double.parseDouble ( The_Value );
	        if(sim.funs.ProgramUtilitiesFun__Is_String_Double(The_Value) && temp_value <= GlobalUtilities.round(temp_value,3) ) {
	          temp_chunk_pointer.Creation_Time = temp_value;
	        }
	        else {
	          System.err.println("ParametersFun__Declarative_Module_Sdp error, CHUNK CREATION-TIME MUST BE SET TO A NUMBER LESS THAN OR EQUAL TO THE CURRENT TIME.");
	        }
	        break;
	      }
	      case ":references":{ 
	        /*
					(:reference-count
			              (cond ((null (dm-bll dm))
			                     (print-warning "WHEN BLL DISABLED BASE-LEVEL SHOULD BE SET DIRECTLY")
			                     :error)
			                    ((null (dm-ol dm))
			                     (print-warning "WHEN OL IS DISABLED BASE-LEVEL MUST BE SET THROUGH THE REFERENCE-LIST")
			                     :error)
			                    ((not (numberp value))
			                     (print-warning "CHUNK REFERENCE-COUNT MUST BE SET TO A NUMBER")
			                     :error) 
			                    ((numberp (dm-ol dm)) 
			                     (cond ((= (length (chunk-reference-list chunk)) value)
			                            ;; do nothing
			                            )
			                           ((> (length (chunk-reference-list chunk)) value)
			                            (setf (chunk-reference-list chunk) (subseq (chunk-reference-list chunk) 0 value)))
			                           ((= (length (chunk-reference-list chunk)) (dm-ol dm))
			                            ;; do nothing
			                            )
			                           (t 
			                            (setf (chunk-reference-list chunk) (adapt-references dm value (chunk-creation-time chunk)))))
			                     (setf (chunk-reference-count chunk) value))
			                    (t ;; dm-ol = t so just set the number...
			                     (setf (chunk-reference-count chunk) value))))
	         */
	        if(sim.vars.declarativeModule.bll.equals( "nil")) {
	          System.out.println("ParametersFun__Declarative_Module_Sdp warning: WHEN BLL DISABLED BASE-LEVEL SHOULD BE SET DIRECTLY");
	        }
	        else if(sim.vars.centralParametersModule.ol.equals( "nil")){
	          System.out.println("ParametersFun__Declarative_Module_Sdp warning: WHEN OL IS DISABLED BASE-LEVEL MUST BE SET THROUGH THE REFERENCE-LIST");
	        }
	        else if(sim.funs.ProgramUtilitiesFun__Is_String_Double(The_Value) == false){
	          System.out.println("ParametersFun__Declarative_Module_Sdp warning: CHUNK REFERENCE-COUNT MUST BE SET TO A NUMBER");
	        }
	        else if( sim.funs.ProgramUtilitiesFun__Is_String_Double( sim.vars.centralParametersModule.ol ) ) {
	          long temp_value = Long.parseLong ( The_Value );
	          if (temp_chunk_pointer.Presentation_Time_References.size() == temp_value){
	            //do nothing
	          }
	          else if (temp_chunk_pointer.Presentation_Time_References.size() > temp_value){
	            System.out.println("ToDo: ParametersFun__Declarative_Module_Sdp when temp_chunk_pointer.Presentation_Time_References.Count > temp_value, need: (setf (chunk-reference-list chunk) (subseq (chunk-reference-list chunk) 0 value))");
	          }
	          else if (temp_chunk_pointer.Presentation_Time_References.size() == Integer.parseInt( sim.vars.centralParametersModule.ol ) ){
	            //do nothing
	          }
	          else {
	            System.out.println("ToDo: ParametersFun__Declarative_Module_Sdp when temp_chunk_pointer.Presentation_Time_References.Count > temp_value, need: (setf (chunk-reference-list chunk) (adapt-references dm value (chunk-creation-time chunk)))");
	          }
	          temp_chunk_pointer.Number_Of_Presentations = temp_value;
	        }
	        else { //dm-ol = t so just set the number...
	          temp_chunk_pointer.Number_Of_Presentations = Long.parseLong ( The_Value )	;			
	        }
	        
	        break;
	      }
	      default:{
	        System.err.println("ParametersFun__Declarative_Module_Sdp has undefined case: " + The_Key);
	        break;
	      }
	    }
	    //currently don't have other key
	  }	
	}
	
	public  void ParametersFun__General_Sgp(String[] The_Key_Value_Pairs){
	  
	  // sim.vars.programGlobalVar__Rand1_Seed1?
	  
	  int j;
	  
	  if (The_Key_Value_Pairs.length < 2) System.err.println("ParametersFun__General_Sgp error! need at least 2 strings");
	  
	  //GlobalUtilities.popUpMessage(sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty(The_Key_Value_Pairs));
	  
	  for (j = 0; j < The_Key_Value_Pairs.length; j+=2){
	    String para_name = The_Key_Value_Pairs[j].toLowerCase();
	    switch (para_name)
	    {
	      case ":act":
	      {
	        if (The_Key_Value_Pairs[j+1].equals( "t" )) sim.vars.declarativeModule.act = true;
	        else if (The_Key_Value_Pairs[j+1].equals( "nil" )) sim.vars.declarativeModule.act = false;
	        else System.err.println ("ParametersFun__General_Sgp :act error! the value must be string t or nil");
	        break;
	      }
	      case ":alpha":
	      {
	        //could be either TD or PG-C //if (!sim.vars.utilityModule.utility_Computation_Method.equals("temporal-difference-reinforcement")) GlobalUtilities.popUpMessage("Warning: sgp " + The_Key_Value_Pairs[j].ToLower() +" needs sim.vars.utilityModule.utility_Computation_Method == \"temporal-difference-reinforcement\" ");
	        if( !ProgramUtilitiesFun__Is_String_Double( The_Key_Value_Pairs[j+1] ) ) System.err.println("Error! ParametersFun__General_Sgp needs para_name: " + para_name + " to be a double rather than: " + The_Key_Value_Pairs[j+1]   );
	        sim.vars.utilityModule.alpha =  (double) Double.parseDouble (The_Key_Value_Pairs[j+1] );
	        break;
	      }
	      case ":ans":
	      {
	        sim.vars.declarativeModule.ans =  The_Key_Value_Pairs[j+1] ;
	        break;
	      }
	      case ":aural-activation":
	      {
	        if( !ProgramUtilitiesFun__Is_String_Double( The_Key_Value_Pairs[j+1] ) ) System.err.println("Error! ParametersFun__General_Sgp needs para_name: " + para_name + " to be a double rather than: " + The_Key_Value_Pairs[j+1]   );
	        sim.vars.auralBuffer.Aural_Activation =  (double) Double.parseDouble (The_Key_Value_Pairs[j+1] );
	        break;
	      }
	      case ":aural-location-activation":
	      {
	        if( !ProgramUtilitiesFun__Is_String_Double( The_Key_Value_Pairs[j+1] ) ) System.err.println("Error! ParametersFun__General_Sgp needs para_name: " + para_name + " to be a double rather than: " + The_Key_Value_Pairs[j+1]   );
	        sim.vars.auralLocationBuffer.Aural_Location_Activation =  (double) Double.parseDouble (The_Key_Value_Pairs[j+1] );
	        break;
	      }
	      
	      case ":blc":
	      {
	        if( !ProgramUtilitiesFun__Is_String_Double( The_Key_Value_Pairs[j+1] ) ) System.out.println("Error! ParametersFun__General_Sgp needs para_name: " + para_name + " to be a double rather than: " + The_Key_Value_Pairs[j+1]   );
	        sim.vars.declarativeModule.blc =  (double) Double.parseDouble (The_Key_Value_Pairs[j+1] );
	        break;
	      }
	      
	      
	      case ":bll":
	      {
	        sim.vars.declarativeModule.bll =  The_Key_Value_Pairs[j+1] ;
	        break;
	      }
	      
	      case ":cursor-noise":
	      {
	        if (The_Key_Value_Pairs[j+1].equals( "t") ) sim.vars.motorModule.Cursor_Noise = true;
	        else if (The_Key_Value_Pairs[j+1].equals( "nil" )) sim.vars.motorModule.Cursor_Noise = false;
	        else System.err.println ("ParametersFun__General_Sgp " + para_name + " error! the value must be string t or nil");
	        
	        break;
	      }
	      
	      case ":declarative-finst-span":
	      {
	        if( !ProgramUtilitiesFun__Is_String_Double( The_Key_Value_Pairs[j+1] ) ) System.err.println("Error! ParametersFun__General_Sgp needs para_name: " + para_name + " to be a double rather than: " + The_Key_Value_Pairs[j+1]   );
	        sim.vars.declarativeModule.Declarative_Finst_Span = (double) Double.parseDouble(The_Key_Value_Pairs[j+1] );
	        break;
	      }
	      case ":declarative-num-finsts":
	      {
	        if( !ProgramUtilitiesFun__Is_String_Int( The_Key_Value_Pairs[j+1] ) ) System.err.println("Error! ParametersFun__General_Sgp needs para_name: " + para_name + " to be an int rather than: " + The_Key_Value_Pairs[j+1]   );
	        sim.vars.declarativeModule.Declarative_Num_Finsts = Integer.parseInt(The_Key_Value_Pairs[j+1] );
	        break;
	      }
	      
	      case ":default-target-width":
	      {
	        if( !ProgramUtilitiesFun__Is_String_Double( The_Key_Value_Pairs[j+1] ) ) System.err.println("Error! ParametersFun__General_Sgp needs para_name: " + para_name + " to be a double rather than: " + The_Key_Value_Pairs[j+1]   );
	        sim.vars.motorModule.Default_Target_Width = (double) Double.parseDouble(The_Key_Value_Pairs[j+1] );
	        break;
	      }
	      
	      case ":egs":
	      {
	        if( !ProgramUtilitiesFun__Is_String_Double( The_Key_Value_Pairs[j+1] ) ) System.err.println("Error! ParametersFun__General_Sgp needs para_name: " + para_name + " to be a double rather than: " + The_Key_Value_Pairs[j+1]   );
	        sim.vars.utilityModule.egs =  (double) Double.parseDouble(The_Key_Value_Pairs[j+1] );
	        break;
	      }
	      
	      case ":epl":
	      {
	        if (The_Key_Value_Pairs[j+1].equals( "t") ) sim.vars.productionCompilationModule.epl = true;
	        else if (The_Key_Value_Pairs[j+1].equals( "nil") ) sim.vars.productionCompilationModule.epl = false;
	        else System.err.println ("ParametersFun__General_Sgp :epl error! the value must be string t or nil");
	        break;
	      }
	      case ":er":
	      {
	        if (The_Key_Value_Pairs[j+1].equals( "t" )) sim.vars.centralParametersModule.er = true;
	        else if (The_Key_Value_Pairs[j+1].equals( "nil") ) sim.vars.centralParametersModule.er = false;
	        else System.err.println ("ParametersFun__General_Sgp :er error! the value must be string t or nil");
	        break;
	      }
	      case ":esc":
	      {
	        if (The_Key_Value_Pairs[j+1].equals( "t") ) sim.vars.centralParametersModule.esc = true;
	        else if (The_Key_Value_Pairs[j+1].equals( "nil" )) sim.vars.centralParametersModule.esc = false;
	        else System.err.println ("ParametersFun__General_Sgp :esc error! the value must be string t or nil");
	        break;
	      }
	      case ":g":
	      {
	        if( !ProgramUtilitiesFun__Is_String_Double( The_Key_Value_Pairs[j+1] ) ) System.err.println("Error! ParametersFun__General_Sgp needs para_name: " + para_name + " to be a double rather than: " + The_Key_Value_Pairs[j+1]   );
	        sim.vars.utilityModule.PG_C_g =  (double) Double.parseDouble(The_Key_Value_Pairs[j+1] );
	        break;
	      }
	      case ":ga":
	      {
	        if( !ProgramUtilitiesFun__Is_String_Double( The_Key_Value_Pairs[j+1] ) ) System.err.println("Error! ParametersFun__General_Sgp needs para_name: " + para_name + " to be a double rather than: " + The_Key_Value_Pairs[j+1]   );
	        sim.vars.goalBuffer.ga =  (double) Double.parseDouble(The_Key_Value_Pairs[j+1] );
	        break;
	      }
	      case ":imaginal-activation":
	      {
	        if( !ProgramUtilitiesFun__Is_String_Double( The_Key_Value_Pairs[j+1] ) ) System.err.println("Error! ParametersFun__General_Sgp needs para_name: " + para_name + " to be a double rather than: " + The_Key_Value_Pairs[j+1]   );
	        sim.vars.imaginalBuffer.Imaginal_Activation =  (double) Double.parseDouble(The_Key_Value_Pairs[j+1] );
	        break;
	      }
	      case ":imaginal-delay":
	      {
	        if( !ProgramUtilitiesFun__Is_String_Double( The_Key_Value_Pairs[j+1] ) ) System.err.println("Error! ParametersFun__General_Sgp needs para_name: " + para_name + " to be a double rather than: " + The_Key_Value_Pairs[j+1]   );
	        sim.vars.imaginaryModule.Imaginal_Delay =  (double) Double.parseDouble(The_Key_Value_Pairs[j+1] );
	        break;
	      }
	      
	      case ":incremental-mouse-moves":
	      {
	        sim.vars.motorModule.Incremental_Mouse_Moves = The_Key_Value_Pairs[j+1] ;
	        break;
	      }
	      
	      case ":iu":
	      {
	        if (!sim.vars.utilityModule.utility_Computation_Method.equals( "temporal-difference-reinforcement")) System.out.println("Warning: sgp " + The_Key_Value_Pairs[j].toLowerCase() +" needs sim.vars.utilityModule.utility_Computation_Method == \"temporal-difference-reinforcement\" ");
	        if( !ProgramUtilitiesFun__Is_String_Double( The_Key_Value_Pairs[j+1] ) ) System.err.println("Error! ParametersFun__General_Sgp needs para_name: " + para_name + " to be a double rather than: " + The_Key_Value_Pairs[j+1]   );
	        sim.vars.utilityModule.iu =  (double) Double.parseDouble(The_Key_Value_Pairs[j+1] );
	        break;
	      }
	      case ":lf":
	      {
	        if( !ProgramUtilitiesFun__Is_String_Double( The_Key_Value_Pairs[j+1] ) ) System.err.println("Error! ParametersFun__General_Sgp needs para_name: " + para_name + " to be a double rather than: " + The_Key_Value_Pairs[j+1]   );
	        sim.vars.declarativeModule.lf =  (double) Double.parseDouble(The_Key_Value_Pairs[j+1] );
	        break;
	      }
	      
	      case ":mas":
	      {
	        sim.vars.declarativeModule.mas = The_Key_Value_Pairs[j+1] ;
	        break;
	      }
	      case ":min-fitts-time":
	      {
	        if( !ProgramUtilitiesFun__Is_String_Double( The_Key_Value_Pairs[j+1] ) ) System.err.println("Error! ParametersFun__General_Sgp needs para_name: " + para_name + " to be a double rather than: " + The_Key_Value_Pairs[j+1]   );
	        double the_number =  Double.parseDouble(The_Key_Value_Pairs[j+1] );
	        if(the_number <=0 ) System.out.println("Error! ParametersFun__General_Sgp needs para_name: " + para_name + " to be larger than zero rather than: " + The_Key_Value_Pairs[j+1]   );
	        sim.vars.motorModule.Min_Fitts_Time = (double) the_number;
	        break;
	      }	
	      
	      case ":mouse-fitts-coeff":
	      {
	        if( !ProgramUtilitiesFun__Is_String_Double( The_Key_Value_Pairs[j+1] ) ) System.err.println("Error! ParametersFun__General_Sgp needs para_name: " + para_name + " to be a double rather than: " + The_Key_Value_Pairs[j+1]   );
	        double the_number =  Double.parseDouble(The_Key_Value_Pairs[j+1] );
	        if(the_number <=0 ) System.err.println("Error! ParametersFun__General_Sgp needs para_name: " + para_name + " to be larger than zero rather than: " + The_Key_Value_Pairs[j+1]   );
	        sim.vars.motorModule.Mouse_Fitts_Coeff = (double) the_number;
	        break;
	      }		
	      case ":mp":
	      {
	        sim.vars.declarativeModule.mp = The_Key_Value_Pairs[j+1];
	        break;
	      }
	      case ":needs-mouse":
	      {
	        if(sim.vars.printingModule.Popout_Message)System.out.println ("WARNING! ToDo: ParametersFun__General_Sgp " + The_Key_Value_Pairs[j].toLowerCase() + " currently undefined." );
	        break;
	      }
	      case ":nu":
	      {
	        if (!sim.vars.utilityModule.utility_Computation_Method.equals( "temporal-difference-reinforcement")) System.out.println("Warning: sgp " + The_Key_Value_Pairs[j].toLowerCase() +" needs sim.vars.utilityModule.utility_Computation_Method == \"temporal-difference-reinforcement\" ");
	        if( !ProgramUtilitiesFun__Is_String_Double( The_Key_Value_Pairs[j+1] ) ) System.err.println("Error! ParametersFun__General_Sgp needs para_name: " + para_name + " to be a double rather than: " + The_Key_Value_Pairs[j+1]   );
	        sim.vars.utilityModule.nu = (double) Double.parseDouble(The_Key_Value_Pairs[j+1] );
	        break;
	      }
	      
	      case ":ol":
	      {
	        sim.vars.centralParametersModule.ol = The_Key_Value_Pairs[j+1];
	        break;
	      }
	      
	      case ":pct":
	      {
	        if (The_Key_Value_Pairs[j+1].equals( "t" )) sim.vars.productionCompilationModule.pct = true;
	        else if (The_Key_Value_Pairs[j+1].equals( "nil" )) sim.vars.productionCompilationModule.pct = false;
	        else System.err.println("ParametersFun__General_Sgp :pct error! the value must be string t or nil");
	        break;
	      }
	      case ":peck-fitts-coeff":
	      {
	        if( !ProgramUtilitiesFun__Is_String_Double( The_Key_Value_Pairs[j+1] ) ) System.err.println("Error! ParametersFun__General_Sgp needs para_name: " + para_name + " to be a double rather than: " + The_Key_Value_Pairs[j+1]   );
	        double the_number =  Double.parseDouble(The_Key_Value_Pairs[j+1] );
	        if(the_number <=0 ) System.err.println("Error! ParametersFun__General_Sgp needs para_name: " + para_name + " to be larger than zero rather than: " + The_Key_Value_Pairs[j+1]   );
	        sim.vars.motorModule.Peck_Fitts_Coeff = (double) the_number;
	        break;
	      }
	      case ":pl":
	      {
	        if (!sim.vars.utilityModule.utility_Computation_Method.equals("PG-C")) System.out.println("Warning: sgp " + The_Key_Value_Pairs[j].toLowerCase() +" needs sim.vars.utilityModule.utility_Computation_Method == \"PG-C\" ");
	        sim.vars.utilityModule.PG_C_pl = The_Key_Value_Pairs[j+1];
	        break;
	      }
	      
	      case ":qn-enable-all-default-result-outputs":
	      {
	        if (The_Key_Value_Pairs[j+1].equals( "t") ) PrintingFun__Enable_All_Default_Result_Outputs (true);
	        else if (The_Key_Value_Pairs[j+1].equals( "nil") ) PrintingFun__Enable_All_Default_Result_Outputs ( false );
	        else System.err.println("ParametersFun__General_Sgp :qn-enable-all-default-result-outputs error! the value must be string t or nil");
	        break;
	      }
	      
	      case ":qn-show-hide-all-animator3d-comments":
	      {
	        if (The_Key_Value_Pairs[j+1].equals( "t") ) AnimatorModuleFun__Animator3D_Show_Hide_All_Comments (true);
	        else if (The_Key_Value_Pairs[j+1].equals( "nil") ) AnimatorModuleFun__Animator3D_Show_Hide_All_Comments ( false );
	        else System.err.println("ParametersFun__General_Sgp :qn-show-hide-all-animator3d-comments error! the value must be string t or nil");
	        break;
	      }
	      
	      case ":randomize-time":
	      {
	        sim.vars.centralParametersModule.randomize_time = The_Key_Value_Pairs[j+1];
	        break;
	      }
	      
	      case ":rt":
	      {
	        if( !ProgramUtilitiesFun__Is_String_Double( The_Key_Value_Pairs[j+1] ) ) System.out.println("Error! ParametersFun__General_Sgp needs para_name: " + para_name + " to be a double rather than: " + The_Key_Value_Pairs[j+1]   );
	        sim.vars.declarativeModule.rt =  (double) Double.parseDouble(The_Key_Value_Pairs[j+1] );
	        break;
	      }
	      case ":seed":  //e.g., :seed ( 12345 0 )
	      {	
	        sim.vars.centralParametersModule.Randomize_Seed_For_Display_Sequence = false;
	        
	        if ( !The_Key_Value_Pairs[j+1].equals( "(" )) System.out.println("ParametersFun__General_Sgp :seed error, parameters must be a list with two numbers and starts with ( ");
	        if( !ProgramUtilitiesFun__Is_String_Int( The_Key_Value_Pairs[j+2] ) ) System.err.println("Error! ParametersFun__General_Sgp needs para_name: " + para_name + " to be an int rather than: " + The_Key_Value_Pairs[j+2]   );
	        if( !ProgramUtilitiesFun__Is_String_Int( The_Key_Value_Pairs[j+3] ) ) System.err.println("Error! ParametersFun__General_Sgp needs para_name: " + para_name + " to be an int rather than: " + The_Key_Value_Pairs[j+3]   );
	        sim.vars.programGlobalVar__Rand1_Seed1 = Integer.parseInt(The_Key_Value_Pairs[j+2] );
	        sim.vars.programGlobalVar__Rand1_Seed2 = Integer.parseInt(The_Key_Value_Pairs[j+3] );
	        if ( !The_Key_Value_Pairs[j+4].equals( ")" ) )System.err.println("ParametersFun__General_Sgp :seed error, parameters must be a list with two numbers and ends with ) ");
	        j = j + 3; //normally there is 1 parameter, but here it has 4. compensate for this.
	        break;
	      }
	      case ":show-focus":
	      {
	        if (The_Key_Value_Pairs[j+1].equals( "t") ) sim.vars.animatorModule.Show_Visual_Attention_Focus = true;
	        else if (The_Key_Value_Pairs[j+1].equals( "nil") ) sim.vars.animatorModule.Show_Visual_Attention_Focus = false;
	        else System.err.println("ParametersFun__General_Sgp :show-focus error! the value must be string t or nil");
	        break;
	      }
	      case ":time-master-start-increment":
	      {
	        if( !ProgramUtilitiesFun__Is_String_Double( The_Key_Value_Pairs[j+1] ) ) System.err.println("Error! ParametersFun__General_Sgp needs para_name: " + para_name + " to be a double rather than: " + The_Key_Value_Pairs[j+1]   );
	        sim.vars.temporalModule.Time_Master_Start_Increment =  (double) Double.parseDouble (The_Key_Value_Pairs[j+1] );
	        break;
	      }
	      case ":time-mult":
	      {
	        if( !ProgramUtilitiesFun__Is_String_Double( The_Key_Value_Pairs[j+1] ) ) System.err.println("Error! ParametersFun__General_Sgp needs para_name: " + para_name + " to be a double rather than: " + The_Key_Value_Pairs[j+1]   );
	        sim.vars.temporalModule.Time_Mult =  (double) Double.parseDouble(The_Key_Value_Pairs[j+1] );
	        break;
	      }
	      case ":time-noise":
	      {
	        if( !ProgramUtilitiesFun__Is_String_Double( The_Key_Value_Pairs[j+1] ) ) System.err.println("Error! ParametersFun__General_Sgp needs para_name: " + para_name + " to be a double rather than: " + The_Key_Value_Pairs[j+1]   );
	        sim.vars.temporalModule.Time_Noise =  (double) Double.parseDouble(The_Key_Value_Pairs[j+1] );
	        break;
	      }
	      case ":tone-detect-delay":
	      {
	        if( !ProgramUtilitiesFun__Is_String_Double( The_Key_Value_Pairs[j+1] ) ) System.err.println("Error! ParametersFun__General_Sgp needs para_name: " + para_name + " to be a double rather than: " + The_Key_Value_Pairs[j+1]   );
	        sim.vars.audioModule.Tone_Detect_Delay =  (double) Double.parseDouble(The_Key_Value_Pairs[j+1] );
	        break;
	      }
	      case ":tone-recode-delay":
	      {
	        if( !ProgramUtilitiesFun__Is_String_Double( The_Key_Value_Pairs[j+1] ) ) System.err.println("Error! ParametersFun__General_Sgp needs para_name: " + para_name + " to be a double rather than: " + The_Key_Value_Pairs[j+1]   );
	        sim.vars.audioModule.Tone_Recode_Delay =  (double) Double.parseDouble(The_Key_Value_Pairs[j+1] );
	        break;
	      }
	      case ":trace-detail":
	      {
	        if(sim.vars.printingModule.Popout_Message) System.out.println("WARNING! ToDo: ParametersFun__General_Sgp :trace-detail currently only has the level of high." );
	        sim.vars.printingModule.v = "t";  //:v is t by default; it is was set to nil, change it to t here. 
	        break;
	      }
	      case ":ul":
	      {
	        if (!sim.vars.utilityModule.utility_Computation_Method.equals( "temporal-difference-reinforcement")) System.out.println("Warning: sgp " + The_Key_Value_Pairs[j].toLowerCase() +" needs sim.vars.utilityModule.utility_Computation_Method == \"temporal-difference-reinforcement\" ");
	        if (The_Key_Value_Pairs[j+1].equals( "t") ) sim.vars.utilityModule.ul = true;
	        else if (The_Key_Value_Pairs[j+1].equals( "nil") ) sim.vars.utilityModule.ul = false;
	        else System.err.println("ParametersFun__General_Sgp :ul error! the value must be string t or nil");
	        break;
	      }
	      case ":ut":
	      {
	        sim.vars.utilityModule.ut = The_Key_Value_Pairs[j+1];
	        break;
	      }
	      case ":v":
	      {
	        sim.vars.printingModule.v = The_Key_Value_Pairs[j+1];
	        break;
	      }
	      
	      case ":viewing-distance":
	      {
	        if( !ProgramUtilitiesFun__Is_String_Double( The_Key_Value_Pairs[j+1] ) ) System.err.println("Error! ParametersFun__General_Sgp needs para_name: " + para_name + " to be a double rather than: " + The_Key_Value_Pairs[j+1]   );
	        sim.vars.deviceModule.Viewing_Distance =  Double.parseDouble(The_Key_Value_Pairs[j+1] );
	        break;
	      }
	      
	      case ":visual-activation":
	      {
	        if( !ProgramUtilitiesFun__Is_String_Double( The_Key_Value_Pairs[j+1] ) ) System.err.println("Error! ParametersFun__General_Sgp needs para_name: " + para_name + " to be a double rather than: " + The_Key_Value_Pairs[j+1]   );
	        sim.vars.visualBuffer.Visual_Activation =  Double.parseDouble(The_Key_Value_Pairs[j+1] );
	        break;
	      }
	      case ":visual-attention-latency":
	      {
	        if( !ProgramUtilitiesFun__Is_String_Double( The_Key_Value_Pairs[j+1] ) ) System.err.println("Error! ParametersFun__General_Sgp needs para_name: " + para_name + " to be a double rather than: " + The_Key_Value_Pairs[j+1]   );
	        sim.vars.visionModule.Visual_Attention_Latency =  Double.parseDouble(The_Key_Value_Pairs[j+1] );
	        break;
	      }
	      case ":visual-finst-span":
	      {
	        if( !ProgramUtilitiesFun__Is_String_Double( The_Key_Value_Pairs[j+1] ) ) System.err.println("Error! ParametersFun__General_Sgp needs para_name: " + para_name + " to be a double rather than: " + The_Key_Value_Pairs[j+1]   );
	        sim.vars.visionModule.Visual_Finst_Span  = Double.parseDouble( The_Key_Value_Pairs[j+1]  );
	        break;
	      }
	      case ":visual-location-activation":
	      {
	        if( !ProgramUtilitiesFun__Is_String_Double( The_Key_Value_Pairs[j+1] ) ) System.err.println("Error! ParametersFun__General_Sgp needs para_name: " + para_name + " to be a double rather than: " + The_Key_Value_Pairs[j+1]   );
	        sim.vars.visualLocationBuffer.Visual_Location_Activation =  Double.parseDouble (The_Key_Value_Pairs[j+1] );
	        break;
	      }
	      case ":visual-num-finsts":
	      {
	        if( !ProgramUtilitiesFun__Is_String_Int( The_Key_Value_Pairs[j+1] ) ) System.err.println("Error! ParametersFun__General_Sgp needs para_name: " + para_name + " to be an int rather than: " + The_Key_Value_Pairs[j+1]   );
	        sim.vars.visionModule.Visual_Num_Finsts = Integer.parseInt ( The_Key_Value_Pairs[j+1]  );
	        break;
	      }
	      case ":visual-movement-tolerance":
	      {
	        if( !ProgramUtilitiesFun__Is_String_Double( The_Key_Value_Pairs[j+1] ) ) System.err.println("Error! ParametersFun__General_Sgp needs para_name: " + para_name + " to be a double rather than: " + The_Key_Value_Pairs[j+1]	);
	        sim.vars.visionModule.Visual_Movement_Tolerance = Double.parseDouble( The_Key_Value_Pairs[j+1]  );
	        break;
	      }
	      default:
	      {
	        if(sim.vars.printingModule.Popout_Message) System.out.println("WARNING! ParametersFun__General_Sgp. The Key is undefined: " + The_Key_Value_Pairs[j]);
	        break;
	      }
	    }
	    
	  }
	  
	}
	
	public  LinkedList<String> ParametersFun__Get_Add_DM_Adding_Chunk_Names(LinkedList<String> the_list){
	  LinkedList<String> a_list_clone = sim.funs.ProgramUtilitiesFun__LinkedListString_Clone ( the_list );
	  LinkedList<String> return_list = new LinkedList<String> ();
	  LinkedList<String> temp_list = ParametersFun__Remove_A_List_From_Initialization_Lists (  a_list_clone  );
	  while(temp_list != null){
	    //GlobalUtilities.popUpMessage(  temp_list.First.Value  );
	    return_list.addLast(temp_list.getFirst()  );
	    temp_list = ParametersFun__Remove_A_List_From_Initialization_Lists (a_list_clone);
	  }
	  
	  return return_list;
	}
	  
	public  LinkedList<String> ParametersFun__Load_ACTR_Default_Into_Lines(){
	  	  
	  //1. each original line in a string. linked these lines in a linkedlist
	  LinkedList<String> return_list = new LinkedList<String>();
	  int i=1; //line number
	  //int empty_lines = 0; //track continuously empty lines
	  boolean comment_area_open = false; // track (false)  #|   (true)  |#   (false)   area comment
	  
	  String line = null;
    try
    {
      while ((line = sim.files.Defaults_ACTR_Default.reader.readLine()) != null) {
        String temp_line = line;
             
        temp_line = sim.funs.ProgramUtilitiesFun__String_Remove_Space_And_Tab_From_The_Beginning(temp_line);
        if(comment_area_open){ //when the comment area is open
          //close the comment area
          if(temp_line.length() >= 2){ //play it safe
            if(temp_line.substring(0, 2).equals( "|#") ){ //close comment area
              comment_area_open = false;
              temp_line = temp_line.substring(2); //remove the first two "|#", the rest of the line may be informative
              temp_line = sim.funs.ProgramUtilitiesFun__String_Remove_Space_And_Tab_From_The_Beginning(temp_line); //remove potential spaces and tabs
            }
            else if (temp_line.substring(0, 2).equals( "#|")){//double open error
              System.err.println("Error! ParametersFun__Load_ACTR_Model_Into_Lines temp_line.Substring(0, 2) == #| double open error. Line: " + temp_line);
              return null;
            }
            else{//keep it open and skip this line
              i++;
              continue; //go to the next line
            }
          }
          else {//temp_line.Length = 0 or 1, keep it open and skip this line
            i++;
            continue; //go to the next line
          }
        }
        
        if(!temp_line.equals( "" )){ //this may be an informative line, need to think about ; and |#
          temp_line = temp_line.toLowerCase();  //change all Initialization codes to lowercase
          //ignore chars after that the ';' comment
          int j;
          for(j = 0; j < temp_line.length() ; j++){
            if(temp_line.charAt(j) == ';')break;
          }
          temp_line = temp_line.substring(0, j);
          
          if(!temp_line.equals( "" )){ //this may be an informative line, need to think about |#
            if(temp_line.length() >= 2){ //play it safe
              if(temp_line.substring(0, 2).equals( "#|") ){ //open comment area
                comment_area_open = true;
                i++;
                continue; //go to the next line
              }
            }
            if(temp_line.length() != 0){ 
              return_list.addLast( temp_line );  // this the the line not in a comment area, without space and ; comments
            }
          }
        }
        i++;
        
      }
    } catch (IOException e)
    {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }      
	  
    
    
    //C# way
    /*
	  while ( true ){
	    String temp_line = Communication.ACTR_Default.GetLine(i); 
	    
	    if(temp_line.equals( "" ))		empty_lines++;
	    else 		empty_lines = 0;  //reset 
	    
	    if(empty_lines >= 1000) break; // QN_ACTR_Model_Initialization.txt should not have more than 999 lines empty continously between two informative lines
	    
	    temp_line = sim.funs.ProgramUtilitiesFun__String_Remove_Space_And_Tab_From_The_Beginning(temp_line);
	    if(comment_area_open){ //when the comment area is open
	      //close the comment area
	      if(temp_line.length() >= 2){ //play it safe
	        if(temp_line.substring(0, 2).equals( "|#") ){ //close comment area
	          comment_area_open = false;
	          temp_line = temp_line.substring(2); //remove the first two "|#", the rest of the line may be informative
	          temp_line = sim.funs.ProgramUtilitiesFun__String_Remove_Space_And_Tab_From_The_Beginning(temp_line); //remove potential spaces and tabs
	        }
	        else if (temp_line.substring(0, 2).equals( "#|")){//double open error
	          System.out.println("ParametersFun__Load_ACTR_Model_Into_Lines temp_line.Substring(0, 2) == #| double open error. Line: " + temp_line);
	          return null;
	        }
	        else{//keep it open and skip this line
	          i++;
	          continue; //go to the next line
	        }
	      }
	      else {//temp_line.Length = 0 or 1, keep it open and skip this line
	        i++;
	        continue; //go to the next line
	      }
	    }
	    
	    if(temp_line != "" ){ //this may be an informative line, need to think about ; and |#
	      temp_line = temp_line.toLowerCase();	//change all Initialization codes to lowercase
	      //ignore chars after that the ';' comment
	      int j;
	      for(j = 0; j < temp_line.length() ; j++){
	        if(temp_line.charAt(j) == ';')break;
	      }
	      temp_line = temp_line.substring(0, j);
	      
	      if(temp_line != "" ){ //this may be an informative line, need to think about |#
	        if(temp_line.length() >= 2){ //play it safe
	          if(temp_line.substring(0, 2).equals( "#|") ){ //open comment area
	            comment_area_open = true;
	            i++;
	            continue; //go to the next line
	          }
	        }
	        return_list.addLast( temp_line );  // this the the line not in a comment area, without space and ; comments
	        //GlobalUtilities.popUpMessage(temp_line);
	      }
	    }
	    i++;
	  }
	  */
    
    //double check
	  if(comment_area_open == true) System.err.println("Error! ParametersFun__Load_ACTR_Model_Into_Lines Error. comment_area_open == true At the end.");
	  	  
	  return return_list;
	}
	
	//PrintingFun
	
	public  void PrintingFun__Enable_All_Default_Result_Outputs(boolean the_switch){
	  
	  sim.vars.printingModule.Eye_Movement_Results = the_switch;
	  sim.vars.printingModule.Foot_Results = the_switch;
	  sim.vars.printingModule.Human_Drive_Results = the_switch;
	  sim.vars.printingModule.Output_Trace = the_switch;
	  sim.vars.printingModule.Response_Results  = the_switch;
	  
	}
	
	public  void PrintingFun__Output_Experiment_Trial_Result_List_To_Response_Results_Txt(){
	  
	  
	  //ProgramUtilitiesFun__Output_Response_Results_Txt("");
	  
	  //first, find the largest key list among all elements in the hashtable
	  LinkedList<String> largest_key_linkedlist = new LinkedList<String>();
	  for (Hashtable a_hashtable : sim.vars.centralParametersModule.Experiment_Trial_Result_List){
	    sim.funs.ProgramUtilitiesFun__Merge_Two_LinkedListString(largest_key_linkedlist,  sim.funs.ProgramUtilitiesFun__Hashtable_To_LinkedListString ( a_hashtable, "key") );
	  }
	  
	  
	  //sort largest_key_list by ascending. //without this, an alternative way is to load the response_results.txt into an excel sheet, transpose the matrix, and sort the keys.
	  List<String> largest_key_list = sim.funs.ProgramUtilitiesFun__LinkedListString_To_ListString( largest_key_linkedlist );
	  	  
	  Collections.sort(largest_key_list);
	  
	  //output the keys as the first line of the txt file
	  sim.funs.ProgramUtilitiesFun__Output_Response_Results_Txt( sim.funs.ProgramUtilitiesFun__ListString_To_String_Show_Empty(largest_key_list )) ;
	  
	  for (Hashtable parameters_for_this_trial : sim.vars.centralParametersModule.Experiment_Trial_Result_List) {
	    LinkedList<String> a_line_of_results_for_a_trial = new LinkedList<String> ();
	    for( String a_key : largest_key_list){
	      if ( parameters_for_this_trial.containsKey( a_key)) {
	        if( parameters_for_this_trial.get(a_key) == null ) a_line_of_results_for_a_trial.addLast( "[NULL]" ) ;
	        else a_line_of_results_for_a_trial.addLast( parameters_for_this_trial.get(a_key).toString() );
	      }
	      else a_line_of_results_for_a_trial.addLast("");
	    }
	    //output a line of results for a trial
	    sim.funs.ProgramUtilitiesFun__Output_Response_Results_Txt( sim.funs.ProgramUtilitiesFun__LinkedListString_To_String_Show_Empty( a_line_of_results_for_a_trial )) ;
	  }
	  
	  
	}
	
	public  void PrintingFun__Print_At_Simulation_End(){

	  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t" + "\t" + "------" + "\t\t" + "Stopped because no events left to process");  //do not print clock() because JMT move clock to a very large number
	  System.out.println("Simulation stopped because no events left to process.");
	  
	  /////////////////////////////////////////////////////////////////
	  //possible output methods to Output_Trace_Txt
	  
	  //DeclarativeModuleFun__Print_All_DM_Chunks();
	  //ChunkFun__Print_All_Chunks_In_Model();
	  //ProductionModuleFun__Print_All_Productions();
	  
	  
	  /////////////////////////////////////////////////////////////////
	  
	  //print Experiment Result list to response_results.txt
	  if (sim.vars.programGlobalVar__Use_Predefined_Model_Setup.equals( "dual_task_sample_typing_and_reading_comprehension"	) || sim.vars.programGlobalVar__Use_Predefined_Model_Setup.equals( "touch_screen_typing"	)){
	  }
	  else PrintingFun__Output_Experiment_Trial_Result_List_To_Response_Results_Txt();
	}
	
	//ProductionCompilationModuleFun
	
	public  void ProductionCompilationModuleFun__Add_Equivalent_Var_Var_Constant_List(String the_var1, String the_var2_or_constant){
	  
	  // sim.vars.programGlobalVar__ProductionCompilationModule_Equivalent_Var_Var_Constant_List?
	  
	  if (the_var1.charAt(0) != '=')System.err.println("ProductionCompilationModuleFun__Add_Equivalent_Var_Var_Constant_List Input error. the first parameter should be a var rather than constant");
	  boolean is_2_var = (the_var2_or_constant.charAt(0) == '=');
	  
	  //find the home for the_var1 in sim.vars.programGlobalVar__ProductionCompilationModule_Equivalent_Var_Var_Constant_List
	  ListIterator enum_list = sim.vars.programGlobalVar__ProductionCompilationModule_Equivalent_Var_Var_Constant_List.listIterator();
	  LinkedList<String> home_list = null;
	  while(enum_list.hasNext()){
	    LinkedList<String> a_list = (LinkedList<String>)enum_list.next();
	    if ( a_list.contains(the_var1) ||  a_list.contains(the_var2_or_constant)   ) {
	      home_list = a_list;
	      break;
	    }
	  }
	  
	  
	  if(home_list == null){ // this is the first time to add this equivalent pair.
	    home_list = new LinkedList<String>();
	    home_list.addLast(the_var1);
	    home_list.addLast(the_var2_or_constant); //this order is for the first time adding only so that the_var2 from p1 or the constant (from p1 or p2) is the last item in the list (the last will be used the representative value for all var in this list)
	    sim.vars.programGlobalVar__ProductionCompilationModule_Equivalent_Var_Var_Constant_List.addLast(home_list);
	  }
	  else{ //not the first time
	    if(home_list.contains(the_var1)==false)home_list.addFirst(the_var1); //var cannot be the representative
	    if(is_2_var){ //the_var2_or_constant is a var
	      if(home_list.contains(the_var2_or_constant)==false)home_list.addFirst(the_var2_or_constant); //var cannot be the representative
	    }
	    else{ //the_var2_or_constant is a constant
	      if(home_list.contains(the_var2_or_constant)==false){
	        //here check whether there is already another constant in this list. If there is one, it is an error bug. 
	        Enumeration temp_enum = Collections.enumeration(home_list);
	        while(temp_enum.hasMoreElements()){
	          if( ((String)temp_enum.nextElement()).charAt(0) != '=' ){
	            System.err.println("ProductionCompilationModuleFun__Add_Equivalent_Var_Var_Constant_List Bug:  ( ((String)temp_enum.Current)[0] != '=' )");
	            return;
	          }
	        }
	        home_list.addLast(the_var2_or_constant); //no error. addLast here so that the constant will become the representative for this list
	      }
	    }
	  }
	}
	
	public  Object ProductionCompilationModuleFun__Buffer_Description_Conflict_Union(Object ob1, Object ob2){
	  
	  LinkedList<String> return_linkedlist = (LinkedList<String>) sim.funs.ProgramUtilitiesFun__LinkedListString_Clone( (LinkedList<String>) ob1  );
	  LinkedList<String> linkedlist_2 = (LinkedList<String>) ob2;
	  
	  //GlobalUtilities.popUpMessage(sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_EmptyogramUtilitiesFun__LinkedListString_To_ArrayString(linkedlist_2)));
	  
	  Enumeration Enum = Collections.enumeration(linkedlist_2);
	  while(Enum.hasMoreElements()){
	    String slot_name = (String) Enum.nextElement();
	    
	    String slot_value = (String) Enum.nextElement();
	    if (return_linkedlist.contains(slot_name) == false){ //not such (slot_name, slot_value) in ob1, need to add
	      //if(slot_name.ToLower().equals( "isa") ){ // keep the ISA chunk-type pair in the front // AddFirst or Last are the same 
	      return_linkedlist.addFirst(slot_value);	
	      return_linkedlist.addFirst(slot_name);
	      //}
	      //else{
	      //			return_linkedlist.addLast(slot_name);
	      //			return_linkedlist.addLast(slot_value);
	      //}
	    }
	    else{ //no need to do anything
	    }
	  }
	  
	  
	  return return_linkedlist;
	}
	
	public  LinkedList<String> ProductionCompilationModuleFun__Buffer_Description_Difference(Object the_c2,Object the_a1){
	  LinkedList<String> c2 = (LinkedList<String>) sim.funs.ProgramUtilitiesFun__LinkedListString_Clone( (LinkedList<String>) the_c2  );
	  LinkedList<String> a1 = (LinkedList<String>) the_a1;
	  
	  //make c2_hashtable for correct version of slot name slot value match
	  Hashtable c2_hashtable = new Hashtable(); //<key: slot name,  value: slot value>
	  Enumeration c2_enum = Collections.enumeration(c2);
	  while(c2_enum.hasMoreElements()){
	    String temp_slot_name = (String)c2_enum.nextElement();
	    String temp_slot_value;
	    if( c2_enum.hasMoreElements()){
	      temp_slot_value = (String)c2_enum.nextElement();
	    }
	    else { //error. slot name and value must come in pairs
	      System.out.println("ProductionCompilationModuleFun__Buffer_Description_Difference c2_enum.MoveNext() == false" );
	      break;
	    }
	    if(c2_hashtable.containsKey(temp_slot_name)){
	      System.out.println("ProductionCompilationModuleFun__Buffer_Description_Difference ToDo: c2 has at least two slot names that are the same: " + temp_slot_name);
	      break;
	    }
	    else {
	      c2_hashtable.put( temp_slot_name , temp_slot_value);
	    }
	  }
	  
	  
	  /*
		GlobalUtilities.popUpMessage("before");
		IEnumerator enum_temp8 = c2.GetEnumerator();
		while(enum_temp8.MoveNext()){
		GlobalUtilities.popUpMessage((String)enum_temp8.Current );
		}
	   */
	  Enumeration Enum = Collections.enumeration(a1);
	  while(Enum.hasMoreElements()){ //=A1 already have done this, so =C2 does not need this (slot_name slot_value) any more
	    String slot_name = (String) Enum.nextElement();
	    String slot_value;
	    if(Enum.hasMoreElements()){
	      slot_value = (String) Enum.nextElement();
	    }
	    else {
	      System.err.println("ProductionCompilationModuleFun__Buffer_Description_Difference has Enum.MoveNext() == false, slot name and value must come in pairs" );
	      break;
	    }
	    
	    //if (c2.Find( slot_name )!=null){
	    //if(c2.Contains(slot_name) ) {
	    if(c2_hashtable.containsKey(slot_name)){//only do C2 - A1 when A1 mentioned something in C2, otherwise do nothing because C2 does not require that slot name-value in A1
	      //LinkedListNode<String> c2_node = c2.Find( slot_name );
	      String temp_slot_value_in_c2 = (String) c2_hashtable.get(slot_name);
	      //if( !((String)c2_node.Next.Value).equals(  slot_value) ){
	      if(! ProgramUtilitiesFun__StringsEqualByStringOrDouble(temp_slot_value_in_c2, slot_value)){
	        System.out.println("ProductionCompilationModuleFun__Buffer_Description_Difference has temp_slot_value_in_c2 not equal slot_value");
	        /*
		GlobalUtilities.popUpMessage( "ProductionCompilationModuleFun__Buffer_Description_Difference, (String)c2_node.Next.Value: "+ (String)c2_node.Next.Value  +" not equal  slot_value: " +  slot_value);
		ProgramUtilitiesFun__Output_Trace_Txt("  (String)c2_node.Next.Value: " + (String)c2_node.Next.Value  +" !=  slot_value: " +  slot_value);
		ProgramUtilitiesFun__Output_Trace_Txt("  debug c2: "+ sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty (sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(c2)));
		ProgramUtilitiesFun__Output_Trace_Txt("  debug a1: "+ sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty (sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(a1)));
	         */
	        break;
	      }
	      c2_hashtable.remove(slot_name);
	      //c2.Remove(c2_node.Next); //incorrect old version, because there may be slot name and value that have the same name.
	      //c2.Remove(c2_node);
	    }
	  }
	  
	  /* //currently this is not correct for =visual-location> isa visual-location in P2.
		if(c2.Count == 2){ //since A1 will not have "isa chunk_type" in its descriptor, do not leave the new_rule's condition part be just "isa chunk_type"
		if ( !((String)c2.First.Value).equals( "isa")) GlobalUtilities.popUpMessage("ProductionCompilationModuleFun__Buffer_Description_Difference. (String)c2.First.Value != isa ");
		c2 = new LinkedList<String> ();
		}
	   */
	  /*
		GlobalUtilities.popUpMessage("after");
		enum_temp8 = c2.GetEnumerator();
		while(enum_temp8.MoveNext()){
		GlobalUtilities.popUpMessage((String)enum_temp8.Current );
		}
	   */
	  
	  //change c2_hashtable back to linkedlist for return
	  LinkedList<String> return_string = new LinkedList<String>();
	  
	  Iterator<Entry>itrTable = c2_hashtable.entrySet().iterator();
	  while (itrTable.hasNext()){
	    Entry currentEntry = itrTable.next();
	    return_string.addLast((String)currentEntry.getKey());
	    return_string.addLast((String)currentEntry.getValue());
	  }
	  
	  return return_string; 
	  //return c2; old version incorrect
	}
	
	/**
	 * no conflict means if two descriptors have the same slot name, the two slot values must be the same.
	 * @param ob1
	 * @param ob2
	 * @return return cloned linkedlist
	 */
	public  LinkedList<String> ProductionCompilationModuleFun__Buffer_Description_No_Conflict_Union(Object ob1, Object ob2){
	  LinkedList<String> return_linkedlist = (LinkedList<String>) sim.funs.ProgramUtilitiesFun__LinkedListString_Clone( (LinkedList<String>) ob1  );
	  LinkedList<String> linkedlist_2 = (LinkedList<String>) ob2;
	  
	  //change return_linkedlist to return_hashtable
	  Hashtable return_hashtable = new Hashtable(); //<key: slot name,  value: slot value>
	  Enumeration return_enum = Collections.enumeration(return_linkedlist);
	  while(return_enum.hasMoreElements()){
	    String temp_slot_name = (String)return_enum.nextElement();
	    String temp_slot_value;
	    if( return_enum.hasMoreElements()){
	      temp_slot_value = (String)return_enum.nextElement();
	    }
	    else { //error. slot name and value must come in pairs
	      System.out.println("ProductionCompilationModuleFun__Buffer_Description_No_Conflict_Union return_enum.MoveNext() == false" );
	      break;
	    }
	    if(return_hashtable.containsKey(temp_slot_name)){
	      System.out.println("ProductionCompilationModuleFun__Buffer_Description_No_Conflict_Union ToDo: return_linkedlist has at least two slot names that are the same: " + temp_slot_name);
	      break;
	    }
	    else {
	      return_hashtable.put( temp_slot_name , temp_slot_value);
	    }
	  }
	  
	  Enumeration enum2 = Collections.enumeration(linkedlist_2);
	  while(enum2.hasMoreElements()){
	    String slot_name = (String) enum2.nextElement();
	    String slot_value;
	    if(enum2.hasMoreElements()){
	      slot_value = (String) enum2.nextElement();
	      //if (return_linkedlist.Find( slot_name ) == null){ 
	      if(return_hashtable.containsKey(slot_name)==false) {//not such (slot_name, slot_value) in C1, need to add
	        return_linkedlist.addLast(slot_name);
	        return_linkedlist.addLast(slot_value);
	        return_hashtable.put(slot_name,slot_value);
	      }
	      else{ //no need to do anything, just check for error
	        /* //old version has problem
		System.Collections.Generic.LinkedListNode<String> node = return_linkedlist.Find( slot_name );
		if( !((String)node.Next.Value).equals(slot_value))GlobalUtilities.popUpMessage( "ProductionCompilationModuleFun__Buffer_Description_No_Conflict_Union, (String)node.Next.Value !=  slot_value " );
	         */
	        String slot_value_in_return_table = (String) return_hashtable.get(slot_name);
	        if (!ProgramUtilitiesFun__StringsEqualByStringOrDouble(slot_value_in_return_table, slot_value)){
	          System.err.println( "Error! ProductionCompilationModuleFun__Buffer_Description_No_Conflict_Union has slot_value_in_return_table not equal to slot_value");
	          break;
	        }
	        
	      }
	    }
	    else {
	      System.out.println("ProductionCompilationModuleFun__Buffer_Description_No_Conflict_Union has Enum.MoveNext() ==false" );
	      break;
	    }
	    
	  }
	  
	  
	  return return_linkedlist;
	}
	
	public  void ProductionCompilationModuleFun__Clear_Previous(){
	  sim.vars.productionCompilationModule.Last_Fired_Rule_Name = "";
	  sim.vars.productionCompilationModule.Last_Rule_Fired_Time = (double) 0.0;
	  
	  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("  Production compilation setting previous production to [EMPTY]"  );
	}
	
	/**
	 * ToDo: Newly composed rule display trace cosmetic issue: ISA is better to be the first line after =buffer-name>. When adding a buffer description, move ISA pair to the front, after =buffer-name>
	 * @param the_p1
	 * @param the_p2
	 * @return return value newly constructed
	 */
	public  String[] ProductionCompilationModuleFun__Collapsing(String[] the_p1,String[] the_p2){

	  LinkedList<String> return_linkedlist = new LinkedList<String>();
	  LinkedList<String> new_rule_condition = new LinkedList<String>();
	  LinkedList<String> new_rule_action = new LinkedList<String>();
	  
	  //buffer-by-buffer basis.
	  LinkedList<String> p1_buffer_names = (LinkedList<String>) ProductionCompilationModuleFun__Get_Production_Buffers_From_Rule_Descriptors(the_p1);
	  LinkedList<String> p2_buffer_names = (LinkedList<String>) ProductionCompilationModuleFun__Get_Production_Buffers_From_Rule_Descriptors(the_p2);
	  LinkedList<String> buffer_names = (LinkedList<String>) sim.funs.ProgramUtilitiesFun__Merge_Two_LinkedListString (p1_buffer_names , p2_buffer_names);
	  
	  Enumeration enum_buffer_names = Collections.enumeration(buffer_names);
	  while(enum_buffer_names.hasMoreElements()){
	    String current_buffer_name = (String) enum_buffer_names.nextElement();
	    //1. whether there is buffer query ?buffers>
	    LinkedList<String> pure_p1_condition_buffer_description_request = ProductionCompilationModuleFun__Get_Buffer_Without_Head_Description (the_p1, current_buffer_name, "condition", "=" );
	    LinkedList<String> pure_p2_condition_buffer_description_request = ProductionCompilationModuleFun__Get_Buffer_Without_Head_Description (the_p2, current_buffer_name, "condition", "=" );
	    LinkedList<String> pure_p1_condition_buffer_description_query = ProductionCompilationModuleFun__Get_Buffer_Without_Head_Description (the_p1, current_buffer_name, "condition", "?" );
	    LinkedList<String> pure_p2_condition_buffer_description_query = ProductionCompilationModuleFun__Get_Buffer_Without_Head_Description (the_p2, current_buffer_name, "condition", "?" );
	    
	    LinkedList<String> p1_condition_buffer_description_request = ProductionCompilationModuleFun__Get_Buffer_With_Head_Description (the_p1, current_buffer_name, "condition", "=" );
	    LinkedList<String> p2_condition_buffer_description_request = ProductionCompilationModuleFun__Get_Buffer_With_Head_Description (the_p2, current_buffer_name, "condition", "=" );
	    LinkedList<String> p1_condition_buffer_description_query = ProductionCompilationModuleFun__Get_Buffer_With_Head_Description (the_p1, current_buffer_name, "condition", "?" );
	    LinkedList<String> p2_condition_buffer_description_query = ProductionCompilationModuleFun__Get_Buffer_With_Head_Description (the_p2, current_buffer_name, "condition", "?" );
	    
	    //GlobalUtilities.popUpMessage("not pure " + sim.funs.ProgramUtilitiesFun__StringArray_To_String_Stop_If_Empty(sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(p1_condition_buffer_description_request)));
	    //GlobalUtilities.popUpMessage("pure " + sim.funs.ProgramUtilitiesFun__StringArray_To_String_Stop_If_Empty( sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(pure_p1_condition_buffer_description_request)));
	    
	    
	    
	    //GlobalUtilities.popUpMessage(sim.funs.ProgramUtilitiesFun__StringArray_To_String_Stop_If_Empty("ProductionCompilationModuleFun__Collapsing: " + sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(p1_condition_buffer_description_request)));
	    
	    LinkedList<String> pure_p1_action_buffer_description_modify = ProductionCompilationModuleFun__Get_Buffer_Without_Head_Description (the_p1, current_buffer_name, "action", "=" );
	    LinkedList<String> pure_p2_action_buffer_description_modify = ProductionCompilationModuleFun__Get_Buffer_Without_Head_Description (the_p2, current_buffer_name, "action", "=" );
	    LinkedList<String> pure_p1_action_buffer_description_add = ProductionCompilationModuleFun__Get_Buffer_Without_Head_Description (the_p1, current_buffer_name, "action", "+" );
	    LinkedList<String> pure_p2_action_buffer_description_add = ProductionCompilationModuleFun__Get_Buffer_Without_Head_Description (the_p2, current_buffer_name, "action", "+" );
	    
	    LinkedList<String> p1_action_buffer_description_modify = ProductionCompilationModuleFun__Get_Buffer_With_Head_Description (the_p1, current_buffer_name, "action", "=" );
	    LinkedList<String> p2_action_buffer_description_modify = ProductionCompilationModuleFun__Get_Buffer_With_Head_Description (the_p2, current_buffer_name, "action", "=" );
	    LinkedList<String> p1_action_buffer_description_add = ProductionCompilationModuleFun__Get_Buffer_With_Head_Description (the_p1, current_buffer_name, "action", "+" );
	    LinkedList<String> p2_action_buffer_description_add = ProductionCompilationModuleFun__Get_Buffer_With_Head_Description (the_p2, current_buffer_name, "action", "+" );
	    
	    
	    //determine if any ?buffer> in the new rule, ?buffer> condition test cannot trigger strict harvesting in ACT-R, here neither.
	    if (p1_condition_buffer_description_query.size() > 0) { //the ?buffer in the first is used if there is one.
	      //new_rule_condition.addLast( "?" + current_buffer_name + ">"  ); //new change for empty buffer request or action like =imaginal> <then nothing>
	      new_rule_condition = (LinkedList<String>) sim.funs.ProgramUtilitiesFun__LinkedListString_Append(new_rule_condition , p1_condition_buffer_description_query);
	    }
	    else{ //If there is not a ?buffer in the first
	      if (p2_condition_buffer_description_query.size() > 0 &&  p1_action_buffer_description_add.size()==0	){ //If there is not a ?buffer in the first, but one in the second, and not a +buffer (action) in the first, the ?buffer from the second is used.
	        //new_rule_condition.addLast( "?" + current_buffer_name + ">"  ); //new change for empty buffer request or action like =imaginal> <then nothing>
	        new_rule_condition = (LinkedList<String>) sim.funs.ProgramUtilitiesFun__LinkedListString_Append(new_rule_condition , p2_condition_buffer_description_query);
	      }
	      //If there is not a ?buffer in the first, but one in the second, and a +buffer in the first, then no ?buffer is used
	    }	
	    
	    
	    //2. With respect to =buffers and +buffers, There are different cases to consider depending on whether there is a +buffer in the first and whether that is a retrieval-type buffer.
	    String p1_add_buffer_case = ProductionCompilationModuleFun__Get_P1_Add_Buffer_Case (p1_action_buffer_description_add.size(), current_buffer_name  );
	    switch (p1_add_buffer_case){ 
	      case "no_+buffer>":	//2.1. No +buffer in the first production:  
	        // =buffer> in condition
	        
	        //GlobalUtilities.popUpMessage("ProductionCompilationModuleFun__Collapsing pure_p2_condition_buffer_description_request: " + sim.funs.ProgramUtilitiesFun__StringArray_To_String_Stop_If_Empty(sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(pure_p2_condition_buffer_description_request)) + ", pure_p1_action_buffer_description_modify: " + sim.funs.ProgramUtilitiesFun__StringArray_To_String_Stop_If_Empty(sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(pure_p1_action_buffer_description_modify)));			
	        LinkedList<String> C2_minus_A1 =   ProductionCompilationModuleFun__Buffer_Description_Difference(pure_p2_condition_buffer_description_request, pure_p1_action_buffer_description_modify  ); // =C2 - =A1   //LinkedList<String> C2_minus_A1 =   ProductionCompilationModuleFun__Buffer_Description_Difference(p2_condition_buffer_description_request, p1_action_buffer_description_modify  ); // =C2 - =A1
	        //GlobalUtilities.popUpMessage("ProductionCompilationModuleFun__Collapsing C2_minus_A1: " + sim.funs.ProgramUtilitiesFun__StringArray_To_String_Stop_If_Empty(sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(C2_minus_A1)));
	        LinkedList<String> C1_add_C2_minus_A1 = (LinkedList<String>) ProductionCompilationModuleFun__Buffer_Description_No_Conflict_Union( pure_p1_condition_buffer_description_request, C2_minus_A1);  //LinkedList<String> C1_add_C2_minus_A1 = (LinkedList<String>) ProductionCompilationModuleFun__Buffer_Description_No_Conflict_Union( p1_condition_buffer_description_request, C2_minus_A1);
	        if (C1_add_C2_minus_A1.size()> 0) {//add the =buffer> part to new rule condition
	          new_rule_condition.addLast( "=" + current_buffer_name + ">"  );
	          new_rule_condition = (LinkedList<String>) sim.funs.ProgramUtilitiesFun__LinkedListString_Append(new_rule_condition , C1_add_C2_minus_A1);
	        }
	        
	        //=buffer> in action
	        //The =action of the new production will be obtained by unioning =A2 with that of =A1 that is not changed by A2.
	        
	        LinkedList<String> new_action_modify = (LinkedList<String>) ProductionCompilationModuleFun__Buffer_Description_Conflict_Union(pure_p2_action_buffer_description_modify, pure_p1_action_buffer_description_modify  ); 
	        if (new_action_modify.size() > 0){
	          new_rule_action.addLast( "=" + current_buffer_name + ">"  );
	          new_rule_action = (LinkedList<String>) sim.funs.ProgramUtilitiesFun__LinkedListString_Append(new_rule_action, new_action_modify);
	        }
	        else if (new_action_modify.size() == 0){
	          if ( p2_action_buffer_description_modify.size() == 1 && ((String)p2_action_buffer_description_modify.getFirst()).equals ( "=" + current_buffer_name + ">"  ) ) {//if =Action2 =buffer> [empty], then new rule get =buffer> [empty], no matter what is =action1 .  this is used to disable strict harvest.  e.g., ACT-R 6.0 v1.4 tutorial unit 7 paired-learning
	            new_rule_action.addLast( "=" + current_buffer_name + ">"  );
	            //Model.Message ("ProductionCompilationModuleFun__Collapsing  " + "=" + current_buffer_name + ">"  ); //catch =imaginal> empty strict harvest killer, see paired-learning.lisp in ACT-R tutorial unit 7
	            
	          }
	          else if ( p2_action_buffer_description_modify.size() == 0 &&  ( p1_action_buffer_description_modify.size() == 1 && ((String)p1_action_buffer_description_modify.getFirst()).equals( "=" + current_buffer_name + ">"  ) )  ) {
	            //if =Action2 [empty] && =Action1 =buffer> [empty], 
	            //			if =condition2  has something, then   new rule add Nothing
	            //			else (=condition2 has nothing), then =buffer> [empty]
	            if ( pure_p2_condition_buffer_description_request.size() > 0) {
	              //pass , do nothing
	            }
	            else {
	              new_rule_action.addLast( "=" + current_buffer_name + ">"  );
	              //Model.Message ("ProductionCompilationModuleFun__Collapsing  " + "=" + current_buffer_name + ">"  ); //catch =imaginal> empty strict harvest killer, see paired-learning.lisp in ACT-R tutorial unit 7
	            }
	          }
	          else { //else  new rule add Nothing
	            //do nothing
	          }	
	          
	          
	        }
	        
	        //+buffer> in action,  + action must be after = action
	        //The +action of the new production is just the +A2 of the second production if there is one.
	        if (p2_action_buffer_description_add.size() > 0){ 
	          //new_rule_action.addLast( "+" + current_buffer_name + ">"  ); //new change
	          new_rule_action = (LinkedList<String>) sim.funs.ProgramUtilitiesFun__LinkedListString_Append(new_rule_action, p2_action_buffer_description_add);
	        }
	        
	        break;
	        
	      case "non-retrieval-type_+buffer>": //2.2. A +buffer in the first production that is not retrieval type:
	        //=buffer> in condition
	        //The condition of the new production will just be the condition of the first
	        if (p1_condition_buffer_description_request.size() > 0){
	          //new_rule_condition.addLast( "=" + current_buffer_name + ">"  ); //new change
	          new_rule_condition = (LinkedList<String>) sim.funs.ProgramUtilitiesFun__LinkedListString_Append(new_rule_condition , p1_condition_buffer_description_request);
	        }
	        
	        //=buffer> in action
	        //The =action of the new production will be the =action of the first if there is one.
	        if (p1_action_buffer_description_modify.size() > 1){ //new change 0 to 1. because =buffer> empty and +buffer> both in p1 action, don't need the =buffer> empty in the composed rule
	          //new_rule_action.addLast( "=" + current_buffer_name + ">"  ); //new change
	          new_rule_action = (LinkedList<String>) sim.funs.ProgramUtilitiesFun__LinkedListString_Append(new_rule_action, p1_action_buffer_description_modify);
	        }
	        
	        //+buffer> in action,  + action must be after = action
	        //The +action of the new production will be formed by unioning =A2 with that of +A1 that is not changed by =A2.
	        
	        LinkedList<String>  new_action_add = (LinkedList<String>) ProductionCompilationModuleFun__Buffer_Description_Conflict_Union(pure_p2_action_buffer_description_modify, pure_p1_action_buffer_description_add);
	        if (new_action_add.size() > 0){ 
	          new_rule_action.addLast( "+" + current_buffer_name + ">"  );
	          new_rule_action = (LinkedList<String>) sim.funs.ProgramUtilitiesFun__LinkedListString_Append(new_rule_action, new_action_add);
	        }
	        
	        break;
	        
	      case "retrieval-type_+buffer>": //2.3. A +buffer in the first production that is retrieval type:
	        //in this case, buffer_name is retrieval
	        //=buffer> in condition
	        //The condition of the new production will just be the condition of the first if there is one
	        if (p1_condition_buffer_description_request.size() > 0){
	          //new_rule_condition.addLast( "=" + current_buffer_name + ">"  ); // new change
	          new_rule_condition = (LinkedList<String>) sim.funs.ProgramUtilitiesFun__LinkedListString_Append(new_rule_condition , p1_condition_buffer_description_request);
	        }	
	        
	        //There can be no =buffer> in action.
	        
	        //The +buffer> action of the new production will be the +buffer> action of the second if there is one.
	        if (p2_action_buffer_description_add.size() > 0){
	          //new_rule_action.addLast( "+" + current_buffer_name + ">"  ); //new change
	          new_rule_action = (LinkedList<String>) sim.funs.ProgramUtilitiesFun__LinkedListString_Append(new_rule_action, p2_action_buffer_description_add);
	        }
	        
	        break;
	        
	    }
	    
	  }
	  
	  String new_rule_name = "PRODUCTION" + Integer.toString(sim.vars.productionCompilationModule.Number_Of_New_Rules);
	  
	  
	  //=====================this is a temporary bug fix for the production184 problem in Schumacher exp1=================================
	  /*
		2010-07-17
		If there is a =var in the action part that is not presented in the condition part, add something in the condition part so that the rule will never be met. 
		(This is not a correct solution to the problem, but will result in the same result as ACT-R 6 v1.4 r875, OK for now.) 
		The adding something rule could be: if there is a =goal> condition test, add <dummy, this_makes_this_rule_cannot_be_selected_as_in_ACTR>, 
		if there is no =goal>, add a =goal> and the slot name and value.

	   */
	  boolean useTempFix = true;
	  if(useTempFix){
	    LinkedList <String> var_in_action = new LinkedList <String>();
	    for (String an_action_descriptor: new_rule_action){
	      if (an_action_descriptor.substring(0, 1).equals( "=") && !an_action_descriptor.substring( an_action_descriptor.length()-1,  an_action_descriptor.length()).equals( ">") ) { //a variable
	        var_in_action.addLast( an_action_descriptor );
	      }
	    }
	    
	    LinkedList<String> special_var_list = sim.funs.ProgramUtilitiesFun__StringArray_To_LinkedList_String( new String[] {"=visual-location", "=aural-location" } ); //add more special variables here if any
	    boolean problem_detected = false;
	    for( String var: var_in_action) {
	      if ( new_rule_condition.contains(var) ==false && special_var_list.contains(var) == false ){
	        //this is the sign of a bug
	        //GlobalUtilities.popUpMessage("ProductionCompilationModuleFun__Collapsing has unbound var in action part: " + var + ", in rule: " + new_rule_name);
	        problem_detected = true;
	        break;
	      }
	    }
	    
	    //fix the bug so that the composed rule will never be matched like the current ACT-R bug "goal nil"
	    if (problem_detected){
	      if ( new_rule_condition.contains( "=goal>" ) ){
	        int index = new_rule_condition.indexOf( "=goal>" );
	        new_rule_condition.add(index + 1, "this_makes_this_rule_cannot_be_selected_as_in_ACTR");
	        new_rule_condition.add(index + 1, "dummy");
	        //	      LinkedListNode<String> current = new_rule_condition.Find( "=goal>" );
	        //	      new_rule_condition.AddAfter(current, "this_makes_this_rule_cannot_be_selected_as_in_ACTR");
	        //	      new_rule_condition.AddAfter(current, "dummy");
	      }
	      else{
	        new_rule_condition.addLast("=goal>");
	        new_rule_condition.addLast("dummy");
	        new_rule_condition.addLast("this_makes_this_rule_cannot_be_selected_as_in_ACTR");
	      }
	    }
	  }
	  //----------------------------end of the temporary bug fix-----------------------------------------------------------------
	  
	  
	  return_linkedlist.addLast("p"); //the first letter means a "production"
	  return_linkedlist.addLast(new_rule_name);
	  return_linkedlist = (LinkedList<String>) sim.funs.ProgramUtilitiesFun__LinkedListString_Append( return_linkedlist, new_rule_condition);
	  return_linkedlist.addLast("==>");
	  return_linkedlist = (LinkedList<String>) sim.funs.ProgramUtilitiesFun__LinkedListString_Append( return_linkedlist, new_rule_action);
	  
	  /*
		IEnumerator enum_temp9 = return_linkedlist.GetEnumerator();
		while(enum_temp9.MoveNext()){
		GlobalUtilities.popUpMessage((String)enum_temp9.Current );
		}
	   */
	  
	  return sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(return_linkedlist);
	}
	
	public  void ProductionCompilationModuleFun__Compose_Productions(Production_Rule the_previous_rule, Production_Rule the_current_rule){
	  
	  if(sim.vars.printingModule.Output_Window_Trace)System.out.println( "ProductionCompilationModuleFun__Compose_Productions" );
	  
	  
	  String[] p1_descriptors = ProductionModuleFun__Get_Rule_Descriptors_From_Production_Rule (the_previous_rule);
	  String[] p2_descriptors = ProductionModuleFun__Get_Rule_Descriptors_From_Production_Rule (the_current_rule);
	  
	  LinkedList<String> p1_variables = (LinkedList<String>) ProductionModuleFun__Get_Production_None_Buffer_Variables (p1_descriptors);
	  LinkedList<String> p2_variables = (LinkedList<String>) ProductionModuleFun__Get_Production_None_Buffer_Variables (p2_descriptors);
	  
	  
	  boolean debug_flag = false;
	  /*
		if( Clock > 202.77 ){
		debug_flag = true;
		}
	   */
	  if(debug_flag)System.out.println("Compose_Productions p1 name: " + p1_descriptors[1]);
	  if(debug_flag)System.out.println("Compose_Productions p2 name: " + p2_descriptors[1]);
	  if(debug_flag)System.out.println("Compose_Productions p1 variables: " + sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty(sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(p1_variables)) );
	  if(debug_flag)System.out.println("Compose_Productions p2 variables before renaming: " + sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty(sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(p2_variables)) );
	  
	  
	  
	  //renew equivalent list
	  sim.vars.programGlobalVar__ProductionCompilationModule_Equivalent_Var_Var_Constant_List.clear();
	  
	  //following compilation.doc
	  
	  
	  //Step 1. Renaming. e.g., "=val" -> "=val-a"
	  //We rename any of the variables that are the same (and potentially clashes) in the second production. 
	  LinkedList<String> p2_variables_renamed = new LinkedList<String>();
	  Hashtable p2_to_renamed = new Hashtable();
	  Enumeration enum_p2_variables = Collections.enumeration(p2_variables); 
	  boolean need_renaming = false;
	  while(enum_p2_variables.hasMoreElements()){
	    String currentItem = (String)enum_p2_variables.nextElement();
	    if (!p1_variables.contains(currentItem)){
	      p2_variables_renamed.addLast(currentItem);
	      p2_to_renamed.put(currentItem, currentItem);
	    }
	    else{
	      need_renaming = true;
	      p2_variables_renamed.addLast(currentItem + "-a");
	      p2_to_renamed.put( currentItem, currentItem + "-a"  );	
	    }
	  }
	  
	  if(need_renaming && debug_flag)System.out.println("Compose_Productions p2 variables after renaming: " + sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty(sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(p2_variables_renamed)) );
	  if(need_renaming == false && debug_flag)System.out.println("Compose_Productions p2 variables no need to rename.");
	  
	  String[] p2_descriptors_renamed = sim.funs.ProgramUtilitiesFun__Subst_String_Array(p2_descriptors,  p2_to_renamed);  //may be nothing changed after the renaming
	  
	  /*
		IEnumerator temp_enum3 = p2_descriptors_renamed.GetEnumerator();
		GlobalUtilities.popUpMessage(p2_descriptors_renamed[1]);
		while(temp_enum3.MoveNext()){
		Model.Message (temp_enum3.Current);
		}
	   */
	  
	  
	  
	  //Step 2: for each buffer used in p1 condition or action, Extracting buffer descriptions to map. 
	  LinkedList<String> p1_buffer_names = (LinkedList<String>) ProductionCompilationModuleFun__Get_Production_Buffers_From_Production_Rule(the_previous_rule);
	  if(debug_flag)System.out.println("Compose_Productions p1_buffer_names: " +  sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty(sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(p1_buffer_names)));
	  Enumeration enum_p1_buffer_names = Collections.enumeration(p1_buffer_names);
	  while(enum_p1_buffer_names.hasMoreElements()){
	    String buffer_name = (String)enum_p1_buffer_names.nextElement();
	    //Model.Message ("rule_name: " + p1_descriptors[1] + " buffer_name: " + buffer_name);
	    //LinkedList<String> p1_condition_buffer_description = (LinkedList<String>)ProductionCompilationModuleFun__Get_Buffer_Without_Head_Description (p1_descriptors,buffer_name, "condition", "" ); //both = and ? test
	    LinkedList<String> p1_condition_buffer_description = (LinkedList<String>)ProductionCompilationModuleFun__Get_Buffer_Without_Head_Description (p1_descriptors,buffer_name, "condition", "=" ); //only = test, condition_buffer_description should only consider = test, because values in ?buffer tests like state free, buffer empty should not be changed by =buffer modify action. If use both = and ?, when =buffer condition has slot name state or buffer, may raise problems.
	    LinkedList<String> p1_action_buffer_description_modify = (LinkedList<String>)ProductionCompilationModuleFun__Get_Buffer_Without_Head_Description (p1_descriptors, buffer_name, "action", "=" );
	    LinkedList<String> p1_action_buffer_description_add = (LinkedList<String>)ProductionCompilationModuleFun__Get_Buffer_Without_Head_Description (p1_descriptors, buffer_name, "action", "+" );
	    //omit -buffer action because when this function is used, the two rules should be composeable. - buffer action appearing in any rule will not be composeable.
	    //LinkedList<String> p2_condition_buffer_description = (LinkedList<String>)ProductionCompilationModuleFun__Get_Buffer_Without_Head_Description (p2_descriptors_renamed, buffer_name, "condition", "" );//both = and ? test
	    LinkedList<String> p2_condition_buffer_description = (LinkedList<String>)ProductionCompilationModuleFun__Get_Buffer_Without_Head_Description (p2_descriptors_renamed, buffer_name, "condition", "=" );//= test only. 
	    
	    
	    
	    /*	
		IEnumerator temp_enum4 = p2_condition_buffer_description.GetEnumerator();
		while(temp_enum4.MoveNext()){
		Model.Message (temp_enum4.Current);
		}
	     */	
	    String p1_add_buffer_case = ProductionCompilationModuleFun__Get_P1_Add_Buffer_Case (p1_action_buffer_description_add.size(), buffer_name  );
	    //Model.Message ("rule_name: " + p1_descriptors[1] + " buffer_name: " + buffer_name + " p1_add_buffer_case: "  + p1_add_buffer_case);	
	    
	    //GlobalUtilities.popUpMessage("rule 1 name: " + p1_descriptors[1] + ", buffer_name: " + buffer_name + ", p1_condition_buffer_description: " + sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty(sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(p1_condition_buffer_description)));
	    
	    LinkedList<String> p1_description_to_map =  ProductionCompilationModuleFun__Get_P1_Description_To_Map (p1_condition_buffer_description, p1_action_buffer_description_modify, p1_action_buffer_description_add, p1_add_buffer_case   );  //this is what it is in the buffer after p1 fired.
	    if(debug_flag)System.out.println("Compose_Productions p1_description_to_map: " + sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty(sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(p1_description_to_map)) );
	    //change p1_description_to_map to a hashtable, because one slot name may be the same with another slot value e.g., isa goal   goal do-vm
	    Hashtable p1_description_hashtable_to_map = new Hashtable(); //<key: slot name,  value: slot value>
	    Enumeration p1_enum_description_to_map = Collections.enumeration(p1_description_to_map);
	    while(p1_enum_description_to_map.hasMoreElements()){
	      String temp_slot_name = (String)p1_enum_description_to_map.nextElement();
	      String temp_slot_value;
	      if( p1_enum_description_to_map.hasMoreElements()){
	        temp_slot_value = (String)p1_enum_description_to_map.nextElement();
	      }
	      else { //error. slot name and value must come in pairs
	        System.out.println("ProductionCompilationModuleFun__Compose_Productions p1_enum_description_to_map.MoveNext() == false" );
	        break;
	      }
	      if(p1_description_hashtable_to_map.containsKey(temp_slot_name)){
	        System.out.println("ProductionCompilationModuleFun__Compose_Productions ToDo: p1_description_to_map has at least two slot names that are the same: " + temp_slot_name);
	        break;
	      }
	      else {
	        p1_description_hashtable_to_map.put( temp_slot_name , temp_slot_value);
	      }
	    }
	    
	    //GlobalUtilities.popUpMessage("rule 1 name: " + p1_descriptors[1] + ", buffer_name: " + buffer_name + ", p1_description_to_map: " + sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty(sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(p1_description_to_map)));
	    //GlobalUtilities.popUpMessage("rule 2 name: " + p1_descriptors[2])
	    
	    
	    //Step 3: Extract Mappings from buffer descriptions. find the var-var and var-constant bindings so that the result (descriptors for the chunk in the buffer) after p1-action will be the same as p2-condition, for the buffer
	    if(debug_flag)System.out.println("Compose_Productions p2_condition_buffer_description: " + sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty(sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(p2_condition_buffer_description) ));
	    Enumeration enum_p2_condition_buffer_description = Collections.enumeration(p2_condition_buffer_description);
	    
//	    LinkedListNode<String> p2_node = p2_condition_buffer_description.getFirst(); //the first slot name, like "isa"
	    Iterator<String> itr_p2_condition_buffer_description = p2_condition_buffer_description.iterator();
	    
	    if(enum_p2_condition_buffer_description.hasMoreElements())enum_p2_condition_buffer_description.nextElement();
	    while(enum_p2_condition_buffer_description.hasMoreElements()){ //move to slot value
	      String p2_slot_value = (String) enum_p2_condition_buffer_description.nextElement(); //e.g., "number-order"
	      
//	      String p2_slot_name = p2_node.Value;  // e.g., "isa"
	      String p2_slot_name;
	      //if(itr_p2_condition_buffer_description.hasNext()){
	        p2_slot_name = itr_p2_condition_buffer_description.next();
	      //}
//	      else{
//	       System.out.println("Error! ProductionCompilationModuleFun__Compose_Productions has itr_p2_condition_buffer_description.hasNext() == false");
//	       return; 
//	      }
	      
	      if (p2_slot_value.substring(0,1).equals( "=" )){ //1. p2_slot_value is a var . e.g., "arg1  =num1"
	        //if (p1_description_to_map.Contains(p2_slot_name)== true) { // p1 has such slot name  "arg1"
	        if (p1_description_hashtable_to_map.containsKey(p2_slot_name)== true) { // p1 has such slot name  "arg1"
	          //string p1_slot_value = p1_description_to_map.Find(p2_slot_name).Next.Value;
	          String p1_slot_value = (String) p1_description_hashtable_to_map.get(p2_slot_name);
	          //GlobalUtilities.popUpMessage( "_"+ p1_slot_value + "_");
	          
	          if (p1_slot_value.substring(0,1).equals( "=")) { //1.1. p1_slot_value is also a var, var-var mapping 
	            /*
		if (sim.vars.productionCompilationModule.Unify_Var_Var_Map.ContainsKey(p2_slot_value) == false){
		sim.vars.productionCompilationModule.Unify_Var_Var_Map.Add(p2_slot_value, p1_slot_value );  //here add p2-value as key, p1-value as the value
		}
		else{ //contains p2_slot_value
		if( (String)sim.vars.productionCompilationModule.Unify_Var_Var_Map[p2_slot_value] == p1_slot_value ){
		//want to add the same key-value pair, fine
		}
		else{//want to add a different key-value pair
		GlobalUtilities.popUpMessage("ToDo: ProductionCompilationModuleFun__Compose_Productions 1.1. want to add a different key-value pair. key: " + p2_slot_value + ", value 1: " + (String)sim.vars.productionCompilationModule.Unify_Var_Var_Map[p2_slot_value] + ", value 2: " + p1_slot_value);
		}
		}
	             */
	            if(debug_flag)System.out.println("Compose_Productions add var-var mapping p2_slot_value: " + p2_slot_value + ", p1_slot_value: " +  p1_slot_value );
	            ProductionCompilationModuleFun__Add_Equivalent_Var_Var_Constant_List(p2_slot_value, p1_slot_value);//here add p2-value as key, p1-value as the value
	            
	          }
	          else{ //1.2. p1_slot_value is a constant, var-constant mapping
	            /*
		if(sim.vars.productionCompilationModule.Unify_Var_Constant_Map.ContainsKey(p2_slot_value) == false ){
		sim.vars.productionCompilationModule.Unify_Var_Constant_Map.Add(p2_slot_value, p1_slot_value );
		}
		else{
		if((String)sim.vars.productionCompilationModule.Unify_Var_Constant_Map[p2_slot_value] == p1_slot_value){
		//want to add the same key-value pair, fine
		}
		else{//want to add a different key-value pair
		GlobalUtilities.popUpMessage("ToDo: ProductionCompilationModuleFun__Compose_Productions  1.2. want to add a different key-value pair  key: " + p2_slot_value + ", value 1: " + (String)sim.vars.productionCompilationModule.Unify_Var_Constant_Map[p2_slot_value] + ", value 2: " + p1_slot_value);
		}
		}
	             */
	            if(debug_flag)System.out.println("Compose_Productions add var-constant mapping p2_slot_value: " + p2_slot_value + ", p1_slot_value: " +  p1_slot_value );
	            ProductionCompilationModuleFun__Add_Equivalent_Var_Var_Constant_List(p2_slot_value, p1_slot_value);
	          }
	        }
	        else{
	          //p1 does not have such slot name like "arg1", do not need to add any bindings
	        }
	      }
	      else { //2. p2_slot_value is a constant
	        //if (p1_description_to_map.Find(p2_slot_name)!= null) { // p1 has such slot name
	        //string p1_slot_value = p1_description_to_map.Find(p2_slot_name).Next.Value;
	        if (p1_description_hashtable_to_map.containsKey(p2_slot_name)== true) { // p1 has such slot name like "arg1"
	          String p1_slot_value = (String) p1_description_hashtable_to_map.get(p2_slot_name);
	          
	          if (p1_slot_value.substring(0,1).equals( "=")) { //2.1. p1_slot_value is a variable, constant-var reverse, var-constant mapping
	            /*
		if (sim.vars.productionCompilationModule.Unify_Var_Constant_Map.ContainsKey(p1_slot_value)==false){ //don't have this key before
		sim.vars.productionCompilationModule.Unify_Var_Constant_Map.Add(p1_slot_value, p2_slot_value );
		}
		else{
		if(((String)sim.vars.productionCompilationModule.Unify_Var_Constant_Map[p1_slot_value]).equals( p2_slot_value)){
		//want to add the same key-value pair, fine
		}
		else{
		//want to add a different key-value pair
		GlobalUtilities.popUpMessage("ToDo: ProductionCompilationModuleFun__Compose_Productions 2.1. want to add a different key-value pair. key: " + p1_slot_value + ", value 1: " + (String)sim.vars.productionCompilationModule.Unify_Var_Constant_Map[p1_slot_value] + ", value 2: " + p2_slot_value);
		}
		}
	             */
	            ProductionCompilationModuleFun__Add_Equivalent_Var_Var_Constant_List(p1_slot_value, p2_slot_value);
	          }
	          else{ //2.2. p1_slot_value is also a constant, constant-constant 
	            if ( ProgramUtilitiesFun__StringsEqualByStringOrDouble(p1_slot_value, p2_slot_value)){ //this is normal, no problem
	            }
	            else {
	              sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("   " + the_previous_rule.Rule_Name + " and " + the_current_rule.Rule_Name + " cannot be composed because two constants are inconsistant p1_slot_value != p2_slot_value: " + p1_slot_value + " != " +  p2_slot_value );
	              return;
	              //GlobalUtilities.popUpMessage("ProductionCompilationModuleFun__Compose_Productions error!  p1_slot_value != p2_slot_value: " + p1_slot_value + " " +  p2_slot_value + ". P1 name: " + the_previous_rule.Rule_Name + ", P2 name: " + the_current_rule.Rule_Name );
	              //debug 
	              /*
		sim.vars.printingModule.Output_Trace = true;
		ProductionModuleFun__Print_A_Production(the_previous_rule);
		ProductionModuleFun__Print_A_Production(the_current_rule);
	               */
	            }
	          }
	        }
	        else{
	          //p1 does not have such slot name like "arg1", do not need to add any bindings
	        }
	      }
//	      if (enum_p2_condition_buffer_description.hasMoreElements()){ //there is next pair of slot_name : slot_value
//	        p2_node = p2_node.Next.Next;
//	      }
	      
	      if(enum_p2_condition_buffer_description.hasMoreElements()){
	        enum_p2_condition_buffer_description.nextElement();
	        itr_p2_condition_buffer_description.next(); // just jump one, another .next() will be called in the beginning of this while loop
	      }
	      
//	      if(itr_p2_condition_buffer_description.hasNext()){
//          itr_p2_condition_buffer_description.next(); // jump one
//        }
//        else{
//         System.out.println("Error! ProductionCompilationModuleFun__Compose_Productions has itr_p2_condition_buffer_description.hasNext() == false");
//         return; 
//        }
	      
	    }
	  }
	  
	  //Step 4:  Merging Mappings to be Consistent
	  /*
		IEnumerator enum_temp6 =  sim.vars.productionCompilationModule.Unify_Var_Var_Map.Keys.GetEnumerator();
		while(enum_temp6.MoveNext()){
		GlobalUtilities.popUpMessage((String)enum_temp6.Current + " " + sim.vars.productionCompilationModule.Unify_Var_Var_Map[(String)enum_temp6.Current]);
		}

		IEnumerator enum_temp7 =  sim.vars.productionCompilationModule.Unify_Var_Constant_Map.Keys.GetEnumerator();
		while(enum_temp7.MoveNext()){
		GlobalUtilities.popUpMessage((String)enum_temp7.Current + " _" + sim.vars.productionCompilationModule.Unify_Var_Constant_Map[(String)enum_temp7.Current] + "_");
		}
	   */
	  
	  
	  //ProductionCompilationModuleFun__Obsolete_Make_Mapping_Consistent();
	  Hashtable mapping = ProductionCompilationModuleFun__Make_Mapping_Hashtable();
	  
	  
	  //B. Substitution: 
	  //String[] p1_descriptors_subst = sim.funs.ProgramUtilitiesFun__Subst_String_Array( sim.funs.ProgramUtilitiesFun__Subst_String_Array( p1_descriptors, sim.vars.productionCompilationModule.Unify_Var_Var_Map) , sim.vars.productionCompilationModule.Unify_Var_Constant_Map );
	  //String[] p2_descriptors_subst = sim.funs.ProgramUtilitiesFun__Subst_String_Array( sim.funs.ProgramUtilitiesFun__Subst_String_Array( p2_descriptors_renamed, sim.vars.productionCompilationModule.Unify_Var_Var_Map) , sim.vars.productionCompilationModule.Unify_Var_Constant_Map );
	  String[] p1_descriptors_subst = sim.funs.ProgramUtilitiesFun__Subst_String_Array(p1_descriptors, mapping);
	  String[] p2_descriptors_subst = sim.funs.ProgramUtilitiesFun__Subst_String_Array(p2_descriptors_renamed, mapping);
	  
	  
	  /*
		if(p1_descriptors[1].equals(  "respond-to-retrieval-failure" && p2_descriptors[1].equals( "retrieve-operator"))){
		IEnumerator enum_temp8 = sim.vars.productionCompilationModule.Unify_Var_Var_Map.GetEnumerator();
		while(enum_temp8.MoveNext()){
		GlobalUtilities.popUpMessage((String)enum_temp8.Current );
		}
		}
	   */
	  /*
		IEnumerator enum_temp9 = p2_descriptors_subst.GetEnumerator();
		while(enum_temp9.MoveNext()){
		GlobalUtilities.popUpMessage((String)enum_temp9.Current );
		}
	   */
	  
	  //C. Collapsing:
	  
	  if( debug_flag ){
	    System.out.println( "ProductionCompilationModuleFun__Compose_Productions p1_descriptors_subst : " + sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty( p1_descriptors_subst ) );
	    System.out.println( "ProductionCompilationModuleFun__Compose_Productions p1_descriptors_subst : " + sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty( p2_descriptors_subst ) );
	  }
	  
	  String[] new_rule_descriptors = ProductionCompilationModuleFun__Collapsing(p1_descriptors_subst,  p2_descriptors_subst);
	  
	  if( debug_flag  ){
	    System.out.println( "ProductionCompilationModuleFun__Compose_Productions new_rule_descriptors : " + sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty( new_rule_descriptors ) );
	  }
	  
	  String compilation_note_for_new_rule = ProductionCompilationModuleFun__Get_Compilation_Note (p1_descriptors_subst,  p2_descriptors_subst[1]) ; //e.g., "RETRIEVE-OPERATOR & READ-ARG1 - OP1"
	  String new_rule_already_in_rule_pool = ProductionCompilationModuleFun__New_Rule_Already_In_Rule_Pool ( new_rule_descriptors);
	  
	  //compute utility for the new_rule
	  
	  if (new_rule_already_in_rule_pool.equals( "" )){//get this new rule compiled for the first time
	    //1st
	    ProductionModuleFun__Add_Production_Rule ( new_rule_descriptors ); //utility is initialized within this function, so must re-initialize
	    
	    //2nd
	    sim.vars.productionCompilationModule.Number_Of_New_Rules ++;
	    ProductionCompilationModuleFun__Set_Rule_Compilation_Note(new_rule_descriptors[1], compilation_note_for_new_rule);
	    /*
		Production_Rule the_rule_pointer = ProductionModuleFun__Find_Production_Rule_Pointer_By_Rule_Name(new_rule_descriptors[1]);
		GlobalUtilities.popUpMessage("Compose_Productions " + the_rule_pointer.Compilation_Note_For_New_Rule);
	     */
	    
	    //3rd, compilation father sons, QN features
	    Production_Rule son_pointer = ProductionModuleFun__Find_Production_Rule_Pointer_By_Rule_Name(new_rule_descriptors[1] );
	    Production_Rule father_pointer = ProductionModuleFun__Find_Production_Rule_Pointer_By_Rule_Name(p1_descriptors_subst[1] );
	    father_pointer.Compilation_Sons.addLast ( new_rule_descriptors[1]);  //add a son name
	    son_pointer.Compilation_Father = p1_descriptors_subst[1] ; //set the father name
	    
	    //4th
	    UtilityModuleFun__Initialize_Utility_For_Compiled_Production(new_rule_descriptors[1],p1_descriptors_subst[1],  p2_descriptors_subst[1] );
	    
	    sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("  Production " + p1_descriptors_subst[1].toUpperCase() + " and " + p2_descriptors_subst[1].toUpperCase() +" are being composed.");
	    sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("  New production:");
	    sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("  '"+ compilation_note_for_new_rule + "'");
	    sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("");
	    sim.funs.ProgramUtilitiesFun__Output_Rule_Descriptors_Trace_Txt ( new_rule_descriptors );
	    
	    sim.funs.ProgramUtilitiesFun__Output_Trace_Txt ("Parameters for production: " + new_rule_descriptors[1]);
	    sim.funs.ProgramUtilitiesFun__Output_Trace_Txt (" :utility    " + (String)sim.vars.utilityModule.utility.get( new_rule_descriptors[1]));
	    
	    if (sim.vars.utilityModule.utility_Computation_Method.equals( "temporal-difference-reinforcement")){
	      sim.funs.ProgramUtilitiesFun__Output_Trace_Txt (" :at    " + sim.vars.utilityModule.dat);
	      sim.funs.ProgramUtilitiesFun__Output_Trace_Txt (" :u          " + (String)sim.vars.utilityModule.U_N_Without_Noise.get( new_rule_descriptors[1]));
	      String reward = (String)sim.vars.utilityModule.reward.get( new_rule_descriptors[1]);
	      if (reward.equals( "" )){
	        sim.funs.ProgramUtilitiesFun__Output_Trace_Txt (" :reward     NIL"  );
	      }
	      else sim.funs.ProgramUtilitiesFun__Output_Trace_Txt (" :reward    " + reward  );
	    }
	    else if (sim.vars.utilityModule.utility_Computation_Method.equals( "PG-C")){
	      String temp_rule_name = new_rule_descriptors[1];
	      sim.funs.ProgramUtilitiesFun__Output_Trace_Txt (" :Effort    " +   sim.vars.utilityModule.PG_C_effort_rule_firing_time.get(temp_rule_name) );
	      sim.funs.ProgramUtilitiesFun__Output_Trace_Txt (" :P    " +   sim.vars.utilityModule.PG_C_p.get(temp_rule_name) );
	      sim.funs.ProgramUtilitiesFun__Output_Trace_Txt (" :C    " +   sim.vars.utilityModule.PG_C_c.get(temp_rule_name) );
	      sim.funs.ProgramUtilitiesFun__Output_Trace_Txt (" :PG-C    " +   sim.vars.utilityModule.pg_c.get(temp_rule_name) );
	      sim.funs.ProgramUtilitiesFun__Output_Trace_Txt (" :Successes    " +   sim.vars.utilityModule.PG_C_successes_num_for_each_rule.get(temp_rule_name) );
	      sim.funs.ProgramUtilitiesFun__Output_Trace_Txt (" :Failures    " +   sim.vars.utilityModule.PG_C_failures_num_for_each_rule.get(temp_rule_name) );
	      sim.funs.ProgramUtilitiesFun__Output_Trace_Txt (" :Efforts    " +   sim.vars.utilityModule.PG_C_efforts_for_cost_calculation.get(temp_rule_name) );
	      sim.funs.ProgramUtilitiesFun__Output_Trace_Txt (" :Success    " +   sim.vars.utilityModule.PG_C_success_flags.containsKey(temp_rule_name) );
	      sim.funs.ProgramUtilitiesFun__Output_Trace_Txt (" :Failure    " +   sim.vars.utilityModule.PG_C_failure_flags.containsKey(temp_rule_name) );
	    }
	    else System.out.println("Compose_Productions has undefined sim.vars.utilityModule.utility_Computation_Method case: " + sim.vars.utilityModule.utility_Computation_Method);
	    
	  }
	  else { //update utility of new_rule_descriptors[1]
	    sim.vars.productionCompilationModule.Number_Of_New_Rules ++;  //follow ACT-R convention, update but also add this number.
	    //each time New is recreated, its utility is updated with a reward equal to the current utility of Old1, using the same learning equation as discussed in the previous unit: Difference Learning Equation
	    //string recreating_rule_name =  ProductionCompilationModuleFun__Get_Rule_Name_By_Compilation_Note(compilation_note_for_new_rule);      //function deleted 05-01-2010
	    String recreating_rule_name = new_rule_already_in_rule_pool;
	    sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("  Production " + p1_descriptors_subst[1].toUpperCase() + " and " + p2_descriptors_subst[1].toUpperCase() +" are being composed.");
	    sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("  Recreating production " + recreating_rule_name);
	    
	    //update utility related values
	    UtilityModuleFun__Update_Utility_For_Compiled_Production(recreating_rule_name, p1_descriptors_subst[1],  p2_descriptors_subst[1] );
	    
	    sim.funs.ProgramUtilitiesFun__Output_Trace_Txt ("Parameters for production: " + recreating_rule_name);
	    sim.funs.ProgramUtilitiesFun__Output_Trace_Txt (" :utility    " + (String)sim.vars.utilityModule.utility.get( recreating_rule_name));
	    
	    //print output
	    if (sim.vars.utilityModule.utility_Computation_Method.equals( "temporal-difference-reinforcement")){
	      sim.funs.ProgramUtilitiesFun__Output_Trace_Txt (" :at    " + sim.vars.utilityModule.dat);
	      sim.funs.ProgramUtilitiesFun__Output_Trace_Txt (" :u          " + (String)sim.vars.utilityModule.U_N_Without_Noise.get( recreating_rule_name));
	      String reward = (String)sim.vars.utilityModule.reward .get( recreating_rule_name);
	      if (reward.equals( "" )){
	        sim.funs.ProgramUtilitiesFun__Output_Trace_Txt (" :reward     NIL"  );
	      }
	      else sim.funs.ProgramUtilitiesFun__Output_Trace_Txt (" :reward    " + reward  );
	    }
	    else if (sim.vars.utilityModule.utility_Computation_Method.equals( "PG-C")){
	      String temp_rule_name = recreating_rule_name;
	      sim.funs.ProgramUtilitiesFun__Output_Trace_Txt (" :Effort    " +   sim.vars.utilityModule.PG_C_effort_rule_firing_time.get(temp_rule_name) );
	      sim.funs.ProgramUtilitiesFun__Output_Trace_Txt (" :P    " +   sim.vars.utilityModule.PG_C_p.get(temp_rule_name) );
	      sim.funs.ProgramUtilitiesFun__Output_Trace_Txt (" :C    " +   sim.vars.utilityModule.PG_C_c.get(temp_rule_name) );
	      sim.funs.ProgramUtilitiesFun__Output_Trace_Txt (" :PG-C    " +   sim.vars.utilityModule.pg_c.get(temp_rule_name) );
	      sim.funs.ProgramUtilitiesFun__Output_Trace_Txt (" :Successes    " +   sim.vars.utilityModule.PG_C_successes_num_for_each_rule.get(temp_rule_name) );
	      sim.funs.ProgramUtilitiesFun__Output_Trace_Txt (" :Failures    " +   sim.vars.utilityModule.PG_C_failures_num_for_each_rule.get(temp_rule_name) );
	      sim.funs.ProgramUtilitiesFun__Output_Trace_Txt (" :Efforts    " +   sim.vars.utilityModule.PG_C_efforts_for_cost_calculation.get(temp_rule_name) );
	      sim.funs.ProgramUtilitiesFun__Output_Trace_Txt (" :Success    " +   sim.vars.utilityModule.PG_C_success_flags.containsKey(temp_rule_name) );
	      sim.funs.ProgramUtilitiesFun__Output_Trace_Txt (" :Failure    " +   sim.vars.utilityModule.PG_C_failure_flags.containsKey(temp_rule_name) );
	    }
	    else  System.out.println("Compose_Productions has undefined sim.vars.utilityModule.utility_Computation_Method case: " + sim.vars.utilityModule.utility_Computation_Method);
	  }
	  
	  
	  //play it safe, renew equivalent list again
	  sim.vars.programGlobalVar__ProductionCompilationModule_Equivalent_Var_Var_Constant_List.clear();
	}
	
	public  boolean ProductionCompilationModuleFun__Composeable_Productions_P(Production_Rule the_current_rule){
	  
	  if(sim.vars.printingModule.Output_Window_Trace)System.out.println( "ProductionCompilationModuleFun__Composeable_Productions_P for the_current_rule: " + the_current_rule.Rule_Name );
	  
	  //Parameterized_Production_Rule_Node the_previous_rule_node = ProductionModuleFun__Get_Rule_Node_From_Rule_Name(sim.vars.productionCompilationModule.Last_Fired_Rule_Name);
	  Production_Rule the_previous_rule = ProductionModuleFun__Find_Production_Rule_Pointer_By_Rule_Name(sim.vars.productionCompilationModule.Last_Fired_Rule_Name);
	  
	  LinkedList<String> current_production_buffers =   ProductionCompilationModuleFun__Get_Production_Buffers_From_Production_Rule(the_current_rule);
	  LinkedList<String> previous_production_buffers =  ProductionCompilationModuleFun__Get_Production_Buffers_From_Production_Rule(the_previous_rule);
	  LinkedList<String> merged_production_buffers = (LinkedList<String>) sim.funs.ProgramUtilitiesFun__Merge_Two_LinkedListString (current_production_buffers, previous_production_buffers) ;
	  
	  Enumeration buffer_list = Collections.enumeration(merged_production_buffers); 
	  while(buffer_list.hasMoreElements()){
	    //GlobalUtilities.popUpMessage(buffer_list.Current);
	    String currentItem = (String)buffer_list.nextElement();
	    String buffer_index_p1 = ProductionCompilationModuleFun__Get_Buffer_Index( the_previous_rule, currentItem);
	    String buffer_index_p2 = ProductionCompilationModuleFun__Get_Buffer_Index( the_current_rule , currentItem);
	    
	    
	    String buffer_type = ProductionCompilationModuleFun__Get_Buffer_Type ( currentItem );
	    
	    String look_up_key = buffer_type + ";" + buffer_index_p1 + ";" + buffer_index_p2;
	    
	    /*
				GlobalUtilities.popUpMessage(sim.vars.productionCompilationModule.Last_Fired_Rule_Name);
				GlobalUtilities.popUpMessage(the_current_rule_node.Rule_Descriptors[1]);
				GlobalUtilities.popUpMessage((String)buffer_list.Current);
				GlobalUtilities.popUpMessage(look_up_key);
	     */
	    
	    //look up compilation criteria, if uncomposeable, return false. otherwise, continue
	    //GlobalUtilities.popUpMessage( sim.vars.productionCompilationModule.Compilation_Check_Lookup_Table[look_up_key] );
	    String look_up_value = (String)sim.vars.productionCompilationModule.Compilation_Check_Lookup_Table.get(look_up_key);
	    switch (look_up_value){
	      case "t": //then this buffer is ok
	        //GlobalUtilities.popUpMessage((String)buffer_list.Current);
	        break;
	        
	      case "nil": //this buffer prevent composing
	        sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("  Buffer " + currentItem + " prevents composition of these productions");
	        return false;
	        
        case "no-rhs-reference": //ACT-R production-compilation.lisp: "Can't compile if the variable naming the buffer is used in the actions of p2"  
	        //This means that, when the previous rule p1 has +goal-type> action, p2 right hand side cannot have =goal as a buffer action slot value, so that p1 p2 can be composed. By the way, usually =goal can be used as a buffer action slot value, which refers to the chunk in the goal buffer.
	        //the reason is simple, because +goal> in p1 will change the goal buffer. if compiled, the =goal value will become the goal buffer chunk before the +goal> action, which will be different from p1 + p2 separately
	        //this has been tested in ACT-R. the =goal value in RHS of p2 can be in any buffer goal or imaginal, anywhere.
	        if (ProductionCompilationModuleFun__No_RHS_Reference( currentItem, the_current_rule) == false){
	          sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("  Buffer " + currentItem + " prevents composition of these productions, because 'Can't compile if the variable naming the buffer is used in the actions of p2'(no-rhs-reference)");
	          return false;
	        }
	        break;
	        
	      case "r-b-c1": //can compile Only if the p2 query is "state busy" or "buffer empty" (ACT-R 6.0 2009-1-7. potential bug, ToDo: may also need to accept "-state free" and "-buffer full")
	        if (ProductionCompilationModuleFun__R_B_C1( currentItem, the_current_rule) == false){
	          sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("  Buffer " + currentItem + " prevents composition of these productions, because production 2 query must be 'state busy/free' or 'buffer empty'(R_B_C1)");
	          return false;
	        }
	        break;
	        
	      case "r-b-c2": //queries in p1 and p2 must be the same //   ToDo: NOTE: this doesn't take into account any variables at this time" (ACT-R 6.0 2009-1-7)
	        if (ProductionCompilationModuleFun__R_B_C2( currentItem, the_previous_rule ,the_current_rule) == false){
	          sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("  Buffer " + currentItem + " prevents composition of these productions, because queries in p1 and p2 must be the same (R_B_C2)");
	          return false;
	        }
	        break;
	        
	      default:
	      {
	        System.out.println ("ProductionCompilationModuleFun__Composeable_Productions_P error! the look_up_value is undefined: " + look_up_value + ", look_up_key: " + look_up_key + ", the_previous_rule: " + the_previous_rule.Rule_Name + ", the_current_rule " + the_current_rule.Rule_Name);
	        break;
	      }
	    }
	  }
	  
	  
	  //if not returned before, then composeable
	  return true;
	  
	  
	}
	
	public  String ProductionCompilationModuleFun__Get_Buffer_Index(Production_Rule the_rule, String the_buffer_name){
	  String return_string = "";
	  String[] rule_descriptors = ProductionModuleFun__Get_Rule_Descriptors_From_Production_Rule (the_rule);
	  int i;
	  LinkedList <String> temp_index = new LinkedList <String>();
	  
	  for (i = 0 ; i < rule_descriptors.length; i++){
	    if(rule_descriptors[i].length() == 0) { //this may happen when A direct request is used. see ACT-R 6.0 tutorial v1.4. chapter 5.8.1 . e.g., ==>	   =imaginal>      sum         =number   +retrieval>   =number
	      //GlobalUtilities.popUpMessage("ProductionCompilationModuleFun__Get_Buffer_Index has rule_descriptors[i].Length == 0. the rule_descriptors is: " +  sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty(rule_descriptors) );
	      continue;
	    }
	    if ( rule_descriptors[i].substring(rule_descriptors[i].length()-1).equals( ">") && !rule_descriptors[i].equals( ">" )) { //something interesting, exclude  ">"
	      if (rule_descriptors[i].equals( "==>")){
	        temp_index.addLast(">");
	      }
	      else if( rule_descriptors[i].substring(1, rule_descriptors[i].length()-2 +1 ).equals(the_buffer_name )){//target buffer
	        temp_index.addLast(rule_descriptors[i].substring(0,1)); //add the first symbol
	      }
	      else{} //other buffers, do nothing
	    }
	  }
	  
	  if (temp_index.getFirst().equals( ">")) temp_index.addFirst("{}");
	  if (temp_index.getLast().equals( ">")) temp_index.addLast("{}");
	  
	  Enumeration temp_enum = Collections.enumeration(temp_index); 
	  while(temp_enum.hasMoreElements()){
	    return_string = return_string + temp_enum.nextElement();
	  }
	  
	  //order the return_string characters
	  switch (return_string){
	    case "{}>+-":
	      return_string = "{}>-+";
	      break;
	      
	    case "=>-=":
	      return_string = "=>=-";
	      break;	
	      
	    case "=>+=":
	      return_string = "=>=+";
	      break;
	      
	    case "=>+-":
	      return_string = "=>-+";
	      break;
	      
	    case "=>=-+":
	    case "=>=+-":
	    case "=>-=+":
	    case "=>-+=":
	    case "=>+=-":
	    case "=>+-=":
	      return_string = "=>=-+";
	      break;
	      
	    case "?>+-":
	      return_string = "?>-+";
	      break;
	      
	    case "?=>{}":
	      return_string = "=?>{}";
	      break;
	      
	    case "?=>=":
	      return_string = "=?>=";
	      break;
	      
	    case "?=>-":
	      return_string = "=?>-";
	      break;
	      
	    case "?=>+":
	      return_string = "=?>+";
	      break;
	      
	    case "=?>=-":
	    case "=?>-=":
	    case "?=>=-":
	    case "?=>-=":
	      return_string = "=?>=-";
	      break;
	      
	    case "=?>=+":
	    case "=?>+=":
	    case "?=>=+":
	    case "?=>+=":
	      return_string = "=?>=+";
	      break;
	      
	    case "=?>-+":
	    case "=?>+-":
	    case "?=>-+":
	    case "?=>+-":
	      return_string = "=?>-+";
	      break;
	      
	    case "=?>=-+":
	    case "=?>=+-":
	    case "=?>-+=":
	    case "=?>-=+":
	    case "=?>+=-":
	    case "=?>+-=":
	    case "?=>=-+":
	    case "?=>=+-":
	    case "?=>-+=":
	    case "?=>-=+":
	    case "?=>+=-":
	    case "?=>+-=":
	      return_string = "=?>=-+";
	      break;
	      
	    default: //current order is OK
	    {
	      break;
	    }
	  }
	  
	  return return_string;
	}
	
	public  String ProductionCompilationModuleFun__Get_Buffer_Type(String the_buffer_name){
	  String buffer_type = null;
	  switch (the_buffer_name.toLowerCase()){
	    case "goal":
	    case "goal-2":
	    case "goal-x":
	    case "imaginal":
	      buffer_type = "Goal";
	      break;
	      
	    case "retrieval":
	      buffer_type = "Retrieval";
	      break;	
	      
	    case "visual-location":
	    case "visual":
	    case "aural-location":
	    case "aural":
	      buffer_type = "Perceptual";
	      break;
	      
	    case "manual":
	    case "vocal":
	      buffer_type = "Motor";
	      break;
	      
	    default:
	    {
	      System.out.println ("ProductionCompilationModuleFun__Get_Buffer_Type error! the buffer_name is undefined: " + the_buffer_name);
	      break;
	    }
	  }
	  
	  return buffer_type;
	}
	
	public  LinkedList<String> ProductionCompilationModuleFun__Get_Buffer_With_Head_Description(String[] the_rule_descriptors, String the_buffer_name,String the_key, String the_buffer_index){
	  LinkedList<String> return_linkedlist = new LinkedList<String>();
	  String[] rule_descriptors = the_rule_descriptors;
	  int i, j;
	  
	  if 	(the_key.equals( "condition")){
	    for (i=0; i < rule_descriptors.length; i++){
	      if(rule_descriptors[i].equals( "==>")){
	        break;
	      }
	      else{ 
	        if ( the_buffer_index.equals( "" )){ //both "=" and "?"
	          if ( rule_descriptors[i].equals( "=" + the_buffer_name + ">" ) || rule_descriptors[i].equals( "?" + the_buffer_name + ">" )){ // the only two possibilities
	            return_linkedlist.addLast( rule_descriptors[i] ); //new change for empty buffer request or action like =imaginal> <then nothing>
	            for ( j = 1 ; i + j < rule_descriptors.length; j ++){
	              if ( rule_descriptors[i + j].substring(rule_descriptors[i + j].length()-1).equals( ">") ) break; //reach the next ****>
	              else{
	                return_linkedlist.addLast( rule_descriptors[i + j] );			
	              }
	            }
	          }
	          else {} //do nothing
	        }
	        else if (the_buffer_index.equals( "=")){ //"="
	          if ( rule_descriptors[i].equals( "=" + the_buffer_name + ">" )){ //one of the only two possibilities
	            return_linkedlist.addLast( rule_descriptors[i] ); //new change for empty buffer request or action like =imaginal> <then nothing>
	            for ( j = 1 ; i + j < rule_descriptors.length; j ++){
	              if ( rule_descriptors[i + j].substring(rule_descriptors[i + j].length()-1).equals( ">") ) break; //reach the next ****>
	              else{
	                return_linkedlist.addLast( rule_descriptors[i + j] );			
	              }
	            }
	          }
	          else {} //do nothing
	          
	          
	        }
	        else if (the_buffer_index.equals( "?")){ //"?"
	          if (rule_descriptors[i].equals( "?" + the_buffer_name + ">")){ //one of the only two possibilities
	            return_linkedlist.addLast( rule_descriptors[i] ); //new change for empty buffer request or action like =imaginal> <then nothing>
	            for ( j = 1 ; i + j < rule_descriptors.length; j ++){
	              if ( rule_descriptors[i + j].substring(rule_descriptors[i + j].length()-1).equals( ">") ) break; //reach the next ****>
	              else{
	                return_linkedlist.addLast( rule_descriptors[i + j] );			
	              }
	            }
	          }
	          else {} //do nothing
	          
	        }
	        else{
	          System.err.println ("ProductionCompilationModuleFun__Get_Buffer_Without_Head_Description error! the_buffer_index for: "+  the_key +". is undefined: " + the_buffer_index);
	        }
	      }
	    }
	  }
	  else if (the_key.equals( "action")) {
	    for (i=0; i < rule_descriptors.length; i++){
	      if(rule_descriptors[i].equals( "==>")){
	        break;
	      }
	    }
	    for ( ; i < rule_descriptors.length; i++){
	      if ( the_buffer_index.equals( "" )){ //both "=" and "+"
	        if ( rule_descriptors[i].equals( "=" + the_buffer_name + ">" ) ||  rule_descriptors[i].equals( "+" + the_buffer_name + ">")){ //the only two possibilities, "-" will not pass composeable_p test
	          return_linkedlist.addLast( rule_descriptors[i] ); //new change for empty buffer request or action like =imaginal> <then nothing>
	          for ( j = 1 ; i + j < rule_descriptors.length; j ++){
	            if ( rule_descriptors[i + j].substring(rule_descriptors[i + j].length()-1).equals( ">") ) break; //reach the next ****>
	            else{
	              return_linkedlist.addLast( rule_descriptors[i + j] );			
	            }
	          }
	        }
	        else {} //do nothing
	      }	
	      else if ( the_buffer_index.equals( "=")){ //"="
	        if ( rule_descriptors[i].equals( "=" + the_buffer_name + ">")){ //one of the the only two possibilities, "-" will not pass composeable_p test
	          return_linkedlist.addLast( rule_descriptors[i] ); //new change for empty buffer request or action like =imaginal> <then nothing>
	          for ( j = 1 ; i + j < rule_descriptors.length; j ++){
	            if ( rule_descriptors[i + j].substring(rule_descriptors[i + j].length()-1).equals( ">") ) break; //reach the next ****>
	            else{
	              return_linkedlist.addLast( rule_descriptors[i + j] );			
	            }
	          }
	        }
	        else {} //do nothing
	      }
	      else if (the_buffer_index.equals( "+")){ //"+"
	        if ( rule_descriptors[i].equals( "+" + the_buffer_name + ">")){ //one of the the only two possibilities, "-" will not pass composeable_p test
	          return_linkedlist.addLast( rule_descriptors[i] ); //new change for empty buffer request or action like =imaginal> <then nothing>
	          for ( j = 1 ; i + j < rule_descriptors.length; j ++){
	            if ( rule_descriptors[i + j].substring(rule_descriptors[i + j].length()-1).equals( ">") ) break; //reach the next ****>
	            else{
	              return_linkedlist.addLast( rule_descriptors[i + j] );			
	            }
	          }
	        }
	        else {} //do nothing
	      }
	      else {//undefined
	        System.err.println ("ProductionCompilationModuleFun__Get_Buffer_Without_Head_Description error! the_buffer_index for: "+  the_key +". is undefined: " + the_buffer_index);
	      }
	    }
	  }
	  else{
	    System.err.println ("ProductionCompilationModuleFun__Get_Buffer_Without_Head_Description error! the_key is undefined: " + the_key);
	  }
	  
	  return return_linkedlist;
	}
	
	public  LinkedList<String> ProductionCompilationModuleFun__Get_Buffer_Without_Head_Description(String[] the_rule_descriptors, String the_buffer_name,String the_key, String the_buffer_index){
	  LinkedList<String> return_linkedlist = new LinkedList<String>();
	  String[] rule_descriptors = the_rule_descriptors;
	  int i, j;
	  
	  if 	(the_key.equals( "condition")){
	    for (i=0; i < rule_descriptors.length; i++){
	      if(rule_descriptors[i].equals( "==>")){
	        break;
	      }
	      else{ 
	        if ( the_buffer_index.equals( "" )){ //both "=" and "?"
	          if ( rule_descriptors[i].equals( "=" + the_buffer_name + ">" ) || rule_descriptors[i].equals( "?" + the_buffer_name + ">")){ // the only two possibilities
	            for ( j = 1 ; i + j < rule_descriptors.length; j ++){
	              if ( rule_descriptors[i + j].substring(rule_descriptors[i + j].length()-1).equals( ">") ) break; //reach the next ****>
	              else{
	                return_linkedlist.addLast( rule_descriptors[i + j] );			
	              }
	            }
	          }
	          else {} //do nothing
	        }
	        else if (the_buffer_index.equals( "=")){ //"="
	          if ( rule_descriptors[i].equals( "=" + the_buffer_name + ">" )){ //one of the only two possibilities
	            for ( j = 1 ; i + j < rule_descriptors.length; j ++){
	              if ( rule_descriptors[i + j].substring(rule_descriptors[i + j].length()-1).equals( ">") ) break; //reach the next ****>
	              else{
	                return_linkedlist.addLast( rule_descriptors[i + j] );			
	              }
	            }
	          }
	          else {} //do nothing
	          
	          
	        }
	        else if (the_buffer_index.equals( "?")){ //"?"
	          if (rule_descriptors[i].equals( "?" + the_buffer_name + ">")){ //one of the only two possibilities
	            for ( j = 1 ; i + j < rule_descriptors.length; j ++){
	              if ( rule_descriptors[i + j].substring(rule_descriptors[i + j].length()-1).equals( ">") ) break; //reach the next ****>
	              else{
	                return_linkedlist.addLast( rule_descriptors[i + j] );			
	              }
	            }
	          }
	          else {} //do nothing
	          
	        }
	        else{
	          System.err.println ("ProductionCompilationModuleFun__Get_Buffer_Without_Head_Description error! the_buffer_index for: "+  the_key +". is undefined: " + the_buffer_index);
	        }
	      }
	    }
	  }
	  else if (the_key.equals( "action")) {
	    for (i=0; i < rule_descriptors.length; i++){
	      if(rule_descriptors[i].equals( "==>")){
	        break;
	      }
	    }
	    for ( ; i < rule_descriptors.length; i++){
	      if ( the_buffer_index.equals( "" )){ //both "=" and "+"
	        if ( rule_descriptors[i].equals( "=" + the_buffer_name + ">" ) ||  rule_descriptors[i].equals( "+" + the_buffer_name + ">")){ //the only two possibilities, "-" will not pass composeable_p test
	          for ( j = 1 ; i + j < rule_descriptors.length; j ++){
	            if ( rule_descriptors[i + j].substring(rule_descriptors[i + j].length()-1).equals( ">") ) break; //reach the next ****>
	            else{
	              return_linkedlist.addLast( rule_descriptors[i + j] );			
	            }
	          }
	        }
	        else {} //do nothing
	      }	
	      else if ( the_buffer_index.equals( "=")){ //"="
	        if ( rule_descriptors[i].equals( "=" + the_buffer_name + ">")){ //one of the the only two possibilities, "-" will not pass composeable_p test
	          for ( j = 1 ; i + j < rule_descriptors.length; j ++){
	            if ( rule_descriptors[i + j].substring(rule_descriptors[i + j].length()-1).equals( ">") ) break; //reach the next ****>
	            else{
	              return_linkedlist.addLast( rule_descriptors[i + j] );			
	            }
	          }
	        }
	        else {} //do nothing
	      }
	      else if (the_buffer_index.equals( "+")){ //"+"
	        if ( rule_descriptors[i].equals( "+" + the_buffer_name + ">")){ //one of the the only two possibilities, "-" will not pass composeable_p test
	          for ( j = 1 ; i + j < rule_descriptors.length; j ++){
	            if ( rule_descriptors[i + j].substring(rule_descriptors[i + j].length()-1).equals( ">") ) break; //reach the next ****>
	            else{
	              return_linkedlist.addLast( rule_descriptors[i + j] );			
	            }
	          }
	        }
	        else {} //do nothing
	      }
	      else {//undefined
	        System.err.println ("ProductionCompilationModuleFun__Get_Buffer_Without_Head_Description error! the_buffer_index for: "+  the_key +". is undefined: " + the_buffer_index);
	      }
	    }
	  }
	  else{
	    System.err.println ("ProductionCompilationModuleFun__Get_Buffer_Without_Head_Description error! the_key is undefined: " + the_key);
	  }
	  
	  return return_linkedlist;
	}
	
	public  String ProductionCompilationModuleFun__Get_Compilation_Note(String[] p1, String p2_name){
	  String return_string;
	  return_string = p1[1] + " & " + p2_name ;
	  
	  boolean p1_has_add_retrieval = false;
	  int i;
	  for (i=0;i < p1.length ; i++ ){
	    if (p1[i].equals( "+retrieval>")) p1_has_add_retrieval = true;
	  }
	  
	  if (p1_has_add_retrieval){ //add the chunk's name currently in retrieval buffer
	    String chunk_name = sim.vars.retrievalBuffer.Retrieval_Buffer_Chunk.Chunk_Name;
	    return_string = return_string + " - " + chunk_name;
	  }
	  //GlobalUtilities.popUpMessage("_"+return_string+ "_");
	  return return_string;
	}
	
	public  String ProductionCompilationModuleFun__Get_P1_Add_Buffer_Case(int the_count, String the_buffer_name){
	  String return_string = null;
	  if (the_count == 0 ) { //Step 2a:  No +buffer> in first production.
	    return_string = "no_+buffer>";
	  }
	  else{
	    if ( !ProductionCompilationModuleFun__Get_Buffer_Type (the_buffer_name).equals( "Retrieval" ) ){ //Step 2b:  A non-retrieval-type +buffer> in first production
	      return_string = "non-retrieval-type_+buffer>";
	    }
	    else{ //Step 2c:  A retrieval-type +buffer> in first production
	      return_string = "retrieval-type_+buffer>";
	    }
	  }
	  return return_string;
	}
	
	/**
	 * side effect, adding Unify_Var_Constant_Map appeared in +retrieval> action
	 * @param p1_condition
	 * @param p1_action_modify
	 * @param p1_action_add
	 * @param the_p1_add_buffer_case
	 * @return return LinkedList<string> newly constructed; return what the buffer descritpors is in the buffer after p1 fired.
	 */
	public  LinkedList<String> ProductionCompilationModuleFun__Get_P1_Description_To_Map(LinkedList<String> p1_condition, LinkedList<String> p1_action_modify, LinkedList<String> p1_action_add, String the_p1_add_buffer_case){
	  	  
	  LinkedList<String> return_linkedlist = new LinkedList<String>();
	  //LinkedList<String> p1_condition = (LinkedList<String>)  the_p1_condition;
	  //LinkedList<String> p1_action_modify = (LinkedList<String>) the_p1_action_buffer_description_modify;
	  //LinkedList<String> p1_action_add = (LinkedList<String>) the_p1_action_buffer_description_add;
	  
	  /*
		Hashtable p1_action_modify_hashtable = new Hashtable();
		IEnumerator enum_p1_action_modify = p1_action_modify.GetEnumerator();
		while(enum_p1_action_modify.MoveNext()){
		string key = (String)enum_p1_action_modify.Current;
		enum_p1_action_modify.MoveNext();
		string value = (String)enum_p1_action_modify.Current;
		p1_action_modify_hashtable.Add (key, value ) ;
		}
	   */
	  
	  switch (the_p1_add_buffer_case){ 
	    case "no_+buffer>":  //Step 2a:  No +buffer> in first production.
	      
	      LinkedList<String> temp_linkedlist = (LinkedList<String>)ProductionCompilationModuleFun__Buffer_Description_Conflict_Union(p1_action_modify, p1_condition  ); // p1_condition includes only =buffer  condition
	      return_linkedlist = sim.funs.ProgramUtilitiesFun__LinkedListString_Append (return_linkedlist,  temp_linkedlist ); //this is equivalent to LinkedList clone because the list after appending is based on return_linkedlist which is newly constructed.
	      
	      /*
		IEnumerator enum_p1_condition = p1_condition.GetEnumerator();
		while(enum_p1_condition.MoveNext()){
		//GlobalUtilities.popUpMessage("enum_p1_condition.Current: " + enum_p1_condition.Current);
		if ( ! p1_action_modify_hashtable.Contains( (String)enum_p1_condition.Current  ) ) {
		//GlobalUtilities.popUpMessage((String)enum_p1_condition.Current ) ;	
		return_linkedlist.addLast((String)enum_p1_condition.Current);
		enum_p1_condition.MoveNext();
		//GlobalUtilities.popUpMessage((String)enum_p1_condition.Current ) ;			
		return_linkedlist.addLast((String)enum_p1_condition.Current); //add the slot-value pair
		}
		else {
		string key = (String)enum_p1_condition.Current;
		return_linkedlist.addLast(  key  );
		enum_p1_condition.MoveNext();
		return_linkedlist.addLast( (String)p1_action_modify_hashtable[  key  ]  );
		}
		//GlobalUtilities.popUpMessage( return_linkedlist.Count );
		}
	       */
	      
	      break;
	      
	    case "non-retrieval-type_+buffer>":  //Step 2b:  A non-retrieval-type +buffer> in first production
	      /*
		IEnumerator enum_p1_action_add = p1_action_add.GetEnumerator();	
		while (enum_p1_action_add.MoveNext()){
		return_linkedlist.addLast((String)enum_p1_action_add.Current);
		}	
	       */
	      return_linkedlist = sim.funs.ProgramUtilitiesFun__LinkedListString_Append (return_linkedlist, p1_action_add); //this is equivalent to LinkedList clone
	      
	      break;
	      
	      
	    case "retrieval-type_+buffer>": //Step 2c:  A retrieval-type +buffer> in first production
	      
	      LinkedList<String> retrieved_chunk_in_linkedlist =   DeclarativeModuleFun__Get_Retrieved_Chunk_In_Linkedlist(); //used for return
	      Chunk retrieval_buffer_chunk_pointer = sim.vars.retrievalBuffer.Retrieval_Buffer_Chunk; //used for variable-constant matching
	      LinkedList<String> variables_in_add_retrieval_description =   ProductionModuleFun__Get_Production_None_Buffer_Variables (   sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString ( p1_action_add ) );
	      Enumeration enum_variables_in_add_retrieval_description = Collections.enumeration(variables_in_add_retrieval_description);
	      while(enum_variables_in_add_retrieval_description.hasMoreElements()){ //deal with +retrieval> in p1 and retrieved buffer chunk. e.g., +retrieval> isa number-order  first  =num1
	        String key =  (String) enum_variables_in_add_retrieval_description.nextElement(); //e.g., =num1
	        String slot_name = p1_action_add.get( p1_action_add.indexOf(key) - 1 );
	        //string value = retrieved_chunk_in_linkedlist.Find(slot_name).Next.Value;
	        String value = (String) retrieval_buffer_chunk_pointer.Slot.get(slot_name); //e.g., 7 . Since p1 is the previously fired rule that leads to the chunk in the retrieval buffer, the current chunk in the retrieval buffer should have slot key and value match to p1 +retrieval> request
	        
	        /*
		//old method
		if(sim.vars.productionCompilationModule.Unify_Var_Constant_Map.ContainsKey(key) == true){
		if((String)sim.vars.productionCompilationModule.Unify_Var_Constant_Map[key].equals( value)){
		//want to add the same key-value pair, OK
		}
		else{//want to add a different key-value pair
		GlobalUtilities.popUpMessage("ToDo: ProductionCompilationModuleFun__Get_P1_Description_To_Map Step 2c wants to add a different key-value pair");
		}
		}
		else{ //newly add
		sim.vars.productionCompilationModule.Unify_Var_Constant_Map.Add(key, value );
		}
	         */
	        ProductionCompilationModuleFun__Add_Equivalent_Var_Var_Constant_List(key, value);
	        
	        //GlobalUtilities.popUpMessage( key +" " + value );
	      }
	      
	      return_linkedlist = retrieved_chunk_in_linkedlist;
	      
	      break;
	      
	    default:
	      System.err.println("ProductionCompilationModuleFun__Get_P1_Description_To_Map. the_p1_add_buffer_case is undefined: " + the_p1_add_buffer_case);
	      break;
	      
	  }
	  
	  
	  return return_linkedlist;
	}
	
	public  LinkedList<String> ProductionCompilationModuleFun__Get_Production_Buffers_From_Production_Rule(Production_Rule the_rule){
	  LinkedList <String> return_linkedlist = new LinkedList<String>();
	  
	  Enumeration enum_condition_item = Collections.enumeration(the_rule.Condition);
	  while (enum_condition_item.hasMoreElements()){
	    return_linkedlist.addLast (  ((Production_Rule_Condition_Action_Item)enum_condition_item.nextElement()).Buffer_Name);
	  }
	  
	  Enumeration enum_action_item = Collections.enumeration(the_rule.Action);
	  while (enum_action_item.hasMoreElements()){
	    return_linkedlist.addLast ( ((Production_Rule_Condition_Action_Item)enum_action_item.nextElement()).Buffer_Name);
	  }
	  
	  return return_linkedlist;
	}
	
	public  LinkedList<String> ProductionCompilationModuleFun__Get_Production_Buffers_From_Rule_Descriptors(String[] the_rule_descriptors){

	  LinkedList <String> return_linkedlist = new LinkedList<String>();
	  String[] rule_descriptors = the_rule_descriptors;
	  int i;
	  
	  for (i = 0 ; i < rule_descriptors.length; i++){
	    if ( rule_descriptors[i].substring(rule_descriptors[i].length()-1).equals( ">")   && !rule_descriptors[i].equals( "==>" ) ){
	      if (!return_linkedlist.contains(rule_descriptors[i].substring(1, rule_descriptors[i].length()-2 +1)) ) return_linkedlist.addLast(rule_descriptors[i].substring(1, rule_descriptors[i].length()-2 +1));
	    }
	  }
	  
	  return return_linkedlist;
	}
	  
	public  void ProductionCompilationModuleFun__Load_Compilation_Criteria(){

  	  //QN-Java way
  	  Sheet sheetSymbolList = sim.files.Defaults_compilation_check_criteria.wb.getSheet("Symbol_List");
  	  for (int i = 0; i < 24; i ++){
  	    String stringCellValue = sheetSymbolList.getRow(i).getCell(0).getStringCellValue();
        sim.vars.productionCompilationModule.Buffer_Test_Symbol_List.put( stringCellValue, Integer.toString(i+1) ); // e.g., key: {}>{}  / value: 1  
        sim.vars.productionCompilationModule.Buffer_Test_Symbol_List.put( Integer.toString(i+1), stringCellValue ); // also has reversed pair like key: 1 / value: {}>{}
        //System.out.println(stringCellValue + " " + (i+1));
      }
  	  
  	  String temp_key_string;
  	  
  	  //load goal type buffer check table
  	  Sheet goalCompilation = sim.files.Defaults_compilation_check_criteria.wb.getSheet("goal-compilation");
      for (int i = 0; i < 24; i ++){
        for (int j = 0; j< 24; j++){
          String stringCellValue = goalCompilation.getRow(i).getCell(j).getStringCellValue();
          sim.vars.productionCompilationModule.Goal_Compilation_Check_Table[i][j] = stringCellValue;
          temp_key_string = "Goal" + ";" + sim.vars.productionCompilationModule.Buffer_Test_Symbol_List.get(Integer.toString(i+1)) + ";" + sim.vars.productionCompilationModule.Buffer_Test_Symbol_List.get(Integer.toString(j+1));  //e.g., Goal;{}>{};{}>-
          sim.vars.productionCompilationModule.Compilation_Check_Lookup_Table.put(temp_key_string, stringCellValue);
          //System.out.println(temp_key_string + " - " + stringCellValue);
        }
      }
      
      
      //load retrieval type buffer check table
      Sheet retrievalCompilation = sim.files.Defaults_compilation_check_criteria.wb.getSheet("retrieval-compilation");
      for (int i = 0; i < 24; i ++){
        for (int j = 0; j< 24; j++){
          String stringCellValue = retrievalCompilation.getRow(i).getCell(j).getStringCellValue();
          sim.vars.productionCompilationModule.Retrieval_Compilation_Check_Table[i][j] = stringCellValue;
          temp_key_string = "Retrieval" + ";" + sim.vars.productionCompilationModule.Buffer_Test_Symbol_List.get(Integer.toString(i+1)) + ";" + sim.vars.productionCompilationModule.Buffer_Test_Symbol_List.get(Integer.toString(j+1));  //e.g., Retrieval;{}>{};{}>-
          sim.vars.productionCompilationModule.Compilation_Check_Lookup_Table.put(temp_key_string, stringCellValue);
          //System.out.println(temp_key_string + " - " + stringCellValue);
        }
      }
      
      //load perceptual type buffer check table
      Sheet perceptualCompilation = sim.files.Defaults_compilation_check_criteria.wb.getSheet("perceptual-compilation");
      for (int i = 0; i < 24; i ++){
        for (int j = 0; j< 24; j++){
          String stringCellValue = perceptualCompilation.getRow(i).getCell(j).getStringCellValue();
          sim.vars.productionCompilationModule.Perceptual_Compilation_Check_Table[i][j] = stringCellValue;
          temp_key_string = "Perceptual" + ";" + sim.vars.productionCompilationModule.Buffer_Test_Symbol_List.get(Integer.toString(i+1)) + ";" + sim.vars.productionCompilationModule.Buffer_Test_Symbol_List.get(Integer.toString(j+1));  //e.g., Perceptual;{}>{};{}>-
          sim.vars.productionCompilationModule.Compilation_Check_Lookup_Table.put(temp_key_string, stringCellValue);
          //System.out.println(temp_key_string + " - " + stringCellValue);
        }
      }
      
      //load motor type buffer check table
      Sheet motorCompilation = sim.files.Defaults_compilation_check_criteria.wb.getSheet("motor-compilation");
      for (int i = 0; i < 24; i ++){
        for (int j = 0; j< 24; j++){
          String stringCellValue = motorCompilation.getRow(i).getCell(j).getStringCellValue();
          sim.vars.productionCompilationModule.Motor_Compilation_Check_Table[i][j] = stringCellValue;
          temp_key_string = "Motor" + ";" + sim.vars.productionCompilationModule.Buffer_Test_Symbol_List.get(Integer.toString(i+1)) + ";" + sim.vars.productionCompilationModule.Buffer_Test_Symbol_List.get(Integer.toString(j+1));  //e.g., Motor;{}>{};{}>-
          sim.vars.productionCompilationModule.Compilation_Check_Lookup_Table.put(temp_key_string, stringCellValue);
          //System.out.println(temp_key_string + " - " + stringCellValue);
        }
      }
      
  	  //C# way
	  /*
	  int i, j;
	  //load buffer condition symbols
	  Communication.Excel_compilation_check_criteria.SetSheet("Symbol_List");
	  Object [,] temp_object = (Object [,])Communication.Excel_compilation_check_criteria.GetCell("A1:A24");
	  for (i = 0; i < 24; i ++){
	    sim.vars.productionCompilationModule.Buffer_Test_Symbol_List.put( (String) temp_object[i+1][1], i+1 ); // e.g., key: {}>{}  / value: 1  
	    sim.vars.productionCompilationModule.Buffer_Test_Symbol_List.put( i+1, (String) temp_object[i+1][1] ); // also has reversed pair like key: 1 / value: {}>{}
	  }
	  
	  String temp_key_string;
	  //load goal type buffer check table
	  Communication.Excel_compilation_check_criteria.SetSheet("goal-compilation");
	  temp_object = (Object [,])Communication.Excel_compilation_check_criteria.GetCell("A1:X24");
	  for (i = 0; i < 24; i ++){
	    for (j = 0; j< 24; j++){
	      sim.vars.productionCompilationModule.Goal_Compilation_Check_Table[i][j] = (String) temp_object[i+1][j+1];
	      temp_key_string = "Goal" + ";" + sim.vars.productionCompilationModule.Buffer_Test_Symbol_List[i+1] + ";" + sim.vars.productionCompilationModule.Buffer_Test_Symbol_List[j+1];  //e.g., Goal;{}>{};{}>-
	      sim.vars.productionCompilationModule.Compilation_Check_Lookup_Table.Add(temp_key_string, sim.vars.productionCompilationModule.Goal_Compilation_Check_Table[i][j]);
	    }
	  }
	  
	  //load retrieval type buffer check table
	  Communication.Excel_compilation_check_criteria.SetSheet("retrieval-compilation");
	  temp_object = (Object [,])Communication.Excel_compilation_check_criteria.GetCell("A1:X24");
	  for (i = 0; i < 24; i ++){
	    for (j = 0; j< 24; j++){
	      sim.vars.productionCompilationModule.Retrieval_Compilation_Check_Table[i][j] = (String) temp_object[i+1][j+1];
	      temp_key_string = "Retrieval" + ";" + sim.vars.productionCompilationModule.Buffer_Test_Symbol_List[i+1] + ";" + sim.vars.productionCompilationModule.Buffer_Test_Symbol_List[j+1];  //e.g., Retrieval;{}>{};{}>-
	      sim.vars.productionCompilationModule.Compilation_Check_Lookup_Table.put(temp_key_string, sim.vars.productionCompilationModule.Retrieval_Compilation_Check_Table[i][j]);
	    }
	  }
	  
	  //load perceptual type buffer check table
	  Communication.Excel_compilation_check_criteria.SetSheet("perceptual-compilation");
	  temp_object = (Object [,])Communication.Excel_compilation_check_criteria.GetCell("A1:X24");
	  for (i = 0; i < 24; i ++){
	    for (j = 0; j< 24; j++){
	      sim.vars.productionCompilationModule.Perceptual_Compilation_Check_Table[i][j] = (String) temp_object[i+1][j+1];
	      temp_key_string = "Perceptual" + ";" + sim.vars.productionCompilationModule.Buffer_Test_Symbol_List[i+1] + ";" + sim.vars.productionCompilationModule.Buffer_Test_Symbol_List[j+1];  //e.g., Perceptual;{}>{};{}>-
	      sim.vars.productionCompilationModule.Compilation_Check_Lookup_Table.put(temp_key_string, sim.vars.productionCompilationModule.Perceptual_Compilation_Check_Table[i][j]);
	    }
	  }
	  
	  //load motor type buffer check table
	  Communication.Excel_compilation_check_criteria.SetSheet("motor-compilation");
	  temp_object = (Object [,])Communication.Excel_compilation_check_criteria.GetCell("A1:X24");
	  for (i = 0; i < 24; i ++){
	    for (j = 0; j< 24; j++){
	      sim.vars.productionCompilationModule.Motor_Compilation_Check_Table[i][j] = (String) temp_object[i+1,j+1];
	      temp_key_string = "Motor" + ";" + sim.vars.productionCompilationModule.Buffer_Test_Symbol_List[i+1] + ";" + sim.vars.productionCompilationModule.Buffer_Test_Symbol_List[j+1];  //e.g., Motor;{}>{};{}>-
	      sim.vars.productionCompilationModule.Compilation_Check_Lookup_Table.put(temp_key_string, sim.vars.productionCompilationModule.Motor_Compilation_Check_Table[i][j]);
	    }
	  }
	  */
	}
		
	public  Hashtable ProductionCompilationModuleFun__Make_Mapping_Hashtable(){
	  
	  Hashtable return_hashtable = new Hashtable();
	  Enumeration enum_list = Collections.enumeration(sim.vars.programGlobalVar__ProductionCompilationModule_Equivalent_Var_Var_Constant_List);
	  while(enum_list.hasMoreElements()){
	    LinkedList<String> a_list = (LinkedList<String>)enum_list.nextElement();
	    if(a_list.size() < 2){ //play it safe
	      System.out.println("ProductionCompilationModuleFun__Make_Mapping_Hashtable a_list.Count < 2");
	      break;
	    }
	    String representative = (String)a_list.getLast();  //the last value is the representative that can be var or constant, guarenteed by ProductionCompilationModuleFun__Add_Equivalent_Var_Var_Constant_List
	    a_list.remove(representative); // do not need mapping one to oneself
	    Enumeration enum_var = Collections.enumeration(a_list);
	    while(enum_var.hasMoreElements()){ // add all the var-representative mapping. 
	      return_hashtable.put( (String)enum_var.nextElement(),  representative );
	    }
	  }
	  return return_hashtable ;
	}
	
	public  String ProductionCompilationModuleFun__New_Rule_Already_In_Rule_Pool(String[] the_descriptors){
	  Enumeration enum_rule = Collections.enumeration(sim.vars.productionModule.Production_Rules);
	  while ( enum_rule.hasMoreElements()){//check average rule
	    //test if the two rules have the same content.  
	    Production_Rule currentRule = (Production_Rule)enum_rule.nextElement();
	    boolean is_two_rules_same_in_content = ProductionModuleFun__Does_Two_Production_Rule_Have_Same_Contents(  currentRule,   ProductionModuleFun__Make_Production_Rule_From_Descriptors(the_descriptors) );
	    if (is_two_rules_same_in_content) return currentRule.Rule_Name;
	  }
	  return ""; //no such rule in procedural memory
	  
	  //old version using Rule_Node, and compare the whole descriptor after the rule-name.
	  /*
		Parameterized_Production_Rule_Node a_node = new Parameterized_Production_Rule_Node();
		a_node = Parameterized_Production_Rule_Pool;
		while(a_node!=null){
		LinkedList<String> temp1 = sim.funs.ProgramUtilitiesFun__StringArray_To_LinkedList_String(a_node.Rule_Descriptors);
		temp1.RemoveFirst();
		temp1.RemoveFirst();
		LinkedList<String> temp2 = sim.funs.ProgramUtilitiesFun__StringArray_To_LinkedList_String(the_descriptors);
		temp2.RemoveFirst();
		temp2.RemoveFirst();
		if (sim.funs.ProgramUtilitiesFun__StringArray_To_String_Stop_If_Empty( sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(temp1)) .equals( sim.funs.ProgramUtilitiesFun__StringArray_To_String_Stop_If_Empty( sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(temp2))){
		//GlobalUtilities.popUpMessage(sim.funs.ProgramUtilitiesFun__StringArray_To_String_Stop_If_Empty( sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(temp1)));	
		return a_node.Rule_Descriptors[1];
		}

		a_node = a_node.Next_Rule;
		}
		return "";
	   */
	  //the old way of taking (String) the_note
	  /*
		Parameterized_Production_Rule_Node a_node = new Parameterized_Production_Rule_Node();
		a_node = Parameterized_Production_Rule_Pool;
		while(a_node!=null){
		if (a_node.Compilation_Note_For_New_Rule .equals( the_note) return true;
		a_node = a_node.Next_Rule;
		}
		return false;
	   */
	}
	
	public  boolean ProductionCompilationModuleFun__No_RHS_Reference(String the_buffer_name, Production_Rule the_current_rule){
	  //GlobalUtilities.popUpMessage(the_buffer_name); //like goal, retrieval
	  String target_string =  "=" + the_buffer_name;
	  LinkedList<String> action_part_variable_list = ProductionModuleFun__Get_Production_Action_Part_None_Buffer_Variables( ProductionModuleFun__Get_Rule_Descriptors_From_Production_Rule(the_current_rule));
	  if(action_part_variable_list.contains(target_string)){ //there is RHS reference of =goal like buffer chunk
	    return false;
	  }
	  else{ //there is no RHS reference
	    return true;
	  }
	}
	
	public  void ProductionCompilationModuleFun__Obsolete_Reset_Production_Compilation(){
	  sim.vars.productionCompilationModule.Last_Fired_Rule_Name = "";
	  sim.vars.productionCompilationModule.Last_Rule_Fired_Time = (double) 0.0;
	}
	
	public  void ProductionCompilationModuleFun__Production_Compilation_Process(Production_Rule the_current_rule){
	  
	  // Model.PrintOutput?
	  
	  if(sim.vars.printingModule.Output_Window_Trace)System.out.println( "ProductionCompilationModuleFun__Production_Compilation_Process for the_current_rule: " + the_current_rule.Rule_Name );
	  
	  //checking flow chart, from production-compilation.lisp ACT-R 6.0
	  /*

		    start
		      |
		      V
		      |
		-------------------------
		.--------------------.--------------------->| Wait for a production |
		|                    |                      -------------------------
		|                    |                                 |
		|                    |                                 V
		|                    |                                 |
		|                    |                      ------------------------- 
		|                    |                      | call it current       |
		|                    |                      -------------------------
		|                    |                                 |
		|                    |                                 V
		|                    ^                                 |
		|                    |                       /---------------------\
		|            ------------------             /  is current valid-p   \
		|            | clear previous | ------<--N- \                       / 
		|            ------------------              \---------------------/
		|                    |                                 | 
		|                    |                                 Y
		|                    |                                 |
		|                    ^                                 V
		|                    |                                 |
		^                    N                                 |
		|                    |                       /---------------------\
		----------------      /-----------\                /  is there a previous  \
		| set previous |     / is current  \---------<--N- \                       /
		| to current   |-<-Y-\ valid-1st-p /                \---------------------/
		----------------      \-----------/                           |
		|                                 | 
		|                                 Y
		|                                 |
		|                                 |
		^                                 V
		|                                 | 
		|                       /---------------------\
		|                      /   are previous and    \
		+----------------<--N- \ current composable    /
		|                       \---------------------/
		|                                 | 
		|                                 Y
		|                                 |
		^                                 V
		|                                 | 
		|                      --------------------------
		+----------------<---- | Compose new production |
		--------------------------


	   */
	  boolean debug_trace = false;
	  String[] current_rule_descriptors = ProductionModuleFun__Get_Rule_Descriptors_From_Production_Rule(the_current_rule);
	  String current_rule_name = the_current_rule.Rule_Name;
	  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("Production Compilation process started for " + current_rule_name);
	  
	  //is current valid-p. 
	  
	  //if  "current" is valid-p false, clear previous and return
	  if( ProductionCompilationModuleFun__Valid_P( the_current_rule ) == false ) { 
	    ProductionCompilationModuleFun__Clear_Previous ();
	    return;
	  }
	  
	  //if "current" is valid-p true, continue the following
	  
	  
	  
	  
	  //is there a previous
	  //if no previous
	  if(sim.vars.productionCompilationModule.Last_Fired_Rule_Name.equals("")){
	    sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("  No previous production to compose with.");
	    //is current valid-1st-p. 
	    if ( ProductionCompilationModuleFun__Valid_First_P ( the_current_rule ) == false){
	      //if no, clear previous and return
	      ProductionCompilationModuleFun__Clear_Previous ();
	      return;
	    }
	    else{
	      //if yes, set previous to current and return. 
	      //record last rule info
	      ProductionCompilationModuleFun__Set_Previous_To_Current(current_rule_name);
	      return;
	    }
	  }
	  //if there is a previous, continue as the follows:
	  
	  
	  //Parameterized_Production_Rule_Node previous_rule_node = ProductionModuleFun__Get_Rule_Node_From_Rule_Name(sim.vars.productionCompilationModule.Last_Fired_Rule_Name);
	  Production_Rule the_previous_rule = ProductionModuleFun__Find_Production_Rule_Pointer_By_Rule_Name(sim.vars.productionCompilationModule.Last_Fired_Rule_Name);
	  //String[] last_rule_descriptors = ProductionModuleFun__Get_Rule_Descriptors_From_Rule_Node (previous_rule_node);
	  String[] last_rule_descriptors = ProductionModuleFun__Get_Rule_Descriptors_From_Production_Rule (the_previous_rule);
	  //String last_rule_name = last_rule_descriptors[1];
	  String last_rule_name = the_previous_rule.Rule_Name;
	  
	  //are previous and current composable?
	  /*
		;;; First, the production must fire within the threshold time of each other.
		;;; Then, for each buffer used in either production the composition charts
		;;; are consulted to determine if its useage is composeable.  In addition,
		;;; if the buffer tests are successful, there is an additional pass to
		;;; check that the buffer actions in the first are compatible with the
		;;; conditions in the second to avoid any problems with an "unusual" change
		;;; in the buffers.
		;;;
		;;; The composition process considers buffers to fall into one of 4 general
		;;; types (goal, retrieval, perceptual, and motor) and the mechanism differs
		;;; based on the types of buffers used in the two productions.  The Microsoft 
		;;; Excel file "compose.xls" in the docs directory lays out the rules that
		;;; govern the composabilty of productions based on the types of buffers
		;;; used and the conditions and actions they contain.
		;;;
		;;; That file is used to generate the composability tables used in this file.
		;;; The idea is that if one wants to either modify or extend the compilation
		;;; mechanism, then that can be done by changing or adding new spreadsheets
		;;; and then rebuilding the corresponding tables in this file instead of
		;;; having to recode the whole thing.  That may require also adding some new
		;;; testing functions or composition functions, but it should not require
		;;; changing the existing testing and composing functions.
		;;;   
		;;; The Microsoft Word document "compose.doc" in the docs directory describes
		;;; the process used to compose the productions into a new one.
		;;;
		;;; The default assignment of buffers to types is as follows (assuming that
		;;; a buffer by that name exists):
		;;;
		;;; Buffer name           Type
		;;;  goal              goal
		;;;  retrieval         retrieval
		;;;  visual-location   perceptual
		;;;  visual            perceptual
		;;;  aural-location    perceptual
		;;;  aural             perceptual
		;;;  manual            motor
		;;;  vocal             motor
		;;; 
		;;; Any other buffer will be assumed to be of type motor unless configured
		;;; using the specify-compilation-buffer-type command (which can also be used
		;;; to change the types for the default buffer assignments).
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	   */
	  
	  //are previous and current composable? 1, Check time between last_rule and current_rule	
	  //if the interval time is too long:
	  if ( GlobalUtilities.round (SimSystem.clock(),3) - sim.vars.productionCompilationModule.Last_Rule_Fired_Time > sim.vars.productionCompilationModule.tt){
	    sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("  Cannot compile "+ sim.vars.productionCompilationModule.Last_Fired_Rule_Name + " and " + current_rule_name+ " because the time between them exceeds the threshold time.");
	    
	    //is current valid-1st-p. 
	    if ( ProductionCompilationModuleFun__Valid_First_P ( the_current_rule ) == false){
	      //if no, clear previous and return
	      ProductionCompilationModuleFun__Clear_Previous ();
	      return;
	    }
	    else{
	      //if yes, set previous to current and return. 
	      //record last rule info
	      ProductionCompilationModuleFun__Set_Previous_To_Current(current_rule_name);
	      return;
	    }
	  }
	  //else the interval time is not too long, continue the follows:
	  
	  //are previous and current composable? 2, Check buffer constraints
	  //if buffer constraints are not OK
	  if (ProductionCompilationModuleFun__Composeable_Productions_P(the_current_rule) == false ){
	    sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("  Production "+ sim.vars.productionCompilationModule.Last_Fired_Rule_Name + " and " + current_rule_name+ " cannot be compiled.");
	    //is current valid-1st-p. 
	    if ( ProductionCompilationModuleFun__Valid_First_P ( the_current_rule ) == false){
	      //if no, clear previous and return
	      ProductionCompilationModuleFun__Clear_Previous ();
	      return;
	    }
	    else{
	      //if yes, set previous to current and return. 
	      //record last rule info
	      ProductionCompilationModuleFun__Set_Previous_To_Current(current_rule_name);
	      return;
	    }
	  }	
	  //else, no problem with buffer constraints, continue the follows
	  
	  //goes here means composeable
	  ProductionCompilationModuleFun__Compose_Productions(the_previous_rule, the_current_rule);
	  //after composing
	  //is current valid-1st-p. 
	  if ( ProductionCompilationModuleFun__Valid_First_P ( the_current_rule ) == false){
	    //if no, clear previous and return
	    ProductionCompilationModuleFun__Clear_Previous ();
	    return;
	  }
	  else{
	    //if yes, set previous to current and return. 
	    //record last rule info
	    ProductionCompilationModuleFun__Set_Previous_To_Current(current_rule_name);
	    return;
	  }
	}
	
	public  boolean ProductionCompilationModuleFun__R_B_C1(String the_buffer_name, Production_Rule the_rule){
	  String[] rule_descriptors = ProductionModuleFun__Get_Rule_Descriptors_From_Production_Rule (the_rule);
	  int i;
	  for (i = 0 ; i < rule_descriptors.length; i++){
	    if (rule_descriptors[i].equals( "==>"))break; //because r-b-c1 only checks query in the condition part
	    if ( rule_descriptors[i].equals( "?" + the_buffer_name + ">")){
	      if (rule_descriptors[i+1].substring(0,1).equals ( "-")){
	        if(rule_descriptors[i+1].toLowerCase().equals( "-state" ) &&  rule_descriptors[i+2].toLowerCase().equals( "free") ){
	          System.out.println("ProductionCompilationModuleFun__R_B_C1 follows ACT-R (potential bug) treat '- state free' as not composeable" );
	          return false;
	        }
	        else if (rule_descriptors[i+1].toLowerCase().equals( "-buffer") &&  rule_descriptors[i+2].toLowerCase().equals( "full") ){
	          System.out.println("ProductionCompilationModuleFun__R_B_C1 follows ACT-R (potential bug) treat '- buffer full' as not composeable" );
	          return false;
	        }
	        else{
	          return false;
	        }	
	      }
	      else{
	        if(rule_descriptors[i+1].toLowerCase().equals( "state") &&  rule_descriptors[i+2].toLowerCase().equals( "busy") ){}
	        else if (rule_descriptors[i+1].toLowerCase().equals( "buffer") &&  rule_descriptors[i+2].toLowerCase().equals( "empty") ){}
	        else{
	          return false;
	        }		
	      }
	    }
	  }
	  
	  return true; //if it goes here, then it is composeable.
	}
	
	public  boolean ProductionCompilationModuleFun__R_B_C2(String the_buffer_name, Production_Rule the_previous_rule, Production_Rule the_current_rule){
	  //similar to a condition item test in ProductionModuleFun__Does_Two_Production_Rule_Have_Same_Contents
	  //play it safe by using clone rather than pointer to the two rules
	  boolean debug_trace = false;
	  Production_Rule the_previous_rule_clone = sim.funs.ProgramUtilitiesFun__Production_Rule_Clone(the_previous_rule);
	  Production_Rule the_current_rule_clone = sim.funs.ProgramUtilitiesFun__Production_Rule_Clone(the_current_rule);
	  Production_Rule_Condition_Action_Item    the_previous_rule_clone_item_pointer     = ProductionModuleFun__Get_Condition_Action_Item_Pointer_From_Production_Rule(the_previous_rule_clone, ("?" + the_buffer_name + ">") , "condition");
	  Production_Rule_Condition_Action_Item    the_current_rule_clone_item_pointer     = ProductionModuleFun__Get_Condition_Action_Item_Pointer_From_Production_Rule(the_current_rule_clone, ("?" + the_buffer_name + ">") , "condition");
	  
	  if(the_previous_rule_clone_item_pointer == null) {
	    System.out.println("ProductionCompilationModuleFun__R_B_C2 Error! the_previous_rule_clone_item_pointer == null");
	    return false;
	  }
	  if(the_current_rule_clone_item_pointer == null) {
	    System.out.println("ProductionCompilationModuleFun__R_B_C2 Error! the_current_rule_clone_item_pointer == null");
	    return false;
	  }
	  
	  //go through every slot attribute and value in the buffer query
	  //prepare used for tracking complicated cases
	  LinkedList <String> variables_from_the_rule_in_memory = new LinkedList <String>();
	  LinkedList <String> variables_from_the_tested_rule = new LinkedList <String>();
	  
	  Production_Rule_Condition_Action_Item a_condition_item = the_previous_rule_clone_item_pointer; //change name so that can use previous code in "ProductionModuleFun__Does_Two_Production_Rule_Have_Same_Contents"
	  Production_Rule_Condition_Action_Item the_tested_rule_clone_item_pointer  = the_current_rule_clone_item_pointer;
	  
	 
	  Iterator<Entry<String, String>> itrSlot = a_condition_item.Slot.entrySet().iterator();
	  while(itrSlot.hasNext()){ //go over each attribute-name and attribute-value in the condition item
	    Entry<String, String> currentEntry = itrSlot.next();
	    String key = (String) currentEntry.getKey();
	    String value = (String) currentEntry.getValue();
	    if (the_tested_rule_clone_item_pointer.Slot.containsKey(key) == false){
	      if(debug_trace)System.out.println("ProductionCompilationModuleFun__R_B_C2, the_previous_rule: " + the_previous_rule.Rule_Name + "and the_current_rule: " + the_current_rule.Rule_Name + " false due to condition part (the_tested_rule_clone_item_pointer.Slot.ContainsKey(key) == false)");
	      return false;
	    }
	    String value_in_tested_rule_slot = (String)the_tested_rule_clone_item_pointer.Slot.get(key);
	    if ( ProgramUtilitiesFun__StringsEqualByStringOrDouble(value, value_in_tested_rule_slot )){ //pass this round of match
	      the_tested_rule_clone_item_pointer.Slot.remove(key);
	    }
	    else{ 
	      if (value.charAt(0) == '=' || value_in_tested_rule_slot.charAt(0) == '='){//may be a complicated case, both slot-values are variables but are different like "=num1" and "=number1", track this variable mismatch and see at the end
	        variables_from_the_rule_in_memory.addLast(value);
	        variables_from_the_tested_rule.addLast(value_in_tested_rule_slot);
	      }
	      else { //two values like "7" and "8", or one value one variable are different
	        if(debug_trace)System.out.println("ProductionCompilationModuleFun__R_B_C2, the_previous_rule: " + the_previous_rule.Rule_Name + "and the_current_rule: " + the_current_rule.Rule_Name + " false due to condition part (two values like 7 and 8, or one value one variable are different)");
	        return false;
	      }
	    }
	  }
	  //after passing all the slot key-value pair from the_previous_rule, check if the_current_rule has more slot key-value pair
	  if (the_tested_rule_clone_item_pointer.Slot.size() > 0) {
	    if(debug_trace)System.out.println("ProductionCompilationModuleFun__R_B_C2, the_previous_rule: " + the_previous_rule.Rule_Name + "and the_current_rule: " + the_current_rule.Rule_Name + " false due to condition part (the_tested_rule_clone_item_pointer.Slot.Count > 0)");
	    return false;
	  }
	  
	  if (variables_from_the_rule_in_memory.size() == 0 && variables_from_the_tested_rule.size() ==0){
	    return true;//reach here mean Two_Production_Rule_Have_Same_Contents
	  }
	  else { //complicated cases
	    System.out.println("ToDo: ProductionCompilationModuleFun__R_B_C2, the_previous_rule: " + the_previous_rule.Rule_Name + "and the_current_rule: " + the_current_rule.Rule_Name + " have complicated cases at the end.");
	    return false; //temporarily make the compiler happy, in fact, this may be false or not. 
	  }
	  
	  
	  /*
		//old version
		String[] p1_rule_descriptors = ProductionModuleFun__Get_Rule_Descriptors_From_Production_Rule (the_previous_rule);
		String[] p2_rule_descriptors = ProductionModuleFun__Get_Rule_Descriptors_From_Production_Rule (the_current_rule);
		LinkedList<String> queries_1 = new LinkedList<String>();
		LinkedList<String> queries_2 = new LinkedList<String>();

		int i, j;
		for (i = 0 ; i < p1_rule_descriptors.Length; i++){
		if ( p1_rule_descriptors[i].equals( "?" + the_buffer_name + ">")){
		for ( j = 1 ; i + j < p1_rule_descriptors.Length; j ++){
		if ( p1_rule_descriptors[i + j].Substring(p1_rule_descriptors[i + j].Length-1).equals( ">") ) break; //reach the next ****>
		else{
		queries_1.addLast( p1_rule_descriptors[i + j] );			
		}
		if (p1_rule_descriptors[i + j].Substring(0,1).equals ( "-")){
		GlobalUtilities.popUpMessage("ProductionCompilationModuleFun__Obsolete_R_B_C2 need to deal with '- state busy' type query.");
		//ToDo: deal with '- state busy' type query
		}
		}
		}
		}

		for (i = 0 ; i < p2_rule_descriptors.Length; i++){
		if ( p2_rule_descriptors[i].equals( "?" + the_buffer_name + ">")){
		for ( j = 1 ; i + j < p2_rule_descriptors.Length; j ++){
		if ( p2_rule_descriptors[i + j].Substring(p2_rule_descriptors[i + j].Length-1).equals( ">") ) break; //reach the next ****>
		else{
		queries_2.addLast( p2_rule_descriptors[i + j] );			
		}
		if (p2_rule_descriptors[i + j].Substring(0,1).equals ( "-")){
		GlobalUtilities.popUpMessage("ProductionCompilationModuleFun__Obsolete_R_B_C2 need to deal with '- state busy' type query.");
		//ToDo: deal with '- state busy' type query
		}
		}
		}
		}

		LinkedList<String> query_1_2_merged = sim.funs.ProgramUtilitiesFun__Merge_Two_LinkedListString(queries_1, queries_2);


		if(queries_1.Count == queries_2.Count && queries_1.Count == query_1_2_merged.Count)return true;
		else return false;
	   */
	}
	
	public  void ProductionCompilationModuleFun__Set_Previous_To_Current(String current_rule_name){
	  
	  
	  sim.vars.productionCompilationModule.Last_Fired_Rule_Name= current_rule_name;
	  sim.vars.productionCompilationModule.Last_Rule_Fired_Time = GlobalUtilities.round (SimSystem.clock(),3);
	  
	  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("  Production compilation setting previous production to " + sim.vars.productionCompilationModule.Last_Fired_Rule_Name); 
	  
	}
	
	public  void ProductionCompilationModuleFun__Set_Rule_Compilation_Note(String the_rule_name,String the_compilation_note){
	  Production_Rule the_rule_pointer = ProductionModuleFun__Find_Production_Rule_Pointer_By_Rule_Name(the_rule_name);
	  the_rule_pointer.Compilation_Note_For_New_Rule = the_compilation_note;
	  
	  /*
		//old rule node version
		Parameterized_Production_Rule_Node a_node =  Parameterized_Production_Rule_Pool;
		while(a_node!=null){
		if (a_node.Rule_Descriptors[1] .equals( the_rule_name)break;
		a_node = a_node.Next_Rule;
		}
		if(a_node==null)GlobalUtilities.popUpMessage("ProductionCompilationModuleFun__Set_Rule_Compilation_Note ERROR. no such rule name.");
		a_node.Compilation_Note_For_New_Rule = the_compilation_note;
	   */
	}
	
	public  boolean ProductionCompilationModuleFun__Valid_First_P(Production_Rule the_rule){
	  Enumeration enum_action_item = Collections.enumeration(the_rule.Action);
	  
	  List<String> multiple_add_same_buffer_action_check = new ArrayList<String> ();
	  
	  while (enum_action_item.hasMoreElements()){
	    Production_Rule_Condition_Action_Item an_action_item = (Production_Rule_Condition_Action_Item)enum_action_item.nextElement();
	    String action_type = an_action_item.Type; // e.g.,  = or + or !eval!
	    String action_buffer_name = an_action_item.Buffer_Name; //e.g., goal  or visual-location  or  ...contents for !eval!...
	    
	    
	    //			;;;     - RHS !stop!
	    if( action_type.equals( "!stop!") ) {
	      return false;
	    }
	    
	    //- multiple +<buffer> actions for a specific buffer of any style
	    if( action_type.equals( "+" )){ 
	      if(multiple_add_same_buffer_action_check.contains( action_buffer_name ) == false) {
	        multiple_add_same_buffer_action_check.add (action_buffer_name );
	      }
	      else {
	        return false;
	      }
	    }
	  }
	  
	  
	  //if pass all the tests
	  return true;
	}
	
	public  boolean ProductionCompilationModuleFun__Valid_P(Production_Rule the_rule){
	  //Left Hand Side or condition, screening for
	  //;;;    - LHS !eval!
	  //;;;    - LHS !bind!
	  //;;;    - LHS !safe-bind! (this is a precautionary stance for now)
	  //;;;    - LHS !mv-bind!
	  Enumeration enum_condition_item = Collections.enumeration(the_rule.Condition);
	  
	  List<String> multiple_LHS_same_buffer_test_check = new ArrayList<String>(); // ;;;    - multiple LHS ='s for any one buffer.
	  
	  
	  while (enum_condition_item.hasMoreElements()){
	    Production_Rule_Condition_Action_Item a_condition_item = (Production_Rule_Condition_Action_Item)enum_condition_item.nextElement();
	    String condition_type = a_condition_item.Type; // e.g.,  = or ? or !eval!
	    String condition_buffer_name = a_condition_item.Buffer_Name; //e.g., goal  or visual-location  or  ...contents for !eval!...
	    
	    
	    //			;;;    - LHS !eval!
	    //			;;;    - LHS !bind!
	    //			;;;    - LHS !safe-bind! (this is a precautionary stance for now)
	    //			;;;    - LHS !mv-bind!
	    if( condition_type.equals( "!eval!" ) ||  condition_type.equals( "!bind!"  ) ||   condition_type.equals( "!safe-bind!" )    ||   condition_type.equals( "!mv-bind!")  ){
	      return false;
	    }
	    
	    
	    //if not returned,  // ;;;    - multiple LHS ='s for any one buffer.
	    if( condition_type.equals( "=") ){ 
	      if(multiple_LHS_same_buffer_test_check.contains( condition_buffer_name) == false){
	        multiple_LHS_same_buffer_test_check.add ( condition_buffer_name );
	      }
	      else{
	        return false;
	      }
	    }
	    
	  }
	  
	  
	  
	  //;;;    - RHS !eval!
	  //;;;    - RHS !bind!
	  //;;;    - RHS !mv-bind!
	  Enumeration enum_action_item = Collections.enumeration(the_rule.Action);
	  while (enum_action_item.hasMoreElements()){
	    Production_Rule_Condition_Action_Item an_action_item = (Production_Rule_Condition_Action_Item)enum_action_item.nextElement();
	    String action_type = an_action_item.Type; // e.g.,  = or + or !eval!
	    String action_buffer_name = an_action_item.Buffer_Name; //e.g., goal  or visual-location  or  ...contents for !eval!...
	    
	    
	    //			;;;    - RHS !eval!
	    //			;;;    - RHS !bind!
	    //			;;;    - RHS !mv-bind!
	    if( action_type.equals( "!eval!" )  ||   action_type.equals( "!bind!" )     ||  action_type.equals( "!mv-bind!")  ){
	      return false;
	    }
	    
	    
	    //;;;    - *NEW* No direct requests 
	    if( action_type.charAt(0) != '!' &&  an_action_item.Slot.size() == 1 && an_action_item.Slot.containsKey ("")  &&  !((String) an_action_item.Slot.get("")).equals( "" )){
	      //it is a direct request
	      return false;
	    }
	    
	    //TODO	;;;    - *Temporary* No slot modifiers other than = in conditions other than goal tests.
	  }
	  
	  //passed all the tests
	  return true;
	}
	
	//ProductionModuleFun
	
	public  void ProductionModuleFun__Action_Bang_Ouput_Bang(String the_expression, Hashtable the_variable_value_pair){
	  
	  String output_string = "!output!\t";
	  
	  if( the_expression.equals( "" ) ) {
	    sim.funs.ProgramUtilitiesFun__Output_Trace_Txt( output_string );
	    return;
	  }
	  //else
	  
	  String [] the_expression_array_substituted = sim.funs.ProgramUtilitiesFun__Subst_String_Array (  sim.funs.ProgramUtilitiesFun__String_To_StringArray (the_expression)  , the_variable_value_pair);
	  output_string += sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty(  the_expression_array_substituted);
	  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt( output_string );
	  
	  
//	  Iterator<Entry>itrTemp = the_variable_value_pair.entrySet().iterator();
//	  while(itrTemp.hasNext()){
//	    Entry anEntry = itrTemp.next();
//	    System.out.println("ProductionModuleFun__Action_Bang_Ouput_Bang anEntry: " + anEntry.getKey() + ", " + anEntry.getValue());
//	  }
	  
	}
	
	public  void ProductionModuleFun__Add_Aural_Request(String[] The_Chunk_Spec_Request){
	  
	  //modifed from Add Visual Request
	  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(),3) + "\t" + "PROCEDURAL" + "\t" + "MODULE-REQUEST AURAL"); 
	  
	  ProductionModuleFun__Clear_Aural_Buffer_Request();
	  
	  Entity Temp_Entity = sim.funs.createEntity( "Audio Module" , "Execution", "Audio Module", "Add Aural", 0.0);
	  
	  //Entity Temp_Entity = new Entity();  //send entity rather than change Global variable immediately, because aural request must take some time aboue 0.285, so no need to finish it before the next cycle of production matching.
	  //Temp_Entity.ID = "13"; //directly send to Audio Module
	  //Temp_Entity.Time = (double) SimSystem.clock();
	  //Temp_Entity.Tag = Entity_Number; //give it an entity number, init. 1
	  //Entity_Number++;
	  //Temp_Entity.From = "Execution"; //tag from and to
	  //Temp_Entity.To = "Audio Module";
	  //Temp_Entity.Entity_Type = "Add Aural";    // +aural>
	  // parameters: ISA (slot_0), chunk_type(slot_0), slot_name_1, slot_value_1, slot_name_2, slot_value_2, ... for nil value, put "nil"
	  
	  int j;
	  for (j = 0; j < The_Chunk_Spec_Request.length; j+=2){
	    if(The_Chunk_Spec_Request[j+1].equals( "=aural-location")){
	      String aural_location_chunk_name = sim.funs.ChunkFun__Get_Chunk_Slot_Value( sim.vars.auralLocationBuffer.Aural_Location_Buffer_Chunk, "id");
	      sim.funs.ChunkFun__Add_Chunk_Slot_Name_And_Value(Temp_Entity.Chunk, The_Chunk_Spec_Request[j], aural_location_chunk_name);
	    }
	    else{
	      sim.funs.ChunkFun__Add_Chunk_Slot_Name_And_Value(Temp_Entity.Chunk, The_Chunk_Spec_Request[j], The_Chunk_Spec_Request[j+1]);  //can handle exception for ISA chunk-type
	    }
	  }
	  
	  //ChunkFun__Print_Chunk (Temp_Entity.Chunk); //debug
	  
	  
	  
	}
	
	public  void ProductionModuleFun__Add_Goal_2_Request(String[] The_Chunk_Spec_Request){
	  
	  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(),3) + "\t" + "PROCEDURAL" + "\t" + "MODULE-REQUEST GOAL-2"); 
	  
	  ProductionModuleFun__Clear_Goal_Buffer_2_Request();
	  
	  Entity Temp_Entity = sim.funs.createEntity( "Intentional Module" , "Execution", "Intentional Module", "Add Goal-2", 0.0);
	  //Entity Temp_Entity = new Entity();  
	  //Temp_Entity.ID = "1"; //Intentional Module
	  //Temp_Entity.Time = (double) SimSystem.clock();
	  //Temp_Entity.Tag = Entity_Number; //give it an entity number, init. 1
	  //Entity_Number++;
	  //Temp_Entity.From = "Execution"; //tag from and to
	  //Temp_Entity.To = "Intentional Module";
	  //Temp_Entity.Entity_Type = "Add Goal-2";    // +goal-2>
	  // parameters: ISA (slot_0), chunk_type(slot_0), slot_name_1, slot_value_1, slot_name_2, slot_value_2, ... for nil value, put ""
	  
	  //define-chunk, +goal> will not specify chunk_name, so it does not have a name.
	  Temp_Entity.Chunk = sim.funs.ChunkFun__Define_Chunk( sim.funs.ChunkFun__Make_Chunk_From_Descritption(The_Chunk_Spec_Request));
	  
	  
	  
	  /*
			//old
			int j;
			for (j = 0; j < The_Chunk_Spec_Request.Length; j+=2){
				ChunkFun__Add_Chunk_Slot_Name_And_Value(Temp_Entity.Chunk, The_Chunk_Spec_Request[j], The_Chunk_Spec_Request[j+1]);  //can handel exception for ISA chunk-type
			}
			Temp_Entity.Chunk.Chunk_Name = Temp_Entity.Chunk.Chunk_Type;
	   */
	  
	}
	
	public  void ProductionModuleFun__Add_Goal_Request(String[] The_Chunk_Spec_Request){

	  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(),3) + "\t" + "PROCEDURAL" + "\t" + "MODULE-REQUEST GOAL"); 
	  
	  ProductionModuleFun__Clear_Goal_Buffer_Request();
	  
	  Entity Temp_Entity = sim.funs.createEntity( "Intentional Module" , "Execution", "Intentional Module", "Add Goal", 0.0);
//	  Entity Temp_Entity = new Entity();  
//	  Temp_Entity.ID = "1"; //Intentional Module
//	  Temp_Entity.Time = (double) SimSystem.clock();
//	  Temp_Entity.Tag = Entity_Number; //give it an entity number, init. 1
//	  Entity_Number++;
//	  Temp_Entity.From = "Execution"; //tag from and to
//	  Temp_Entity.To = "Intentional Module";
//	  Temp_Entity.Entity_Type = "Add Goal";    // +goal>
	  // parameters: ISA (slot_0), chunk_type(slot_0), slot_name_1, slot_value_1, slot_name_2, slot_value_2, ... for nil value, put ""
	  
	  //define-chunk, +goal> will not specify chunk_name, so it does not have a name.
	  Temp_Entity.Chunk = sim.funs.ChunkFun__Define_Chunk( sim.funs.ChunkFun__Make_Chunk_From_Descritption(The_Chunk_Spec_Request));
	  
	  
	  
	  /*
			//old
			int j;
			for (j = 0; j < The_Chunk_Spec_Request.Length; j+=2){
				ChunkFun__Add_Chunk_Slot_Name_And_Value(Temp_Entity.Chunk, The_Chunk_Spec_Request[j], The_Chunk_Spec_Request[j+1]);  //can handel exception for ISA chunk-type
			}
			Temp_Entity.Chunk.Chunk_Name = Temp_Entity.Chunk.Chunk_Type;
	   */
	  
	}
	
	public  void ProductionModuleFun__Add_Imaginal_Request(String[] The_Chunk_Spec_Request){

	  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(),3) + "\t" + "PROCEDURAL" + "\t" + "MODULE-REQUEST IMAGINAL"); 
	  
	  ProductionModuleFun__Clear_Imaginal_Buffer_Request();
	  
	  // below changed by Yelly
//	  Entity Temp_Entity = new Entity();  
//	  Temp_Entity.ID = "8"; //Imaginal Module
//	  Temp_Entity.Time = (double) SimSystem.clock();
//	  //Temp_Entity.Tag = Entity_Number; //give it an entity number, init. 1
//	  //Entity_Number++;
//	  Temp_Entity.From = "Execution"; //tag from and to
//	  Temp_Entity.To = "Imaginary Module";
//	  Temp_Entity.Entity_Type = "Add Imaginal";    // +imaginal>
	  // parameters: ISA (slot_0), chunk_type(slot_0), slot_name_1, slot_value_1, slot_name_2, slot_value_2, ... for nil value, put ""
	  
	  //define-chunk, +imaginal> will not specify chunk_name, so it does not have a name.
	  //Temp_Entity.Chunk = sim.funs.ChunkFun__Define_Chunk( sim.funs.ChunkFun__Make_Chunk_From_Descritption(The_Chunk_Spec_Request));
	  
	  // below are from master branch	  
	  Entity Temp_Entity = sim.funs.createEntity( "Imaginary Module" , "Execution", "Imaginary Module", "Add Imaginal", 0.0);
//	  Entity Temp_Entity = new Entity();  
//	  Temp_Entity.ID = "8"; //Imaginal Module
//	  Temp_Entity.Time = (double) SimSystem.clock();
//	  Temp_Entity.Tag = Entity_Number; //give it an entity number, init. 1
//	  Entity_Number++;
//	  Temp_Entity.From = "Execution"; //tag from and to
//	  Temp_Entity.To = "Imaginary Module";
//	  Temp_Entity.Entity_Type = "Add Imaginal";    // +imaginal>
	  // parameters: ISA (slot_0), chunk_type(slot_0), slot_name_1, slot_value_1, slot_name_2, slot_value_2, ... for nil value, put ""
	  
	  // modified by Yelly:
	  // when it comes to speedometer&critical element, define carefully to avoid chunk accumulation
	  Chunk temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(The_Chunk_Spec_Request);

	  String chunk_type = temp_chunk.Chunk_Type;
	  //System.out.println("ProductionModuleFun__Add_Imaginal_Request, chunk: ");
	  //sim.funs.ChunkFun__Print_Chunk(temp_chunk);
	  if(chunk_type.equals("world3d-driving-criticalelement-vehicle-img") || chunk_type.equals("world3d-driving-criticalelement-sign-img")) {
		  int temp_int = sim.funs.DeclarativeModuleFun__Find_The_DM_Chunk_ID_By_Chunk_Spec (temp_chunk);
		  if (temp_int == -1) {
			  // a new chunk
			  //define-chunk, +imaginal> will not specify chunk_name, so it does not have a name.
			  sim.funs.ChunkFun__Define_Chunk(temp_chunk);
		  }
		  else if (temp_int >= 0 && temp_int < sim.vars.declarativeModule.Number_of_Chunks) {
			  // the chunk with the same content already exists
			  // return that existing chunk
			  temp_chunk = sim.funs.ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer(sim.vars.declarativeModule.DM_Chunk, temp_int) ;
		  }
		  else {
			  System.err.println ("ProductionModuleFun__Add_Imaginal_Request, dm_chunk_id range Error!");
			  temp_chunk = new Chunk();
		  }
	  }
	  else if(chunk_type.equals("world3d-driving-speed-img")) {
		  int temp_int = sim.funs.DeclarativeModuleFun__Find_The_DM_Chunk_ID_By_Chunk_Spec (temp_chunk);
		  if (temp_int == -1) {
			  // a new chunk
			  //define-chunk, +imaginal> will not specify chunk_name, so it does not have a name.
			  sim.funs.ChunkFun__Define_Chunk(temp_chunk);
		  }
		  else if (temp_int >= 0 && temp_int < sim.vars.declarativeModule.Number_of_Chunks) {
			  // the chunk with the same content already exists
			  // return that existing chunk
			  temp_chunk = sim.funs.ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer(sim.vars.declarativeModule.DM_Chunk, temp_int) ;
		  }
		  else {
			  System.err.println ("ProductionModuleFun__Add_Imaginal_Request, dm_chunk_id range Error!");
			  temp_chunk = new Chunk();
		  }
	  }
	  
	  Temp_Entity.Chunk = temp_chunk;
	  
	  /*
			int j;
			for (j = 0; j < The_Chunk_Spec_Request.Length; j+=2){
				ChunkFun__Add_Chunk_Slot_Name_And_Value(Temp_Entity.Chunk, The_Chunk_Spec_Request[j], The_Chunk_Spec_Request[j+1]);  //can handel exception for ISA chunk-type
			}
			Temp_Entity.Chunk.Chunk_Name = Temp_Entity.Chunk.Chunk_Type;
	   */
	 
	}
	
	public  void ProductionModuleFun__Add_Manual_Request(String[] The_Chunk_Spec_Request){

	  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(),3) + "\t" + "PROCEDURAL" + "\t" + "MODULE-REQUEST MANUAL"); 
	  
	  ProductionModuleFun__Clear_Manual_Buffer_Request();
	  
	  Entity Temp_Entity = sim.funs.createEntity( "Motor Module" , "Execution", "Motor Module", "Add Manual", 0.0);
//	  Entity Temp_Entity = new Entity();  
//	  Temp_Entity.ID = "20"; //Motor Module
//	  Temp_Entity.Time = (double) SimSystem.clock();
//	  Temp_Entity.Tag = Entity_Number; //give it an entity number, init. 1
//	  Entity_Number++;
//	  Temp_Entity.From = "Execution"; //tag from and to
//	  Temp_Entity.To = "Motor Module";
//	  Temp_Entity.Entity_Type = "Add Manual";    // +manual>
	  // parameters: ISA (slot_0), chunk_type(slot_0), slot_name_1, slot_value_1, slot_name_2, slot_value_2, ... for nil value, put ""
	  
	  
	  //Model.Message ( sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty(The_Chunk_Spec_Request));
	  
	  Temp_Entity.Chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption ( The_Chunk_Spec_Request ); //make the chunk based on its ISA type, but do not define it in the model's chunk list
	  
	  /*
			//obsolete way of making the request chunk.
			int j;
			for (j = 0; j < The_Chunk_Spec_Request.Length; j+=2){
				ChunkFun__Add_Chunk_Slot_Name_And_Value(Temp_Entity.Chunk, The_Chunk_Spec_Request[j], The_Chunk_Spec_Request[j+1]);  //can handel exception for ISA chunk-type
			}
	   */
	  
	}
	
	public  void ProductionModuleFun__Add_Production_Rule(String[] The_Rule_Spec){
	  
	  Production_Rule new_rule = ProductionModuleFun__Make_Production_Rule_From_Descriptors (The_Rule_Spec) ;
	  new_rule.Action_Time = sim.vars.utilityModule.dat;
	  String rule_name = new_rule.Rule_Name;
	  
	  /*
			//GlobalUtilities.popUpMessage(rule_name + " " + MultitaskingFun__Is_Rule_Name_For_Multitasking(rule_name) + " " + MultitaskingFun__Is_Rule_For_Multitasking( The_Rule_Spec) );
			//for multitasking rule name orgin mapping
			if ( MultitaskingFun__Is_Rule_Name_For_Multitasking(rule_name) && MultitaskingFun__Is_Rule_For_Multitasking( The_Rule_Spec) ) {
				
			    string origin_name =  MultitaskingFun__Get_Origin_Counterpart_Name_For_A_Multitasking_Rule( new_rule ) ;
				//  GlobalUtilities.popUpMessage(rule_name + " " + origin_name);
				if(origin_name.equals( "" ) ) GlobalUtilities.popUpMessage("ProductionModuleFun__Add_Production_Rule has origin_name == empty " );
				sim.vars.utilityModule.Rule_Name_Origin_For_Multitasking.Add( rule_name, origin_name );
			}
			/////
	   */
	  
	  //ToDo: add rule name check. #|Warning: Production TEST1 already exists and it is being redefined. |# Model.Halt();
	  sim.vars.productionModule.Production_Rules.addLast( new_rule );
	  if (sim.vars.centralParametersModule.esc == true)	ProductionModuleFun__Initialize_Production_Rule_Utilities(new_rule.Rule_Name); 
	  
	  //initialize the Rule_Process_Goal_Buffer_Table
	  
	  String goal_buffer_index = ProductionCompilationModuleFun__Get_Buffer_Index(new_rule, "goal");
	  String goal_2_buffer_index = ProductionCompilationModuleFun__Get_Buffer_Index(new_rule, "goal-2");
	  LinkedList<String> processed_buffer_name_list = new LinkedList<String>();
	  if ( !goal_buffer_index.equals( "{}>{}" )) {
	    //debug	Model.Message ("ProductionModuleFun__Add_Production_Rule rule: " + rule_name + " is determined to have processed goal buffer");
	    processed_buffer_name_list.addLast("goal");
	  }
	  if ( ! goal_2_buffer_index.equals( "{}>{}" )){
	    //debug	Model.Message ("ProductionModuleFun__Add_Production_Rule rule: " + rule_name + " is determined to have processed goal-2 buffer");
	    processed_buffer_name_list.addLast("goal-2");
	  }
	  sim.vars.productionModule.Rule_Process_Goal_Buffer_Table.put( rule_name, processed_buffer_name_list );
	  
	  //GlobalUtilities.popUpMessage( "ProductionModuleFun__Add_Production_Rule " + rule_name + " " + processed_buffer_name_list  );
	  
	  
	  //ProductionModuleFun__Print_A_Production(new_rule);
	  
	}
	
	public  void ProductionModuleFun__Add_Retrieval_Request(String[] The_Chunk_Spec_Request){

	  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(),3) + "\t" + "PROCEDURAL" + "\t" + "MODULE-REQUEST RETRIEVAL"); 
	  
	  ProductionModuleFun__Clear_Retrieval_Buffer_Request();
	  
	  Entity Temp_Entity = sim.funs.createEntity( "Declarative Module" , "Execution", "Declarative Module", "Add Retrieval", 0.0);
//	  Entity Temp_Entity = new Entity();  //send entity rather than change Global variable immediately, because Retrieval must take some time, so no need to finish it before the next cycle of production matching.
//	  Temp_Entity.ID = "6"; //directly send to Declarative Module
//	  Temp_Entity.Time = (double) SimSystem.clock();
//	  Temp_Entity.Tag = Entity_Number; //give it an entity number, init. 1
//	  Entity_Number++;
//	  Temp_Entity.From = "Execution"; //tag from and to
//	  Temp_Entity.To = "Declarative Module";
//	  Temp_Entity.Entity_Type = "Add Retrieval";    // +retrieval>
	  // parameters: ISA (slot_0), chunk_type(slot_0), slot_name_1, slot_value_1, slot_name_2, slot_value_2, ... for nil value, put "nil"
	  int j;
	  for (j = 0; j < The_Chunk_Spec_Request.length; j+=2){
	    if(!The_Chunk_Spec_Request[j].substring(0,1).equals( "-" )){ //normal request
	      sim.funs.ChunkFun__Add_Chunk_Slot_Name_And_Value(Temp_Entity.Chunk, The_Chunk_Spec_Request[j], The_Chunk_Spec_Request[j+1]);  //can handel exception for ISA chunk-type
	    }	
	    else{ // NOT request, like "-arg book" 
	      //ToDo: remove this and change the function to "-" type method, move to DeclarativeModuleFun__Find_Add_Retrieval_Matched_DM_Chunk_IDs_By_Chunk_Spec like VisionModuleFun__Find_Visual_Location_In_Visicons_By_Chunk_Spec
	      String new_slot_name = The_Chunk_Spec_Request[j].substring(1, The_Chunk_Spec_Request[j].length() );
	      String new_slot_value = "NOT_"  + The_Chunk_Spec_Request[j+1];
	      //GlobalUtilities.popUpMessage(new_slot_name + "   " + new_slot_value);
	      sim.funs.ChunkFun__Add_Chunk_Slot_Name_And_Value(Temp_Entity.Chunk, new_slot_name, new_slot_value);
	    }
	  }

	  /*
			if (Clock > 200.4){ //debug
				GlobalUtilities.popUpMessage("Add_Retrieval_Request_" + Temp_Entity.Chunk.Chunk_Type );
				ProgramUtilitiesFun__Output_Trace_Txt("ProductionModuleFun__Add_Retrieval_Request:");
				ChunkFun__Print_Chunk (Temp_Entity.Chunk);
										
			}
	   */
	}
	
	public  void ProductionModuleFun__Add_Temporal_Request(String[] The_Chunk_Spec_Request){

	  
	  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(),3) + "\t" + "PROCEDURAL" + "\t" + "MODULE-REQUEST TEMPORAL"); 
	  
	  ProductionModuleFun__Clear_Temporal_Buffer_Request(); //ACT-R's +temporal> will trigger an implicit buffer clear action before it.
	  
	  Entity Temp_Entity = sim.funs.createEntity( "Temporal Module" , "Execution", "Temporal Module", "Add Temporal", 0.0);
//	  Entity Temp_Entity = new Entity();  
//	  Temp_Entity.ID = "602"; //Temporal Module
//	  Temp_Entity.Time = (double) SimSystem.clock();
//	  Temp_Entity.Tag = Entity_Number; //give it an entity number, init. 1
//	  Entity_Number++;
//	  Temp_Entity.From = "Execution"; //tag from and to
//	  Temp_Entity.To = "Temporal Module";
//	  Temp_Entity.Entity_Type = "Add Temporal";    // +temporal>
	  // parameters: ISA (slot_0), chunk_type(slot_0), slot_name_1, slot_value_1, slot_name_2, slot_value_2, ... for nil value, put ""
	  
	  //Temp_Entity.Chunk = sim.funs.ChunkFun__Define_Chunk( sim.funs.ChunkFun__Make_Chunk_From_Descritption(The_Chunk_Spec_Request));
	  // TODO (by Chris) we don't have to define chunk right?
	  
	  // (by Shi) ACT-R's temporal.pdf said "By issuing a +temporal> isa time on the RHS of a production, the Temporal buffer, that is, the current tick
	  // count, is initialized to zero. A chunk of type time is placed into temporal buffer with the tick slot set to 0."
	  // It is defined as (chunk-type time ticks) in temporal.lisp. I put this definition in ACTR_Default.txt
	  Temp_Entity.Chunk = sim.funs.ChunkFun__Define_Chunk(ChunkFun__Make_Chunk_From_Descritption(The_Chunk_Spec_Request));
	  
	  
	}
	
	public  void ProductionModuleFun__Add_Visual_Location_Request(String[] The_Chunk_Spec_Request){

	  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(),3) + "\t" + "PROCEDURAL" + "\t" + "MODULE-REQUEST VISUAL-LOCATION"); 
	  
	  ProductionModuleFun__Clear_Visual_Location_Buffer_Request();
	  
	  Entity Temp_Entity = sim.funs.createEntity( "Vision Module" , "Execution", "Vision Module", "Add Visual-location", 0.0);
//	  Entity Temp_Entity = new Entity();  
//	  Temp_Entity.ID = "10"; //Vision Module
//	  Temp_Entity.Time = (double) SimSystem.clock();
//	  Temp_Entity.Tag = Entity_Number; 
//	  Entity_Number++;
//	  Temp_Entity.From = "Execution"; //tag from and to
//	  Temp_Entity.To = "Vision Module";
//	  Temp_Entity.Entity_Type = "Add Visual-location";    
	  // parameters: ISA (slot_0), chunk_type(slot_0), slot_name_1, slot_value_1, slot_name_2, slot_value_2, ... for nil value, put ""
	  
	  //ToDo: here not sure whether to use renaming and define-chunk method like add_goal_request
	  
	  int j;
	  for (j = 0; j < The_Chunk_Spec_Request.length; j+=2){
	    sim.funs.ChunkFun__Add_Chunk_Slot_Name_And_Value(Temp_Entity.Chunk, The_Chunk_Spec_Request[j], The_Chunk_Spec_Request[j+1]);  //can handel exception for ISA chunk-type
	    Temp_Entity.Chunk.Slot_Names_In_Order.addLast(The_Chunk_Spec_Request[j]);
	  }
	}
	
	public  void ProductionModuleFun__Add_Visual_Request(String[] The_Chunk_Spec_Request){
	  
 
	  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(),3) + "\t" + "PROCEDURAL" + "\t" + "MODULE-REQUEST VISUAL"); 
	  
	  ProductionModuleFun__Clear_Visual_Buffer_Request();
	  
	  Entity Temp_Entity = sim.funs.createEntity( "Vision Module" , "Execution", "Vision Module", "Add Visual", 0.0);
//	  Entity Temp_Entity = new Entity();  //send entity rather than change Global variable immediately, because visual request must take some time 0.085, so no need to finish it before the next cycle of production matching.
//	  Temp_Entity.ID = "10"; //directly send to Vision Module
//	  Temp_Entity.Time = (double) SimSystem.clock();
//	  Temp_Entity.Tag = Entity_Number; //give it an entity number, init. 1
//	  Entity_Number++;
//	  Temp_Entity.From = "Execution"; //tag from and to
//	  Temp_Entity.To = "Vision Module";
//	  Temp_Entity.Entity_Type = "Add Visual";    // +visual>
	  // parameters: ISA (slot_0), chunk_type(slot_0), slot_name_1, slot_value_1, slot_name_2, slot_value_2, ... for nil value, put ""
	  
	  
	  
	  int j;
	  for (j = 0; j < The_Chunk_Spec_Request.length; j+=2){
	    //if(The_Chunk_Spec_Request[j+1].equals( "=visual-location")){  //moved to ProductionModuleFun__Make_Chunk_Spec_For_Buffer_Operator_In_Action_Part
	    //	string visual_location_chunk_name = sim.vars.visualLocationBuffer.Visual_Location_Buffer_Chunk.Chunk_Name;
	    //	ChunkFun__Add_Chunk_Slot_Name_And_Value(Temp_Entity.Chunk, The_Chunk_Spec_Request[j], visual_location_chunk_name);
	    //}
	    //else{
	    sim.funs.ChunkFun__Add_Chunk_Slot_Name_And_Value(Temp_Entity.Chunk, The_Chunk_Spec_Request[j], The_Chunk_Spec_Request[j+1]);  //can handel exception for ISA chunk-type
	    //}
	  }
	  
	  //ChunkFun__Print_Chunk (Temp_Entity.Chunk); //debug
	  
	}
	
	public  void ProductionModuleFun__Add_Vocal_Request(String[] The_Chunk_Spec_Request){

	  
	  //modified from Add Manual Request
	  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(),3) + "\t" + "PROCEDURAL" + "\t" + "MODULE-REQUEST VOCAL"); 
	  
	  ProductionModuleFun__Clear_Vocal_Buffer_Request();
	  
	  Entity Temp_Entity = sim.funs.createEntity( "Speech Module" , "Execution", "Speech Module", "Add Vocal", 0.0);
//	  Entity Temp_Entity = new Entity();  
//	  Temp_Entity.ID = "30"; //Speech Module
//	  Temp_Entity.Time = (double) SimSystem.clock();
//	  Temp_Entity.Tag = Entity_Number; //give it an entity number, init. 1
//	  Entity_Number++;
//	  Temp_Entity.From = "Execution"; //tag from and to
//	  Temp_Entity.To = "Speech Module";
//	  Temp_Entity.Entity_Type = "Add Vocal";    // +vocal>
	  // parameters: ISA (slot_0), chunk_type(slot_0), slot_name_1, slot_value_1, slot_name_2, slot_value_2, ... for nil value, put "nil"
	  
	  
	  
	  
	  int j;
	  for (j = 0; j < The_Chunk_Spec_Request.length; j+=2){
	    sim.funs.ChunkFun__Add_Chunk_Slot_Name_And_Value(Temp_Entity.Chunk, The_Chunk_Spec_Request[j], The_Chunk_Spec_Request[j+1]);  //can handel exception for ISA chunk-type
	  }

	}
	
	public  String ProductionModuleFun__Any_Module_Process_Pending(){
	  
	  //add ALL modules THAT take time
	  //ToDo: when adding new Module, change this
	  
	  if(sim.vars.declarativeModule.State_Free == false || sim.vars.imaginaryModule.State_Free == false || sim.vars.visionModule.State_Free == false ||  sim.vars.visionModule.State_Preparation_Free == false || sim.vars.audioModule.State_Free == false || sim.vars.audioModule.State_Preparation_Free == false ){
	    if (sim.vars.motorModule.State_Free == false || sim.vars.speechModule.State_Free == false) return "MOTOR_AND_NON_MOTOR_PROCESS_PENDING"; //ToDo: should speech count as motor or not, or it doesn't matter to deferencitate between motor and non-motor
	    else return "NON_MOTOR_PROCESS_PENDING";
	  }
	  else{
	    if(sim.vars.motorModule.State_Free == false || sim.vars.speechModule.State_Free == false) return "MOTOR_PROCESS_PENDING";
	    else return ""; //no module process pending
	  }
	  
	  
	  //Old version
	  /*
			if(sim.vars.motorModule.State_Free == false){ 
				if (sim.vars.declarativeModule.State_Free == false || sim.vars.visionModule.State_Free == false || sim.vars.imaginaryModule.State_Free == false || sim.vars.visionModule.State_Preparation_Free == false) return "MOTOR_AND_NON_MOTOR_PROCESS_PENDING";
				//if (sim.vars.declarativeModule.State_Busy == true || sim.vars.visionModule.State_Free == false || sim.vars.imaginaryModule.State_Busy == true || sim.vars.visionModule.State_Preparation_Free == false) return "MOTOR_AND_NON_MOTOR_PROCESS_PENDING";
				else return "MOTOR_PROCESS_PENDING";
			}
			else{
				if (sim.vars.declarativeModule.State_Free == false || sim.vars.visionModule.State_Free == false || sim.vars.imaginaryModule.State_Free == false || sim.vars.visionModule.State_Preparation_Free == false) return "NON_MOTOR_PROCESS_PENDING";
				//if (sim.vars.declarativeModule.State_Busy == true || sim.vars.visionModule.State_Free == false || sim.vars.imaginaryModule.State_Busy == true || sim.vars.visionModule.State_Preparation_Free == false) return "NON_MOTOR_PROCESS_PENDING";
			}

	   */
	  
	}
	
	public Hashtable ProductionModuleFun__Bind_Variables_In_Rule_Condition(Production_Rule the_rule){
	  	  
	  boolean debug_trace = false; //when set to true, will output some traces through GlobalUtilities.popUpMessage();
	  Hashtable return_variable_value_pair = new Hashtable();
	  Enumeration enum_condition_item = Collections.enumeration(the_rule.Condition);
	  while(enum_condition_item.hasMoreElements()){ //for each buffer test item in the condition part, in the sequence of the rule definition
	    Production_Rule_Condition_Action_Item currentItem =  (Production_Rule_Condition_Action_Item)enum_condition_item.nextElement();
	    String condition_item_type = currentItem.Type;
	    if (  condition_item_type.equals( "=") ){ // =buffer> test
	      Chunk buffer_chunk = new Chunk();
	      switch ( currentItem.Buffer_Name  ) //determine the buffer to match
	      {
	        case "goal":
	        {
	          buffer_chunk = sim.vars.goalBuffer.Goal_Buffer_Chunk;
	          break;
	        }
	        
	        case "goal-2":
	        {
	          buffer_chunk = sim.vars.goalBuffer.Goal_Buffer_Chunk_2;
	          break;
	        }
	        
	        case "goal-x":
	        {
	          if( the_rule.Condition_Part_Goal_X_Reference.equals( "" )){
	            System.out.println("ProductionModuleFun__Bind_Variables_In_Rule_Condition has the_rule.Condition_Part_Goal_X_Reference == empty for =goal-x ");
	            break;
	          }
	          else if ( the_rule.Condition_Part_Goal_X_Reference.equals( "goal")) {
	            //same as  case "goal"
	            buffer_chunk = sim.vars.goalBuffer.Goal_Buffer_Chunk; 
	          }
	          else if ( the_rule.Condition_Part_Goal_X_Reference.equals( "goal-2")){
	            //same as case "goal-2"
	            buffer_chunk = sim.vars.goalBuffer.Goal_Buffer_Chunk_2;
	          }
	          else {
	            System.out.println("ProductionModuleFun__Bind_Variables_In_Rule_Condition =goal-x has undefined the_rule.Condition_Part_Goal_X_Reference: " + the_rule.Condition_Part_Goal_X_Reference);
	            break;
	          }
	          //buffer_chunk = sim.vars.goalBuffer.Goal_Buffer_Chunk_2;
	          //break;
	        }
	        
	        case "retrieval":
	        {
	          buffer_chunk = sim.vars.retrievalBuffer.Retrieval_Buffer_Chunk;
	          break;
	        }
	        
	        case "visual-location":
	        {
	          buffer_chunk = sim.vars.visualLocationBuffer.Visual_Location_Buffer_Chunk;
	          break;
	        }
	        
	        case "visual":
	        {
	          buffer_chunk = sim.vars.visualBuffer.Visual_Buffer_Chunk;
	          break;
	        }
	        
	        case "aural-location":
	        {
	          buffer_chunk = sim.vars.auralLocationBuffer.Aural_Location_Buffer_Chunk;
	          break;
	        }
	        
	        case "aural":
	        {
	          buffer_chunk = sim.vars.auralBuffer.Aural_Buffer_Chunk;
	          break;
	        }
	        
	        
	        case "imaginal":
	        {
	          buffer_chunk = sim.vars.imaginalBuffer.Imaginal_Buffer_Chunk;
	          break;
	        }
	        
	        case "temporal":
	        {
	          buffer_chunk = sim.vars.temporalBuffer.Temporal_Buffer_Chunk;
	          break;
	        }
	        
	        default:
	        {
	          System.out.println("ProductionModuleFun__Bind_Variables_In_Rule_Condition has an undifined buffer name in the condition part: " + currentItem.Buffer_Name);
	          break;
	        }
	      }
	      if (debug_trace) System.out.println("ProductionModuleFun__Bind_Variables_In_Rule_Condition: " + the_rule.Rule_Name + "   buffer: " + currentItem.Buffer_Name);
	     
	      
	      Iterator<Entry>itrSlot = currentItem.Slot.entrySet().iterator();
	      
	      while(itrSlot.hasNext()){ //go over each attribute-name and attribute-value in the condition item
	        Entry currentEntry = itrSlot.next();
	        String slot_key = (String) currentEntry.getKey();
	        String slot_value = (String) currentEntry.getValue();
	        
	        if (debug_trace)System.out.println("ProductionModuleFun__Bind_Variables_In_Rule_Condition slot_key, slot_value: " + slot_key + ", " + slot_value);
	        
	        //ignore > >= < <= - cases
	        if ( (slot_key.length() >= 2 && !slot_key.substring(0,2).equals( "<=" )) && slot_key.substring(0,1).equals( "<") ){
	          //do nothing, just pass
	        }// end of < test
	        else if ( (slot_key.length() >= 2 && slot_key.substring(0,2).equals( "<=")) ){
	          //do nothing, just pass
	        }// end of <= test
	        else if ( (slot_key.length() >= 2 && !slot_key.substring(0,2).equals( ">=" )) && slot_key.charAt(0) == '>'){
	          //do nothing, just pass
	        }// end of > test
	        else if ((slot_key.length() >= 2 && slot_key.substring(0,2).equals( ">="))){
	          //do nothing, just pass
	        }// end of >= test
	        else if(slot_key.charAt(0) == '-') { // NOT test, like "-arg1",        "=num1" / or "7"
	          //do not bind variables in NOT tests, so do nothing here
	        }
	        else { // normal test, like "arg1",        "=num1" / or "7"
	          //There should not be varible is ISA test. ISA must be followed by a defined chunk type. ToDo: syntax checking needs to insure this, so it is not checked here.
	          if(slot_key.toLowerCase().equals( "isa")){
	            continue;
	          }
	          if (slot_value.charAt(0) != '=' ){ // value rather than variable ; values like "7",  "CHUNK_wall"
	            //do nothing
	            if (debug_trace) System.out.println("ProductionModuleFun__Bind_Variables_In_Rule_Condition: value: " + slot_key + "  " + slot_value);
	            continue;
	          }
	          else{ //  variable, like "arg1",        "=num1"
	            if (debug_trace) System.out.println("ProductionModuleFun__Bind_Variables_In_Rule_Condition: variable: " + slot_key + "  " + slot_value);
	            if (buffer_chunk.Slot.containsKey(slot_key) == false ){ // if the buffer chunk does not have the slot. NOTE: ISA is not in a Chunk's slot
	              //When the buffer test and the buffer chunk have the same ISA type, this case should not happen because, syntax checking (ToDo) when adding production rule should have found this.
	              //However, since QN-ACTR here does not check ISA type match first, this case may still happen even with rule adding syntax checking, because the buffer test and the buffer chunk may have different ISA type.
	              //Anyway, this is a not_match case (the rule cannot be matched).
	              sim.funs.ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(return_variable_value_pair, slot_value,  "nil");
	              if (debug_trace) System.out.println("buffer chunk does not have the slot.  fail");
	              return return_variable_value_pair;
	            }
	            else{// the buffer chunk has the slot.
	              if(ChunkFun__Get_Chunk_Slot_Value(buffer_chunk, slot_key).equals( "nil")){ // "arg1   =num1" entails that the slot "arg1" value cannot be "nil"
	                sim.funs.ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(return_variable_value_pair, slot_value,  "nil");
	                if (debug_trace) System.out.println("buffer chunk has slot value nil.  fail");
	                return return_variable_value_pair;
	              }
	              else{ //add the not "nil" buffer chunk slot-value to the binding hashtable, do not return
	                if ( return_variable_value_pair.containsKey(slot_value) == false){ //do not have this binding before
	                  return_variable_value_pair.put (slot_value,  sim.funs.ChunkFun__Get_Chunk_Slot_Value(buffer_chunk, slot_key)  ) ;
	                }
	                else{
	                  // already have this binding pair, the two buffer chunk slot-value must be the same for a valid rule match, so here do some job for Match_A_Rule_Test
	                  String old_buffer_chunk_slot_value = (String)return_variable_value_pair.get(slot_value);
	                  String new_buffer_chunk_slot_value = sim.funs.ChunkFun__Get_Chunk_Slot_Value(buffer_chunk, slot_key);
	                  if ( ProgramUtilitiesFun__StringsEqualByStringOrDouble(old_buffer_chunk_slot_value, new_buffer_chunk_slot_value) ){
	                    //no problem for a valid rule match, do nothing
	                  }
	                  else{
	                    sim.funs.ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(return_variable_value_pair, slot_value, "_MULTI_BOUND_" );
	                    if (debug_trace) System.out.println("_MULTI_BOUND_.  fail");
	                    //GlobalUtilities.popUpMessage( "ProductionModuleFun__Bind_Variables_In_Rule_Condition has the_rule.Rule_Name: " + the_rule.Rule_Name + " old_buffer_chunk_slot_value  != new_buffer_chunk_slot_value: " + old_buffer_chunk_slot_value  + " != " + new_buffer_chunk_slot_value );
	                    return return_variable_value_pair;
	                  }
	                }
	              }
	            }
	          }
	        }
	        
	        
	      }
	    }
	    else if ( condition_item_type.equals( "?")){ // ?buffer> test
	      //leave a ToDo for =num in ?buffer>test
	      //can it have variable like  =num?  
	      //?retrieval>
	      //state =num1
	      //In ACT-R, it is not valid when =num1 is not bound, or =num1 is bound to a value other than a valid buffer state keyword like free, busy
	      //In QN-ACTR, since the chance that a user will use =num such variable test in ?buffer> tests, it leaves a ToDo in ProductionModuleFun__Bind_Variables_In_Rule_Condition and ProductionModuleFun__Match_A_Rule_Test
	      
	      Iterator<Entry> itrSlot = currentItem.Slot.entrySet().iterator();
	      while(itrSlot.hasNext()){ //go over each attribute-name and attribute-value in the condition item
	        Entry currentEntry = itrSlot.next();
	        //string slot_key = (String) currentEntry.getKey();
	        String slot_value = (String) currentEntry.getValue();
	        if (slot_value.charAt(0) == '=' )System.out.println("ToDo: ProductionModuleFun__Bind_Variables_In_Rule_Condition has variable in ?buffer> test. Variable: " + slot_value);
	      }
	    }
	    else if ( condition_item_type.equals( "!eval!")) {
	      //no binding variables here, so pass.
	    }
	    else if ( condition_item_type.equals( "!bind!" )) { //ACT-R 6.0 does not allow the same =val to be bound twice in the condition part, here it is OK to do so. A user just needs to pay attention to the order or !bind! in the rule definition to get wanted results.
	      String content_string = currentItem.Buffer_Name;
	      String [] content_array = sim.funs.ProgramUtilitiesFun__String_To_StringArray( content_string );
	      if( content_array.length < 2 ) {
	        System.err.println("Error! ProductionModuleFun__Bind_Variables_In_Rule_Condition has !bind! content_array.Length < 2, content_string: " + content_string);
	      }
	      else{ //at least !bind!  string_group_1 string_group_2
	        if( content_array[0].equals( "(") )System.err.println("Error! ProductionModuleFun__Bind_Variables_In_Rule_Condition has !bind! starts with (. the first string must be a variable, e.g., =val ");
	        else if( content_array[0].charAt(0) != '=' ) System.err.println ("Error! ProductionModuleFun__Bind_Variables_In_Rule_Condition has !bind! starts with " + content_array[0] + ". the first string must be a variable, e.g., =val ");
	        else{
	          String variable_to_bind = content_array[0];
	          
	          //remove the first string from the array.
	          LinkedList<String> temp_linkedlist = sim.funs.ProgramUtilitiesFun__StringArray_To_LinkedList_String ( content_array );
	          temp_linkedlist.removeFirst();
	          
	          //substitute with the variable_value_table generated so far. e.g., !bind! =val ( + =num 1 ) may be substituted into !bind! =val ( + 4 1 )
	          String [] content_array_subst = sim.funs.ProgramUtilitiesFun__Subst_String_Array(    sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString (  temp_linkedlist  )   , return_variable_value_pair);
	          //safety check, content_array_subst could not contain variables e.g., =num,  "=" is ok.
	          for(int i = 0; i < content_array_subst.length ; i ++){
	            if( content_array_subst[i].length() == 0 ) System.err.println("Error! ProductionModuleFun__Bind_Variables_In_Rule_Condition for rule: " + the_rule.Rule_Name + ", has !bind! with an empty string in its contents.");
	            else if( content_array_subst[i].length() >= 2 && content_array_subst[i].charAt(0) == '=' ) System.err.println("Error! ProductionModuleFun__Bind_Variables_In_Rule_Condition for rule: " + the_rule.Rule_Name + ", has !bind! with a variable in its contents not bound: " + content_array_subst[i] );
	          }
	          //!eval! part of !bind!
	          String bind_result = LispFun__Evaluate_A_List ( sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty( content_array_subst ) );
	          //store bind_result in slot, 
	          if(  currentItem.Slot.containsKey ( "bind_result" ) ){
	            if ( ProgramUtilitiesFun__StringsEqualByStringOrDouble( ((String) currentItem.Slot.get( "bind_result" )), bind_result )) { //same
	              //no problem, pass, do nothing
	            }
	            else{
	              System.out.println( "WARNING! ProductionModuleFun__Bind_Variables_In_Rule_Condition, rule: " + the_rule.Rule_Name + ". !bind! " + content_string + ", has a new bind_result: " + bind_result + " that is different from the old one: " + (String) currentItem.Slot.get( "bind_result" ) );
	            }
	          }
	          else{ //add it for the first time
	            currentItem.Slot.put ( "bind_result", bind_result ); //should be added only once
	          }
	          //!bind!, different from buffer bind varaibles, here it is ok to have "nil" bound to a variable; also, it is ok if a varaible is already bound, just change it again (no "_MULTI_BOUND_" issue)
	          sim.funs.ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(return_variable_value_pair, variable_to_bind , bind_result );
	          
	        }
	      }
	      
	      
	      //string bind_eval_contents
	    }
	    else{
	      System.err.println ("ProductionModuleFun__Bind_Variables_In_Rule_Condition has an invalid condition item type: " + condition_item_type);
	    }
	  }
	  if(debug_trace)System.out.println("ProductionModuleFun__Bind_Variables_In_Rule_Condition return: " + sim.funs.ProgramUtilitiesFun__StringArray_To_String_Stop_If_Empty(sim.funs.ProgramUtilitiesFun__Hashtable_To_Array_String(return_variable_value_pair, "key")) +"      " + sim.funs.ProgramUtilitiesFun__StringArray_To_String_Stop_If_Empty(sim.funs.ProgramUtilitiesFun__Hashtable_To_Array_String(return_variable_value_pair, "value")));
	  return return_variable_value_pair;
	}
	
	public  void ProductionModuleFun__Clear_Aural_Buffer_Request(){
	  
	  
	  //modified from ProductionModuleFun__Clear_Visual_Buffer_Request
	  if (!sim.vars.auralBuffer.Aural_Buffer_Chunk.Chunk_Type.equals("")){ //if  buffer is not empty
	    DeclarativeModuleFun__Merge_Chunk_Into_DM (sim.vars.auralBuffer.Aural_Buffer_Chunk, "Aural_Buffer");
	  }
	  sim.vars.auralBuffer.Aural_Buffer_Chunk = new Chunk();
	  NetworkDetailsVisualizationFun__Get_Aural_Buffer_Contents();
	  
	  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t" + Math.round (SimSystem.clock()) + "\t" + "PROCEDURAL" + "\t" + "CLEAR-BUFFER AURAL"); 
	  
	  //this is from -aurual> ToDo: what is the difference between this and +aural> isa clear. Should reset aural buffer state here or send an entity to the aural module is -aural> takes time?
	  
	}
	
	public  void ProductionModuleFun__Clear_Aural_Location_Buffer_Request(){
	  
	  
	  if (!sim.vars.auralLocationBuffer.Aural_Location_Buffer_Chunk.Chunk_Type.equals("")){ //if  buffer is not empty
	    DeclarativeModuleFun__Merge_Chunk_Into_DM (sim.vars.auralLocationBuffer.Aural_Location_Buffer_Chunk, "Aural_Location_Buffer");
	  }
	  sim.vars.auralLocationBuffer.Aural_Location_Buffer_Chunk = new Chunk();
	  NetworkDetailsVisualizationFun__Get_Aural_Location_Buffer_Contents();
	  
	  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t" + Math.round (SimSystem.clock()) + "\t" + "PROCEDURAL" + "\t" + "CLEAR-BUFFER AURAL-LOCATION"); 
	  sim.vars.auralLocationBuffer.Empty = true;
	  
	}
	
	public  void ProductionModuleFun__Clear_Goal_Buffer_2_Request(){
	  
	  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(),3) + "\t" + "PROCEDURAL" + "\t" + "CLEAR-BUFFER GOAL-2"); 
	  
	  Entity Temp_Entity = sim.funs.createEntity( "Intentional Module" , "Execution", "Intentional Module", "Clear Goal-2", 0.0);
//	  Entity Temp_Entity = new Entity();  
//	  Temp_Entity.ID = "1"; //Intentional Module
//	  Temp_Entity.Time = (double) SimSystem.clock();
//	  Temp_Entity.Tag = Entity_Number; //give it an entity number, init. 1
//	  Entity_Number++;
//	  Temp_Entity.From = "Execution"; //tag from and to
//	  Temp_Entity.To = "Intentional Module";
//	  Temp_Entity.Entity_Type = "Clear Goal-2";    // -goal-2> action
	  
	 
	}
	
	public  void ProductionModuleFun__Clear_Goal_Buffer_Request(){

	  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(),3) + "\t" + "PROCEDURAL" + "\t" + "CLEAR-BUFFER GOAL"); 
	  
	  Entity Temp_Entity = sim.funs.createEntity( "Intentional Module" , "Execution", "Intentional Module", "Clear Goal", 0.0);
//	  Entity Temp_Entity = new Entity();  
//	  Temp_Entity.ID = "1"; //Intentional Module
//	  Temp_Entity.Time = (double) SimSystem.clock();
//	  Temp_Entity.Tag = Entity_Number; //give it an entity number, init. 1
//	  Entity_Number++;
//	  Temp_Entity.From = "Execution"; //tag from and to
//	  Temp_Entity.To = "Intentional Module";
//	  Temp_Entity.Entity_Type = "Clear Goal";    // -goal> action

	  
	}
	
	public  void ProductionModuleFun__Clear_Imaginal_Buffer_Request(){

	  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(),3) + "\t" + "PROCEDURAL" + "\t" + "CLEAR-BUFFER IMAGINAL");
	  
	  Entity Temp_Entity = sim.funs.createEntity( "Imaginary Module" , "Execution", "Imaginary Module", "Clear Imaginal", 0.0);
//	  Entity Temp_Entity = new Entity();  
//	  Temp_Entity.ID = "8"; //Imaginal Module
//	  Temp_Entity.Time = (double) SimSystem.clock();
//	  Temp_Entity.Tag = Entity_Number; //give it an entity number, init. 1
//	  Entity_Number++;
//	  Temp_Entity.From = "Execution"; //tag from and to
//	  Temp_Entity.To = "Imaginary Module";
//	  Temp_Entity.Entity_Type = "Clear Imaginal";    // -imaginal> action
	}
	
	public  void ProductionModuleFun__Clear_Manual_Buffer_Request(){
	  
	  
	  //ACT-R: The motor module does not place any chunks into the manual buffer - it is only used for requests.
	  sim.vars.manualBuffer.Manual_Buffer_Chunk = new Chunk();
	  
	  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(),3) + "\t" + "PROCEDURAL" + "\t" + "CLEAR-BUFFER MANUAL"); 
	}
	
	public  void ProductionModuleFun__Clear_Retrieval_Buffer_Request(){
	  
	  
	  if (!sim.vars.retrievalBuffer.Retrieval_Buffer_Chunk.Chunk_Type.equals("")  && sim.vars.declarativeModule.State_Error == false ){ //if retrieval buffer is not empty and module state is not error
	    //Model.Message (sim.vars.declarativeModule.Number_of_Chunks);
	    //sim.vars.declarativeModule.Chunk_Name_Number--;	//in DeclarativeModuleFun__Merge_Chunk_Into_DM: sim.vars.declarativeModule.Chunk_Name_Number++; for clear GOAL buffer, but not for clear RETREIVAL BUFFER. That is, the new chunk name suffix number will not be increased for a valid clear retrieval buffer request, but will be increased by a valid clear goal buffer request.
		  //System.out.println("ProductionModuleFun__Clear_Retrieval_Buffer_Request, merging chunk");
		DeclarativeModuleFun__Merge_Chunk_Into_DM (sim.vars.retrievalBuffer.Retrieval_Buffer_Chunk, "Retrieval_Buffer");
		  //System.out.println("ProductionModuleFun__Clear_Retrieval_Buffer_Request, finished merging chunk");
			sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(),3) + "\t" + "PROCEDURAL" + "\t" + "CLEAR-BUFFER RETRIEVAL"); 
	  }
	  else if (sim.vars.declarativeModule.State_Error == false){ //because it seems that ACT-R will still show clear retrieval buffer output trace even if no chunk to be cleared.
	    sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(),3) + "\t" + "PROCEDURAL" + "\t" + "CLEAR-BUFFER RETRIEVAL"); 
	  }
	  sim.vars.retrievalBuffer.Retrieval_Buffer_Chunk = new Chunk();
	  sim.vars.retrievalBuffer.Empty = true;
	  sim.vars.declarativeModule.State_Error = false;
	  
	  
	  
	}
	
	public  void ProductionModuleFun__Clear_Temporal_Buffer_Request(){

	  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(), 3) + "\t" + "PROCEDURAL" + "\t" + "CLEAR-BUFFER TEMPORAL");
	  
	  Entity Temp_Entity = sim.funs.createEntity( "Temporal Module" , "Execution", "Temporal Module", "Clear Temporal", 0.0);
//	  Entity Temp_Entity = new Entity();  
//	  Temp_Entity.ID = "602"; //Temporal Module
//	  Temp_Entity.Time = Clock;
//	  Temp_Entity.Tag = Entity_Number; //give it an entity number, init. 1
//	  Entity_Number++;
//	  Temp_Entity.From = "Execution"; //tag from and to
//	  Temp_Entity.To = "Temporal Module";
//	  Temp_Entity.Entity_Type = "Clear Temporal";    // -temporal> action

	}
	
	public  void ProductionModuleFun__Clear_Visual_Buffer_Request(){
	  
	  
	  if (!sim.vars.visualBuffer.Visual_Buffer_Chunk.Chunk_Type.equals("")){ //if  buffer is not empty
	    if( sim.vars.visualBuffer.Visual_Buffer_Chunk.Chunk_Name.length() >= 7 && sim.vars.visualBuffer.Visual_Buffer_Chunk.Chunk_Name.substring(0,7).equals( "world3d")){
	      //currently don't merge "world3d-" visual buffer chunk.
	    }
	    else{
	    	//System.out.println("ProductionModuleFun__Clear_Visual_Buffer_Request, merging chunk");
	      DeclarativeModuleFun__Merge_Chunk_Into_DM (sim.vars.visualBuffer.Visual_Buffer_Chunk, "Visual_Buffer");
	    	//System.out.println("ProductionModuleFun__Clear_Visual_Buffer_Request, finished merging chunk");
	    }
	    
	  }
	  
	  //GlobalUtilities.popUpMessage(" ProductionModuleFun__Clear_Visual_Buffer_Request " );
	  
	  sim.vars.visualBuffer.Visual_Buffer_Chunk = new Chunk();
	  //sim.vars.visionModule.State_Error = false;
	  
	  NetworkDetailsVisualizationFun__Get_Visual_Buffer_Contents();
	  
	  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(),3) + "\t" + "PROCEDURAL" + "\t" + "CLEAR-BUFFER VISUAL"); 
	  
	  //this is from -visual> 
	  //the difference between this and +visual> isa clear. is:
	  //in addition to the -visual> function, +visual> isa clear also reset last attended info and therefore can disable re-encoding.
	  
	  
	}
	
	public  void ProductionModuleFun__Clear_Visual_Location_Buffer_Request(){
	 
	  if (!sim.vars.visualLocationBuffer.Visual_Location_Buffer_Chunk.Chunk_Type.equals("")){ //if  buffer is not empty
		if( sim.vars.visualLocationBuffer.Visual_Location_Buffer_Chunk.Chunk_Type.equals( "visual-location-world3d-driving") ){
			//don't merge world3d location	
			    	
			// do merge critical elements. 
		}
	    else
	    {
	    	//System.out.println("ProductionModuleFun__Clear_Visual_Location_Buffer_Request, merging chunk");
	      DeclarativeModuleFun__Merge_Chunk_Into_DM (sim.vars.visualLocationBuffer.Visual_Location_Buffer_Chunk, "Visual_Location_Buffer"); 
	    	//System.out.println("ProductionModuleFun__Clear_Visual_Location_Buffer_Request, finished merging chunk");
	    }
	    
	    
	  }
	  sim.vars.visualLocationBuffer.Visual_Location_Buffer_Chunk = new Chunk(); 
	  
	  NetworkDetailsVisualizationFun__Get_Visual_Location_Buffer_Contents();
	  
	  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(), 3) + "\t" + "PROCEDURAL" + "\t" + "CLEAR-BUFFER VISUAL-LOCATION"); 
	  sim.vars.visualLocationBuffer.Empty = true;
	  sim.vars.visualLocationBuffer.Requested = false;
	  sim.vars.visualLocationBuffer.State_Error = false;
	  sim.vars.visualLocationBuffer.State_Free = true;
	  sim.vars.visualLocationBuffer.Unrequested = false;
	  
	}
	
	public  void ProductionModuleFun__Clear_Vocal_Buffer_Request(){
	  
	  //The speech module does not place any chunks into its buffer in response to the requests.  The vocal buffer should always be empty
	  sim.vars.vocalBuffer.Vocal_Buffer_Chunk = new Chunk();
	  
	  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(), 3) + "\t" + "PROCEDURAL" + "\t" + "CLEAR-BUFFER VOCAL"); 
	  
	  //don't know whether should reset sim.vars.speechModule state here.
	}
	
	public  boolean ProductionModuleFun__Does_Two_Production_Rule_Have_Same_Contents(Production_Rule the_rule_in_memory, Production_Rule the_tested_rule){
	  
	  boolean debug_trace = false;
	  String[] the_rule_in_memory_descritpors = ProductionModuleFun__Get_Rule_Descriptors_From_Production_Rule(the_rule_in_memory  );
	  String[] the_tested_rule_descritpors = ProductionModuleFun__Get_Rule_Descriptors_From_Production_Rule(  the_tested_rule );
	  //quick check the number of descriptors
	  if (the_rule_in_memory_descritpors.length != the_tested_rule_descritpors.length){
	    if(debug_trace)System.out.println("Does_Two_Production_Rule_Have_Same_Contents, rule in memory: " + the_rule_in_memory.Rule_Name + "and tested rule: " + the_tested_rule.Rule_Name + " false due to (the_rule_in_memory_descritpors.Length != the_tested_rule_descritpors.Length)");
	    return false;
	  }
	  
	  //quick check the originally ordered descriptors
	  LinkedList<String> the_rule_in_memory_linkedlist = sim.funs.ProgramUtilitiesFun__StringArray_To_LinkedList_String( the_rule_in_memory_descritpors );
	  LinkedList<String> the_tested_rule_linkedlist = sim.funs.ProgramUtilitiesFun__StringArray_To_LinkedList_String(the_tested_rule_descritpors); 
	  the_rule_in_memory_linkedlist.removeFirst();
	  the_rule_in_memory_linkedlist.removeFirst();
	  the_tested_rule_linkedlist.removeFirst();
	  the_tested_rule_linkedlist.removeFirst();
	  String[] the_rule_in_memory_descritpors_2 = sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(the_rule_in_memory_linkedlist);
	  String[] the_tested_rule_descritpors_2 = sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(the_tested_rule_linkedlist);
	  if (sim.funs.ProgramUtilitiesFun__StringArray_To_String_Stop_If_Empty(the_rule_in_memory_descritpors_2).equals( sim.funs.ProgramUtilitiesFun__StringArray_To_String_Stop_If_Empty(the_tested_rule_descritpors_2) )) return true;
	  
	  //prepare used for tracking complicated cases
	  LinkedList <String> variables_from_the_rule_in_memory = new LinkedList <String>();
	  LinkedList <String> variables_from_the_tested_rule = new LinkedList <String>();
	  
	  //need further test the condition part, check if the_tested_rule_clone contains every buffer test and every same slot in each buffer test
	  Production_Rule the_rule_in_memory_clone = sim.funs.ProgramUtilitiesFun__Production_Rule_Clone(the_rule_in_memory);
	  Production_Rule the_tested_rule_clone = sim.funs.ProgramUtilitiesFun__Production_Rule_Clone(the_tested_rule);
	  
	  Enumeration enum_condition_item = Collections.enumeration(the_rule_in_memory_clone.Condition);
	  while (enum_condition_item.hasMoreElements()){
	    Production_Rule_Condition_Action_Item a_condition_item = (Production_Rule_Condition_Action_Item)enum_condition_item.nextElement();
	    
	    if( a_condition_item.Type.charAt(0) == '!' ) System.out.println("ProductionModuleFun__Does_Two_Production_Rule_Have_Same_Contents has condition: " +  a_condition_item.Type );
	    
	    String buffer_operator_string =  a_condition_item.Type + a_condition_item.Buffer_Name + ">";
	    Production_Rule_Condition_Action_Item    the_tested_rule_clone_item_pointer     = ProductionModuleFun__Get_Condition_Action_Item_Pointer_From_Production_Rule(the_tested_rule_clone, buffer_operator_string , "condition");
	    if( the_tested_rule_clone_item_pointer == null){ //no such buffer_operator_string in the_tested_rule
	      if(debug_trace)System.out.println("Does_Two_Production_Rule_Have_Same_Contents, rule in memory: " + the_rule_in_memory.Rule_Name + "and tested rule: " + the_tested_rule.Rule_Name + " false due to (the_tested_rule_clone_item_pointer == null)");
	      return false;
	    }
	    
	    
	    Iterator<Entry<String, String>> itrSlot = a_condition_item.Slot.entrySet().iterator();
	    while(itrSlot.hasNext()){ //go over each attribute-name and attribute-value in the condition item
	      Entry<String, String> currentEntry = itrSlot.next();
	      String key = (String) currentEntry.getKey();
	      String value = (String) currentEntry.getValue();
	      if (the_tested_rule_clone_item_pointer.Slot.containsKey(key) == false){
	        if(debug_trace)System.out.println("Does_Two_Production_Rule_Have_Same_Contents, rule in memory: " + the_rule_in_memory.Rule_Name + "and tested rule: " + the_tested_rule.Rule_Name + " false due to condition part (the_tested_rule_clone_item_pointer.Slot.ContainsKey(key) == false)");
	        return false;
	      }
	      String value_in_tested_rule_slot = (String)the_tested_rule_clone_item_pointer.Slot.get(key);
	      if ( ProgramUtilitiesFun__StringsEqualByStringOrDouble(value, value_in_tested_rule_slot)){ //pass this round of match
	        the_tested_rule_clone_item_pointer.Slot.remove(key);
	      }
	      else{ 
	        if (value.charAt(0) == '=' || value_in_tested_rule_slot.charAt(0)== '='){//may be a complicated case, both slot-values are variables but are different like "=num1" and "=number1", track this variable mismatch and see at the end
	          variables_from_the_rule_in_memory.addLast(value);
	          variables_from_the_tested_rule.addLast(value_in_tested_rule_slot);
	        }
	        else { //two values like "7" and "8", or one value one variable are different
	          if(debug_trace)System.out.println("Does_Two_Production_Rule_Have_Same_Contents, rule in memory: " + the_rule_in_memory.Rule_Name + "and tested rule: " + the_tested_rule.Rule_Name + " false due to condition part (two values like 7 and 8, or one value one variable are different)");
	          return false;
	        }
	      }
	    }
	    //after passing all the slot key-value pair from the rule_in_memory, check if the tested rule has more slot key-value pair
	    if (the_tested_rule_clone_item_pointer.Slot.size() > 0) {
	      if(debug_trace)System.out.println("Does_Two_Production_Rule_Have_Same_Contents, rule in memory: " + the_rule_in_memory.Rule_Name + "and tested rule: " + the_tested_rule.Rule_Name + " false due to condition part (the_tested_rule_clone_item_pointer.Slot.Count > 0)");
	      return false;
	    }
	    else{//pass this item test
	      the_tested_rule_clone.Condition.remove(the_tested_rule_clone_item_pointer);
	    }
	  }
	  //after passing all the buffer test item from the rule_in_memory, check if the tested rule has more buffer test
	  if (the_tested_rule_clone.Condition.size() > 0){
	    if(debug_trace)System.out.println("Does_Two_Production_Rule_Have_Same_Contents, rule in memory: " + the_rule_in_memory.Rule_Name + "and tested rule: " + the_tested_rule.Rule_Name + " false due to condition part (the_tested_rule_clone.Condition.Count > 0)");
	    return false;
	  }
	  
	  
	  
	  //need further test the action part, check if the_tested_rule_clone contains every buffer test and every same slot in each buffer test
	  the_rule_in_memory_clone = sim.funs.ProgramUtilitiesFun__Production_Rule_Clone(the_rule_in_memory);
	  the_tested_rule_clone = sim.funs.ProgramUtilitiesFun__Production_Rule_Clone(the_tested_rule);
	  Enumeration enum_action_item = Collections.enumeration(the_rule_in_memory_clone.Action);
	  while (enum_action_item.hasMoreElements()){
	    Production_Rule_Condition_Action_Item a_action_item = (Production_Rule_Condition_Action_Item)enum_action_item.nextElement();
	    
	    if( a_action_item.Type.charAt(0) == '!' ) System.out.println("ProductionModuleFun__Does_Two_Production_Rule_Have_Same_Contents has action: " +  a_action_item.Type );
	    
	    String buffer_operator_string =  a_action_item.Type + a_action_item.Buffer_Name + ">";
	    Production_Rule_Condition_Action_Item    the_tested_rule_clone_item_pointer     = ProductionModuleFun__Get_Condition_Action_Item_Pointer_From_Production_Rule(the_tested_rule_clone, buffer_operator_string , "action");
	    if( the_tested_rule_clone_item_pointer == null){ //no such buffer_operator_string in the_tested_rule
	      if(debug_trace)System.out.println("Does_Two_Production_Rule_Have_Same_Contents, rule in memory: " + the_rule_in_memory.Rule_Name + "and tested rule: " + the_tested_rule.Rule_Name + " false due to action part (the_tested_rule_clone_item_pointer == null)");
	      return false;
	    }
	    
	    
	    Iterator<Entry<String, String>> itrSlot = a_action_item.Slot.entrySet().iterator();
	    
	    while(itrSlot.hasNext()){ //go over each attribute-name and attribute-value in the action item
	      Entry<String, String> currentEntry = itrSlot.next();
	      String key = (String) currentEntry.getKey();
	      String value = (String) currentEntry.getValue();
	      if (the_tested_rule_clone_item_pointer.Slot.containsKey(key) == false){
	        if(debug_trace)System.out.println("Does_Two_Production_Rule_Have_Same_Contents, rule in memory: " + the_rule_in_memory.Rule_Name + "and tested rule: " + the_tested_rule.Rule_Name + " false due to action part (the_tested_rule_clone_item_pointer.Slot.ContainsKey(key) == false)");
	        return false;
	      }
	      String value_in_tested_rule_slot = (String)the_tested_rule_clone_item_pointer.Slot.get(key);
	      if ( ProgramUtilitiesFun__StringsEqualByStringOrDouble(value, value_in_tested_rule_slot)){ //pass this round of match
	        the_tested_rule_clone_item_pointer.Slot.remove(key);
	      }
	      else{ 
	        if (value.charAt(0) == '=' || value_in_tested_rule_slot.charAt(0) == '='){//may be a complicated case, both slot-values are variables but are different like "=num1" and "=number1". track the mismatched variables and see at the end
	          variables_from_the_rule_in_memory.addLast(value);
	          variables_from_the_tested_rule.addLast(value_in_tested_rule_slot);
	        }
	        else { //two values like "7" and "8", or one value one variable are different
	          if(debug_trace)System.out.println("Does_Two_Production_Rule_Have_Same_Contents, rule in memory: " + the_rule_in_memory.Rule_Name + "and tested rule: " + the_tested_rule.Rule_Name + " false due to action part (two values like 7 and 8, or one value one variable are different)");
	          return false;
	        }
	      }
	    }
	    //after passing all the slot key-value pair from the rule_in_memory, check if the tested rule has more slot key-value pair
	    if (the_tested_rule_clone_item_pointer.Slot.size() > 0) {
	      if(debug_trace)System.out.println("Does_Two_Production_Rule_Have_Same_Contents, rule in memory: " + the_rule_in_memory.Rule_Name + "and tested rule: " + the_tested_rule.Rule_Name + " false due to action part (the_tested_rule_clone_item_pointer.Slot.Count > 0)");
	      return false;
	    }
	    else{//pass this item test
	      the_tested_rule_clone.Action.remove(the_tested_rule_clone_item_pointer);
	    }
	  }
	  //after passing all the buffer test item from the rule_in_memory, check if the tested rule has more buffer test
	  if (the_tested_rule_clone.Action.size() > 0){
	    if(debug_trace)System.out.println("Does_Two_Production_Rule_Have_Same_Contents, rule in memory: " + the_rule_in_memory.Rule_Name + "and tested rule: " + the_tested_rule.Rule_Name + " false due to action part (the_tested_rule_clone.Action.Count > 0)");
	    return false;
	  }
	  
	  if (variables_from_the_rule_in_memory.size() == 0 && variables_from_the_tested_rule.size() ==0){
	    return true;//reach here mean Two_Production_Rule_Have_Same_Contents
	  }
	  else { //complicated cases
	    System.out.println("ToDo: Does_Two_Production_Rule_Have_Same_Contents, rule 1 in memory: " + the_rule_in_memory.Rule_Name + "and tested rule 2: " + the_tested_rule.Rule_Name + " have complicated cases at the end.");
	    return false; //temporarily make the compiler happy, in fact, this may be false or not. 
	  }
	  
	  
	  
	  
	  
	  /*
			//temp work for descritpor strings comparision, which is not good
			LinkedList<String> a_rule_descriptors_in_memory = sim.funs.ProgramUtilitiesFun__StringArray_To_LinkedList_String( the_descriptors_in_memory  ); //newly constructed value
			LinkedList<String> the_tested_descriptors = sim.funs.ProgramUtilitiesFun__StringArray_To_LinkedList_String(the_descriptors);//newly constructed value
			if ( !a_rule_descriptors_in_memory.Count.equals( the_tested_descriptors.Count)) return false; //don't have the same number of descriptors
			if (a_rule_descriptors_in_memory.Count < 3){
				GlobalUtilities.popUpMessage("ProductionModuleFun__Is_Two_Rule_Descritpors_Same a_rule_descriptors_in_memory.Count < 3");
				return false;
			}
			if (the_tested_descriptors.Count < 3){
				GlobalUtilities.popUpMessage("ProductionModuleFun__Is_Two_Rule_Descritpors_Same the_tested_descriptors.Count < 3");
				return false;
			}

			//remove the first item "p" and the second item "rule-name"
			a_rule_descriptors_in_memory.RemoveFirst();
			a_rule_descriptors_in_memory.RemoveFirst();
			the_tested_descriptors.RemoveFirst();
			the_tested_descriptors.RemoveFirst();

			Enumerator enum_tested_descritpor = the_tested_descriptors.GetEnumerator();
			while( enum_tested_descritpor.MoveNext()){
				string a_item_in_the_tested_descriptors = (String) enum_tested_descritpor.Current;
				if ( a_rule_descriptors_in_memory.Count == 0 || a_rule_descriptors_in_memory.Contains (a_item_in_the_tested_descriptors)==false ){
					return false;
				}
				
				//Removes the first occurrence of the specified value from the LinkedList<T>. 
			}

	   */
	}
	
	public Production_Rule ProductionModuleFun__Find_Production_Rule_Pointer_By_Rule_Name(String the_rule_name){
	  
	  Enumeration enum_rule = Collections.enumeration(sim.vars.productionModule.Production_Rules);
	  while (enum_rule.hasMoreElements()){
	    Production_Rule currentRule = (Production_Rule)enum_rule.nextElement();
	    if ( currentRule.Rule_Name.equals(the_rule_name )) return currentRule;
	  }
	  System.err.println("ProductionModuleFun__Find_Production_Rule_Pointer_By_Rule_Name. No such production rule with name: " + the_rule_name);
	  return null;
	  
	}
	
	public void ProductionModuleFun__Execute_Rule(Production_Rule the_rule){
	  
	  
	  String the_rule_name = the_rule.Rule_Name;
	  //if(sim.vars.printingModule.Output_Window_Trace)System.out.println( "ProductionModuleFun__Execute_Rule: " + the_rule_name);
	  
	  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(),3) + "\t" + "PROCEDURAL" + "\t" + "PRODUCTION-FIRED " + the_rule_name); 
	  //Production_Rule the_rule = ProductionModuleFun__Find_Production_the_rule_By_Rule_Name(the_rule_name);
	  boolean debug_trace = false;
	  
	  
	  //update Goal_Thread_Order_List_For_Threaded_Cognition in the order of goal requests and queries happen in the rule condition description.
	  Enumeration enum_condition_item = Collections.enumeration(the_rule.Condition);
	  while (enum_condition_item.hasMoreElements()){
	    String buffer_name =  ( (Production_Rule_Condition_Action_Item)enum_condition_item.nextElement()).Buffer_Name;
	    if (	buffer_name.equals( "goal" ) ){ //no matter =goal> or ?goal>
	      ProductionModuleFun__Goal_Thread_Add_Or_Update (sim.vars.goalBuffer.Goal_Buffer_Chunk.Chunk_Name);
	    }
	    else if (buffer_name.equals( "goal-2" )) {
	      ProductionModuleFun__Goal_Thread_Add_Or_Update (sim.vars.goalBuffer.Goal_Buffer_Chunk_2.Chunk_Name);
	    }
	    else if (buffer_name.equals( "goal-x" )) {
	      //System.out.println("ProductionModuleFun__Execute_Rule ToDo: (buffer_name == goal-x) in condition goal thread update" );
	      String reference = the_rule.Condition_Part_Goal_X_Reference ;
	      if (reference.equals( "goal" ) ) ProductionModuleFun__Goal_Thread_Add_Or_Update (sim.vars.goalBuffer.Goal_Buffer_Chunk.Chunk_Name);
	      else if (reference.equals( "goal-2" )) ProductionModuleFun__Goal_Thread_Add_Or_Update (sim.vars.goalBuffer.Goal_Buffer_Chunk_2.Chunk_Name);
	      else System.out.println("ProductionModuleFun__Execute_Rule has undefined =goal-x reference: " + reference );
	    }
	  }
	  
	  
	  
	  //Production Compilation 
	  if (sim.vars.productionCompilationModule.epl==true){
	    ProductionCompilationModuleFun__Production_Compilation_Process(the_rule);
	  }
	  
	  //initialize the variable binding list comes from the condition part of the rule
	  //if(Clock > 2.03) System.out.println("ProductionModuleFun__Execute_Rule called Bind_Variables_In_Rule_Condition rule: " + the_rule.Rule_Name);
	  /*Hashtable variable_value_pair = ProductionModuleFun__Bind_Variables_In_Rule_Condition(the_rule); //track variables like "=num" across all condition items in this rule's condition part
			if(variable_value_pair.ContainsValue("nil") || variable_value_pair.ContainsValue("_MULTI_BOUND_")){
				if(variable_value_pair.ContainsValue("nil")){
					//this may happen when: 1, a rule is selected at time T0. and 2, before the rule is executed at T0 + 0.05 (s) (default firing cycle is 50ms) ,
					//model internal status was changed by commands like FrameworkFun__ReInitialize_Intentional_Module, so some buffer chunk slot becomes nil.
					//when this happens, print an extra line of trace as below. and stop firing this rule
					ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(), 3) + "\t" + "PROCEDURAL" + "\t" + "PRODUCTION-FIRING CANCELLED due to model internal status change between rule selection and rule execution (ACTR-QN). Rule name: " + the_rule_name); 
					//System.out.println("ProductionModuleFun__Execute_Rule variable_value_pair.ContainsValue nil ");
				}
				if(variable_value_pair.ContainsValue("_MULTI_BOUND_"))System.out.println("ProductionModuleFun__Execute_Rule variable_value_pair.ContainsValue _MULTI_BOUND_ ");
				return; //Error. Such rule should not be matched.
			}*/
	  // Don't rebind values, just get them from the production
	  Hashtable variable_value_pair = the_rule.Variable_Binding;
	  
	  
	  //initialize strict harvest list
	  LinkedList <String> strict_harvest_list = new LinkedList <String>(); 
	  enum_condition_item = Collections.enumeration(the_rule.Condition);
	  while (enum_condition_item.hasMoreElements()){
	    Production_Rule_Condition_Action_Item currentItem = (Production_Rule_Condition_Action_Item)enum_condition_item.nextElement();
	    String buffer_name =  currentItem.Buffer_Name;
	    String test_type = currentItem.Type;
	    
	    if(test_type.charAt(0) == '!' ) continue; // ignore !name!
	    
	    //	Done here, if "goal-x", check String reference = the_rule.Condition_Part_Goal_X_Reference to know which to add.
	    if (  buffer_name.equals( "goal-x" ) ) {
	      String reference = the_rule.Condition_Part_Goal_X_Reference ;
	      if( the_rule.Condition_Part_Goal_X_Reference.equals( "" )){
	        System.out.println("ProductionModuleFun__Execute_Rule has the_rule.Condition_Part_Goal_X_Reference == empty for =goal-x ");
	      }
	      else if ( the_rule.Condition_Part_Goal_X_Reference.equals( "goal" )) {
	        buffer_name = "goal";
	      }
	      else if ( the_rule.Condition_Part_Goal_X_Reference.equals( "goal-2" )){
	        buffer_name = "goal-2";
	      }
	      else {
	        System.out.println("ProductionModuleFun__Execute_Rule =goal-x has undefined the_rule.Condition_Part_Goal_X_Reference: " + the_rule.Condition_Part_Goal_X_Reference);
	      }
	      
	    }
	    
	    if( strict_harvest_list.contains(  buffer_name ) == false && !test_type.equals( "?" )){  //ACT-R does not add a buffer name from ?buffer> test into this strict harvest list.
	      strict_harvest_list.addLast( buffer_name  ); //e.g., "goal", "goal-2"
	    }
	  }
	  
	  //go through all the action part of the rule
	  Enumeration enum_action_item = Collections.enumeration(the_rule.Action);
	  
	  //if (the_rule_name.equals( "harvest-answer"))System.out.println("ProductionModuleFun__Execute_Rule " + the_rule.Action.Count);
	  
	  while (enum_action_item.hasMoreElements()){
	    Production_Rule_Condition_Action_Item currentItem = (Production_Rule_Condition_Action_Item)enum_action_item.nextElement();
	    
	    String buffer_operator_string =  currentItem.Type + currentItem.Buffer_Name + ">";
	    String buffer_type = currentItem.Type ;
	    
	    //substitue variables like "arg1 =num" with their values into like "arg1  7"  // no need to do this for !name! actions
	    String [] chunk_spec =  ProductionModuleFun__Make_Chunk_Spec_For_Buffer_Operator_In_Action_Part(  currentItem  , variable_value_pair); 
	    //System.out.println( sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty(chunk_spec));	
	    //if the buffer operator appears in the action part, do not strict harvest.
	    String buffer_name = currentItem.Buffer_Name;
	    
	    //Done here, if "goal-x", do not remove anything, because the specific case to remove is decided later
	    if(	!buffer_name.equals( "goal-x" ) && strict_harvest_list.contains( buffer_name  ))strict_harvest_list.remove(  buffer_name );
	    
	    //take action according to each buffer operator
	    switch (buffer_operator_string)  
	    {
	      case "=goal>":
	      {
	        ProductionModuleFun__Modify_Goal_Buffer_Request( chunk_spec );
	        break;
	      }
	      case "=goal-2>":
	      {
	        ProductionModuleFun__Modify_Goal_Buffer_2_Request( chunk_spec );
	        break;
	      }
	      case "=goal-x>":
	      {
	        if (sim.vars.intentionalModule.Multitasking_Schedule_Method.equals( "" )) System.out.println ("ProductionModuleFun__Execute_Rule case: " + buffer_operator_string + " need sim.vars.intentionalModule.Multitasking_Schedule_Method not being empty");
	        
	        //Done here, also determine which case to remove from the strict harvest list, if it needs to be removed.
	        if( the_rule.Condition_Part_Goal_X_Reference.equals( "" )){
	          System.out.println("ProductionModuleFun__Execute_Rule has the_rule.Condition_Part_Goal_X_Reference == empty for =goal-x ");
	          break;
	        }
	        else if ( the_rule.Condition_Part_Goal_X_Reference.equals( "goal" )) {
	          if (strict_harvest_list.contains( "goal"  ))strict_harvest_list.remove( "goal" );
	          buffer_operator_string = "=goal>"; //goto case must be a constant
	        }
	        else if ( the_rule.Condition_Part_Goal_X_Reference.equals( "goal-2" )) {
	          if (strict_harvest_list.contains( "goal-2"  ))strict_harvest_list.remove( "goal-2" );
	          buffer_operator_string =  "=goal-2>"; //goto case must be a constant
	        }
	        else {
	          System.out.println("ProductionModuleFun__Execute_Rule =goal-x has undefined the_rule.Condition_Part_Goal_X_Reference: " + the_rule.Condition_Part_Goal_X_Reference);
	          break;
	        }
	      }
	      
	      case "=imaginal>":
	      {
	        ProductionModuleFun__Modify_Imaginal_Buffer_Request( chunk_spec );
	        break;
	      }
	      case "=retrieval>":
	      {
	        //no modify retrieval, this is for disable strict harvesting for the retrieval buffer
	        //do nothing
	        //safety check
	        if(chunk_spec.length != 0)System.out.println("WARNING! ProductionModuleFun__Execute_Rule  =retrieval>  has chunk_spec.Length != 0, which should be used only as disabling strict harvesting. ");
	        break;
	      }
	      case "=visual>":
	      {
	        //ACT-R (v1.4 ) allows modify =visual>
	        ProductionModuleFun__Modify_Visual_Buffer_Request( chunk_spec );
	        
	        //disable modify visual buffer, 
	        // this is for disable strict harvesting for the visual buffer
	        //do nothing
	        //safety check
	        //if(chunk_spec.Length != 0)System.out.println("WARNING! ProductionModuleFun__Execute_Rule  =visual>  has chunk_spec.Length != 0 ");
	        break;
	      }
	      
	      case "=visual-location>":
	      {
	        //ACT-R (v1.4 ) allows modify =visual-location>
	        ProductionModuleFun__Modify_Visual_Location_Buffer_Request( chunk_spec );
	        
	        //no modify =visual-location>, this is for disabling strict harvesting for the =visual-location> buffer
	        //do nothing
	        //safety check
	        //if(chunk_spec.Length != 0)System.out.println("WARNING! ProductionModuleFun__Execute_Rule  =visual-location>  has chunk_spec.Length != 0, which should be used only as disabling strict harvesting.");
	        break;
	      }
	      
	      case "=aural>":
	      {
	        //no modify =aural>, this is for disabling strict harvesting for the =aural> buffer
	        //do nothing
	        //safety check
	        if(chunk_spec.length != 0)System.out.println("WARNING! ProductionModuleFun__Execute_Rule  =aural>  has chunk_spec.Length != 0, which should be used only as disabling strict harvesting.");
	        break;
	      }
	      
	      case "=aural-location>":
	      {
	        //no modify =aural-location>, this is for disabling strict harvesting for the =aural-location> buffer
	        //do nothing
	        //safety check
	        if(chunk_spec.length != 0)System.out.println("WARNING! ProductionModuleFun__Execute_Rule  =aural-location>  has chunk_spec.Length != 0, which should be used only as disabling strict harvesting.");
	        break;
	      }
	      
	      
	      case "=manual>":
	      {
	        //do nothing , for taking a manual action resource //QN-ACTR
	        
	        break;
	      }
	      
	      case "=temporal>":
	      {
	        ProductionModuleFun__Modify_Temporal_Buffer_Request( chunk_spec );
	        break;
	      }
	      
	      case "+goal>":
	      {
	        ProductionModuleFun__Add_Goal_Request ( chunk_spec ); 
	        break;
	      }
	      case "+goal-2>":
	      {
	        //if (sim.vars.intentionalModule.Multitasking_Schedule_Method.equals( "" )) System.out.println ("ProductionModuleFun__Execute_Rule case: " + buffer_operator_string + " need sim.vars.intentionalModule.Multitasking_Schedule_Method not being empty");
	        ProductionModuleFun__Add_Goal_2_Request ( chunk_spec ); 
	        break;
	      }
	      case "+goal-x>":{
	        
	        //Done here, also determine which case to remove from the strict harvest list, if it needs to be removed.
	        
	        if (sim.vars.intentionalModule.Multitasking_Schedule_Method.equals( "" )) System.out.println ("ProductionModuleFun__Execute_Rule case: " + buffer_operator_string + " need sim.vars.intentionalModule.Multitasking_Schedule_Method not being empty");
	        /*
						+goal-x>
						goal> for goal buffer 1, goal-2> for goal buffer 2. 
						+goal-x means, if goal buffer 1 is empty, add the goal chunk to buffer 1. If goal buffer 1 is full but buffer 2 is empty, add the goal chunk to buffer 2. 
	         */
	        if ( sim.funs.ProgramUtilitiesFun__Is_Buffer_Empty( "goal" ) ) {
	          if (strict_harvest_list.contains( "goal"  ))strict_harvest_list.remove( "goal" );
	          ProductionModuleFun__Add_Goal_Request ( chunk_spec ); 
	        }
	        else if ( sim.funs.ProgramUtilitiesFun__Is_Buffer_Empty( "goal-2" ) ) {
	          if (strict_harvest_list.contains( "goal-2"  ))strict_harvest_list.remove( "goal-2" );
	          ProductionModuleFun__Add_Goal_2_Request ( chunk_spec ); 
	        }
	        else {
	          System.out.println( "ProductionModuleFun__Execute_Rule If both buffer 1 and 2 are full, +goal-x> ToDo " ) ;
	        }
	        break;
	      }
	      case "+retrieval>":
	      {
	        ProductionModuleFun__Add_Retrieval_Request ( chunk_spec );
	        break;
	      }
	      
	      case "+manual>":
	      {
	        ProductionModuleFun__Add_Manual_Request ( chunk_spec );
	        break;
	      }
	      case "+vocal>":
	      {
	        ProductionModuleFun__Add_Vocal_Request ( chunk_spec );
	        break;
	      }
	      case "+aural>":
	      {
	        ProductionModuleFun__Add_Aural_Request(chunk_spec);
	        break;
	      }
	      case "+visual>":
	      {
	        ProductionModuleFun__Add_Visual_Request(chunk_spec);
	        /*
						if (chunk_spec[1].equals( "move-attention")){
							ProductionModuleFun__Add_Visual_Request(chunk_spec);
						}
						else if (chunk_spec[1].equals( "clear"))    ProductionModuleFun__Add_Visual_Request(new String[] { "ISA", "clear"}); //      isa      clear
						else System.out.println("ProductionModuleFun__Execute_Rule +visual> has undefined ISA: " + chunk_spec[1]);
	         */
	        break;
	      }
	      
	      case "+visual-location>":
	      {
	        ProductionModuleFun__Add_Visual_Location_Request ( chunk_spec );
	        break;
	      }
	      
	      case "+imaginal>":
	      {
	        ProductionModuleFun__Add_Imaginal_Request ( chunk_spec ); 
	        break;
	      }
	      
	      case "+temporal>":
	      {
	        ProductionModuleFun__Add_Temporal_Request ( chunk_spec );
	        break;
	      }
	      
	      case "-goal>":
	      {
	        //System.out.println("-goal>");		
	        ProductionModuleFun__Clear_Goal_Buffer_Request();
	        break;
	      }
	      case "-goal-2>":
	      {
	        //System.out.println("-goal>");		
	        ProductionModuleFun__Clear_Goal_Buffer_2_Request();
	        break;
	      }		
	      case "-imaginal>":
	      {
	    	  //System.out.println("-imaginal>");
	        ProductionModuleFun__Clear_Imaginal_Buffer_Request();
	        break;
	      }
	      
	      case "-visual>":
	      {
	        ProductionModuleFun__Clear_Visual_Buffer_Request();
	        break;
	      }
	      case "-visual-location>":
	      {
	        ProductionModuleFun__Clear_Visual_Location_Buffer_Request();
	        break;
	      }
	      case "-temporal-location>":
	      {
	        ProductionModuleFun__Clear_Temporal_Buffer_Request();
	        break;
	      }
	      default:
	      {
	        
	        if( buffer_type.length() >= 8  && buffer_type.substring(0,8).equals( "!output!") ){  //all information stored in .Type, nothing in .Buffer_Name
	          //System.out.println("ProductionModuleFun__Execute_Rule has !output!");
	          ProductionModuleFun__Action_Bang_Ouput_Bang ( buffer_name , variable_value_pair );
	        }
	        else if ( buffer_type.equals( "!bind!") ) { // !name! in .Type, contents in .Buffer_Name
	          String content_string = buffer_name;
	          String [] content_array = sim.funs.ProgramUtilitiesFun__String_To_StringArray( content_string );
	          if( content_array.length < 2 ) {
	            System.err.println("Error! ProductionModuleFun__Execute_Rule has !bind! action content_array.Length < 2, content_string: " + content_string);
	          }
	          else{
	            String variable_to_bind = content_array[0];
	            
	            //remove the first String from the array.
	            LinkedList<String> temp_linkedlist = sim.funs.ProgramUtilitiesFun__StringArray_To_LinkedList_String ( content_array );
	            temp_linkedlist.removeFirst();
	            
	            //substitute with the variable_value_table that is so far  ( most of the table come from the condition part, but some may also comes from previous !bind! actions)  . e.g., !bind! =val ( + =num 1 ) may be substituted into !bind! =val ( + 4 1 )
	            String [] content_array_subst = sim.funs.ProgramUtilitiesFun__Subst_String_Array(    sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString (  temp_linkedlist  )   , variable_value_pair);
	            //safety check, content_array_subst could not contain variables e.g., =num,  "=" is ok.
	            for(int i = 0; i < content_array_subst.length ; i ++){
	              if( content_array_subst[i].length() == 0 ) System.err.println("Error! ProductionModuleFun__Execute_Rule for rule: " + the_rule.Rule_Name + ", has !bind! action with an empty String in its contents.");
	              else if( content_array_subst[i].length() >= 2 && content_array_subst[i].charAt(0) == '=' ) System.err.println("Error! ProductionModuleFun__Execute_Rule for rule: " + the_rule.Rule_Name + ", has !bind! action with a variable in its contents not bound: " + content_array_subst[i] );
	            }
	            //!eval! part of !bind!
	            String bind_result = LispFun__Evaluate_A_List ( sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty( content_array_subst ) );
	            //store bind_result in slot, though this may not be as necessary as !bind! in the condition part.
	            if(  currentItem.Slot.containsKey ( "bind_result" ) ){
	              if ( ProgramUtilitiesFun__StringsEqualByStringOrDouble( ( (String) currentItem.Slot.get( "bind_result" )), bind_result) ) { //same
	                //no problem, pass, do nothing
	              }
	              else{
	                System.out.println( "WARNING! ProductionModuleFun__Execute_Rule, rule: " + the_rule.Rule_Name + ". !bind! action " + content_string + ", has a new bind_result: " + bind_result + " that is different from the old one: " + (String) currentItem.Slot.get( "bind_result" ) );
	              }
	            }
	            else{ //add it for the first time
	              currentItem.Slot.put ( "bind_result", bind_result ); //should be added only once
	            }
	            
	            //!bind!, different from buffer bind varaibles, here it is ok to have "nil" bound to a variable; also, it is ok if a varaible is already bound, just change it again (no "_MULTI_BOUND_" issue)
	            //update variable_value_pair
	            sim.funs.ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(variable_value_pair, variable_to_bind , bind_result );
	            
	            //output trace
	            sim.funs.ProgramUtilitiesFun__Output_Trace_Txt( buffer_type + " (ACTION)   " + content_string  + "   : " +  bind_result);
	          }
	          
	        } //end of !bind! action
	        
	        else if ( buffer_type.equals( "!eval!") ) { // !name! in .Type, contents in .Buffer_Name
	          String content_string = buffer_name;
	          String [] content_array = sim.funs.ProgramUtilitiesFun__String_To_StringArray( content_string );
	          if( content_array.length < 1 ) {
	            System.err.println("Error! ProductionModuleFun__Execute_Rule has !eval! action content_array.Length < 1, content_string: " + content_string);
	          }
	          else{
	            //substitute with the variable_value_table that is so far  ( most of the table come from the condition part, but some may also comes from previous !bind! actions)  . e.g., !bind! =val ( + =num 1 ) may be substituted into !bind! =val ( + 4 1 )
	            String [] content_array_subst = sim.funs.ProgramUtilitiesFun__Subst_String_Array(    content_array  , variable_value_pair);
	            //safety check, content_array_subst could not contain variables e.g., =num,  "=" is ok.
	            for(int i = 0; i < content_array_subst.length ; i ++){
	              if( content_array_subst[i].length() == 0 ) System.err.println("Error! ProductionModuleFun__Execute_Rule for rule: " + the_rule.Rule_Name + ", has !eval! action with an empty String in its contents.");
	              else if( content_array_subst[i].length() >= 2 && content_array_subst[i].charAt(0) == '=' ) System.err.println("Error! ProductionModuleFun__Execute_Rule for rule: " + the_rule.Rule_Name + ", has !eval! action with a variable in its contents not bound: " + content_array_subst[i] );
	            }
	            //!eval!
	            String eval_result = LispFun__Evaluate_A_List ( sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty( content_array_subst ) );
	            
	            //output trace
	            sim.funs.ProgramUtilitiesFun__Output_Trace_Txt( buffer_type + " (ACTION)   " + content_string  + "   : " +  sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty( content_array_subst ) + " " + eval_result);
	          }
	          
	        } //end of !eval! action
	        
	        else System.err.println("ProductionModuleFun__Execute_Rule has undefined case: " + buffer_operator_string);
	        
	        break;
	      }
	    } //end take action according to each buffer operator
	    
	  }
	  
	  //check and do strict harvest
	  ProductionModuleFun__Strict_Harvest(strict_harvest_list);
	  
	  //progapage reward
	  //System.out.println("Execute_Rule debug the_rule_name: " + the_rule_name);
	  if(sim.vars.centralParametersModule.esc == true && ((sim.vars.utilityModule.utility_Computation_Method.equals( "temporal-difference-reinforcement" ) && sim.vars.utilityModule.ul == true) || (sim.vars.utilityModule.utility_Computation_Method.equals( "PG-C" ) && !sim.vars.utilityModule.PG_C_pl.equals( "nil" )) ) ) UtilityModuleFun__Propagate_Reward ( the_rule_name );
	  
	  /*
			//old version
			Parameterized_Production_Rule_Node a_node = new Parameterized_Production_Rule_Node();
			a_node = Parameterized_Production_Rule_Pool;
			while(a_node!=null){
				if (a_node.Rule_Descriptors[1] .equals( the_rule_name) break; //found the selected rule node: a_node
				a_node = a_node.Next_Rule;
			}
			//System.out.println(a_node.Rule_Descriptors[1]);
			ProductionModuleFun__Execute_Parameterized_Production_Obsolete_Rule (a_node);
	   */
	  
	}
	
	public  Production_Rule_Condition_Action_Item ProductionModuleFun__Get_Condition_Action_Item_Pointer_From_Production_Rule(Production_Rule the_rule, String the_buffer_operator_string, String the_key){
	  
	  if(the_key.toLowerCase().equals( "condition")){
	    Enumeration enum_condition_item = Collections.enumeration(the_rule.Condition);
	    while (enum_condition_item.hasMoreElements()){
	      Production_Rule_Condition_Action_Item a_condition_item = (Production_Rule_Condition_Action_Item)enum_condition_item.nextElement();
	      String buffer_operator_string =  a_condition_item.Type + a_condition_item.Buffer_Name + ">";
	      if(buffer_operator_string.equals( the_buffer_operator_string)) return a_condition_item;
	    }
	    return null; //no such item with such a name.
	  }
	  else if (the_key.toLowerCase().equals( "action")){
	    Enumeration enum_action_item = Collections.enumeration(the_rule.Action);
	    while (enum_action_item.hasMoreElements()){
	      Production_Rule_Condition_Action_Item a_action_item = (Production_Rule_Condition_Action_Item)enum_action_item.nextElement();
	      String buffer_operator_string =  a_action_item.Type + a_action_item.Buffer_Name + ">";
	      if(buffer_operator_string.equals( the_buffer_operator_string)) return a_action_item;
	    }
	    return null; //no such item with such a name.
	  }
	  else {
	    System.out.println("ProductionModuleFun__Get_Condition_Action_Item_Pointer_From_Production_Rule has invalid key: " + the_key);
	    return null;
	  }
	  
	  
	}
	
	public  LinkedList<String> ProductionModuleFun__Get_Production_Action_Part_None_Buffer_Variables(String[] the_rule_descriptors){
	  
	  LinkedList<String> return_list = new LinkedList<String>();
	  int i ;
	  for( i = 0; i < the_rule_descriptors.length; i++ ){
	    if(the_rule_descriptors[i].equals( "==>")) break;
	  }
	  //GlobalUtilities.popUpMessage(the_rule_descriptors[i]);
	  //GlobalUtilities.popUpMessage(the_rule_descriptors[i+1]);
	  i++;
	  for ( ; i < the_rule_descriptors.length; i++){  //none buffer variables start with "=" but not end with ">"
	    if(the_rule_descriptors[i].substring(0,1).equals( "=") && !the_rule_descriptors[i].substring(the_rule_descriptors[i].length()-1).equals( ">" )) {
	      if (!return_list.contains(the_rule_descriptors[i])){
	        return_list.addLast( the_rule_descriptors[i]);
	      }
	    }
	  }
	  return return_list;
	}
	
	public  LinkedList<String> ProductionModuleFun__Get_Production_None_Buffer_Variables(String[] the_rule_descriptors){
	  
	  LinkedList<String> return_list = new LinkedList<String>();
	  int i ;
	  for (i = 0 ; i < the_rule_descriptors.length; i++){  //none buffer variables start with "=" but not end with ">"
	    if(the_rule_descriptors[i].substring(0,1).equals( "=") && !the_rule_descriptors[i].substring(the_rule_descriptors[i].length()-1).equals( ">")) {
	      if (!return_list.contains(the_rule_descriptors[i])){
	        return_list.addLast( the_rule_descriptors[i]);
	      }
	    }
	  }
	  return return_list;
	}
	
	public  String ProductionModuleFun__Get_Rule_Contents_In_String(Production_Rule the_rule){ 
	  
	  String return_string = "";
    return_string +=  "\n" + "(Production rule P: " + the_rule.Rule_Name ;
    if(!the_rule.Compilation_Note_For_New_Rule.equals( "" )) return_string += "\n" + "\"" + the_rule.Compilation_Note_For_New_Rule +  "\"" ;
    return_string += "\n" +  "Compilation father: " + the_rule.Compilation_Father ;
    return_string += "\n" + "Compilation sons: " + ProgramUtilitiesFun__LinkedListString_To_String_Show_Empty(the_rule.Compilation_Sons) ;
    Iterator enum_condition_item = (the_rule).Condition.iterator();
    while (enum_condition_item.hasNext()){
      Production_Rule_Condition_Action_Item currentItem = (Production_Rule_Condition_Action_Item) enum_condition_item.next();
//      if( (((Production_Rule_Condition_Action_Item)enum_condition_item.Current).Type)[0] == '!' ) { // !name! special
      if(currentItem.Type.charAt(0) == '!' ){
        return_string += "\n" + "   " + currentItem.Type + "    " + currentItem.Buffer_Name;
        //ignore slots
        continue;
      } //
      //else, normal condition
      
      return_string += "\n" + "   " + currentItem.Type + currentItem.Buffer_Name + ">";
      String isa_type = (String)currentItem.Slot.get("isa");
      if (isa_type != null){
        return_string += "\n" + "      isa  " + "     " +  isa_type ; //print isa type first.
      } 
      Iterator enum_slot = currentItem.Slot.entrySet().iterator();
      while(enum_slot.hasNext()){
        Entry an_entry = (Entry) enum_slot.next();
        if(!((String)an_entry.getKey()).equals( "isa" )){ //ignore isa type here.
          return_string += "\n" + "      " +  (String)an_entry.getKey() + "   " + (String)an_entry.getValue();
        }
      }
    }
    
    return_string += "\n" + "   ==>";
    Iterator enum_action_item = (the_rule).Action.iterator();
    while (enum_action_item.hasNext()){
      Production_Rule_Condition_Action_Item currentItem = (Production_Rule_Condition_Action_Item) enum_action_item.next();
      if( currentItem.Type.charAt(0) == '!' ) { // !name! special
        return_string += "\n" + "   " + currentItem.Type + "     " + currentItem.Buffer_Name;
        continue;
      } //
      //else, normal condition
      
      return_string += "\n" + "   " + currentItem.Type + currentItem.Buffer_Name + ">";
      String isa_type = (String)currentItem.Slot.get("isa");
      if (isa_type != null){
        return_string += "\n" + "      isa  " + "     " +  isa_type; //print isa type first.
      }
      Iterator enum_slot = currentItem.Slot.entrySet().iterator();
      while(enum_slot.hasNext()){
        Entry an_entry = (Entry) enum_slot.next();
        if(!((String)an_entry.getKey()).equals( "isa" ) ){ //ignore isa type here.
          return_string += "\n" + "      " +  (String)an_entry.getKey() + "   " + (String)an_entry.getValue();
        }
      }
    }
    return_string += "\n" + ")";
    return_string += "\n" + the_rule.Condition_Part_Goal_X_Reference  ;

    String rule_name = the_rule.Rule_Name;
    //common codes for all methods
    Production_Rule rule_pointer = the_rule;
    return_string += "\n" + " .Num_Low_Level_Requests    " + Integer.toString(rule_pointer.Num_Low_Level_Requests) ;
    return_string += "\n" + " .Num_High_Level_Requests    " + Integer.toString(rule_pointer.Num_High_Level_Requests) ;

    if (sim.vars.utilityModule.utility_Computation_Method.equals( "temporal-difference-reinforcement")){
      return_string += "\n" + " :UTILITY    " + (String)sim.vars.utilityModule.utility.get( rule_name) ;
      return_string += "\n" + " :U          " + (String)sim.vars.utilityModule.U_N_Without_Noise.get(rule_name);
      return_string += "\n" + " :REWARD     " +  (String)sim.vars.utilityModule.reward.get( rule_name);
    }
    else if (sim.vars.utilityModule.utility_Computation_Method.equals( "PG-C")){
      return_string += "\n" + " :UTILITY    " + (String)sim.vars.utilityModule.utility.get( rule_name) ;
      String temp_rule_name = rule_name;
      return_string += "\n" + " :Effort    " +   sim.vars.utilityModule.PG_C_effort_rule_firing_time.get(temp_rule_name) ;
      return_string += "\n" + " :P    " +   sim.vars.utilityModule.PG_C_p.get(temp_rule_name) ;
      return_string += "\n" + " :C    " +   sim.vars.utilityModule.PG_C_c.get(temp_rule_name) ;
      return_string += "\n" + " :PG-C    " +   sim.vars.utilityModule.pg_c.get(temp_rule_name) ;
      return_string += "\n" + " :Successes    " +   sim.vars.utilityModule.PG_C_successes_num_for_each_rule.get(temp_rule_name);
      return_string += "\n" + " :Failures    " +   sim.vars.utilityModule.PG_C_failures_num_for_each_rule.get(temp_rule_name);
      return_string += "\n" + " :Efforts    " +   sim.vars.utilityModule.PG_C_efforts_for_cost_calculation.get(temp_rule_name);
      return_string += "\n" + " :Success    " +   sim.vars.utilityModule.PG_C_success_flags.containsKey(temp_rule_name) ;
      return_string += "\n" + " :Failure    " +   sim.vars.utilityModule.PG_C_failure_flags.containsKey(temp_rule_name) ;
      
    }
    else System.err.println("Error! ProductionModuleFun__Get_Rule_Contents_In_String has undefined sim.vars.utilityModule.Utility_Computation_Method case: " + sim.vars.utilityModule.utility_Computation_Method);

    return return_string;
	}
	
	public  String[] ProductionModuleFun__Get_Rule_Descriptors_From_Production_Rule(Production_Rule the_rule){
	  
	  LinkedList<String> return_list = new LinkedList<String> ();
	  return_list.addLast("p");
	  return_list.addLast(the_rule.Rule_Name);
	  Enumeration enum_condition_item = Collections.enumeration(the_rule.Condition);
	  while (enum_condition_item.hasMoreElements()){
	    Production_Rule_Condition_Action_Item currentItem = (Production_Rule_Condition_Action_Item)enum_condition_item.nextElement();
	    
	    
	    
	    if ( (currentItem.Type).charAt(0) == '!' ){ //!name! alike
	      return_list.addLast( currentItem.Type );
	      String bang_contents = currentItem.Buffer_Name ; //e.g., ( + 1 =val )
	      if ( bang_contents.equals( "" )){
	        //add nothing
	      }
	      else {
	        sim.funs.ProgramUtilitiesFun__LinkedListString_Append( return_list , 	ProgramUtilitiesFun__StringArray_To_LinkedList_String ( sim.funs.ProgramUtilitiesFun__String_To_StringArray(  bang_contents ) ) );
	      }
	      
	      //neglect slots
	      
	    }
	    else { //normal, not !name!
	      return_list.addLast( currentItem.Type + currentItem.Buffer_Name + ">");
	    }
	    
	    Iterator<Entry<String, String>> itrSlot = currentItem.Slot.entrySet().iterator();
	    while(itrSlot.hasNext()){ //go over each attribute-name and attribute-value in the condition item
	      Entry<String, String> currentEntry = itrSlot.next();
	      return_list.addLast( (String) currentEntry.getKey() );
	      return_list.addLast( (String) currentEntry.getValue());
	    }
	  }
	  return_list.addLast( "==>");
	  Enumeration enum_action_item = Collections.enumeration(the_rule.Action);
	  while (enum_action_item.hasMoreElements()){
	    Production_Rule_Condition_Action_Item an_action_item = (Production_Rule_Condition_Action_Item)enum_action_item.nextElement();
	    
	    //Enumeration enum_slot = an_action_item.Slot.elements();
	    
	    if ( (an_action_item.Type).charAt(0) == '!' ){ //!name! alike
	      return_list.addLast( an_action_item.Type );
	      String bang_contents = an_action_item.Buffer_Name ; //e.g., ( + 1 =val )
	      if ( bang_contents.equals( "" )){
	        //add nothing
	      }
	      else {
	        sim.funs.ProgramUtilitiesFun__LinkedListString_Append( return_list , 	ProgramUtilitiesFun__StringArray_To_LinkedList_String ( sim.funs.ProgramUtilitiesFun__String_To_StringArray(  bang_contents ) ) );
	      }
	      
	    }
	    else { //normal, not !name!
	      return_list.addLast( an_action_item.Type + an_action_item.Buffer_Name + ">");
	    }
	    
	    
	    /*
					//old without order
					while(enum_slot.MoveNext()){ //go over each attribute-name and attribute-value in the condition item
						
						if((String) enum_slot.Key.equals( "" )){//for direct requesting chunk, e.g., +retrieval>   =number, the slot name is considered "", do not add a "" to the rule descriptors.
							//GlobalUtilities.popUpMessage("ProductionModuleFun__Get_Rule_Descriptors_From_Production_Rule has (String) enum_slot.Key == [EMPTY]");
							//DO NOT ADD to return_list.
						}
						else { //normal
							return_list.addLast( (String) enum_slot.Key );
						}
						return_list.addLast( (String) enum_slot.Value);
					}
	     */
	    
	    //new with order
	    for (String key : an_action_item.Slot_Names_In_Order ){
	      String value = (String)an_action_item.Slot.get(key);
	      if( key.equals( "" )){//for direct requesting chunk, e.g., +retrieval>   =number, the slot name is considered "", do not add a "" to the rule descriptors.
	        //GlobalUtilities.popUpMessage("ProductionModuleFun__Get_Rule_Descriptors_From_Production_Rule has (String) enum_slot.Key == [EMPTY]");
	        //DO NOT ADD to return_list.
	      }
	      else { //normal
	        return_list.addLast( key );
	      }
	      return_list.addLast( value);
	      //System.out.println("ProductionModuleFun__Get_Rule_Descriptors_From_Production_Rule   " + key + "  " +   value );				
	    }
	    
	  }
	  return sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(return_list);
	}
	
	public  void ProductionModuleFun__Goal_2_Focus(Chunk the_chunk){

	  Entity Goal_Focus_Temp_Ent = sim.funs.createEntity( "Intentional Module" , "Intentional Module", "Goal Buffer-2", "First Goal", 0.0);
//	  Entity Goal_Focus_Temp_Ent = new Entity();
//	  Goal_Focus_Temp_Ent.ID = "1";               //this entity arrives at Task 1, intentional module
//	  Goal_Focus_Temp_Ent.Time = GlobalUtilities.round(SimSystem.clock(),3);
//	  Goal_Focus_Temp_Ent.Tag = Entity_Number;			//give it an entity number, init. 1
//	  Entity_Number++;
//	  Goal_Focus_Temp_Ent.From = "Intentional Module"; //tag from and to
//	  Goal_Focus_Temp_Ent.To = "Goal Buffer-2";
//	  Goal_Focus_Temp_Ent.Entity_Type = "First Goal";
	  
	  //set the goal //usually set a chunk in the declarative memory as the goal. 
	  
	  /* //moved to Goal Buffer beginning effect
			//put Chunk in buffer naming rule: its name is changed into name-j, where j starts from 0. If "name-j" is already a name in the model chunk list, then j++, unitl it is a new name.
			int j = 0;
			string old_chunk_name = the_chunk.Chunk_Name;
			string new_chunk_name = old_chunk_name + "-" + j.ToString();
			while(ChunkFun__Is_Chunk_Name(new_chunk_name)){
				j++;
				new_chunk_name = old_chunk_name + "-" + j.ToString();
			}
			the_chunk.Chunk_Name = new_chunk_name;
			ChunkFun__Define_Chunk( the_chunk );
	   */
	  
	  Goal_Focus_Temp_Ent.Chunk = the_chunk;  

	}
	
	public  void ProductionModuleFun__Goal_Focus(Chunk the_chunk){

	  Entity Goal_Focus_Temp_Ent = sim.funs.createEntity( "Intentional Module" , "Intentional Module", "Goal Buffer", "First Goal", 0.0);
//	  Entity Goal_Focus_Temp_Ent = new Entity();
//	  Goal_Focus_Temp_Ent.ID = "1";               //this entity arrives at Task 1, intentional module
//	  Goal_Focus_Temp_Ent.Time = GlobalUtilities.round(SimSystem.clock(),3);
//	  
//	  Goal_Focus_Temp_Ent.Tag = Entity_Number;			//give it an entity number, init. 1
//	  Entity_Number++;
//	  
//	  Goal_Focus_Temp_Ent.From = "Intentional Module"; //tag from and to
//	  Goal_Focus_Temp_Ent.To = "Goal Buffer";
//	  Goal_Focus_Temp_Ent.Entity_Type = "First Goal";
	  
	  //set the goal //usually set a chunk in the declarative memory as the goal. 
	  
	  /* //moved to Goal Buffer beginning effect
			//put Chunk in buffer naming rule: its name is changed into name-j, where j starts from 0. If "name-j" is already a name in the model chunk list, then j++, unitl it is a new name.
			int j = 0;
			string old_chunk_name = the_chunk.Chunk_Name;
			string new_chunk_name = old_chunk_name + "-" + j.ToString();
			while(ChunkFun__Is_Chunk_Name(new_chunk_name)){
				j++;
				new_chunk_name = old_chunk_name + "-" + j.ToString();
			}
			the_chunk.Chunk_Name = new_chunk_name;
			ChunkFun__Define_Chunk( the_chunk );
	   */
	  
	  Goal_Focus_Temp_Ent.Chunk = the_chunk;  
	}
	
	public void ProductionModuleFun__Goal_Thread_Add_Or_Update(String the_goal_chunk_name){
	  
	  //for threaded cognition
	  if (sim.vars.productionModule.Goal_Thread_Order_List_For_Threaded_Cognition.contains(the_goal_chunk_name) == false){
	    sim.vars.productionModule.Goal_Thread_Order_List_For_Threaded_Cognition.addLast (the_goal_chunk_name);
	  }
	  else{
	    sim.vars.productionModule.Goal_Thread_Order_List_For_Threaded_Cognition.remove(the_goal_chunk_name);
	    sim.vars.productionModule.Goal_Thread_Order_List_For_Threaded_Cognition.addLast (the_goal_chunk_name);
	  }
	  
	  //for urgency
	  sim.funs.ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value( sim.vars.intentionalModule.Obsolete_Goal_Thread_Last_Processed_Time_For_Urgency , the_goal_chunk_name , GlobalUtilities.round(SimSystem.clock(),3) );
	  
	  //for goal adaptation
	  if(the_goal_chunk_name.equals( "" ))System.out.println("Goal_Thread_Add_Or_Update has the_goal_chunk_name == empty");
	  if (the_goal_chunk_name.equals(sim.vars.intentionalModule.Obsolete_Active_Goal_Chunk_Name_For_Goal_Adaptation)) { //same goal thread keep processing
	    //do nothing
	  }
	  else { //new active goal thread
	    sim.vars.intentionalModule.Obsolete_Active_Goal_Chunk_Name_For_Goal_Adaptation = the_goal_chunk_name;
	    sim.vars.intentionalModule.Obsolete_Active_Goal_Chunk_Activated_Clock_Time_For_Adaptation = GlobalUtilities.round(SimSystem.clock(), 3);
	  }
	  
	  if(sim.vars.printingModule.Show_Multiple_Goal_Trace_In_Output_Trace_Txt)ProgramUtilitiesFun__Output_Trace_Txt(GlobalUtilities.round (SimSystem.clock(), 3) + "\tActive_Goal: " + sim.vars.intentionalModule.Obsolete_Active_Goal_Chunk_Name_For_Goal_Adaptation + ", Activated_Clock_Time: " + sim.vars.intentionalModule.Obsolete_Active_Goal_Chunk_Activated_Clock_Time_For_Adaptation );
	}
	
	public void ProductionModuleFun__Goal_Thread_Remove(String the_chunk_name ){
	  
	  //for threaded cognition
	  sim.vars.productionModule.Goal_Thread_Order_List_For_Threaded_Cognition.remove(the_chunk_name);
	  
	  //for urgency
	  if (sim.vars.intentionalModule.Obsolete_Goal_Thread_Last_Processed_Time_For_Urgency.containsKey(the_chunk_name) == false ) System.out.println("ProductionModuleFun__Goal_Thread_Remove ContainsKey(the_chunk_name) == false");
	  else sim.vars.intentionalModule.Obsolete_Goal_Thread_Last_Processed_Time_For_Urgency.remove( the_chunk_name );
	  
	  //for goal adaptation
	  sim.vars.intentionalModule.Obsolete_Active_Goal_Chunk_Name_For_Goal_Adaptation = "";
	  sim.vars.intentionalModule.Obsolete_Active_Goal_Chunk_Activated_Clock_Time_For_Adaptation = (double) -1.0;
	  
	  if(sim.vars.printingModule.Show_Multiple_Goal_Trace_In_Output_Trace_Txt)ProgramUtilitiesFun__Output_Trace_Txt(GlobalUtilities.round (SimSystem.clock(), 3) + "\tActive_Goal: " + sim.vars.intentionalModule.Obsolete_Active_Goal_Chunk_Name_For_Goal_Adaptation + ", Activated_Clock_Time: " + sim.vars.intentionalModule.Obsolete_Active_Goal_Chunk_Activated_Clock_Time_For_Adaptation );
	}
	
	public  void ProductionModuleFun__Initialize_Production_Rule_Utilities(String the_rule_name){
	  
	  //if( sim.vars.utilityModule.Rule_Name_Origin_For_Multitasking.ContainsKey(the_rule_name) ) return; //no need to initialize utilities for =goal-2> like related rules, because their utility parameters will be mapped to their counterpart original rule.
	  
	  if (sim.vars.utilityModule.utility_Computation_Method.equals( "temporal-difference-reinforcement")){
	    sim.funs.ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.utility, the_rule_name, Double.toString(sim.vars.utilityModule.iu));
	    sim.funs.ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.U_N_Without_Noise, the_rule_name, Double.toString(sim.vars.utilityModule.iu));
	    if (sim.vars.utilityModule.ul == true) {
	      sim.funs.ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.reward, the_rule_name, ""); //reward, if no reward assigned, just don't add the rule name.
	      //This is a reward value to apply when this production fires. If this is set to a non-nil value (the default is nil) then after this production fires a trigger-reward call will be made using this reward value.
	    }
	  }
	  else if (sim.vars.utilityModule.utility_Computation_Method.equals( "PG-C")){
	    sim.funs.ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.PG_C_value, the_rule_name, Double.toString(0.0)); //(extend-productions value :default-value 0.0)
	    if (sim.vars.centralParametersModule.esc == true){
	      sim.funs.ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.pg_c , the_rule_name, Double.toString(1.0));
	      sim.funs.ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.PG_C_c, the_rule_name, Double.toString(sim.vars.utilityModule.dat)); //(extend-productions c :default-function get-default-action-time)
	      sim.funs.ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.PG_C_effort_rule_firing_time, the_rule_name, Double.toString(0.050) );
	      sim.funs.ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.PG_C_efforts_for_cost_calculation, the_rule_name, Double.toString(0.050) );
	      //failure_flags skipped
	      sim.funs.ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.PG_C_failures_num_for_each_rule, the_rule_name, Double.toString(0.0));  //(extend-productions failures :default-value 0.0)
	      sim.funs.ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.PG_C_p, the_rule_name, Double.toString(1.0)); //(extend-productions p :default-value 1.0)
	      //success flags skipped
	      sim.funs.ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.PG_C_successes_num_for_each_rule, the_rule_name, Double.toString(1.0)); //(extend-productions successes :default-value 1.0)
	      sim.funs.ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.PG_C_prior_p, the_rule_name, Double.toString(0.0)); //(extend-productions priorp :default-value 0)
	      sim.funs.ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.PG_C_prior_c, the_rule_name, Double.toString(sim.vars.utilityModule.PG_C_g) ); //(extend-productions priorc :default-function get-g-value)
	    }
	  }
	  else System.out.println("Initialize_Production_Rule_Utilities has undefined sim.vars.utilityModule.utility_Computation_Method case: " + sim.vars.utilityModule.utility_Computation_Method);
	}
	
	public  String[] ProductionModuleFun__Make_Chunk_Spec_For_Buffer_Operator_In_Action_Part(Production_Rule_Condition_Action_Item the_action_item, Hashtable the_variable_value_pair){
	  
	  Hashtable the_buffer_slot_name_value_pair = sim.funs.ProgramUtilitiesFun__Hashtable_Clone(the_action_item.Slot);
	  LinkedList<String> return_linkedList = new LinkedList<String>();
	  Enumeration enum_slot = the_buffer_slot_name_value_pair.elements();
	  
	  //old without order
	  //while(enum_slot.MoveNext()){
	  //				string slot_key = (String) enum_slot.Key;     //like arg1
	  //				string slot_value = (String) enum_slot.Value; //like =num
	  
	  //new with order
	  for (String slot_key : the_action_item.Slot_Names_In_Order){
	    String slot_value = (String) the_buffer_slot_name_value_pair.get(slot_key);
	    
	    //GlobalUtilities.popUpMessage("ProductionModuleFun__Make_Chunk_Spec_For_Buffer_Operator_In_Action_Part: " + slot_key + "_" + slot_value);
	    if(slot_key.toLowerCase().equals( "isa")){ //add slot-name and value to the first place, because Add buffer request need ISA placed at first, but chunk slotname value hashtable has random order.
	      if ( the_variable_value_pair.containsKey( slot_value )){ // like maping "=type  chunk-type1"
	        return_linkedList.addFirst (  (String)the_variable_value_pair.get(slot_value)   );
	      }
	      else{
	        return_linkedList.addFirst(slot_value);
	      }
	      return_linkedList.addFirst(slot_key);
	    }
	    else if (slot_key.equals( "" )){//catch direct request made in ProductionModuleFun__Make_Production_Rule_From_Descriptors
	      //GlobalUtilities.popUpMessage("ProductionModuleFun__Make_Chunk_Spec_For_Buffer_Operator_In_Action_Part has a direct request: " + slot_value);
	      String chunk_name; //the essential of the direct request is to make request spec by the chunk's spec.
	      if ( the_variable_value_pair.containsKey( slot_value )){ // slot_value is a variable like =number
	        chunk_name = (String)the_variable_value_pair.get(slot_value);
	      }
	      else{
	        if (slot_value.charAt(0) == '\"') slot_value = slot_value.substring(1);
	        if (slot_value.charAt(slot_value.length()-1) == '\"') slot_value = slot_value.substring(0, slot_value.length()-1); //remove the first and last " " surrounding the slot_value if there is any "
	        chunk_name = slot_value;
	      }
	      if (sim.vars.centralParametersModule.Chunks.containsKey(chunk_name) == false ){//no such chunk in the model chunk list
	        System.out.println("ProductionModuleFun__Make_Chunk_Spec_For_Buffer_Operator_In_Action_Part, direct request for chunk :" +chunk_name + " error, because there is no such chunk name");
	      }
	      else{
	        /*
					if in the production above =number were bound to the chunk eight from the model:
					(eight ISA number value 8 name "eight")
					Then that retrieval request would be equivalent to this:
					+retrieval> 
						isa    number
						value  8
						name   "eight"
	         */
	        Chunk temp_chunk_pointer = (Chunk)sim.vars.centralParametersModule.Chunks.get(chunk_name);
	        return_linkedList.addLast("isa");
	        return_linkedList.addLast(temp_chunk_pointer.Chunk_Type);
	        
	        
	        Iterator<Entry<String, String>> itrSlot = temp_chunk_pointer.Slot.entrySet().iterator();
	        while(itrSlot.hasNext()){
	          Entry<String, String> currentEntry = itrSlot.next();
	          String chunk_slot_key = (String) currentEntry.getKey();     
	          String chunk_slot_value = (String) currentEntry.getValue();
	          if (chunk_slot_key.charAt(0) != ':'){ //exclude ":attended alike chunk special attributes"
	            return_linkedList.addLast( chunk_slot_key);
	            return_linkedList.addLast( chunk_slot_value);
	          }
	        }
	      }
	    }
	    else{ // add slot-name and value to the last place
	      return_linkedList.addLast(slot_key);
	      if ( the_variable_value_pair.containsKey( slot_value )){ // like maping "=num  7"
	        return_linkedList.addLast (  (String)the_variable_value_pair.get(slot_value)  );
	      }
	      else{
	        if (slot_value.charAt(0) == '=') {
	          //GlobalUtilities.popUpMessage("ProductionModuleFun__Make_Chunk_Spec_For_Buffer_Operator_In_Action_Part has unbound variable in the action part " + slot_value);
	          String new_slot_value = null;
	          switch(slot_value){
	            case "=aural-location":{ //since the current aural-location does not use chunk name change, here do not need to worry about the chunk name issue like audio-event0-0 and audio-event0-1
	              new_slot_value = sim.vars.auralLocationBuffer.Aural_Location_Buffer_Chunk.Chunk_Name;
	              break;
	            }
	            case "=visual-location":{ //since the current visual-location does not use chunk name change, here do not need to worry about the chunk name issue like location0-0 and location0-1
	              new_slot_value = sim.vars.visualLocationBuffer.Visual_Location_Buffer_Chunk.Chunk_Name;
	              break;
	            }
	            case "=retrieval":{
	              //search for the true DM name origin, e.g., in buffer chunk it is lawyer-0, but the true origin in lawyer
	              if( !sim.vars.retrievalBuffer.Retrieval_Buffer_Chunk.DM_Name_Origin.equals( "" )){
	                new_slot_value = sim.vars.retrievalBuffer.Retrieval_Buffer_Chunk.DM_Name_Origin;
	              }
	              else {
	                new_slot_value = sim.vars.retrievalBuffer.Retrieval_Buffer_Chunk.Chunk_Name;
	              }
	              //GlobalUtilities.popUpMessage("ProductionModuleFun__Make_Chunk_Spec_For_Buffer_Operator_In_Action_Part =retrieval new_slot_value: " + new_slot_value);
	              break;
	            }
	            default:{
	              System.err.println("ProductionModuleFun__Make_Chunk_Spec_For_Buffer_Operator_In_Action_Part has undefined slot_value variable name: " + slot_value);
	              break;
	            }
	          }
	          if (new_slot_value != null)	{
	            return_linkedList.addLast(new_slot_value);			 
	          }
	        }
	        else {
	          return_linkedList.addLast(slot_value);
	        }
	      }
	    }	
	  }
	  return sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString (return_linkedList);
	}
	
	public  Production_Rule ProductionModuleFun__Make_Production_Rule_From_Descriptors(String[] The_Rule_Spec){

	  
	  //linkedlist version, new version
	  boolean debug_trace = false;
	  
	  if(debug_trace)System.out.println("Make_Production_Rule_From_Descriptors input: " + sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty (The_Rule_Spec));
	  
	  Production_Rule new_rule = new Production_Rule();
	  new_rule.Rule_Name = The_Rule_Spec[1];
	  int head_i ; // = 2 cut out "P", and rule_name 
	  String head_string;
	  boolean in_action_part = false; //start from in the condition part
	  if(The_Rule_Spec.length < 3)System.err.println("ProductionModuleFun__Make_Production_Rule_From_Descriptors: the rule has too few descriptors.");
	  for(head_i = 2; head_i < The_Rule_Spec.length ; head_i++  ){ //go over every rule descriptor
	    head_string = (The_Rule_Spec[head_i]);
	    LinkedList<Production_Rule_Condition_Action_Item>  part_pointer = new LinkedList<Production_Rule_Condition_Action_Item> ();
	    if (head_string.equals( "==>")){
	      in_action_part = true;
	      continue;
	    }
	    if (in_action_part==false) { //in the condition part
	      part_pointer = new_rule.Condition;
	    }
	    else{//in the action part
	      part_pointer = new_rule.Action;
	    }
	    if( head_string.charAt(0) == '!' && head_string.charAt(head_string.length()-1) == '!'){  //!name! cases like !output!
	      //System.out.println("ProductionModuleFun__Make_Production_Rule_From_Descriptors has head_string: " + head_string);
	      Production_Rule_Condition_Action_Item new_item = new Production_Rule_Condition_Action_Item();
	      new_item.Type = head_string; //e.g., !output!
	      
	      head_i++; //pass the !name! 
	      if(head_i < The_Rule_Spec.length){			
	        head_string = (The_Rule_Spec[head_i]);	
	        //System.out.println("ProductionModuleFun__Make_Production_Rule_From_Descriptors has head_string: " + head_string + ", for new_item.Type: " + new_item.Type);
	        if( head_string.equals( "==>") || (head_string.length() >= 3 && head_string.charAt(head_string.length()-1) == '>') || (  head_string.charAt(0) == '!' && head_string.charAt(head_string.length()-1) == '!' ) ){ //is a "==>" || the next head_string is a buffer condition or action like =goal> ||  is !name! like,  then  !name! content is empty . pring warning
	          if(sim.vars.printingModule.Popout_Message) System.out.println("WARNING! ProductionModuleFun__Make_Production_Rule_From_Descriptors has No Content in new_item.Type: " + new_item.Type);
	          //do not part_pointer.addLast(new_item);
	          head_i--;
	        }
	        else{ //at least one content of the !name! case 
	          String bang_contents = "";  
	          while(true){ 
	            //add head String to the contents of the !name! condition or action
	            bang_contents = bang_contents + " " + head_string  + " ";
	            
	            head_i = head_i + 1;
	            if(head_i < The_Rule_Spec.length){			
	              head_string = (The_Rule_Spec[head_i]);	
	              //System.out.println("ProductionModuleFun__Make_Production_Rule_From_Descriptors has head_string: " + head_string + ", for new_item.Type: " + new_item.Type);						
	              if( head_string.equals( "==>") || (head_string.length() >= 3 && head_string.charAt(head_string.length()-1) == '>') || (  head_string.charAt(0) == '!' && head_string.charAt(head_string.length()-1) == '!' ) ) { //next condition or action item
	                head_i--; //will be ++ in the for loop.
	                break;
	              }
	            }
	            else break; //reach the end
	          }
	          new_item.Buffer_Name = bang_contents; //e.g., ( + 1 =val )
	          part_pointer.addLast(new_item);
	        }
	        
	      }
	      else { //directly reach the end of the rule spec , empty !name! case. pring warning
	        if(sim.vars.printingModule.Popout_Message) System.out.println("WARNING! ProductionModuleFun__Make_Production_Rule_From_Descriptors has No Content in new_item.Type: " + new_item.Type);
	        //pass, do not part_pointer.addLast(new_item);
	      }
	      
	      
	      
	    }
	    else if(head_string.charAt(head_string.length()-1) == '>' && !head_string.equals( ">" )){ // buffer condition or action like =goal> , not ">"
	      //here do not need to worry about ">" like in !name! cases
	      Production_Rule_Condition_Action_Item new_item = new Production_Rule_Condition_Action_Item();
	      new_item.Type = head_string.substring(0,1); //= ? for condition, = + - for action 
	      new_item.Buffer_Name = head_string.substring(1, head_string.length()-1); //get the buffer-name from "=buffer-name>"
	      
	      
	      //this is for QN-ACTR central cognition resources
	      if (in_action_part && sim.vars.centralParametersModule.Use_Procedural_Resources) {
	        
	        //  =visual> alike empty action does not count as action number
	        //if( (head_i + 1 < The_Rule_Spec.Length) && (The_Rule_Spec[head_i+1])[The_Rule_Spec[head_i+1].Length -1] != '>' ){ //if there is a next String && that String is not another request like =buffer> .otherwise it is a =visual> like empty action, just for disabling strict harvesting.
	        
	        
	        // =visual> alike empty action  count as action number
	        if (true){
	          
	          if (sim.vars.programGlobalVar__High_Level_Process_Module_Name_List.contains( new_item.Buffer_Name) ) {
	            new_rule.Num_High_Level_Requests++;
	          }
	          else {
	            new_rule.Num_Low_Level_Requests++;
	          }
	          
	          switch (new_item.Buffer_Name){
	            
	            case "aural": {
	              new_rule.Num_Aural_Action++ ;	
	              break;
	            }
	            case "aural-location": {
	              new_rule.Num_Aural_Location_Action++ ;	
	              break;
	            }
	            case "goal": 
	            case "goal-2":
	            case "goal-x":{
	              new_rule.Num_Goal_Action++ ;	
	              break;
	            }
	            case "imaginal": {
	              new_rule.Num_Imaginal_Action++ ;	
	              break;
	            }
	            case "manual": {
	              new_rule.Num_Manual_Action++ ;	
	              break;
	            }
	            case "retrieval": {
	              new_rule.Num_Retrieval_Action++ ;	
	              break;
	            }
	            case "visual": {
	              new_rule.Num_Visual_Action++;	
	              break;
	            }
	            case "visual-location": {
	              new_rule.Num_Visual_Location_Action++ ;	
	              break;
	            }
	            case "vocal": {
	              new_rule.Num_Vocal_Action++ ;	
	              break;
	            }
	            default: {
	              System.err.println("Error! ProductionModuleFun__Make_Production_Rule_From_Descriptors has undefined action type for central resources");
	              break;
	            }
	          }
	        }
	      } // end of QN-ACTR central cognition resources settings
	      if ( (head_i + 1 < The_Rule_Spec.length) && (The_Rule_Spec[head_i+1]).charAt(The_Rule_Spec[head_i+1].length() -1) != '>' &&  (  head_string.charAt(0) != '!' && head_string.charAt(head_string.length()-1) != '!' ) &&  (  (head_i + 2 >= The_Rule_Spec.length)  ||  (The_Rule_Spec[head_i + 2]).charAt(The_Rule_Spec[head_i + 2].length() -1) == '>'   )  ){ //if there is a next String && that String is not another request like =buffer> && that String is not like !name! && ( there is no the next next String || the next next String is another request like =buffer>  )		direct requestion action. see ACT-R tutorial unit 5.  e.g., +retrieval>   =number , with only one specifier for the +retrieval> request.   
	        
	        //System.out.println("ProductionModuleFun__Make_Production_Rule_From_Descriptors has a direct request: " + The_Rule_Spec[head_i+1]);
	        head_i++;
	        String key   = ""; //direct request use key = ""
	        String value = (The_Rule_Spec[head_i]) ;
	        if( value.charAt(0) != '=' && value.charAt(0) != '"' && sim.vars.productionModule.Forbidden_Name_In_Production_Rule.contains(value)==false && sim.funs.ChunkFun__Is_Chunk_Name(value)==false  && sim.funs.ProgramUtilitiesFun__Is_String_Double(value) == false){ // should define this as a default type of chunk: chunk (also show trace) and change this to an object of Chunk .  Like ACT-R, do not define numbers as chunks
	          Chunk temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(new String[] { value, "isa", "chunk" });				
	          sim.funs.ChunkFun__Define_Chunk (temp_chunk);
	          sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("#|Warning: Creating chunk " + value + " of default type chunk |#");
	        }
	        new_item.Slot.put( key, value  );
	        new_item.Slot_Names_In_Order.addLast (key);
	        part_pointer.addLast(new_item);
	      }
	      else { //normal buffer slots, not direct requestion action
	        head_i++;
	        if(head_i < The_Rule_Spec.length){			
	          head_string = (The_Rule_Spec[head_i]);		
	        }
	        //Hashtable temp_slot_name_value = new Hashtable ();
	        while(head_i < The_Rule_Spec.length-1 && head_string.charAt(head_string.length()-1) != '>' && (  head_string.charAt(0) != '!' && head_string.charAt(head_string.length()-1) != '!' )){ //there is a next String && the next String is not buffer> && String is not like !name! ,   get the slot names and values
	          String key   = (The_Rule_Spec[head_i]);
	          String value = (The_Rule_Spec[head_i + 1]);
	          
	          if(!key.equals( "isa" ) && value.charAt(0) != '=' && value.charAt(0) != '"' && sim.vars.productionModule.Forbidden_Name_In_Production_Rule.contains(value)==false && sim.funs.ChunkFun__Is_Chunk_Name(value)==false  && sim.funs.ProgramUtilitiesFun__Is_String_Double(value) == false){ // should define this as a default type of chunk: chunk (also show trace) and change this to an object of Chunk .  Like ACT-R, do not define numbers as chunks
	            Chunk temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(new String[] { value, "isa", "chunk" });				
	            sim.funs.ChunkFun__Define_Chunk (temp_chunk);
	            sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("#|Warning: Creating chunk " + value + " of default type chunk |#");
	          }
	          
	          new_item.Slot.put( key, value  );
	          new_item.Slot_Names_In_Order.addLast (key);
	          //System.out.println("ProductionModuleFun__Make_Production_Rule_From_Descriptors   " + key + "  " +   value );				
	          //System.out.println("Make_Production_Rule_From_Descriptors key: " + key + ", value: " + value);
	          //temp_slot_name_value.Add( key, value  ); //for reversing slot adding order, first in last out
	          head_i = head_i + 2;
	          if(head_i < The_Rule_Spec.length){			
	            head_string = (The_Rule_Spec[head_i]);		
	          }
	        }
	        part_pointer.addLast(new_item);
	        head_i--; //because the head_i = head_i + 2; in head_string[head_string.Length-1] != '>' test in the above while loop and the head_i++ in the big for loop.
	      }	
	    }
	    else System.err.println("Error! ProductionModuleFun__Make_Production_Rule_From_Descriptors has undefined buffer-name> head String case: " + head_string);
	  }
	  return new_rule;
	}
	
	public  boolean ProductionModuleFun__Manually_Forbid_A_Rule_To_Match(Production_Rule the_rule){
	  
	  
	  //for Schumacher Exp 1 2 3 model by Salvucci and Taatgen, 2008. to match their ACT-R compilation bug. this production is composed with "goal nil" so that it will never be matched.
	  String forbid_compilation_note = "RETRIEVE-INSTRUCTION-FACT & DO-PRESS-FINGER - INVM3".toLowerCase();
	  int length = forbid_compilation_note.length();
	  String compilation_note = the_rule.Compilation_Note_For_New_Rule;
	  if ( compilation_note.length() >=  length && ProgramUtilitiesFun__StringsEqualByStringOrDouble(compilation_note.substring(0, length), forbid_compilation_note  )){
	    //System.out.println ("ProductionModuleFun__Manually_Forbid_A_Rule_To_Match forbid rule: " + the_rule.Rule_Name + " with compilation note: " + compilation_note);
	    return true;
	  }
	  
	  //when none of the above conditions is met,
	  return false;
	}
	
	public  boolean ProductionModuleFun__Match_A_Rule_Test(Production_Rule the_rule){
	  
	  if ( ProductionModuleFun__Manually_Forbid_A_Rule_To_Match(the_rule) ) return false;
	  
	  boolean debug_trace = false; //when set to true, will output some traces through System.out.println();
	  
	  /*
			if( (the_rule.Rule_Name.equals( "confirm-key")  || the_rule.Rule_Name.equals( "detected-tone")) && ( GlobalUtilities.round(SimSystem.clock(),3) >= 1.42 )  ) { 
				debug_trace = true;
			}
	  */
	  
	  if(debug_trace)System.out.println("Clock: " + GlobalUtilities.round( SimSystem.clock(), 3));
	  
	  //step 0.1 
	  if(sim.vars.programGlobalVar__ProductionModule_Currently_Processing_Rules_Name_List.contains(the_rule.Rule_Name)) {
	    if(debug_trace)System.out.println("sim.vars.programGlobalVar__ProductionModule_Currently_Processing_Rules_Name_List.Contains(the_rule.Rule_Name)");
	    return false;	
	  }
	  
	  
	  //step 0.2
	  if(!sim.vars.productionModule.Focus_One_Goal_Name.equals( "" )){ // if in a filtering state
	    LinkedList<String> this_rule_process_goals = (LinkedList<String>) sim.vars.productionModule.Rule_Process_Goal_Buffer_Table.get(the_rule.Rule_Name);
	    if( this_rule_process_goals.contains( sim.vars.productionModule.Focus_One_Goal_Name ) == false) return false;	 // if a rule does not process the focused goal, the rule cannot be matched.
	  }
	  
	  
	  //step 0.5
	  if (sim.vars.centralParametersModule.Use_Procedural_Resources) {
	    if(debug_trace){
	      System.out.println("the rule: " + the_rule.Num_Low_Level_Requests + " " + the_rule.Num_High_Level_Requests + " " +the_rule.Num_Aural_Action + " " + the_rule.Num_Aural_Location_Action+ " " + the_rule.Num_Goal_Action+ " " + the_rule.Num_Imaginal_Action + " " +the_rule.Num_Manual_Action + " " +the_rule.Num_Retrieval_Action  + " " + the_rule.Num_Visual_Action+ " " +the_rule.Num_Visual_Location_Action + " " +the_rule.Num_Vocal_Action 		+ "\n  remain: " + sim.vars.productionModule.Processor_Low_Level_Remaining_Capacity+ " " +  sim.vars.productionModule.Processor_High_Level_Remaining_Capacity+ " " + sim.vars.productionModule.Processor_Aural_Action_Remaining_Number+ " " + sim.vars.productionModule.Processor_Aural_Location_Action_Remaining_Number+ " " + sim.vars.productionModule.Processor_Goal_Action_Remaining_Number+ " " + sim.vars.productionModule.Processor_Imaginal_Action_Remaining_Number+ " " + sim.vars.productionModule.Processor_Manual_Action_Remaining_Number+ " " + sim.vars.productionModule.Processor_Retrieval_Action_Remaining_Number+ " " +sim.vars.productionModule.Processor_Visual_Action_Remaining_Number + " " +sim.vars.productionModule.Processor_Visual_Location_Action_Remaining_Number + " " + sim.vars.productionModule.Processor_Vocal_Action_Remaining_Number);	
	    }
	    
	    
	    if(the_rule.Num_Low_Level_Requests > sim.vars.productionModule.Processor_Low_Level_Remaining_Capacity || the_rule.Num_High_Level_Requests > sim.vars.productionModule.Processor_High_Level_Remaining_Capacity) return false;
	    if(the_rule.Num_Aural_Action > sim.vars.productionModule.Processor_Aural_Action_Remaining_Number) return false;
	    if(the_rule.Num_Aural_Location_Action  > sim.vars.productionModule.Processor_Aural_Location_Action_Remaining_Number ) return false;
	    if(the_rule.Num_Goal_Action  > sim.vars.productionModule.Processor_Goal_Action_Remaining_Number ) return false;
	    if(the_rule.Num_Imaginal_Action  > sim.vars.productionModule.Processor_Imaginal_Action_Remaining_Number ) return false;
	    if(the_rule.Num_Manual_Action  > sim.vars.productionModule.Processor_Manual_Action_Remaining_Number ) return false;
	    if(the_rule.Num_Retrieval_Action  > sim.vars.productionModule.Processor_Retrieval_Action_Remaining_Number ) return false;
	    if(the_rule.Num_Visual_Action  > sim.vars.productionModule.Processor_Visual_Action_Remaining_Number ) return false;
	    if(the_rule.Num_Visual_Location_Action  > sim.vars.productionModule.Processor_Visual_Location_Action_Remaining_Number ) return false;
	    if(the_rule.Num_Vocal_Action  > sim.vars.productionModule.Processor_Vocal_Action_Remaining_Number ) return false;
	  }
	  
	  
	  //bool not_match = false; 
	  //if(Clock > 2.03) System.out.println("ProductionModuleFun__Match_A_Rule_Test calls Bind_Variables_In_Rule_Condition: " + the_rule.Rule_Name);
	  Hashtable variable_value_pair = ProductionModuleFun__Bind_Variables_In_Rule_Condition(the_rule); //track variables like "=num" across all condition items in this rule's condition part
	  //=num binds to nil, or the buffer chunk does not have "arg1", or =num bound to multiple values should lead to immediate fail
	  if(variable_value_pair.containsValue("nil") || variable_value_pair.containsValue("_MULTI_BOUND_")){
	    if(debug_trace && variable_value_pair.containsValue("nil")){
	      System.out.println("ProductionModuleFun__Match_A_Rule_Test variable_value_pair.ContainsValue nil ");
	      System.out.println("keys: " + sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty( sim.funs.ProgramUtilitiesFun__Hashtable_To_Array_String(variable_value_pair, "key") ) + " \n    values: " + sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty( sim.funs.ProgramUtilitiesFun__Hashtable_To_Array_String(variable_value_pair, "value") ));
	    }
	    if(debug_trace && variable_value_pair.containsValue("_MULTI_BOUND_"))System.out.println("ProductionModuleFun__Match_A_Rule_Test variable_value_pair.ContainsValue _MULTI_BOUND_ ");
	    return false; //not match
	  }
	  
	  Enumeration enum_condition_item = Collections.enumeration(the_rule.Condition);
	  while(enum_condition_item.hasMoreElements()){ //for each buffer test item in the condition part
	    Production_Rule_Condition_Action_Item currentConditionItem = (Production_Rule_Condition_Action_Item)enum_condition_item.nextElement();
	    String condition_item_type = currentConditionItem.Type;
	    if (  condition_item_type.equals( "=") ){ // =buffer> test
	      Chunk buffer_chunk = new Chunk();
	      String buffer_name = currentConditionItem.Buffer_Name;
	      switch ( buffer_name  ) //determine the buffer to match
	      {
	        case "goal":
	        {
	          buffer_chunk = sim.vars.goalBuffer.Goal_Buffer_Chunk;
	          break;
	        }
	        
	        case "goal-2":
	        {
	          buffer_chunk = sim.vars.goalBuffer.Goal_Buffer_Chunk_2;
	          break;
	        }
	        case "goal-x":
	        {
	          if( the_rule.Condition_Part_Goal_X_Reference.equals( "" )){
	            System.out.println("ProductionModuleFun__Match_A_Rule_Test has the_rule.Condition_Part_Goal_X_Reference == empty for =goal-x ");
	            break;
	          }
	          else if ( the_rule.Condition_Part_Goal_X_Reference.equals( "goal" )) buffer_name = "goal"; //goto case must have constant
	          else if ( the_rule.Condition_Part_Goal_X_Reference.equals( "goal-2" )) buffer_name =  "goal-2"; //goto case must have constant
	          else {
	            System.out.println("ProductionModuleFun__Match_A_Rule_Test =goal-x has undefined the_rule.Condition_Part_Goal_X_Reference: " + the_rule.Condition_Part_Goal_X_Reference);
	            break;
	          }
	          //buffer_chunk = sim.vars.goalBuffer.Goal_Buffer_Chunk_2;
	          //break;
	        }			
	        case "retrieval":
	        {
	          buffer_chunk = sim.vars.retrievalBuffer.Retrieval_Buffer_Chunk;
	          break;
	        }
	        
	        case "visual-location":
	        {
	          buffer_chunk = sim.vars.visualLocationBuffer.Visual_Location_Buffer_Chunk;
	          break;
	        }
	        
	        case "visual":
	        {
	          buffer_chunk = sim.vars.visualBuffer.Visual_Buffer_Chunk;
	          break;
	        }
	        case "aural-location":
	        {
	          buffer_chunk = sim.vars.auralLocationBuffer.Aural_Location_Buffer_Chunk;
	          break;
	        }
	        
	        case "aural":
	        {
	          buffer_chunk = sim.vars.auralBuffer.Aural_Buffer_Chunk;
	          break;
	        }
	        case "imaginal":
	        {
	          buffer_chunk = sim.vars.imaginalBuffer.Imaginal_Buffer_Chunk;
	          break;
	        }
	        
	        case "temporal":
	        {
	          buffer_chunk = sim.vars.temporalBuffer.Temporal_Buffer_Chunk;
	          break;
	        }
	        
	        default:
	        {
	          System.err.println("ProductionModuleFun__Match_A_Rule_Test has an undifined buffer name in the condition part: " + currentConditionItem.Buffer_Name);
	          //not_match = true;
	          return false;
	        }
	      }
	      if (debug_trace) System.out.println("Match_A_Rule_Test rule: " + the_rule.Rule_Name + "   buffer: " + currentConditionItem.Buffer_Name);		
	      
	      
	      Iterator<Entry<String, String>> itrSlot = currentConditionItem.Slot.entrySet().iterator();
	      while(itrSlot.hasNext()){ //check each attribute-name and attribute-value in the condition item
	        Entry<String, String> currentEntry = itrSlot.next();
	        String slot_key = currentEntry.getKey();
	        String slot_value = currentEntry.getValue();
	        if (slot_key.charAt(0) == '-') { // NOT test, like "-arg1",        "=num1"  or "7"
	          String new_slot_key = slot_key.substring(1); // without the first char '-'
	          if (buffer_chunk.Slot.containsKey(new_slot_key) == false && !new_slot_key.toLowerCase().equals( "isa" )){ // if the buffer chunk does not have the slot. 
	            //When the buffer test and the buffer chunk have the same ISA type, this case should not happen because, syntax checking (ToDo) when adding production rule should have found this.
	            //However, since QN-ACTR here does not check ISA type match first, this case may still happen even with rule adding syntax checking, because the buffer test and the buffer chunk may have different ISA type.
	            //Anyway, this is a not_match = true case.
	            //System.out.println("ProductionModuleFun__Match_A_Rule_Test the buffer chunk does not have the slot");
	            //not_match = true;  
	            //break;
	            if (debug_trace) System.out.println("=buffer>, NOT test, Buffer_chunk doesn't have the slot_key test. fail");
	            return false;
	          }
	          if (slot_value.charAt(0) != '=' ){ //NOT match value , like "-arg1",         "four"
	            if (new_slot_key.toLowerCase().equals( "isa") ){ //NOT isa test. NOTE: ACT-R does not allow this but QN here it currently is OK
	              if (buffer_chunk.Chunk_Type.equals( slot_value)){
	                if (debug_trace) System.out.println("=buffer>, NOT Match value, ISA fail");
	                return false;
	              }	
	              else if(debug_trace)System.out.println(slot_key + " " + slot_value + " pass");
	            }
	            else{ //NOT test match value, not isa 
	              if ( ProgramUtilitiesFun__StringsEqualByStringOrDouble(ChunkFun__Get_Chunk_Slot_Value(buffer_chunk, new_slot_key), slot_value)){
	                if (debug_trace) System.out.println("=buffer>, NOT Match value, not ISA test fail");
	                return false;
	              }
	              else if(debug_trace)	System.out.println(slot_key + " " + slot_value + " pass");
	            }
	          }
	          else{ // NOT match variable, like "arg1",        "=num1"
	            if (new_slot_key.toLowerCase().equals( "isa") ){//"-isa =num" is invalid. ToDo: should be checked by syntax checking
	              System.out.println("ProductionModuleFun__Match_A_Rule_Test has -isa =num test. Invalid.");
	              System.out.println(" NOT match variable, like arg1, =num1: " + sim.funs.ProgramUtilitiesFun__StringArray_To_String_Stop_If_Empty(ProductionModuleFun__Get_Rule_Descriptors_From_Production_Rule(the_rule )));
	              return false;
	            }
	            else{//NOT match variable, not isa
	              //=num binds to nil, or the buffer chunk does not have "arg1" cases, or =num bound to multiple values should be taken care just after variable_value_pair get bound
	              //match variable value  "-count",       "=num",       "arg2",        "=num". The variable must appear in this rule at least once without a NOT test and get bound to a single value. The order of =num apprears in the condition part does not matter.
	              if (variable_value_pair.containsKey (slot_value) == false) {// =num not bound (invalid, =num must be bound to a single value in a normal test like "arg3  =num")
	                if (debug_trace) System.out.println("=buffer>, NOT match variable, not isa test =num not bound .fail");
	                return false;
	              }
	              else{
	                String value_bound = (String)variable_value_pair .get(slot_value);
	                if(debug_trace)	System.out.println("NOT match variable, not isa. value_bound: " + value_bound);
	                if(debug_trace)	System.out.println("NOT match variable, not isa. new_slot_key: " + new_slot_key);
	                if(debug_trace)	System.out.println("NOT match variable, not isa. sim.funs.ChunkFun__Get_Chunk_Slot_Value(buffer_chunk, new_slot_key): " + sim.funs.ChunkFun__Get_Chunk_Slot_Value(buffer_chunk, new_slot_key));
	                if ( ProgramUtilitiesFun__StringsEqualByStringOrDouble(ChunkFun__Get_Chunk_Slot_Value(buffer_chunk, new_slot_key), value_bound)){
	                  if (debug_trace) System.out.println("=buffer>, NOT match variable, not isa test == value_bound fail");
	                  return false;
	                }
	                else if(debug_trace)	System.out.println(slot_key + " " + slot_value + " pass");
	              }
	            }
	          }
	        } //end of NOT test
	        else if ( (slot_key.length() >= 2 && !slot_key.substring(0,2).equals( "<=" )) && slot_key.substring(0,1).equals( "<") ){ // < test
	          //System.out.println("ProductionModuleFun__Match_A_Rule_Test < test, " + the_rule.Rule_Name);
	          //debug_trace = true;
	          //modified from "-" test
	          String new_slot_key = slot_key.substring(1); // without the first char '<'
	          if (debug_trace) System.out.println("=buffer>, new_slot_key: " + new_slot_key);
	          if (debug_trace) sim.funs.ChunkFun__Print_Chunk(buffer_chunk);
	          if (buffer_chunk.Slot.containsKey(new_slot_key) == false && !new_slot_key.toLowerCase().equals( "isa" )){ // if the buffer chunk does not have the slot. 
	            //When the buffer test and the buffer chunk have the same ISA type, this case should not happen because, syntax checking (ToDo) when adding production rule should have found this.
	            //However, since QN-ACTR here does not check ISA type match first, this case may still happen even with rule adding syntax checking, because the buffer test and the buffer chunk may have different ISA type.
	            //Anyway, this is a fail case.
	            if (debug_trace) System.out.println("=buffer>, '<' test, Buffer_chunk doesn't have the slot_key. test fail");
	            return false;
	          }
	          if (slot_value.charAt(0) != '=' ){ //match value , like "<arg1",         "7"
	            if(sim.funs.ProgramUtilitiesFun__Is_String_Double(slot_value) == false){
	              System.out.println("ProductionModuleFun__Match_A_Rule_Test rule: " + the_rule.Rule_Name + " relative value test must have numbers as slot values.");
	              return false;
	            }
	            if (new_slot_key.toLowerCase().equals( "isa") ){ //< isa test. illegal
	              System.out.println("ProductionModuleFun__Match_A_Rule_Test rule: " + the_rule.Rule_Name + " relative value test cannot be applied to isa chunk type.");
	            }
	            else{ //< test match value, not isa 
	              String buffer_chunk_value_string = sim.funs.ChunkFun__Get_Chunk_Slot_Value(buffer_chunk, new_slot_key);
	              if(sim.funs.ProgramUtilitiesFun__Is_String_Double( buffer_chunk_value_string ) == false){
	                System.out.println("ProductionModuleFun__Match_A_Rule_Test rule: " + the_rule.Rule_Name + " relative value test has buffer chunk slot value that is not a number: " + buffer_chunk_value_string);
	                return false;
	              }
	              
	              if ( (Double.parseDouble(buffer_chunk_value_string) < Double.parseDouble(slot_value) ) == false){
	                if (debug_trace) System.out.println("=buffer>, < Match value, not ISA test fail");
	                return false;
	              }
	              else if(debug_trace)	System.out.println(slot_key + " " + slot_value + " pass");
	            }
	          }
	          else{ // < match variable, like "<arg1",        "=num1"
	            if (new_slot_key.toLowerCase().equals( "isa") ){//"<isa =num" is invalid. ToDo: should be checked by syntax checking
	              System.out.println("ProductionModuleFun__Match_A_Rule_Test has <isa =num test. Invalid.");
	              System.out.println(" < match variable, like <arg1, =num1: " + sim.funs.ProgramUtilitiesFun__StringArray_To_String_Stop_If_Empty(ProductionModuleFun__Get_Rule_Descriptors_From_Production_Rule(the_rule )));
	              return false;
	            }
	            else{//< match variable, not isa
	              //=num binds to nil, or the buffer chunk does not have "arg1" cases, or =num bound to multiple values should be taken care just after variable_value_pair get bound
	              //match variable value  "-count",       "=num",       "arg2",        "=num". The variable must appear in this rule at least once without a NOT test and get bound to a single value. The order of =num apprears in the condition part does not matter.
	              if (variable_value_pair.containsKey (slot_value) == false) {// =num not bound (invalid, =num must be bound to a single value in a normal test like "arg3  =num")
	                if (debug_trace) System.out.println("=buffer>, < match variable, not isa test =num not bound .fail");
	                return false;
	              }
	              else{
	                String value_bound = (String)variable_value_pair .get(slot_value);
	                if(debug_trace)	System.out.println("< match variable, not isa. value_bound: " + value_bound);
	                if(debug_trace)	System.out.println("< match variable, not isa. new_slot_key: " + new_slot_key);
	                if(debug_trace)	System.out.println("< match variable, not isa. sim.funs.ChunkFun__Get_Chunk_Slot_Value(buffer_chunk, new_slot_key): " + sim.funs.ChunkFun__Get_Chunk_Slot_Value(buffer_chunk, new_slot_key));
	                
	                //value_bound must be a number
	                if(sim.funs.ProgramUtilitiesFun__Is_String_Double(value_bound) == false){
	                  System.out.println("ProductionModuleFun__Match_A_Rule_Test rule: " + the_rule.Rule_Name + " < match variable, not isa. relative value test must have numbers as slot values.");
	                  return false;
	                }
	                
	                //buffer vulue must be a number
	                String buffer_chunk_value_string = sim.funs.ChunkFun__Get_Chunk_Slot_Value(buffer_chunk, new_slot_key);
	                if(sim.funs.ProgramUtilitiesFun__Is_String_Double( buffer_chunk_value_string ) == false){
	                  System.out.println("ProductionModuleFun__Match_A_Rule_Test rule: " + the_rule.Rule_Name + " < match variable, not isa. relative value test has buffer chunk slot value that is not a number: " + buffer_chunk_value_string);
	                  return false;
	                }
	                
	                if ( (Double.parseDouble(buffer_chunk_value_string) < Double.parseDouble(value_bound) ) == false){
	                  if (debug_trace) System.out.println("=buffer>, < Match variable, not ISA test fail");
	                  return false;
	                }
	                else if(debug_trace)	System.out.println(slot_key + " " + slot_value + " pass");
	              }
	            }
	          }
	        }// end of < test
	        else if ((slot_key.length() >= 2 && slot_key.substring(0,2).equals( "<="))){ // <= test
	          //System.out.println("ProductionModuleFun__Match_A_Rule_Test: <= test, " + the_rule.Rule_Name);
	          //debug_trace = true;
	          //modified from "<" test
	          String new_slot_key = slot_key.substring(2); // without the first "<="
	          if (debug_trace) System.out.println("=buffer>, new_slot_key: " + new_slot_key);
	          if (debug_trace) sim.funs.ChunkFun__Print_Chunk(buffer_chunk);
	          if (buffer_chunk.Slot.containsKey(new_slot_key) == false && !new_slot_key.toLowerCase().equals( "isa" )){ // if the buffer chunk does not have the slot. 
	            //When the buffer test and the buffer chunk have the same ISA type, this case should not happen because, syntax checking (ToDo) when adding production rule should have found this.
	            //However, since QN-ACTR here does not check ISA type match first, this case may still happen even with rule adding syntax checking, because the buffer test and the buffer chunk may have different ISA type.
	            //Anyway, this is a fail case.
	            if (debug_trace) System.out.println("=buffer>, <= test, Buffer_chunk doesn't have the slot_key. test fail");
	            return false;
	          }
	          if (slot_value.charAt(0) != '=' ){ //match value , like "<=arg1",         "7"
	            if(sim.funs.ProgramUtilitiesFun__Is_String_Double(slot_value) == false){
	              System.out.println("ProductionModuleFun__Match_A_Rule_Test rule: " + the_rule.Rule_Name + " relative value test must have numbers as slot values.");
	              return false;
	            }
	            if (new_slot_key.toLowerCase().equals( "isa") ){ //<= isa test. illegal
	              System.out.println("ProductionModuleFun__Match_A_Rule_Test rule: " + the_rule.Rule_Name + " relative value test cannot be applied to isa chunk type.");
	            }
	            else{ //<= test match value, not isa 
	              String buffer_chunk_value_string = sim.funs.ChunkFun__Get_Chunk_Slot_Value(buffer_chunk, new_slot_key);
	              if(sim.funs.ProgramUtilitiesFun__Is_String_Double( buffer_chunk_value_string ) == false){
	                System.out.println("ProductionModuleFun__Match_A_Rule_Test rule: " + the_rule.Rule_Name + " relative value test has buffer chunk slot value that is not a number: " + buffer_chunk_value_string);
	                return false;
	              }
	              
	              if ( (Double.parseDouble(buffer_chunk_value_string) <= Double.parseDouble(slot_value) ) == false){
	                if (debug_trace) System.out.println("=buffer>, <= Match value, not ISA test fail");
	                return false;
	              }
	              else if(debug_trace)	System.out.println(slot_key + " " + slot_value + " pass");
	            }
	          }
	          else{ // <= match variable, like "<=arg1",        "=num1"
	            if (new_slot_key.toLowerCase().equals( "isa") ){//"<=isa =num" is invalid. ToDo: should be checked by syntax checking
	              System.out.println("ProductionModuleFun__Match_A_Rule_Test has <=isa =num test. Invalid.");
	              System.out.println(" <= match variable, like <=arg1, =num1: " + sim.funs.ProgramUtilitiesFun__StringArray_To_String_Stop_If_Empty(ProductionModuleFun__Get_Rule_Descriptors_From_Production_Rule(the_rule )));
	              return false;
	            }
	            else{//<= match variable, not isa
	              //=num binds to nil, or the buffer chunk does not have "arg1" cases, or =num bound to multiple values should be taken care just after variable_value_pair get bound
	              //match variable value  "-count",       "=num",       "arg2",        "=num". The variable must appear in this rule at least once without a NOT test and get bound to a single value. The order of =num apprears in the condition part does not matter.
	              if (variable_value_pair.containsKey (slot_value) == false) {// =num not bound (invalid, =num must be bound to a single value in a normal test like "arg3  =num")
	                if (debug_trace) System.out.println("=buffer>, <= match variable, not isa test =num not bound .fail");
	                return false;
	              }
	              else{
	                String value_bound = (String)variable_value_pair .get(slot_value);
	                if(debug_trace)	System.out.println("<= match variable, not isa. value_bound: " + value_bound);
	                if(debug_trace)	System.out.println("<= match variable, not isa. new_slot_key: " + new_slot_key);
	                if(debug_trace)	System.out.println("<= match variable, not isa. sim.funs.ChunkFun__Get_Chunk_Slot_Value(buffer_chunk, new_slot_key): " + sim.funs.ChunkFun__Get_Chunk_Slot_Value(buffer_chunk, new_slot_key));
	                
	                //value_bound must be a number
	                if(sim.funs.ProgramUtilitiesFun__Is_String_Double(value_bound) == false){
	                  System.out.println("ProductionModuleFun__Match_A_Rule_Test rule: " + the_rule.Rule_Name + " <= match variable, not isa. relative value test must have numbers as slot values.");
	                  return false;
	                }
	                
	                //buffer vulue must be a number
	                String buffer_chunk_value_string = sim.funs.ChunkFun__Get_Chunk_Slot_Value(buffer_chunk, new_slot_key);
	                if(sim.funs.ProgramUtilitiesFun__Is_String_Double( buffer_chunk_value_string ) == false){
	                  System.out.println("ProductionModuleFun__Match_A_Rule_Test rule: " + the_rule.Rule_Name + " <= match variable, not isa. relative value test has buffer chunk slot value that is not a number: " + buffer_chunk_value_string);
	                  return false;
	                }
	                
	                if ( (Double.parseDouble(buffer_chunk_value_string) <= Double.parseDouble(value_bound) ) == false){
	                  if (debug_trace) System.out.println("=buffer>, <= Match variable, not ISA test fail");
	                  return false;
	                }
	                else if(debug_trace)	System.out.println(slot_key + " " + slot_value + " pass");
	              }
	            }
	          }
	        }// end of <= test
	        else if ((slot_key.length() >= 2 && !slot_key.substring(0,2).equals( ">=" )) && slot_key.charAt(0) == '>'){ // > test
	          //System.out.println("ProductionModuleFun__Match_A_Rule_Test ToDo: > test, " + the_rule.Rule_Name);
	          //debug_trace = true;
	          //modified from "<" test
	          String new_slot_key = slot_key.substring(1); // without the first ">"
	          if (debug_trace) System.out.println("=buffer>, new_slot_key: " + new_slot_key);
	          if (debug_trace) sim.funs.ChunkFun__Print_Chunk(buffer_chunk);
	          if (buffer_chunk.Slot.containsKey(new_slot_key) == false && !new_slot_key.toLowerCase().equals( "isa" )){ // if the buffer chunk does not have the slot. 
	            //When the buffer test and the buffer chunk have the same ISA type, this case should not happen because, syntax checking (ToDo) when adding production rule should have found this.
	            //However, since QN-ACTR here does not check ISA type match first, this case may still happen even with rule adding syntax checking, because the buffer test and the buffer chunk may have different ISA type.
	            //Anyway, this is a fail case.
	            if (debug_trace) System.out.println("=buffer>, > test, Buffer_chunk doesn't have the slot_key. test fail");
	            return false;
	          }
	          if (slot_value.charAt(0) != '=' ){ //match value , like ">arg1",         "7"
	            if(sim.funs.ProgramUtilitiesFun__Is_String_Double(slot_value) == false){
	              System.out.println("ProductionModuleFun__Match_A_Rule_Test rule: " + the_rule.Rule_Name + " relative value test must have numbers as slot values.");
	              return false;
	            }
	            if (new_slot_key.toLowerCase().equals( "isa") ){ //> isa test. illegal
	              System.out.println("ProductionModuleFun__Match_A_Rule_Test rule: " + the_rule.Rule_Name + " relative value test cannot be applied to isa chunk type.");
	            }
	            else{ //> test match value, not isa 
	              String buffer_chunk_value_string = sim.funs.ChunkFun__Get_Chunk_Slot_Value(buffer_chunk, new_slot_key);
	              if(sim.funs.ProgramUtilitiesFun__Is_String_Double( buffer_chunk_value_string ) == false){
	                System.out.println("ProductionModuleFun__Match_A_Rule_Test rule: " + the_rule.Rule_Name + " relative value test has buffer chunk slot value that is not a number: " + buffer_chunk_value_string);
	                return false;
	              }
	              
	              if ( (Double.parseDouble(buffer_chunk_value_string) > Double.parseDouble(slot_value) ) == false){
	                if (debug_trace) System.out.println("=buffer>, > Match value, not ISA test fail. (Double.valueOf(buffer_chunk_value_string) " + Double.parseDouble(buffer_chunk_value_string) + ", Double.valueOf(slot_value): " + Double.parseDouble(slot_value));
	                return false;
	              }
	              else if(debug_trace)	System.out.println(slot_key + " " + slot_value + " pass");
	            }
	          }
	          else{ // > match variable, like ">arg1",        "=num1"
	            if (new_slot_key.toLowerCase().equals( "isa") ){//">isa =num" is invalid. ToDo: should be checked by syntax checking
	              System.out.println("ProductionModuleFun__Match_A_Rule_Test has >isa =num test. Invalid.");
	              System.out.println(" > match variable, like >arg1, =num1: " + sim.funs.ProgramUtilitiesFun__StringArray_To_String_Stop_If_Empty(ProductionModuleFun__Get_Rule_Descriptors_From_Production_Rule(the_rule )));
	              return false;
	            }
	            else{//> match variable, not isa
	              //=num binds to nil, or the buffer chunk does not have "arg1" cases, or =num bound to multiple values should be taken care just after variable_value_pair get bound
	              //match variable value  "-count",       "=num",       "arg2",        "=num". The variable must appear in this rule at least once without a NOT test and get bound to a single value. The order of =num apprears in the condition part does not matter.
	              if (variable_value_pair.containsKey (slot_value) == false) {// =num not bound (invalid, =num must be bound to a single value in a normal test like "arg3  =num")
	                if (debug_trace) System.out.println("=buffer>, > match variable, not isa test =num not bound .fail");
	                return false;
	              }
	              else{
	                String value_bound = (String)variable_value_pair.get(slot_value);
	                if(debug_trace)	System.out.println("> match variable, not isa. value_bound: " + value_bound);
	                if(debug_trace)	System.out.println("> match variable, not isa. new_slot_key: " + new_slot_key);
	                if(debug_trace)	System.out.println("> match variable, not isa. sim.funs.ChunkFun__Get_Chunk_Slot_Value(buffer_chunk, new_slot_key): " + sim.funs.ChunkFun__Get_Chunk_Slot_Value(buffer_chunk, new_slot_key));
	                
	                //value_bound must be a number
	                if(sim.funs.ProgramUtilitiesFun__Is_String_Double(value_bound) == false){
	                  System.out.println("ProductionModuleFun__Match_A_Rule_Test rule: " + the_rule.Rule_Name + " > match variable, not isa. relative value test must have numbers as slot values.");
	                  return false;
	                }
	                
	                //buffer vulue must be a number
	                String buffer_chunk_value_string = sim.funs.ChunkFun__Get_Chunk_Slot_Value(buffer_chunk, new_slot_key);
	                if(sim.funs.ProgramUtilitiesFun__Is_String_Double( buffer_chunk_value_string ) == false){
	                  System.out.println("ProductionModuleFun__Match_A_Rule_Test rule: " + the_rule.Rule_Name + " > match variable, not isa. relative value test has buffer chunk slot value that is not a number: " + buffer_chunk_value_string);
	                  return false;
	                }
	                
	                if ( (Double.parseDouble(buffer_chunk_value_string) > Double.parseDouble(value_bound) ) == false){
	                  if (debug_trace) System.out.println("=buffer>, > Match variable, not ISA test fail");
	                  return false;
	                }
	                else if(debug_trace)	System.out.println(slot_key + " " + slot_value + " pass");
	              }
	            }
	          }
	        }// end of > test
	        else if ((slot_key.length() >= 2 && slot_key.substring(0,2).equals( ">="))){ // >= test
	          //System.out.println("ProductionModuleFun__Match_A_Rule_Test ToDo: >= test, " + the_rule.Rule_Name);
	          //debug_trace = true;
	          //modified from ">" test
	          String new_slot_key = slot_key.substring(2); // without the first ">="
	          if (debug_trace) System.out.println("=buffer>, new_slot_key: " + new_slot_key);
	          if (debug_trace) sim.funs.ChunkFun__Print_Chunk(buffer_chunk);
	          if (buffer_chunk.Slot.containsKey(new_slot_key) == false && !new_slot_key.toLowerCase().equals( "isa" )){ // if the buffer chunk does not have the slot. 
	            //When the buffer test and the buffer chunk have the same ISA type, this case should not happen because, syntax checking (ToDo) when adding production rule should have found this.
	            //However, since QN-ACTR here does not check ISA type match first, this case may still happen even with rule adding syntax checking, because the buffer test and the buffer chunk may have different ISA type.
	            //Anyway, this is a fail case.
	            if (debug_trace) System.out.println("=buffer>, >= test, Buffer_chunk doesn't have the slot_key. test fail");
	            return false;
	          }
	          if (slot_value.charAt(0) != '=' ){ //match value , like ">=arg1",         "7"
	            if(sim.funs.ProgramUtilitiesFun__Is_String_Double(slot_value) == false){
	              System.out.println("ProductionModuleFun__Match_A_Rule_Test rule: " + the_rule.Rule_Name + " relative value test must have numbers as slot values.");
	              return false;
	            }
	            if (new_slot_key.toLowerCase().equals( "isa") ){ //>= isa test. illegal
	              System.out.println("ProductionModuleFun__Match_A_Rule_Test rule: " + the_rule.Rule_Name + " relative value test cannot be applied to isa chunk type.");
	            }
	            else{ //>= test match value, not isa 
	              String buffer_chunk_value_string = sim.funs.ChunkFun__Get_Chunk_Slot_Value(buffer_chunk, new_slot_key);
	              if(sim.funs.ProgramUtilitiesFun__Is_String_Double( buffer_chunk_value_string ) == false){
	                System.out.println("ProductionModuleFun__Match_A_Rule_Test rule: " + the_rule.Rule_Name + " relative value test has buffer chunk slot value that is not a number: " + buffer_chunk_value_string);
	                return false;
	              }
	              
	              if ( (Double.parseDouble(buffer_chunk_value_string) >= Double.parseDouble(slot_value) ) == false){
	                if (debug_trace) System.out.println("=buffer>, >= Match value, not ISA test fail");
	                return false;
	              }
	              else if(debug_trace)	System.out.println(slot_key + " " + slot_value + " pass");
	            }
	          }
	          else{ // >= match variable, like ">=arg1",        "=num1"
	            if (new_slot_key.toLowerCase().equals( "isa") ){//">=isa =num" is invalid. ToDo: should be checked by syntax checking
	              System.out.println("ProductionModuleFun__Match_A_Rule_Test has >=isa =num test. Invalid.");
	              System.out.println(" >= match variable, like >=arg1, =num1: " + sim.funs.ProgramUtilitiesFun__StringArray_To_String_Stop_If_Empty(ProductionModuleFun__Get_Rule_Descriptors_From_Production_Rule(the_rule )));
	              return false;
	            }
	            else{//>= match variable, not isa
	              //=num binds to nil, or the buffer chunk does not have "arg1" cases, or =num bound to multiple values should be taken care just after variable_value_pair get bound
	              //match variable value  "-count",       "=num",       "arg2",        "=num". The variable must appear in this rule at least once without a NOT test and get bound to a single value. The order of =num apprears in the condition part does not matter.
	              if (variable_value_pair.containsKey (slot_value) == false) {// =num not bound (invalid, =num must be bound to a single value in a normal test like "arg3  =num")
	                if (debug_trace) System.out.println("=buffer>, >= match variable, not isa test =num not bound .fail");
	                return false;
	              }
	              else{
	                String value_bound = (String)variable_value_pair.get(slot_value);
	                if(debug_trace)	System.out.println(">= match variable, not isa. value_bound: " + value_bound);
	                if(debug_trace)	System.out.println(">= match variable, not isa. new_slot_key: " + new_slot_key);
	                if(debug_trace)	System.out.println(">= match variable, not isa. sim.funs.ChunkFun__Get_Chunk_Slot_Value(buffer_chunk, new_slot_key): " + sim.funs.ChunkFun__Get_Chunk_Slot_Value(buffer_chunk, new_slot_key));
	                
	                //value_bound must be a number
	                if(sim.funs.ProgramUtilitiesFun__Is_String_Double(value_bound) == false){
	                  System.out.println("ProductionModuleFun__Match_A_Rule_Test rule: " + the_rule.Rule_Name + " >= match variable, not isa. relative value test must have numbers as slot values.");
	                  return false;
	                }
	                
	                //buffer vulue must be a number
	                String buffer_chunk_value_string = sim.funs.ChunkFun__Get_Chunk_Slot_Value(buffer_chunk, new_slot_key);
	                if(sim.funs.ProgramUtilitiesFun__Is_String_Double( buffer_chunk_value_string ) == false){
	                  System.out.println("ProductionModuleFun__Match_A_Rule_Test rule: " + the_rule.Rule_Name + " >= match variable, not isa. relative value test has buffer chunk slot value that is not a number: " + buffer_chunk_value_string);
	                  return false;
	                }
	                
	                if ( (Double.parseDouble(buffer_chunk_value_string) >= Double.parseDouble(value_bound) ) == false){
	                  if (debug_trace) System.out.println("=buffer>, >= Match variable, not ISA test fail");
	                  return false;
	                }
	                else if(debug_trace)	System.out.println(slot_key + " " + slot_value + " pass");
	              }
	            }
	          }
	        }// end of >= test
	        else{ // normal test, like "arg1",        "=num1" / or "7"
	          if (buffer_chunk.Slot.containsKey(slot_key) == false && ! slot_key.toLowerCase().equals( "isa" )){ // if the buffer chunk does not have the slot. 
	            //When the buffer test and the buffer chunk have the same ISA type, this case should not happen because, syntax checking (ToDo) when adding production rule should have found this.
	            //However, since QN-ACTR here does not check ISA type match first, this case may still happen even with rule adding syntax checking, because the buffer test and the buffer chunk may have different ISA type.
	            //Anyway, this is a not_match = true case.
	            //System.out.println("ProductionModuleFun__Match_A_Rule_Test the buffer chunk does not have the slot");
	            //not_match = true;  
	            //break;
	            if (debug_trace) System.out.println("=buffer>, Normal test, Buffer_chunk don't have the slot_key test  fail");
	            return false;
	          }				
	          if (slot_value.charAt(0) != '=' ){ //match value rather than variable ; values like "7",  "CHUNK_wall"
	            if (slot_key.toLowerCase().equals( "isa") ){ //isa chunk TYPE special test
	              //System.out.println( buffer_chunk.Chunk_Type +  slot_value );
	              if ( ProgramUtilitiesFun__StringsEqualByStringOrDouble(buffer_chunk.Chunk_Type, slot_value )|| sim.funs.ChunkFun__Is_Descendant_Of(buffer_chunk.Chunk_Type, slot_value) == true ) { //e.g., "isa text" will pass "ISA visual-object" test
	                if(debug_trace)	System.out.println(slot_key + " " + slot_value + " pass");
	              }
	              else {
	                //not_match = true;
	                //break;
	                if (debug_trace) System.out.println("=buffer>, Normal test, match value, isa chunk TYPE special test.  fail");
	                return false;
	              }
	            }
	            else{ //not isa, match value rather than variable
	              if (! ProgramUtilitiesFun__StringsEqualByStringOrDouble(ChunkFun__Get_Chunk_Slot_Value(buffer_chunk, slot_key), slot_value)){
	                //not_match = true;
	                //break;
	                if (debug_trace) System.out.println("=" + buffer_name + ">, Normal test, match value, not isa test.  fail. slot_key: " + slot_key + ", buffer chunk value: " + sim.funs.ChunkFun__Get_Chunk_Slot_Value(buffer_chunk, slot_key) + ", slot_value: " + slot_value);
	                return false;
	              }
	              else if(debug_trace)	System.out.println(slot_key + " " + slot_value + " pass");
	            }
	          } // end match value
	          else{ // match variable, like "arg1",        "=num1"
	            if (slot_key.toLowerCase().equals( "isa") ){//"isa =num" is invalid. ToDo: should be checked by syntax checking
	              System.out.println("ProductionModuleFun__Match_A_Rule_Test has isa =num test. Invalid.");
	              System.out.println(" match variable, like arg1, =num1: " + sim.funs.ProgramUtilitiesFun__StringArray_To_String_Stop_If_Empty(ProductionModuleFun__Get_Rule_Descriptors_From_Production_Rule(the_rule )));
	              return false;
	            }
	            else{//not isa, match variable
	              //=num binds to nil, or the buffer chunk does not have "arg1", or =num bound to multiple values cases should be taken care just after variable_value_pair get bound
	              //match variable value  "count",       "=num",       "arg2",        "=num". The variable appeared in this rule before. The order of =num apprears in the condition part does not matter.
	              if (variable_value_pair.containsKey (slot_value) == false) {// =num not bound (this should not be the case in a Normal test, but put it here for consistency and safety)
	                if (debug_trace) System.out.println("=buffer>, Normal test, match variable, =num not bound.  fail");
	                return false;
	              }
	              else{ //=num bound
	                String value_bound = (String)variable_value_pair.get(slot_value);
	                if (! ProgramUtilitiesFun__StringsEqualByStringOrDouble(ChunkFun__Get_Chunk_Slot_Value(buffer_chunk, slot_key), value_bound)){
	                  if (debug_trace) System.out.println("=buffer>, Normal test, match variable, != value_bound.  fail");
	                  return false;
	                }
	                else if(debug_trace)	System.out.println(slot_key + " " + slot_value + " pass");
	              }
	            }
	          }  // end match variable
	        } //end of normal test
	      }
	    } // end of =buffer> test
	    else if ( condition_item_type.equals( "?")){ // ?buffer> test
	      String buffer_name = currentConditionItem.Buffer_Name ;
	      
	      
	      Iterator<Entry<String, String>> itrSlot = currentConditionItem.Slot.entrySet().iterator();
	      while(itrSlot.hasNext()){ //check each attribute-name and attribute-value in the condition item

	        Entry<String, String> currentEntry = itrSlot.next();
	        String slot_key = currentEntry.getKey();
	        String slot_value = currentEntry.getValue();
	        String new_slot_key = slot_key; //give it a value so that the compiler is happy, because of the "slot_key = new_slot_key" below
	        boolean is_NOT_test = false;
	        if (slot_key.charAt(0) == '-'){//NOT test
	          new_slot_key = slot_key.substring(1); 
	          is_NOT_test = true;
	        }
	        else if (slot_key.charAt(0) == '>' || slot_key.charAt(0) == '<'){ //There is NO < > test for ?buffer> test. ToDo: syntax checking should catch this.
	          System.out.println ("ProductionModuleFun__Match_A_Rule_Test There should be NO < or > for ?" + buffer_name + "> test");
	          return false;
	        }
	        if (slot_key.toLowerCase().equals( "isa") || slot_key.toLowerCase().equals( "-isa")){ //There is NO ISA test for ?buffer> test
	          System.out.println ("ProductionModuleFun__Match_A_Rule_Test There should be NO ISA test for ?" + buffer_name + "> test");  //ToDo: syntax checking should take care of this
	          return false;
	        }
	        if (slot_value.charAt(0) == '=' ){//match variable (invalid for all ?buffer> test)
	          System.out.println ("ProductionModuleFun__Match_A_Rule_Test match variable ToDo for ?:" + buffer_name + "> test");  //ToDo: syntax checking should take care a part of this, see notes below
	          return false;
	          //leave a ToDo for variable =num in ?buffer>test
	          //?retrieval>
	          //state =num1
	          //In ACT-R, it is not valid when =num1 is not bound, or =num1 is bound to a value other than a valid buffer state keyword like free, busy,
	          //In QN-ACTR, since the chance that a user will use =num such variable test in ?buffer> tests, it leaves a ToDo in ProductionModuleFun__Bind_Variables_In_Rule_Condition and ProductionModuleFun__Match_A_Rule_Test
	        }
	        
	        else{ // Match value, not isa, Normal or NOT test for ?buffer_name>
	          //Determine bool is_slot_matched (if it is a NOT test, get the corresponding normal test result here)
	          if (is_NOT_test == true) slot_key = new_slot_key; //so that slot_key must be without -, like arg1, for the convenience below
	          //Use exclusive OR ^ to combine normal and NOT test, bool  is_NOT_test . 
	          boolean is_slot_matched = is_NOT_test; //so that the match_result below is default to false;
	          switch (buffer_name.toLowerCase()){ //ToDo: here add more test cases according to ACT-R module/buffer state tests.
	            case "aural":{ //modifed from visual, since they are similar
	              switch (slot_key.toLowerCase() + "_" + slot_value.toLowerCase()){
	                case "state_free":{
	                  //here is the different part for each module
	                  is_slot_matched = (sim.vars.audioModule.State_Free == true);
	                  //
	                  break;
	                }
	                case "buffer_empty":{
	                  is_slot_matched = sim.funs.ProgramUtilitiesFun__Is_Buffer_Empty(buffer_name.toLowerCase()); 
	                  break;
	                }
	                case "buffer_full":{
	                  is_slot_matched =  ( sim.funs.ProgramUtilitiesFun__Is_Buffer_Empty (buffer_name.toLowerCase()) == false) ; 
	                  break;
	                }
	                default:{//this is general to any buffer_name, slot keys and values, and is_NOT_test
	                  String not_sign = "";
	                  if (is_NOT_test == true) not_sign = "-";
	                  System.out.println ("ProductionModuleFun__Match_A_Rule_Test. ?" + buffer_name + "> has undefined test case: " + (not_sign + slot_key.toLowerCase() + "_" + slot_value.toLowerCase()));
	                  return false;
	                }						
	              }					
	              break;
	            }
	            case "aural-location":{
	              switch (slot_key.toLowerCase() + "_" + slot_value.toLowerCase()){
	                case "buffer_empty":{
	                  is_slot_matched = sim.funs.ProgramUtilitiesFun__Is_Buffer_Empty(buffer_name.toLowerCase()); 
	                  break;
	                }
	                case "buffer_full":{
	                  is_slot_matched =  ( sim.funs.ProgramUtilitiesFun__Is_Buffer_Empty (buffer_name.toLowerCase()) == false) ; 
	                  break;
	                }
	                default:{ //this is general to any buffer_name, slot keys and values, and is_NOT_test
	                  String not_sign = "";
	                  if (is_NOT_test == true) not_sign = "-";
	                  System.out.println ("ProductionModuleFun__Match_A_Rule_Test. ?" + buffer_name + "> has undefined test case: " + (not_sign + slot_key.toLowerCase() + "_" + slot_value.toLowerCase()));
	                  return false;
	                  
	                }						
	              }					
	              break;
	            }
	            case "imaginal":{
	              switch (slot_key.toLowerCase() + "_" + slot_value.toLowerCase()){
	                case "buffer_empty":{
	                  is_slot_matched = sim.funs.ProgramUtilitiesFun__Is_Buffer_Empty(buffer_name.toLowerCase()); 
	                  break;
	                }
	                case "buffer_full":{
	                  is_slot_matched =  ( sim.funs.ProgramUtilitiesFun__Is_Buffer_Empty (buffer_name.toLowerCase()) == false) ; 
	                  break;
	                }
	                case "state_free":{
	                  //here is the different part for each module
	                  is_slot_matched = (sim.vars.imaginaryModule.State_Free == true);
	                  //
	                  break;
	                }
	                case "state_error":{
	                  //here is the different part for each module
	                  is_slot_matched = (sim.vars.imaginaryModule.State_Error == true);
	                  //
	                  break;
	                }
	                default:{ //this is general to any buffer_name, slot keys and values, and is_NOT_test
	                  String not_sign = "";
	                  if (is_NOT_test == true) not_sign = "-";
	                  System.out.println ("ProductionModuleFun__Match_A_Rule_Test. ?" + buffer_name + "> has undefined test case: " + (not_sign + slot_key.toLowerCase() + "_" + slot_value.toLowerCase()));
	                  return false;
	                  
	                }						
	              }					
	              break;
	            }
	            case "manual":{
	              // test for last-comand query
	              if(slot_key.toLowerCase().equals( "last-command")) {
	                is_slot_matched = (sim.vars.motorModule.Last_Command_Chunk_Type.equals( slot_value.toLowerCase()));
	              } else {
	                switch (slot_key.toLowerCase() + "_" + slot_value.toLowerCase()){
	                  //Here is a summary indicating the state transitions for a single movement request assuming that the module is entirely free at the start of the request: 
	                  //preparation_state		processor_state		execution_state		When
	                  //FREE					FREE				FREE				Before event arrives at motor module (before motor preparation)
	                  //BUSY					BUSY				FREE				When event is received (in motor preparation)
	                  //FREE					BUSY				BUSY				After preparation of movement (in motor initiation)
	                  //FREE					FREE				BUSY				After initiation movement (in motor execution)
	                  //FREE					FREE				FREE				When movement is complete
	                  //'State free' will be t when all of the internal states of the module (listed below) also report as being free. Essentially, it will be t only when all requests to the manual buffer have completed. It will be nil otherwise.
	                  case "preparation_free":{
	                    //here is the different part for each module
	                    is_slot_matched = (sim.vars.motorModule.Preparation_Free == true);
	                    //
	                    break;
	                  }
	                  case "processor_free":{
	                    //here is the different part for each module
	                    is_slot_matched = (sim.vars.motorModule.Processor_Free == true);
	                    //
	                    break;
	                  }
	                  case "execution_free":{
	                    //here is the different part for each module
	                    is_slot_matched = (sim.vars.motorModule.Execution_Free == true);
	                    //
	                    break;
	                  }
	                  case "state_free":{
	                    //here is the different part for each module
	                    is_slot_matched = (sim.vars.motorModule.State_Free == true);
	                    //
	                    break;
	                  }
	                  case "state_busy":
	                    // state busy is the opposite of state_free
	                    is_slot_matched = (sim.vars.motorModule.State_Free == false);
	                    break;
	                  default:{//this is general to any buffer_name, slot keys and values, and is_NOT_test
	                    String not_sign = "";
	                    if (is_NOT_test == true) not_sign = "-";
	                    System.out.println ("ProductionModuleFun__Match_A_Rule_Test. ?" + buffer_name + "> has undefined test case: " + (not_sign + slot_key.toLowerCase() + "_" + slot_value.toLowerCase()));
	                    return false;
	                    
	                  }						
	                }
	              }
	              break;
	            }
	            case "retrieval":{
	              switch (slot_key.toLowerCase() + "_" + slot_value.toLowerCase()){
	                case "buffer_empty":{
	                  is_slot_matched = sim.funs.ProgramUtilitiesFun__Is_Buffer_Empty(buffer_name.toLowerCase()); 
	                  break;
	                }
	                case "buffer_full":{
	                  is_slot_matched =  ( sim.funs.ProgramUtilitiesFun__Is_Buffer_Empty (buffer_name.toLowerCase()) == false) ; 
	                  break;
	                }
	                case "error_nil":{
	                  //here is the different part for each module
	                  is_slot_matched = (sim.vars.declarativeModule.State_Error == false);
	                  //
	                  break;
	                }
	                case "state_free":{
	                  //here is the different part for each module
	                  is_slot_matched = (sim.vars.declarativeModule.State_Free == true);
	                  //
	                  break;
	                }
	                case "state_error":{
	                  //here is the different part for each module
	                  is_slot_matched = (sim.vars.declarativeModule.State_Error == true);
	                  //
	                  break;
	                }							
	                default:{ //this is general to any buffer_name, slot keys and values, and is_NOT_test
	                  String not_sign = "";
	                  if (is_NOT_test == true) not_sign = "-";
	                  System.out.println ("ProductionModuleFun__Match_A_Rule_Test. ?" + buffer_name + "> has undefined test case: " + (not_sign + slot_key.toLowerCase() + "_" + slot_value.toLowerCase()));
	                  return false;
	                  
	                }						
	              }					
	              break;
	            }
	            case "visual":{
	              switch (slot_key.toLowerCase() + "_" + slot_value.toLowerCase()){
	                case "buffer_empty":{
	                  is_slot_matched = sim.funs.ProgramUtilitiesFun__Is_Buffer_Empty(buffer_name.toLowerCase()); 
	                  break;
	                }
	                case "buffer_full":{
	                  is_slot_matched =  ( sim.funs.ProgramUtilitiesFun__Is_Buffer_Empty (buffer_name.toLowerCase()) == false) ; 
	                  break;
	                }
	                case "state_free":{
	                  //here is the different part for each module
	                  is_slot_matched = (sim.vars.visionModule.State_Free == true);
	                  if(debug_trace) System.out.println("ProductionModuleFun__Match_A_Rule_Test visual state_free: " + sim.vars.visionModule.State_Free +  ", is_slot_matched: " + is_slot_matched);
	                  //
	                  break;
	                }
	                case "state_error":{
	                  //here is the different part for each module
	                	//System.out.println("sim.vars.visionModule.State_Error="+sim.vars.visionModule.State_Error);
	                  is_slot_matched = (sim.vars.visionModule.State_Error == true);
	                  //
	                  break;
	                }
	                default:{//this is general to any buffer_name, slot keys and values, and is_NOT_test
	                  String not_sign = "";
	                  if (is_NOT_test == true) not_sign = "-";
	                  System.out.println ("ProductionModuleFun__Match_A_Rule_Test. ?" + buffer_name + "> has undefined test case: " + (not_sign + slot_key.toLowerCase() + "_" + slot_value.toLowerCase()));
	                  return false;
	                  
	                }						
	              }					
	              break;
	            }
	            case "visual-location":{
	              switch (slot_key.toLowerCase() + "_" + slot_value.toLowerCase()){
	                case "buffer_empty":{
	                  is_slot_matched = sim.funs.ProgramUtilitiesFun__Is_Buffer_Empty(buffer_name.toLowerCase()); 
	                  break;
	                }
	                case "buffer_full":{
	                  is_slot_matched =  ( sim.funs.ProgramUtilitiesFun__Is_Buffer_Empty (buffer_name.toLowerCase()) == false) ; 
	                  break;
	                }
	                case "buffer_unrequested":{
	                  //here is the different part for each module
	                  is_slot_matched = (sim.vars.visualLocationBuffer.Unrequested == true);
	                  //
	                  break;
	                }
	                case "buffer_requested":{
	                  //here is the different part for each module
	                  is_slot_matched = (sim.vars.visualLocationBuffer.Requested == true);
	                  //
	                  break;
	                }
	                case "state_error":{
	                  //here is the different part for each module
	                  is_slot_matched = (sim.vars.visualLocationBuffer.State_Error == true);
	                  //
	                  break;
	                }
	                default:{ //this is general to any buffer_name, slot keys and values, and is_NOT_test
	                  String not_sign = "";
	                  if (is_NOT_test == true) not_sign = "-";
	                  System.out.println ("ProductionModuleFun__Match_A_Rule_Test. ?" + buffer_name + "> has undefined test case: " + (not_sign + slot_key.toLowerCase() + "_" + slot_value.toLowerCase()));
	                  return false;
	                  
	                }						
	              }					
	              break;
	            }
	            
	            case "temporal":
	              switch(slot_key.toLowerCase() + "_" + slot_value.toLowerCase()) {
	                case "buffer_empty":
	                  is_slot_matched = sim.funs.ProgramUtilitiesFun__Is_Buffer_Empty(buffer_name.toLowerCase());
	                  break;
	                  // TODO other temporal buffer tests
	                default:
	                  System.out.println("ProductionModuleFun__Match_A_Rule_Test. ?" + buffer_name + "> has undefined test case: " + (is_NOT_test ? "-" : "") + slot_key.toLowerCase() + "_" + slot_value.toLowerCase());
	                  break;
	              }
	              break;
	              
	            case "vocal":{
	              switch (slot_key.toLowerCase() + "_" + slot_value.toLowerCase()){
	                case "state_busy":{
	                  //here is the different part for each module
	                  is_slot_matched = (sim.vars.speechModule.State_Free == false);
	                  //
	                  break;
	                }
	                case "state_free":{
	                  //here is the different part for each module
	                  is_slot_matched = (sim.vars.speechModule.State_Free == true);
	                  //
	                  break;
	                }
	                default:{//this is general to any buffer_name, slot keys and values, and is_NOT_test
	                  String not_sign = "";
	                  if (is_NOT_test == true) not_sign = "-";
	                  System.out.println ("ProductionModuleFun__Match_A_Rule_Test. ?" + buffer_name + "> has undefined test case: " + (not_sign + slot_key.toLowerCase() + "_" + slot_value.toLowerCase()));
	                  return false;
	                  
	                }						
	              }					
	              break;
	            }
	            default:{
	              System.out.println ("ProductionModuleFun__Match_A_Rule_Test has an undefined buffer_name in: ?" + buffer_name + ">");
	              return false;
	              
	            }
	          }
	          
	          //Determine the test result.
	          boolean match_result = is_slot_matched ^ is_NOT_test;
	          //Normal test like "state  free":	
	          //	is_Slot_matched (true)  ^   is_NOT_test (false)  = true
	          //	is_Slot_matched (false) ^   is_NOT_test (false)  = false
	          //Not test like "-state free"  :
	          //	is_Slot_matched (true)  ^   is_NOT_test (true)  =  false
	          //	is_Slot_matched (false) ^   is_NOT_test (true)  =  true
	          if (match_result == true) { 
	            //pass do nothing
	            if (debug_trace) System.out.println("?" + buffer_name + "> test  pass");
	          }
	          else {
	            if (debug_trace) System.out.println("?" + buffer_name + "> test  fail");
	            return false;
	          }
	        }
	      }
	    }// end of ?buffer> test
	    
	    else if ( condition_item_type.equals( "!eval!") ){
	      String eval_content = currentConditionItem.Buffer_Name ;
	      String[] eval_content_array = sim.funs.ProgramUtilitiesFun__String_To_StringArray( eval_content );
	      //substitute any variable in the content
	      for(int i = 0 ; i < eval_content_array.length ; i ++ ) {
	        String a_string = eval_content_array [ i ] ;
	        if (a_string.charAt(0) == '=' && a_string.length() > 1 && !a_string.equals( "=" )){ // it is a variable like =num, exclude "=" 
	          if( variable_value_pair.containsKey (a_string) == false) {			// =num not bound 
	            System.err.println("Error! ProductionModuleFun__Match_A_Rule_Test has variable_value_pair.ContainsKey (a_string) == false. a_string: " + a_string );
	            return false;
	          }
	          else { //substitute
	            eval_content_array [ i ] = (String) variable_value_pair.get( a_string );
	          }
	        }
	      }
	      
	      //evaluate the content
	      String eval_result = LispFun__Evaluate_A_List ( sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty( eval_content_array ) );
	      if( eval_result.equals( "nil") ) return false; 
	      //else, continue with other tests
	      //store the eval_result in the slot.
	       currentConditionItem.Slot.put ( "eval_result" , eval_result ); //should be added only once
	      
	    } //end of condition_item_type.equals( "!eval!" )
	    else if ( condition_item_type.equals( "!bind!") ){
	      String bind_result = (String) currentConditionItem.Slot.get("bind_result") ; //should have this result from ProductionModuleFun__Bind_Variables_In_Rule_Condition
	      if ( bind_result.equals( "nil") ) return false; 
	      //else, continue with other tests
	    } //end of condition_item_type.equals( "!bindl!")
	    else{
	      System.err.println ("ProductionModuleFun__Match_A_Rule_Test has an invalid condition item type: " + currentConditionItem.Type);
	    }
	  }
	  
	  //if pass all the tests
	  return true; 
	}
	
	public LinkedList<Production_Rule> ProductionModuleFun__Match_Rule(LinkedList<Production_Rule> the_rule_list){
	  
	  //error check
	  if (the_rule_list == null || the_rule_list.size() == 0) {
	    //System.out.println("WARNING! ProductionModuleFun__Match_Rule has input null or empty");
	    return null;
	  }
	  
	  if(sim.vars.printingModule.Show_Multiple_Goal_Trace_In_Output_Trace_Txt)ProgramUtilitiesFun__Output_Trace_Txt( "ProductionModuleFun__Match_Rule- sim.vars.productionModule.Goal_Thread_Order_List_For_Threaded_Cognition: " + sim.funs.ProgramUtilitiesFun__StringArray_To_String_Stop_If_Empty(sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString(sim.vars.productionModule.Goal_Thread_Order_List_For_Threaded_Cognition)));
	  
	  LinkedList<Production_Rule> return_rules = new LinkedList<Production_Rule>();
	  //IEnumerator enum_rules = sim.vars.productionModule.Production_Rules.GetEnumerator(); //this means considering all rules
	  Enumeration enum_rules = Collections.enumeration(the_rule_list); //this is the rule pool.
	  while(enum_rules.hasMoreElements()){
	    //GlobalUtilities.popUpMessage( ((Production_Rule)enum_rules.Current).Rule_Name);
	    
	    Production_Rule current_rule = (Production_Rule)enum_rules.nextElement();
	    Production_Rule current_rule_clone = sim.funs.ProgramUtilitiesFun__Production_Rule_Clone( current_rule ) ;
	    
	    if(MultitaskingFun__Does_Condition_Part_Have_Equal_Goal_X_Test(current_rule_clone)==false){ // no =goal-x> issue
	      if (   ProductionModuleFun__Match_A_Rule_Test( current_rule_clone  ) == true){//match the current mental state
	        return_rules.addLast(  current_rule_clone  );
	      }
	      else{
	        //GlobalUtilities.popUpMessage("false");
	      }
	    }
	    else{ //=goal-x> issue
	      LinkedList<String> multi_goal_name_list = sim.vars.intentionalModule.Multitasking_Goal_Buffer_Name_List;   //"goal", "goal-2". set in QN parameter event
	      for ( String goal_name : multi_goal_name_list){
	        Production_Rule current_rule_clone_2 = sim.funs.ProgramUtilitiesFun__Production_Rule_Clone( current_rule ) ;
	        current_rule_clone_2.Condition_Part_Goal_X_Reference = goal_name;
	        
	        if (   ProductionModuleFun__Match_A_Rule_Test( current_rule_clone_2  ) == true){//match the current mental state
	          return_rules.addLast(  current_rule_clone_2  );
	        }
	        else{
	          //GlobalUtilities.popUpMessage("false");
	        }
	        
	      }
	    }
	    
	    
	    
	  }
	  if(sim.vars.printingModule.v.equals( "t")) sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("");
	  if(sim.vars.printingModule.v.equals( "t")) sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("--------Match and select rule: Start--------");
	  if(sim.vars.printingModule.v.equals( "t")) {
	    List<String> rule_names = new ArrayList<String> ();
	    for (Production_Rule a_rule : return_rules){
	      rule_names.add(a_rule.Rule_Name );
	    }
	    sim.funs.ProgramUtilitiesFun__Output_Trace_Txt(return_rules.size() + " rule(s) matched: " + sim.funs.ProgramUtilitiesFun__ListString_To_String_Show_Empty( rule_names)); 
	  }
	  return return_rules;
	  
	  
	}
	
	public  void ProductionModuleFun__Modify_Goal_Buffer_2_Request(String[] The_Chunk_Spec_Change){

	  //send entity to module
	  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(), 3) + "\t" + "PROCEDURAL" + "\t" + "MOD-BUFFER-CHUNK GOAL-2");
	  
	  Entity Temp_Entity = sim.funs.createEntity( "Intentional Module" , "Execution", "Intentional Module", "Modify Goal-2", 0.0);
//	  Entity Temp_Entity = new Entity();  
//	  Temp_Entity.ID = "1"; //Intentional Module
//	  Temp_Entity.Time = Clock;
//	  Temp_Entity.Tag = Entity_Number; //give it an entity number, init. 1
//	  Entity_Number++;
//	  Temp_Entity.From = "Execution"; //tag from and to
//	  Temp_Entity.To = "Intentional Module";
//	  Temp_Entity.Entity_Type = "Modify Goal-2";    // =goal-2> action
	  
	  //moved to goal buffer-2, because there may be two =goal-2> and =goal-x> in the same rule action part, they need to change the goal buffer one after another (rather than based on the same old goal buffe chunk)
	  /*
			//get the new buffer chunk after modified
			Chunk temp_chunk = sim.funs.ChunkFun__Chunk_Clone (sim.vars.goalBuffer.Goal_Buffer_Chunk_2);
			//may add if conditions for chunk name and chunk type change, below is only for slot value change
			int j;
			for (j = 0; j < The_Chunk_Spec_Change.Length; j+=2){
				ChunkFun__Set_Chunk_Slot_Value(temp_chunk, The_Chunk_Spec_Change[j], The_Chunk_Spec_Change[j+1]);
			}
			Temp_Entity.Chunk = temp_chunk;

	   */
	  Temp_Entity.The_Chunk_Spec_Change_List = sim.funs.ProgramUtilitiesFun__StringArray_To_LinkedList_String(The_Chunk_Spec_Change);

	  
	  /*
			//old. moved to intentional module
			// parameters: slot_name_1, slot_value_1, slot_name_2, slot_value_2, ... for nil value, put ""

			//may add if conditions for chunk name and chunk type change, below is only for slot value change

			int j;
			for (j = 0; j < The_Chunk_Spec_Change.Length; j+=2){
				ChunkFun__Set_Chunk_Slot_Value(sim.vars.goalBuffer.Goal_Buffer_Chunk_2, The_Chunk_Spec_Change[j], The_Chunk_Spec_Change[j+1]);
			}

			//also modify the chunk in the model chunk list.
			string chunk_name = sim.vars.goalBuffer.Goal_Buffer_Chunk_2.Chunk_Name;
			if (ChunkFun__Is_Chunk_Name(chunk_name) ==false ) GlobalUtilities.popUpMessage("ProductionModuleFun__Modify_Goal_Buffer_2_Request sim.funs.ChunkFun__Is_Chunk_Name(chunk_name) ==false");
			Chunk temp_chunk =  (Chunk) sim.vars.centralParametersModule.Chunks [ chunk_name ] ;
			for (j = 0; j < The_Chunk_Spec_Change.Length; j+=2){
				ChunkFun__Set_Chunk_Slot_Value(temp_chunk, The_Chunk_Spec_Change[j], The_Chunk_Spec_Change[j+1]);
			}
			ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.centralParametersModule.Chunks, chunk_name, temp_chunk  );



			Entity ProductionModuleFun__Modify_Goal_Buffer_Request_Temp_Entity = new Entity();   // send a visualization entity "Buffer Change Notice"
			ProductionModuleFun__Modify_Goal_Buffer_Request_Temp_Entity.ID = "4"; //Goal_Buffer_2
			ProductionModuleFun__Modify_Goal_Buffer_Request_Temp_Entity.Time = Clock;
			ProductionModuleFun__Modify_Goal_Buffer_Request_Temp_Entity.Tag = Entity_Number; //give it an entity number, init. 1
			Entity_Number++;
			ProductionModuleFun__Modify_Goal_Buffer_Request_Temp_Entity.From = "Execution"; //tag from and to
			ProductionModuleFun__Modify_Goal_Buffer_Request_Temp_Entity.To = "Goal Buffer-2";
			ProductionModuleFun__Modify_Goal_Buffer_Request_Temp_Entity.Entity_Type = "Buffer Chunk Spec Change Notice";    
			Model.Start(ProductionModuleFun__Modify_Goal_Buffer_Request_Temp_Entity);

			ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(), 3) + "\t" + "PROCEDURAL" + "\t" + "MOD-BUFFER-CHUNK GOAL-2"); 
	   */
	}
	
	public  void ProductionModuleFun__Modify_Goal_Buffer_Request(String[] The_Chunk_Spec_Change){

	  //send entity to module
	  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(), 3) + "\t" + "PROCEDURAL" + "\t" + "MOD-BUFFER-CHUNK GOAL");
	  
	  Entity Temp_Entity = sim.funs.createEntity( "Intentional Module" , "Execution", "Intentional Module", "Modify Goal", 0.0);
//	  Entity Temp_Entity = new Entity();  
//	  Temp_Entity.ID = "1"; //Intentional Module
//	  Temp_Entity.Time = Clock;
//	  Temp_Entity.Tag = Entity_Number; //give it an entity number, init. 1
//	  Entity_Number++;
//	  Temp_Entity.From = "Execution"; //tag from and to
//	  Temp_Entity.To = "Intentional Module";
//	  Temp_Entity.Entity_Type = "Modify Goal";    // =goal> action
	  
	  //moved to goal buffer, because there may be two =goal> and =goal-x> in the same rule action part, they need to change the goal buffer one after another (rather than based on the same old goal buffe chunk)
	  //get the new buffer chunk after modified
	  /*
			Chunk temp_chunk = sim.funs.ChunkFun__Chunk_Clone (sim.vars.goalBuffer.Goal_Buffer_Chunk);
			//may add if conditions for chunk name and chunk type change, below is only for slot value change
			int j;
			for (j = 0; j < The_Chunk_Spec_Change.Length; j+=2){
				ChunkFun__Set_Chunk_Slot_Value(temp_chunk, The_Chunk_Spec_Change[j], The_Chunk_Spec_Change[j+1]);
			}
			Temp_Entity.Chunk = temp_chunk;
	   */
	  Temp_Entity.The_Chunk_Spec_Change_List = sim.funs.ProgramUtilitiesFun__StringArray_To_LinkedList_String(The_Chunk_Spec_Change);

	  
	  
	  /*
			//old. moved to intentional module
			// parameters: slot_name_1, slot_value_1, slot_name_2, slot_value_2, ... for nil value, put ""


			//may add if conditions for chunk name and chunk type change, below is only for slot value change

			int j;
			for (j = 0; j < The_Chunk_Spec_Change.Length; j+=2){
				ChunkFun__Set_Chunk_Slot_Value(sim.vars.goalBuffer.Goal_Buffer_Chunk, The_Chunk_Spec_Change[j], The_Chunk_Spec_Change[j+1]);
			}

			//also modify the chunk in the model chunk list.
			string chunk_name = sim.vars.goalBuffer.Goal_Buffer_Chunk.Chunk_Name;
			if (ChunkFun__Is_Chunk_Name(chunk_name) ==false ) GlobalUtilities.popUpMessage("ProductionModuleFun__Modify_Goal_Buffer_Request sim.funs.ChunkFun__Is_Chunk_Name(chunk_name) ==false");
			Chunk temp_chunk =  (Chunk) sim.vars.centralParametersModule.Chunks [ chunk_name ] ;
			for (j = 0; j < The_Chunk_Spec_Change.Length; j+=2){
				ChunkFun__Set_Chunk_Slot_Value(temp_chunk, The_Chunk_Spec_Change[j], The_Chunk_Spec_Change[j+1]);
			}
			ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.centralParametersModule.Chunks, chunk_name, temp_chunk  );


			Entity ProductionModuleFun__Modify_Goal_Buffer_Request_Temp_Entity = new Entity();   // send a visualization entity "Buffer Change Notice"
			ProductionModuleFun__Modify_Goal_Buffer_Request_Temp_Entity.ID = "2"; //Goal_Buffer
			ProductionModuleFun__Modify_Goal_Buffer_Request_Temp_Entity.Time = Clock;
			ProductionModuleFun__Modify_Goal_Buffer_Request_Temp_Entity.Tag = Entity_Number; //give it an entity number, init. 1
			Entity_Number++;
			ProductionModuleFun__Modify_Goal_Buffer_Request_Temp_Entity.From = "Execution"; //tag from and to
			ProductionModuleFun__Modify_Goal_Buffer_Request_Temp_Entity.To = "Goal Buffer";
			ProductionModuleFun__Modify_Goal_Buffer_Request_Temp_Entity.Entity_Type = "Buffer Chunk Spec Change Notice";    


			ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(), 3) + "\t" + "PROCEDURAL" + "\t" + "MOD-BUFFER-CHUNK GOAL"); 
	   */
	}
	
	public  void ProductionModuleFun__Modify_Imaginal_Buffer_Request(String[] The_Chunk_Spec_Change){

	  //send entity to module
	  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(), 3) + "\t" + "PROCEDURAL" + "\t" + "MOD-BUFFER-CHUNK IMAGINAL"); 
	  
	  Entity Temp_Entity = sim.funs.createEntity( "Imaginary Module" , "Execution", "Imaginary Module", "Modify Imaginal", 0.0);
//	  Entity Temp_Entity = new Entity();  
//	  Temp_Entity.ID = "8"; //Imaginary Module
//	  Temp_Entity.Time = Clock;
//	  Temp_Entity.Tag = Entity_Number; //give it an entity number, init. 1
//	  Entity_Number++;
//	  Temp_Entity.From = "Execution"; //tag from and to
//	  Temp_Entity.To = "Imaginary Module";
//	  Temp_Entity.Entity_Type = "Modify Imaginal";    // =imaginal> action
	  
	  //moved to imaginal buffer, because there may be two =imaginal> and =imaginal-x> not here yet in the same rule action part, they need to change the goal buffer one after another (rather than based on the same old goal buffe chunk)
	  /*
			//get the new buffer chunk after modified
			Chunk temp_chunk = sim.funs.ChunkFun__Chunk_Clone (sim.vars.imaginalBuffer.Imaginal_Buffer_Chunk);
			//may add if conditions for chunk name and chunk type change, below is only for slot value change
			int j;
			for (j = 0; j < The_Chunk_Spec_Change.Length; j+=2){
				ChunkFun__Set_Chunk_Slot_Value(temp_chunk, The_Chunk_Spec_Change[j], The_Chunk_Spec_Change[j+1]);
			}
			Temp_Entity.Chunk = temp_chunk;
	   */
	  Temp_Entity.The_Chunk_Spec_Change_List = sim.funs.ProgramUtilitiesFun__StringArray_To_LinkedList_String(The_Chunk_Spec_Change);

	  
	  /*
			//old. moved to imaginal module

			// parameters: slot_name_1, slot_value_1, slot_name_2, slot_value_2, ... for nil value, put ""
			//GlobalUtilities.popUpMessage("ProductionModuleFun__Modify_Imaginal_Buffer_Request: " + sim.funs.ProgramUtilitiesFun__StringArray_To_String_Stop_If_Empty(The_Chunk_Spec_Change));
			//may add if conditions for chunk name and chunk type change, below is only for slot value change

			int j;
			for (j = 0; j < The_Chunk_Spec_Change.Length; j+=2){
				ChunkFun__Set_Chunk_Slot_Value(sim.vars.imaginalBuffer.Imaginal_Buffer_Chunk, The_Chunk_Spec_Change[j], The_Chunk_Spec_Change[j+1]);
			}

			//also modify the chunk in the model chunk list.
			string chunk_name = sim.vars.imaginalBuffer.Imaginal_Buffer_Chunk.Chunk_Name;
			if (ChunkFun__Is_Chunk_Name(chunk_name) ==false ) GlobalUtilities.popUpMessage("ProductionModuleFun__Modify_Imaginal_Buffer_Request sim.funs.ChunkFun__Is_Chunk_Name(chunk_name) ==false");
			Chunk temp_chunk =  (Chunk) sim.vars.centralParametersModule.Chunks [ chunk_name ] ;
			for (j = 0; j < The_Chunk_Spec_Change.Length; j+=2){
				ChunkFun__Set_Chunk_Slot_Value(temp_chunk, The_Chunk_Spec_Change[j], The_Chunk_Spec_Change[j+1]);
			}
			ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.centralParametersModule.Chunks, chunk_name, temp_chunk  );



			Entity Temp_Entity = new Entity();   // send a visualization entity "Buffer Change Notice"
			Temp_Entity.ID = "9"; //Imaginal_Buffer
			Temp_Entity.Time = Clock;
			Temp_Entity.Tag = Entity_Number; //give it an entity number, init. 1
			Entity_Number++;
			Temp_Entity.From = "Execution"; //tag from and to
			Temp_Entity.To = "Imaginal Buffer";
			Temp_Entity.Entity_Type = "Buffer Chunk Spec Change Notice";    


			ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(), 3) + "\t" + "PROCEDURAL" + "\t" + "MOD-BUFFER-CHUNK IMAGINAL"); 
	   */
	}
	
	public  void ProductionModuleFun__Modify_Temporal_Buffer_Request(String[] The_Chunk_Spec_Change){

	  //send entity to module
	  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(), 3) + "\t" + "PROCEDURAL" + "\t" + "MOD-BUFFER-CHUNK TEMPORAL"); 
	  
	  Entity Temp_Entity = sim.funs.createEntity( "Temporal Module" , "Execution", "Temporal Module", "Modify Temporal", 0.0);
//	  Entity Temp_Entity = new Entity();  
//	  Temp_Entity.ID = "602"; //Temporal Module
//	  Temp_Entity.Time = Clock;
//	  Temp_Entity.Tag = Entity_Number; //give it an entity number, init. 1
//	  Entity_Number++;
//	  Temp_Entity.From = "Execution"; //tag from and to
//	  Temp_Entity.To = "Temporal Module";
//	  Temp_Entity.Entity_Type = "Modify Temporal";    // =temporal> action
	  
	  Temp_Entity.The_Chunk_Spec_Change_List = sim.funs.ProgramUtilitiesFun__StringArray_To_LinkedList_String(The_Chunk_Spec_Change);

	}
	
	public  void ProductionModuleFun__Modify_Visual_Buffer_Request(String[] The_Chunk_Spec_Change){
	 
	  
	  //copied from modify goal buffer request
	  
	  //may add if conditions for chunk name and chunk type change, below is only for slot value change
	  
	  int j;
	  for (j = 0; j < The_Chunk_Spec_Change.length; j+=2){
	    sim.funs.ChunkFun__Set_Chunk_Slot_Value(sim.vars.visualBuffer.Visual_Buffer_Chunk, The_Chunk_Spec_Change[j], The_Chunk_Spec_Change[j+1]);
	  }
	  
	  //also modify the chunk in the model chunk list.
	  String chunk_name = sim.vars.visualBuffer.Visual_Buffer_Chunk.Chunk_Name;
	  if (ChunkFun__Is_Chunk_Name(chunk_name) ==false ) System.out.println("ProductionModuleFun__Modify_Visual_Buffer_Request sim.funs.ChunkFun__Is_Chunk_Name(chunk_name) ==false");
	  Chunk temp_chunk =  (Chunk) sim.vars.centralParametersModule.Chunks .get( chunk_name ) ;
	  for (j = 0; j < The_Chunk_Spec_Change.length; j+=2){
	    sim.funs.ChunkFun__Set_Chunk_Slot_Value(temp_chunk, The_Chunk_Spec_Change[j], The_Chunk_Spec_Change[j+1]);
	  }
	  sim.funs.ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.centralParametersModule.Chunks, chunk_name, temp_chunk  );
	  
	  Entity ProductionModuleFun__Modify_Visual_Buffer_Request_Temp_Entity = sim.funs.createEntity( "Visual Buffer" , "Execution", "Visual Buffer", "Buffer Chunk Spec Change Notice", 0.0);
//	  Entity ProductionModuleFun__Modify_Visual_Buffer_Request_Temp_Entity = new Entity();   // send a visualization entity "Buffer Change Notice"
//	  ProductionModuleFun__Modify_Visual_Buffer_Request_Temp_Entity.ID = "11"; //Visual_Buffer
//	  ProductionModuleFun__Modify_Visual_Buffer_Request_Temp_Entity.Time = Clock;
//	  ProductionModuleFun__Modify_Visual_Buffer_Request_Temp_Entity.Tag = Entity_Number; //give it an entity number, init. 1
//	  Entity_Number++;
//	  ProductionModuleFun__Modify_Visual_Buffer_Request_Temp_Entity.From = "Execution"; //tag from and to
//	  ProductionModuleFun__Modify_Visual_Buffer_Request_Temp_Entity.To = "Visual Buffer";
//	  ProductionModuleFun__Modify_Visual_Buffer_Request_Temp_Entity.Entity_Type = "Buffer Chunk Spec Change Notice";    

	  
	  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(), 3) + "\t" + "PROCEDURAL" + "\t" + "MOD-BUFFER-CHUNK VISUAL"); 
	  
	}
	
	public  void ProductionModuleFun__Modify_Visual_Location_Buffer_Request(String[] The_Chunk_Spec_Change){

	  for (int j = 0; j < The_Chunk_Spec_Change.length; j+=2){
	    sim.funs.ChunkFun__Set_Chunk_Slot_Value(sim.vars.visualLocationBuffer.Visual_Location_Buffer_Chunk, The_Chunk_Spec_Change[j], The_Chunk_Spec_Change[j+1]);
	  }
	  
	  // also modify the chunk in the model chunk list.
	  String chunk_name = sim.vars.visualLocationBuffer.Visual_Location_Buffer_Chunk.Chunk_Name;
	  if (ChunkFun__Is_Chunk_Name(chunk_name) ==false ) System.out.println("ProductionModuleFun__Modify_Visual_Location_Buffer_Request sim.funs.ChunkFun__Is_Chunk_Name(chunk_name) ==false");
	  Chunk temp_chunk =  (Chunk) sim.vars.centralParametersModule.Chunks.get(chunk_name ) ;
	  for (int j = 0; j < The_Chunk_Spec_Change.length; j+=2){
	    sim.funs.ChunkFun__Set_Chunk_Slot_Value(temp_chunk, The_Chunk_Spec_Change[j], The_Chunk_Spec_Change[j+1]);
	  }
	  sim.funs.ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.centralParametersModule.Chunks, chunk_name, temp_chunk  );
	  
	  Entity ProductionModuleFun__Modify_Visual_Location_Buffer_Request_Temp_Entity = sim.funs.createEntity( "Visual Location Buffer" , "Execution", "Visual Location Buffer", "Buffer Chunk Spec Change Notice", 0.0);
//	  Entity ProductionModuleFun__Modify_Visual_Location_Buffer_Request_Temp_Entity = new Entity();   // send a visualization entity "Buffer Change Notice"
//	  ProductionModuleFun__Modify_Visual_Location_Buffer_Request_Temp_Entity.ID = "12"; //Visual Location Buffer
//	  ProductionModuleFun__Modify_Visual_Location_Buffer_Request_Temp_Entity.Time = Clock;
//	  ProductionModuleFun__Modify_Visual_Location_Buffer_Request_Temp_Entity.Tag = Entity_Number; //give it an entity number, init. 1
//	  Entity_Number++;
//	  ProductionModuleFun__Modify_Visual_Location_Buffer_Request_Temp_Entity.From = "Execution"; //tag from and to
//	  ProductionModuleFun__Modify_Visual_Location_Buffer_Request_Temp_Entity.To = "Visual Location Buffer";
//	  ProductionModuleFun__Modify_Visual_Location_Buffer_Request_Temp_Entity.Entity_Type = "Buffer Chunk Spec Change Notice";    

	  
	  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(), 3) + "\t" + "PROCEDURAL" + "\t" + "MOD-BUFFER-CHUNK VISUAL-LOCATION"); 
	  
	}
	
	public  void ProductionModuleFun__Print_A_Production(Production_Rule the_rule){
	  // all console outputs are added by Yelly -  for ease of debugging
	  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt( "      ");
	  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt( "(Production rule P: " + the_rule.Rule_Name);
		System.out.println( "      ");
		System.out.println( "(Production rule P: " + the_rule.Rule_Name);
	  
	  if(!the_rule.Compilation_Note_For_New_Rule.equals( "" )) {
		  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt( "\"" + the_rule.Compilation_Note_For_New_Rule +  "\"" );
			System.out.println( "\"" + the_rule.Compilation_Note_For_New_Rule +  "\"" );
	  }
	  
	  if (sim.vars.centralParametersModule.Use_Procedural_Resources) {
	    sim.funs.ProgramUtilitiesFun__Output_Trace_Txt( "Compilation father: " + the_rule.Compilation_Father );
	    sim.funs.ProgramUtilitiesFun__Output_Trace_Txt( "Compilation sons: " + sim.funs.ProgramUtilitiesFun__LinkedListString_To_String_Show_Empty(the_rule.Compilation_Sons) );

		System.out.println( "Compilation father: " + the_rule.Compilation_Father );
		System.out.println( "Compilation sons: " + sim.funs.ProgramUtilitiesFun__LinkedListString_To_String_Show_Empty(the_rule.Compilation_Sons) );
	}
	  
	  Enumeration enum_condition_item = Collections.enumeration((the_rule).Condition);
	  while (enum_condition_item.hasMoreElements()){
	    Production_Rule_Condition_Action_Item currentItem = (Production_Rule_Condition_Action_Item)enum_condition_item.nextElement();
	    if( (currentItem.Type).charAt(0) == '!' ) { // !name! special
	      sim.funs.ProgramUtilitiesFun__Output_Trace_Txt( "   " + currentItem.Type + "\t" + currentItem.Buffer_Name);
			System.out.println( "   " + currentItem.Type + "\t" + currentItem.Buffer_Name);
	      //ignore slots
	      continue;
	    } //
	    //else, normal condition
	    
	    sim.funs.ProgramUtilitiesFun__Output_Trace_Txt( "   " + currentItem.Type + currentItem.Buffer_Name + ">");
		System.out.println( "   " + currentItem.Type + currentItem.Buffer_Name + ">");
	    String isa_type = (String)currentItem.Slot.get("isa");
	    if (isa_type != null){
	      sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("      isa	" +  isa_type ); //print isa type first.
			System.out.println("      isa	" +  isa_type );
	    }	
	    
	    
	    Iterator<Entry<String, String>> itrSlot = currentItem.Slot.entrySet().iterator();
	    while(itrSlot.hasNext()){
	      Entry<String, String> currentEntry = itrSlot.next();
	      if(!currentEntry.getKey().equals( "isa" ) ){ //ignore isa type here.
	        sim.funs.ProgramUtilitiesFun__Output_Trace_Txt( "      " + currentEntry.getKey() + "	" + currentEntry.getValue());
			System.out.println("      " + currentEntry.getKey() + "	" + currentEntry.getValue());
	      }
	    }
	  }
	  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt( "   ==>");
	  Enumeration enum_action_item = Collections.enumeration((the_rule).Action);
	  while (enum_action_item.hasMoreElements()){
	    Production_Rule_Condition_Action_Item currentItem = (Production_Rule_Condition_Action_Item)enum_action_item.nextElement();
	    if( currentItem.Type.charAt(0) == '!' ) { // !name! special
	      sim.funs.ProgramUtilitiesFun__Output_Trace_Txt( "   " + currentItem.Type + "\t" + currentItem.Buffer_Name);
			System.out.println( "   " + currentItem.Type + "\t" + currentItem.Buffer_Name);
	      continue;
	    } //
	    //else, normal condition
	    
	    sim.funs.ProgramUtilitiesFun__Output_Trace_Txt( "   " + currentItem.Type + currentItem.Buffer_Name + ">");
		System.out.println("   " + currentItem.Type + currentItem.Buffer_Name + ">");
	    String isa_type = (String)currentItem.Slot.get("isa");
	    if (isa_type != null){
	      sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("      isa	" +  isa_type); //print isa type first.
			System.out.println("      isa	" +  isa_type);
	    }
	    
	    
	    //old without order
	    //IDictionaryEnumerator enum_slot = ((Production_Rule_Condition_Action_Item)enum_action_item.Current).Slot.GetEnumerator();
	    //while(enum_slot.MoveNext()){
	    //	if(!(String)enum_slot.Key.equals( "isa" )){ //ignore isa type here.
	    //		ProgramUtilitiesFun__Output_Trace_Txt( "      " +  (String)enum_slot.Key + "	" + (String)enum_slot.Value);
	    //	}
	    //}
	    
	    //new with order
	    for (String key: currentItem.Slot_Names_In_Order ){
	      String value = (String)currentItem.Slot.get(key);
	      if( !key.equals( "isa") ){ //ignore isa type here.
	        sim.funs.ProgramUtilitiesFun__Output_Trace_Txt( "      " +  key + "	" + value);
			System.out.println("      " +  key + "	" + value);
	      }
	    }
	    
	  }
	  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt( ")");
		System.out.println( ")");
	  if (sim.vars.centralParametersModule.Use_Procedural_Resources) {
	    sim.funs.ProgramUtilitiesFun__Output_Trace_Txt( "Actions: " +    the_rule.Num_Low_Level_Requests);
		System.out.println("Actions: " +    the_rule.Num_Low_Level_Requests);
	    String each_action = "    ";
	    if( the_rule.Num_Aural_Action > 0 ) each_action +=  ", aural: " + the_rule.Num_Aural_Action;
	    if( the_rule.Num_Aural_Location_Action > 0 ) each_action +=  ", aural-location: " + the_rule.Num_Aural_Location_Action;
	    if( the_rule.Num_Goal_Action > 0 ) each_action +=  ", goal: " + the_rule.Num_Goal_Action;
	    if( the_rule.Num_Imaginal_Action > 0 ) each_action +=  ", imaginal: " + the_rule.Num_Imaginal_Action;
	    if( the_rule.Num_Manual_Action > 0 ) each_action +=  ", manual: " + the_rule.Num_Manual_Action;
	    if( the_rule.Num_Retrieval_Action > 0 ) each_action +=  ", retrieval: " + the_rule.Num_Retrieval_Action;
	    if( the_rule.Num_Visual_Action > 0 ) each_action +=  ", visual: " + the_rule.Num_Visual_Action;
	    if( the_rule.Num_Visual_Location_Action > 0 ) each_action +=  ", visual-location: " + the_rule.Num_Visual_Location_Action;
	    if( the_rule.Num_Vocal_Action > 0 ) each_action +=  ", vocal: " + the_rule.Num_Vocal_Action;
	    sim.funs.ProgramUtilitiesFun__Output_Trace_Txt( each_action );
		System.out.println(each_action);
	  }
	  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt( the_rule.Condition_Part_Goal_X_Reference ) ;
		System.out.println(the_rule.Condition_Part_Goal_X_Reference);
	  UtilityModuleFun__Print_Utility_For_A_Rule(the_rule.Rule_Name);
	  sim.funs.ProgramUtilitiesFun__Output_Trace_Txt( " " );
		System.out.println( " " );
	}
	
	public  void ProductionModuleFun__Print_All_Productions(){
	  
	  Enumeration enum_rule = Collections.enumeration(sim.vars.productionModule.Production_Rules);
	  while(enum_rule.hasMoreElements()){
	    ProductionModuleFun__Print_A_Production ( (Production_Rule)enum_rule.nextElement() );
	  }
	  
	  
	  /* //descriptor version
			int i =0;
			Parameterized_Production_Rule_Node a_node =  Parameterized_Production_Rule_Pool;
			while(a_node!=null){
			 	i++;
				ProgramUtilitiesFun__Output_Trace_Txt( sim.funs.ProgramUtilitiesFun__StringArray_To_String_Stop_If_Empty(a_node.Rule_Descriptors ));
				
				ProgramUtilitiesFun__Output_Trace_Txt("\t\t, U_N_Without_Noise: " + (String)sim.vars.utilityModule.U_N_Without_Noise[ a_node.Rule_Descriptors[1]] );
				a_node = a_node.Next_Rule;
			}

			ProgramUtilitiesFun__Output_Trace_Txt("\tTotal rules: "+ i );
	   */
	}
	
	public  void ProductionModuleFun__Print_SelectRule_Traces(Production_Rule the_rule){
	  
	  // clock?
	  
	  String the_rule_name = the_rule.Rule_Name;
	  if( the_rule_name.equals( "nil")){ //no rule selected (may be no match or no utility higher than the utility threshold.)
	    //output nothing
	    return;
	  }
	  else{ // there is a rule selected
	    sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(), 3) + "\t" + "PROCEDURAL" + "\t" + "PRODUCTION-SELECTED " + the_rule_name);
	    Enumeration enum_condition_item = Collections.enumeration(the_rule.Condition);
	    while(enum_condition_item.hasMoreElements()){
	      Production_Rule_Condition_Action_Item currentItem = (Production_Rule_Condition_Action_Item)enum_condition_item.nextElement();
	      String buffer_test_method = currentItem.Type + currentItem.Buffer_Name + ">" ;
	      switch (buffer_test_method){
	        case "=goal>":
	        {
	          sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(), 3) + "\t" + "PROCEDURAL" + "\t" + "BUFFER-READ-ACTION GOAL");
	          break;
	        }
	        case "=goal-2>":
	        {
	          sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(), 3) + "\t" + "PROCEDURAL" + "\t" + "BUFFER-READ-ACTION GOAL-2");
	          break;
	        }
	        case "=goal-x>":
	        {
	          sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(), 3) + "\t" + "PROCEDURAL" + "\t" + "BUFFER-READ-ACTION GOAL-X refers to " + the_rule.Condition_Part_Goal_X_Reference);
	          break;
	        }
	        case "=retrieval>":
	        {
	          sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(), 3) + "\t" + "PROCEDURAL" + "\t" + "BUFFER-READ-ACTION RETRIEVAL"); 
	          break;
	        }
	        case "=aural-location>":
	        {
	          sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(), 3) + "\t" + "PROCEDURAL" + "\t" + "BUFFER-READ-ACTION AURAL-LOCATION");
	          break;
	        }
	        case "=aural>":
	        {
	          sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(), 3) + "\t" + "PROCEDURAL" + "\t" + "BUFFER-READ-ACTION AURAL");
	          break;
	        }
	        case "=visual-location>":
	        {
	          sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(), 3) + "\t" + "PROCEDURAL" + "\t" + "BUFFER-READ-ACTION VISUAL-LOCATION");
	          break;
	        }
	        
	        case "=visual>":
	        {
	          sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(), 3) + "\t" + "PROCEDURAL" + "\t" + "BUFFER-READ-ACTION VISUAL");
	          break;
	        }
	        
	        case "=imaginal>":
	        {
	          sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(), 3) + "\t" + "PROCEDURAL" + "\t" + "BUFFER-READ-ACTION IMAGINAL");
	          break;
	        }
	        
	        case "=temporal>":
	        {
	          sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(), 3) + "\t" + "PROCEDURAL" + "\t" + "BUFFER-READ-ACTION TEMPORAL");
	          break;
	        }
	        
	        case "?aural>":
	        {
	          sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(), 3) + "\t" + "PROCEDURAL" + "\t" + "QUERY-BUFFER-ACTION AURAL");
	          break;
	        }
	        case "?aural-location>":
	        {
	          sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(), 3) + "\t" + "PROCEDURAL" + "\t" + "QUERY-BUFFER-ACTION AURAL-LOCATION");
	          break;
	        }
	        case "?imaginal>":
	        {
	          sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(), 3) + "\t" + "PROCEDURAL" + "\t" + "QUERY-BUFFER-ACTION IMAGINAL");
	          break;
	        }
	        case "?visual>":
	        {
	          sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(), 3) + "\t" + "PROCEDURAL" + "\t" + "QUERY-BUFFER-ACTION VISUAL");
	          break;
	        }
	        case "?visual-location>":
	        {
	          sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(), 3) + "\t" + "PROCEDURAL" + "\t" + "QUERY-BUFFER-ACTION VISUAL-LOCATION");
	          break;
	        }
	        case "?retrieval>":
	        {
	          sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(), 3) + "\t" + "PROCEDURAL" + "\t" + "QUERY-BUFFER-ACTION RETRIEVAL");
	          break;
	        }
	        
	        case "?manual>":
	        {
	          sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(), 3) + "\t" + "PROCEDURAL" + "\t" + "QUERY-BUFFER-ACTION MANUAL");			
	          break;
	        }
	        case "?vocal>":
	        {
	          sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(), 3) + "\t" + "PROCEDURAL" + "\t" + "QUERY-BUFFER-ACTION VOCAL");
	          break;
	        }
	        case "?temporal>":
	        {
	          sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(), 3) + "\t" + "PROCEDURAL" + "\t" + "QUERY-BUFFER-ACTION TEMPORAL");
	          break;
	        }
	        
	        default:
	        {
	          String condition_test_type = currentItem.Type ;
	          String condition_test_contents = currentItem.Buffer_Name;
	          if( condition_test_type.equals( "!eval!") ){ 
	            //ACTR-QN here !eval! condition test could be any place in the condition part. its order in the condition part may affect its result.
	            String eval_result = (String) currentItem.Slot.get( "eval_result" ) ;
	            sim.funs.ProgramUtilitiesFun__Output_Trace_Txt(condition_test_type + "   " + condition_test_contents + "   : " +  eval_result);
	            
	            /*
								//obsolete method
								//substitute any variable in the content with variable bindings in the condition part.
								String condition_test_contents_subst =  sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty ( sim.funs.ProgramUtilitiesFun__Subst_String_Array ( sim.funs.ProgramUtilitiesFun__String_To_StringArray( condition_test_contents ) , ProductionModuleFun__Bind_Variables_In_Rule_Condition (the_rule) ) ) ;
								ProgramUtilitiesFun__Output_Trace_Txt(condition_test_type + "   " + condition_test_contents + "   : " + LispFun__Evaluate_A_List ( condition_test_contents_subst ) );
	             */
	          }
	          else if( condition_test_type.equals( "!bind!") ){ 
	            String bind_result = (String) currentItem.Slot.get( "bind_result" ) ;
	            sim.funs.ProgramUtilitiesFun__Output_Trace_Txt(condition_test_type + " (CONDITION)  " + condition_test_contents + "   : " +  bind_result);
	          }
	          else System.out.println ("ProductionModuleFun__Print_SelectRule_Traces undefined condition test method: " + buffer_test_method);
	          break;
	        }
	      }
	    }
	  }
	}
	
	public Production_Rule ProductionModuleFun__Select_Rule(LinkedList<Production_Rule> matched_rules){
	  
	  // Model.RandomInteger?
	  
	  Production_Rule the_selected_rule = new Production_Rule();
	  int number_of_matched_rules = matched_rules.size();
	  
	  Hashtable utility_offset_table = new Hashtable (); //store utility offsets from thread priority
	  
	  
	  if (number_of_matched_rules == 0){  // no match
	    the_selected_rule.Rule_Name = "nil";
	  }
	  else if (number_of_matched_rules == 1){ //single match
	    Enumeration enum_rules = Collections.enumeration(matched_rules);
	    enum_rules.hasMoreElements();
	    Production_Rule a_matched_rule = (Production_Rule)enum_rules.nextElement();
	    if (sim.vars.centralParametersModule.esc == true){
	      UtilityModuleFun__Utility_Update ( a_matched_rule.Rule_Name );		
	      if (sim.vars.utilityModule.ut.equals( "nil")){ // no minimum utility to select a rule
	        the_selected_rule = a_matched_rule;
	        UtilityModuleFun__Add_Selected_Rule_Since_Last_Reward (the_selected_rule.Rule_Name);  
	      }
	      else{// there is a minimum utility to select a rule
	        System.out.println("ProductionModuleFun__Select_Rule, ToDo: need work on sim.vars.utilityModule.ut != nil ");
	      }
	    }
	    else{ // ToDo: I suppose here ACT-R just randomly picks a rule. Since there is only one rule, just pick it.
	      the_selected_rule = a_matched_rule;
	      //no utility calculation or update
	    }	
	  }
	  else{ //multiple matches
	    //update utility with noise
	    Enumeration enum_rules = Collections.enumeration(matched_rules);
	    while(	enum_rules.hasMoreElements()){
	      Production_Rule a_matched_rule = (Production_Rule)enum_rules.nextElement();
	      UtilityModuleFun__Utility_Update( a_matched_rule.Rule_Name ); //get new randomized utility for each matched rule , works for both :esc true and false
	      //Two_Tuple utility_offset_tuple = MultitaskingFun__Compute_Goal_Thread_Utility_Offset (  a_matched_rule.Rule_Name , matched_rules);
	      //String utility_offset_string = (String) utility_offset_tuple.Ob1;
	      String utility_offset_string ; //for multi-tasking
	      if (sim.vars.intentionalModule.Multitasking_Schedule_Method.equals( "" )) { //single task
	        utility_offset_string = "0.0";
	      }
	      else{
	        utility_offset_string = MultitaskingFun__Compute_Goal_Thread_Utility_Offset (  a_matched_rule , matched_rules);
	      }
	      if(sim.vars.printingModule.v.equals( "t")) {
	        //for =goal-x 
	        String for_goal_x = "";
	        if (  !a_matched_rule.Condition_Part_Goal_X_Reference.equals( "" )) for_goal_x = "(goal-x is " + a_matched_rule.Condition_Part_Goal_X_Reference + ")";
	        
	        //output trace
	        String U_without_noise;
	        if ( sim.vars.utilityModule.U_N_Without_Noise.containsKey(a_matched_rule.Rule_Name ) ) U_without_noise = ":    U without noise: " + (String) sim.vars.utilityModule.U_N_Without_Noise.get( a_matched_rule.Rule_Name );
	        else U_without_noise = ":    U without noise: " + "0.0 (default)";
	        String threaded_multitasking_part = "";
	        if (! sim.vars.intentionalModule.Multitasking_Schedule_Method.equals( "" )) threaded_multitasking_part = ", goal thread utility offset: " + utility_offset_string;
	        sim.funs.ProgramUtilitiesFun__Output_Trace_Txt(  "  "+ a_matched_rule.Rule_Name + for_goal_x + U_without_noise + ",    utility: " + (String) sim.vars.utilityModule.utility .get( a_matched_rule.Rule_Name )  + threaded_multitasking_part)  ; 
	      }
	      if (utility_offset_string.equals( "nil")) utility_offset_string = "0.0"; //ToDo: may need to changed this
	      utility_offset_table.put( (a_matched_rule.Rule_Name + a_matched_rule.Condition_Part_Goal_X_Reference) , utility_offset_string );
	      //here utility_offset_table name key add + a_matched_rule.Condition_Part_Goal_X_Reference so that if a rule with =goal-x is instantiated into two rule one with =goal one with =goal-2, this still works
	    }
	    
	    //find the rule with the highest utility with noise
	    enum_rules = Collections.enumeration(matched_rules);
	    //enum_rules.MoveNext();
	    
	    Production_Rule the_highest_utility_rule = (Production_Rule)matched_rules.getFirst(); //initalize with the first rule
	    LinkedList<Production_Rule> tie_rule_list = new LinkedList<Production_Rule>(); // for tie check
	    tie_rule_list.addLast(the_highest_utility_rule);
	    while(	enum_rules.hasMoreElements()){
	      Production_Rule current_rule = (Production_Rule)enum_rules.nextElement();
	      String current_rule_name_with_goal_x_reference =  (current_rule.Rule_Name + current_rule.Condition_Part_Goal_X_Reference);
	      String the_highest_utility_rule_name_with_goal_x_reference = (the_highest_utility_rule.Rule_Name  + the_highest_utility_rule.Condition_Part_Goal_X_Reference);
	      
	      if ( utility_offset_table.containsKey (current_rule_name_with_goal_x_reference) == false)System.out.println("ProductionModuleFun__Select_Rule  has utility_offset_table.ContainsKey (current_rule_name_with_goal_x_reference) == false");
	      if ( utility_offset_table.containsKey (the_highest_utility_rule_name_with_goal_x_reference) == false){
	        System.out.println("ProductionModuleFun__Select_Rule  has utility_offset_table.ContainsKey (the_highest_utility_rule_name_with_goal_x_reference) == false");
	        System.out.println(the_highest_utility_rule_name_with_goal_x_reference);
	        System.out.println ("key: " +  sim.funs.ProgramUtilitiesFun__StringArray_To_String_Stop_If_Empty(sim.funs.ProgramUtilitiesFun__Hashtable_To_Array_String(utility_offset_table, "key")) + ". value: " + sim.funs.ProgramUtilitiesFun__StringArray_To_String_Stop_If_Empty(sim.funs.ProgramUtilitiesFun__Hashtable_To_Array_String(utility_offset_table, "value")));
	      }
	      double current_rule_thread_offset =  Double.parseDouble( (String)utility_offset_table.get( current_rule_name_with_goal_x_reference ) );
	      double the_highest_utility_rule_thread_offset =  Double.parseDouble( (String) utility_offset_table.get(the_highest_utility_rule_name_with_goal_x_reference) );
	      
	      double current_rule_utility_with_thread_offset =  Double.parseDouble ( (String) sim.vars.utilityModule.utility.get(  current_rule.Rule_Name) ) + current_rule_thread_offset ;
	      double the_highest_utility_rule_utility_with_thread_offset =  Double.parseDouble ( (String) sim.vars.utilityModule.utility.get(  the_highest_utility_rule.Rule_Name) ) + the_highest_utility_rule_thread_offset ;
	      
	      if ( current_rule_utility_with_thread_offset   >=   the_highest_utility_rule_utility_with_thread_offset){  //Given adding production rules uses addLast, >= instead of > will make the later added rule get selected if multiple rules have the same utility (same to ACT-R)
	        //if ( Double.valueOf ( (String) sim.vars.utilityModule.utility[  current_rule.Rule_Name] )   >=   Double.valueOf ( (String)sim.vars.utilityModule.utility[ the_highest_utility_rule.Rule_Name ] )){  //Given adding production rules uses addLast, >= instead of > will make the later added rule get selected if multiple rules have the same utility (same to ACT-R)
	        //track if there is a tie of highest utilty rules		
	        if ( current_rule_utility_with_thread_offset   >  the_highest_utility_rule_utility_with_thread_offset){
	          //if ( Double.valueOf ( (String) sim.vars.utilityModule.utility[  current_rule.Rule_Name] )   >   Double.valueOf ( (String)sim.vars.utilityModule.utility[ the_highest_utility_rule.Rule_Name ] )){
	          // > case, renew the tie list
	          tie_rule_list.clear();
	          tie_rule_list.addLast( current_rule );
	        }
	        else{ //= equal case, increas the tie list
	          tie_rule_list.addLast( current_rule );					
	        }
	        the_highest_utility_rule = current_rule; //for the highest when :er is nil (not random, but pick the latest added rule)
	      }
	    }
	    //if there are more than 1 rule in the tie group and :er == true, need to randomize the highest rule. Since do not Common Random Number this with ACT-R, just use MicroSaint random 
	    if(tie_rule_list.size() > 1 && sim.vars.centralParametersModule.er == true){
	      int rand = GlobalUtilities.randomInteger(0, tie_rule_list.size() - 1 );
	      Enumeration Enum = Collections.enumeration(tie_rule_list);
	      int i = 0;
	      while(Enum.hasMoreElements()){
	        if (rand == i ) {
	          the_highest_utility_rule = (Production_Rule)Enum.nextElement();
	          break;
	        }
	        i++;
	      }
	    }
	    
	    //after getting the highest utility rule
	    if (sim.vars.utilityModule.ut.equals( "nil")){ // no minimum utility to select a rule
	      the_selected_rule = the_highest_utility_rule;
	      UtilityModuleFun__Add_Selected_Rule_Since_Last_Reward (the_selected_rule.Rule_Name);  
	    }
	    else{// there is a minimum utility to select a rule
	      System.out.println("ProductionModuleFun__Select_Rule, need work on sim.vars.utilityModule.ut != nil ");
	    }
	  }
	  String for_goal_x_2 = "";
	  if (  !the_selected_rule.Condition_Part_Goal_X_Reference.equals( "")) for_goal_x_2 = "(goal-x is " + the_selected_rule.Condition_Part_Goal_X_Reference + ")";
	  
	  if (!sim.vars.printingModule.v.equals( "t") && the_selected_rule.Rule_Name.equals( "nil" ))  { //common part for all sim.vars.utilityModule.utility_Computation_Method
	    String utility_part;
	    if(sim.vars.utilityModule.utility.containsKey( the_selected_rule.Rule_Name ) ) utility_part = (String) sim.vars.utilityModule.utility.get(the_selected_rule.Rule_Name);
	    else utility_part = "0.0 (default)";
	    String threaded_multitask_part = "";
	    if ( !sim.vars.intentionalModule.Multitasking_Schedule_Method.equals( "" ) ) threaded_multitask_part = " + thread order offset: " + (String) utility_offset_table.get(the_selected_rule.Rule_Name  + the_selected_rule.Condition_Part_Goal_X_Reference) ;
	    
	    //output trace
	    String U_without_noise;
	    if ( sim.vars.utilityModule.U_N_Without_Noise.containsKey(the_selected_rule.Rule_Name ) ) U_without_noise = ":    U without noise: " + (String) sim.vars.utilityModule.U_N_Without_Noise.get( the_selected_rule.Rule_Name );
	    else U_without_noise = ":    U without noise: " + "0.0 (default)";
	    
	    sim.funs.ProgramUtilitiesFun__Output_Trace_Txt( the_selected_rule.Rule_Name + for_goal_x_2 + " is selected " + U_without_noise + ", and utility_with_noise: " + utility_part + threaded_multitask_part);
	  }
	  if (sim.vars.printingModule.v.equals( "t") && !the_selected_rule.Rule_Name.equals( "nil" ) && sim.vars.utilityModule.utility_Computation_Method.equals( "PG-C" )){
	    String rule_name = the_selected_rule.Rule_Name;
	    sim.funs.ProgramUtilitiesFun__Output_Trace_Txt(" :Effort	(rule firing time):	" + sim.vars.utilityModule.PG_C_effort_rule_firing_time.get(rule_name));
	    sim.funs.ProgramUtilitiesFun__Output_Trace_Txt(" :P	(probability to success):	" +  sim.vars.utilityModule.PG_C_p.get(rule_name));
	    sim.funs.ProgramUtilitiesFun__Output_Trace_Txt(" :C	(cost):	" + sim.vars.utilityModule.PG_C_c.get(rule_name));
	    sim.funs.ProgramUtilitiesFun__Output_Trace_Txt(" :PG-C	:	" + sim.vars.utilityModule.pg_c.get(rule_name));
	    sim.funs.ProgramUtilitiesFun__Output_Trace_Txt(" :success	flag?:	" + sim.vars.utilityModule.PG_C_success_flags.containsKey(rule_name) );
	    sim.funs.ProgramUtilitiesFun__Output_Trace_Txt(" :failure	flag?:	" + sim.vars.utilityModule.PG_C_failure_flags.containsKey(rule_name) );
	    sim.funs.ProgramUtilitiesFun__Output_Trace_Txt(" :successes	(times of leading to a success-flaged rule):	" + sim.vars.utilityModule.PG_C_successes_num_for_each_rule.get(rule_name));
	    sim.funs.ProgramUtilitiesFun__Output_Trace_Txt(" :failures	(times of leading to a failure-flaged rule):	" + sim.vars.utilityModule.PG_C_failures_num_for_each_rule.get(rule_name));
	    sim.funs.ProgramUtilitiesFun__Output_Trace_Txt(" :efforts	(for cost calculation):	" + sim.vars.utilityModule.PG_C_efforts_for_cost_calculation.get(rule_name));
	  }
	  
	  if(sim.vars.printingModule.v.equals( "t")) sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("________Match and select rule: End________");
	  if(sim.vars.printingModule.v.equals( "t")) sim.funs.ProgramUtilitiesFun__Output_Trace_Txt("");
	  ProductionModuleFun__Print_SelectRule_Traces(the_selected_rule);
	  return the_selected_rule;
	}
	
	public  void ProductionModuleFun__Strict_Harvest(LinkedList<String> the_strict_harvest_list){
	  
	  Enumeration enum_list = Collections.enumeration(the_strict_harvest_list);
	  while(enum_list.hasMoreElements()){
	    String buffer_name = (String) enum_list.nextElement(); //e.g., "goal", "goal-2"
	    switch (buffer_name)
	    {
	      case "goal":
	      {
	        if (sim.vars.productionModule.Do_Not_Harvest_Goal_Buffer == false) ProductionModuleFun__Clear_Goal_Buffer_Request();
	        break;
	      }
	      case "goal-2":
	      {
	        if (sim.vars.productionModule.Do_Not_Harvest_Goal_Buffer_2 == false) ProductionModuleFun__Clear_Goal_Buffer_2_Request();
	        break;
	      }
	      case "retrieval":
	      {
	        if (sim.vars.productionModule.Do_Not_Harvest_Retrieval_Buffer == false) ProductionModuleFun__Clear_Retrieval_Buffer_Request();
	        break;
	      }
	      case "imaginal":
	      {
	        if (sim.vars.productionModule.Do_Not_Harvest_Imaginal_Buffer == false) ProductionModuleFun__Clear_Imaginal_Buffer_Request();
	        break;
	      }
	      case "visual":
	      {
	        if (sim.vars.productionModule.Do_Not_Harvest_Visual_Buffer == false) ProductionModuleFun__Clear_Visual_Buffer_Request();
	        break;
	      }
	      case "visual-location":
	      {
	        if (sim.vars.productionModule.Do_Not_Harvest_Visual_Location_Buffer == false) ProductionModuleFun__Clear_Visual_Location_Buffer_Request();
	        break;
	      }
	      case "aural":
	      {
	        if (sim.vars.productionModule.Do_Not_Harvest_Aural_Buffer == false) ProductionModuleFun__Clear_Aural_Buffer_Request();
	        break;
	      }
	      case "aural-location":
	      {
	        if (sim.vars.productionModule.Do_Not_Harvest_Aural_Location_Buffer == false) ProductionModuleFun__Clear_Aural_Location_Buffer_Request();
	        break;
	      }
	      case "manual":
	      {
	        if (sim.vars.productionModule.Do_Not_Harvest_Manual_Buffer == false) ProductionModuleFun__Clear_Manual_Buffer_Request();
	        break;
	      }
	      
	      case "temporal":
	      {
	        if (sim.vars.productionModule.Do_Not_Harvest_Temporal_Buffer == false) ProductionModuleFun__Clear_Temporal_Buffer_Request();
	        break;
	      }
	      /*
					case "vocal":
					{
						//	if (sim.vars.productionModule.Do_Not_Harvest_Vocal_Buffer == false) Clear_Vocal_Buffer_Request();
						break;
					}
	       */
	      default:
	      {
	        System.out.println("ProductionModuleFun__Strict_Harvest has undifined case: " + buffer_name);
	        break;
	      }
	    }
	  }
	}
	
	//ProgramUtilitiesFun
	
	public void ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(Hashtable the_hashtable, Object the_key, Object the_value){
	  
	  if(the_hashtable.containsKey(the_key)){
	    the_hashtable.remove(the_key);
	  }
	  the_hashtable.put(the_key, the_value);
	}
	
	public  double ProgramUtilitiesFun__Act_R_Random_Double(double limit){
	  
	  // get a random in [0,1]
	  Three_Tuple rand_tuple = sim.funs.ProgramUtilitiesFun__Combined_Linear_Congruential_Generators( (int) sim.vars.programGlobalVar__Rand2_Seed1, (int) sim.vars.programGlobalVar__Rand2_Seed2);
	  double rand = (double) rand_tuple.Ob1;
	  sim.vars.programGlobalVar__Rand2_Seed1 = (int) rand_tuple.Ob2;
	  sim.vars.programGlobalVar__Rand2_Seed2 = (int) rand_tuple.Ob3;
	  
	  // return random number less than limit
	  return (double) (limit * rand);
	}
	
	public  double ProgramUtilitiesFun__Mod(double the_num1, double the_num2){
	  
	  
	  double devide_integer = (double) Math.floor( (double) the_num1  / (double)the_num2 );
	  the_num1 -= devide_integer * the_num2;
	  
	  //System.out.println(the_num1   );
	  
	  return the_num1;
	  
	  
	  
	}
	
	public String[] ProgramUtilitiesFun__String_To_StringArray(String input_string){
	  
	  input_string = input_string + " ";
	  int head = 0;
	  int tail = 0;
	  String[] temp_string_array = new String[ input_string.length() ];
	  int number_of_return_string = 0;
	  while (head < input_string.length() && tail < input_string.length() ){
	    
//	    System.out.println("ProgramUtilitiesFun__String_To_StringArray: input_string: " + input_string);
	    
	    while ( (input_string.charAt(tail) != '\n') && (input_string.charAt(tail) != '\t') && (input_string.charAt(tail) != ' ') && tail < input_string.length()){
	      
//	      System.out.println("ProgramUtilitiesFun__String_To_StringArray: tail: " + input_string.charAt(tail));
	      
	      tail ++;
	    }
	    if (head != tail) {
	      
//	      System.out.println("ProgramUtilitiesFun__String_To_StringArray: head: " + head + ", tail: " + tail);
	      
	      temp_string_array[number_of_return_string] = input_string.substring(head, tail );
	      number_of_return_string ++;
	    }
	    head = tail + 1;
	    while ( head < input_string.length() && (input_string.charAt(head) == '\n' || input_string.charAt(head) == '\t' || input_string.charAt(head) == ' ') ){
	      head ++;
	    }
	    tail = head;
	  }
	  
	  String[] return_string_array = new String[ number_of_return_string];
	  int i = 0;
	  
	  //System.out.println("number_of_return_string: " + number_of_return_string);
	  
	  while ( i < number_of_return_string){
	    return_string_array[i] = temp_string_array[i];
	    i++;
	  }	
	  return return_string_array;
	}
	
	public  String ProgramUtilitiesFun__String_Parser_Escape_Sequence(String input_string){
	  
	  String the_text = "";
	  
	  String temp_string_text = input_string;
	  the_text = "";
	  boolean back_slash = false;
	  for(int q=0; q<temp_string_text.length();q++){
	    char a_char=temp_string_text.charAt(q);
	    if(back_slash == false && a_char != '\\' ){
	      the_text += a_char;
	    }
	    else if (back_slash == false && a_char == '\\' ){
	      back_slash = true;
	    }
	    else if (back_slash == true){
	      if( a_char == 'n' ){
	        the_text += "\n";
	      }
	      else{
	        System.err.println("Error! sim.funs.ProgramUtilitiesFun__String_Parser_Escape_Sequence has undefined escape sequence in: " + temp_string_text);	
	      }
	      back_slash = false;
	    }
	    
	  }
	  
	  return the_text;
	}
	
	public  double ProgramUtilitiesFun__Distance_Between_Two_Points(int from_x, int from_y, int to_x, int to_y){
	  
	  return (double) Math.sqrt(  Math.pow( (to_x - from_x), 2) +  Math.pow( (to_y - from_y), 2)     );
	}
	
	public  Two_Tuple ProgramUtilitiesFun__Make_Two_Tuple(Object ob1, Object ob2){
	  
	  Two_Tuple temp_tuple = new Two_Tuple();
	  temp_tuple.Ob1 = ob1;
	  temp_tuple.Ob2 = ob2;
	  return temp_tuple;
	}
	
	public  double ProgramUtilitiesFun__Approach_Width(int target_width_in_pixel, int target_height_in_pixel, double approaching_angle_in_radian){
	  
	  if(target_width_in_pixel <= 0 ||  target_height_in_pixel <= 0) return sim.vars.motorModule.Default_Target_Width ; // which is in degree of visual angle
	  
	  double critical_theta = Math.atan2( target_height_in_pixel, target_width_in_pixel ); //since both height and width are positive integers, 0 <= critical_theta <= pi/2 
	  
	  //however, approaching_angle_in_radian computed from Math.Atan (same as Lisp atan) return a  -pi < radian <= pi,
	  //because it covers both e.g., the vector from (0,0) to (1,1), which has an angle of pi/4 and the reversed vector from (1,1) to (0,0), which has an angle of - 3/4 * pi
	  
	  //in order to simplify the computation,
	  //first, convert approaching_angle_in_radian to one within [-pi/2 , pi/2], by + pi or - pi, which will not change its tan value.
	  //since the return cutting widthes for a vector and its reversed vector are the same, this convertion will not change the returned value.
	  if( approaching_angle_in_radian > Math.PI/2 ) approaching_angle_in_radian -= Math.PI;
	  if( approaching_angle_in_radian < -Math.PI/2 ) approaching_angle_in_radian += Math.PI;
	  
	  //second, convert approaching_angle_in_radian to one within [0, pi/2], by taking the absolute value.
	  //this convertion will change all the negative tan value to positive;
	  //however, it will not change the return cutting width, because the target rectangle is symmetrical along both the vertical and horizontal lines across the target center.
	  approaching_angle_in_radian = Math.abs( approaching_angle_in_radian );
	  
	  double return_width_in_pixel;
	  //now need to compare approaching_angle_in_radian with the critical_theta, and determine the return_width_in_pixel
	  if ( approaching_angle_in_radian >= 0 && approaching_angle_in_radian <= critical_theta ){ //NOTE: it is a closed interval covers both 0 and critical_theta
	    return_width_in_pixel =  target_width_in_pixel / Math.cos ( approaching_angle_in_radian ) ;
	  }
	  else if ( approaching_angle_in_radian >= critical_theta && approaching_angle_in_radian <= Math.PI/2 ) { //NOTE: its is a closed interval covers both critical_theta and pi/2, though =critical_theta will be returned in the previous if condition
	    return_width_in_pixel = target_height_in_pixel / Math.sin ( approaching_angle_in_radian ) ;
	  }
	  else {
	    System.err.println ("Error! sim.funs.ProgramUtilitiesFun__Approach_Width has uncovered approaching_angle_in_radian value: " + approaching_angle_in_radian );
	    return -999;
	  }
	  
	  //System.out.println("ProgramUtilitiesFun__Approach_Width has return_width_in_pixel: " + return_width_in_pixel);
	  
	  //at last, convert pixel into visual angle in degree
	  
	  //alternative, may be more reasonable but different with ACT-R
	  return DeviceModuleFun__Double_Pixels_To_Visual_Angle ( (double) return_width_in_pixel );  //ACT-R version
	  
	  //return DeviceModuleFun__Obsolete_Int_Pixels_To_Visual_Angle ( (int)GlobalUtilities.round( return_width_in_pixel, 0) );  //Int alternative version
	  //NOTE: round here is 4 down, 6 up, 5 round to even.
	  //NOTE: ACT-R's pm-pixcels-to-angle can take dould input like 10.28, but here pixel is considered integers only.
	}
	
	public  Three_Tuple ProgramUtilitiesFun__Combined_Linear_Congruential_Generators(int the_x1_j, int the_x2_j){
	  
	  //"	Pseudo random number between (0,1), 	Example BCNN 7.5 (following L'Ecuyer, 1988) p258
	  
	  int M1=2147483563;
	  int M2=2147483399;
	  int A1=40014;
	  int A2=40692;
	  int C1 = 0;
	  int C2 = 0;
	  double rand = -1.0;
	  
	  int X1j_next  = (int) sim.funs.ProgramUtilitiesFun__Mod (( (double) A1 * (double)the_x1_j + (double)C1), (double) M1  ); //use double because int 32-bit not enough
	  //System.out.println("X1j_next: " + X1j_next);
	  
	  int X2j_next = (int) sim.funs.ProgramUtilitiesFun__Mod  ( ( (double)A2 * (double)the_x2_j  + (double)C2),  (double)M2) ;
	  //System.out.println("X2j_next: " + X2j_next);
	  
	  int Xj_next = (int) sim.funs.ProgramUtilitiesFun__Mod( ( (double)X1j_next - (double)X2j_next  ) , (double) (M1-1) )   ; 
	  //System.out.println("Xj_next: " + Xj_next);
	  
	  
	  if (Xj_next > 0 )rand =  (double)Xj_next  / (double) M1;
	  else if (Xj_next == 0 ) rand = (double )(M1 -1) / (double) M1;
	  else {
	    System.err.println("ProgramUtilitiesFun__Combined_Linear_Congruential_Generators Error");
	  }
	  
	  //System.out.println("rand: " + rand);
	  
	  Three_Tuple return_object = new Three_Tuple();
	  return_object.Ob1 = rand;
	  return_object.Ob2 = X1j_next;
	  return_object.Ob3 = X2j_next;
	  
	  return return_object;
	  
	}
	
	public double ProgramUtilitiesFun__Act_R_Noise(double The_S){

	  if (The_S < 0){ 
	    System.err.println ("ProgramUtilitiesFun__Act_R_Noise error! s must >= 0");
	    return 0.0;
	  }
	  else {
	    
	    //Combined_Linear_Congruential_Generators
	    Three_Tuple rand_tuple = sim.funs.ProgramUtilitiesFun__Combined_Linear_Congruential_Generators((int) sim.vars.programGlobalVar__Rand2_Seed1,(int) sim.vars.programGlobalVar__Rand2_Seed2);
	    double rand = (double) rand_tuple.Ob1;
	    sim.vars.programGlobalVar__Rand2_Seed1 = (int) rand_tuple.Ob2;  //rand1  for add past tense to memory and generate goal.
	    sim.vars.programGlobalVar__Rand2_Seed2 = (int) rand_tuple.Ob3;
	    //end Combined_Linear_Congruential_Generators -> rand "	Pseudo random number between (0,1)
	    
	    //ProgramUtilitiesFun__Output_Trace_Txt("  ");
	    if(sim.vars.printingModule.Output_Trace && sim.vars.printingModule.Output_Act_R_Noise_Random_Pick_Trace )
	      sim.funs.ProgramUtilitiesFun__Output_Trace_Txt(GlobalUtilities.round(SimSystem.clock(), 3) + "           sim.funs.ProgramUtilitiesFun__Act_R_Noise picked random rand: " + rand + ",  " + rand * 2147483563 );
	    
	    //double p = Model.Random ();
	    double p = rand;
	    //System.out.println(	"random: " +  p );
	    
	    if (p < 0.0001)p = 0.0001;
	    else if (p > 0.9999)p = 0.9999;
	    
	    return The_S * Math.log ( (1-p)/p ); 
	  }
	}
		
	public String[] ProgramUtilitiesFun__LinkedListString_To_ArrayString(LinkedList<String> the_linkedlist){
	  
	  //LinkedList<String> linkedlist = the_linkedlist;
	  int count = the_linkedlist.size();
	  String[] return_array = new String [count];
	  int i;
	  for (i=0; i< count; i++){
	    return_array[i] = the_linkedlist.get(i);
	  }
	  
	  return return_array;
	}
	
	public String ProgramUtilitiesFun__StringArray_To_String_Show_Empty(String[] the_string_array){
	  
	  int i ;
	  String return_string = "";
	  for (i=0; i < the_string_array.length  ; i++){
	    //if (!the_string_array[i].equals("")) return_string += the_string_array[i] + "   ";
	    if ( !the_string_array[i].equals( "" )) return_string += the_string_array[i] + "\t";  // \t is better for Excel to directly load .txt
	    else 						return_string += "[EMPTY]" + "\t";  // \t is better for Excel to directly load .txt
	  }
	  return return_string;
	}
	
	public String[] ProgramUtilitiesFun__StringArray_Clone(String[] the_string){
	  
	  String [] return_array = new String [the_string.length];
	  
	  int i;
	  for (i = 0; i < the_string.length ; i++){
	    return_array[i] = the_string[i];
	  }
	  
	  return return_array;
	}
	
	public LinkedList<String> ProgramUtilitiesFun__LinkedListString_Clone(LinkedList<String> the_source_linkedlist){
	  
	  if (the_source_linkedlist == null) return null;
	  if (the_source_linkedlist.size() == 0) return new LinkedList<String>();
	  
	  LinkedList<String> return_linkedlist = new LinkedList<String>();
	  Enumeration<String> Enum = Collections.enumeration(the_source_linkedlist); 
	  while(Enum.hasMoreElements()){
	    String next = (String)Enum.nextElement();
	    return_linkedlist.addLast ( next );
	  }
	  return return_linkedlist;
	}
	  
	public void ProgramUtilitiesFun__Output_Trace_Txt(String The_Output){

	  if (sim.vars.printingModule.Output_Trace && sim.vars.printingModule.v.equals("t") ){
	  
	    //System.out.println("ProgramUtilitiesFun__Output_Trace_Txt: " + sim.vars.printingModule.Output_Trace + sim.vars.printingModule.v);
	    
	    //Communication.Trace.SetLine(The_Output, sim.vars.centralParametersModule.Trace_Line_Number); //C# way
	    
	    sim.files.Results_trace.writeLine(The_Output);
	    
	    sim.vars.centralParametersModule.Trace_Line_Number++; //used in C# version, no need here 

	    //System.out.println("ProgramUtilitiesFun__Output_Trace_Txt: " + The_Output);
	  }
	}
	  
	public void ProgramUtilitiesFun__Output_QN_Result_Txt(String The_Output){

	  sim.files.QN_Result.writeLine(The_Output);
	}
	
	public String ProgramUtilitiesFun__ListString_To_String_Show_Empty(List<String> the_list_string){
	  
	  return sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty( the_list_string.toArray(new String[the_list_string.size()]));
	}
	
	public Chunk ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer(LinkedList<Chunk> The_LinkedList, int the_i){
		//System.out.println("ProgramUtilitiesFun__LinkedList_Get_i_th  . the_i=" + the_i + ", The_LinkedList.size() = " + The_LinkedList.size());
	    
	  if (The_LinkedList.size() - 1 < the_i) {
	    System.err.println("ProgramUtilitiesFun__LinkedList_Get_i_th  i is larger than the LinkedList"+". the_i=" + the_i + ", The_LinkedList.size() = " + The_LinkedList.size());
	    return null;
	  }
	  
	  Enumeration<Chunk> Enum = Collections.enumeration(The_LinkedList);
	  int i = 0;
	  while(Enum.hasMoreElements()){
	    Chunk aChunk = (Chunk) Enum.nextElement();
	    
	    //System.out.println("ProgramUtilitiesFun__LinkedList_Get_i_th aChunk.Chunk_Type: " + aChunk.Chunk_Type);
	    
	    if (the_i == i ) return aChunk;
	    i++;
	  }
	  System.err.println("ProgramUtilitiesFun__LinkedList_Get_i_th  i is larger than the LinkedList");
	  return null;
	}
	
	public boolean ProgramUtilitiesFun__Is_String_Double(String the_string){
	  try{
	    Double.parseDouble(the_string);
	    return true;
	  } catch(NumberFormatException e){
	    return false;
	  }
	  
	  
	}
	
	public LinkedList<Double> ProgramUtilitiesFun__LinkedListDouble_Clone(LinkedList<Double> the_linkedlist){
	  
	  LinkedList<Double> return_linkedlist = new LinkedList<Double>();
	  
	  Enumeration<Double> Enum = Collections.enumeration(the_linkedlist); 
	  while(Enum.hasMoreElements()){
	    return_linkedlist.addLast ((double)Enum.nextElement() );
	  }
	  
	  return return_linkedlist;
	}
	
	public  double ProgramUtilitiesFun__Geometry2D_Point_Point_Distance(double x1, double y1, double x2, double y2){
	  
	  return (double) Math.sqrt(  (x1 - x2)* (x1 - x2)  + (y1 - y2) * (y1 - y2)  );
	}
	
	public  void ProgramUtilitiesFun__Delayed_Function_Call_No_Return_Value(double the_delay, String the_function_name, Object the_parameters){
	  
	  
	  if (the_delay < 0.0){
	    System.err.println("Error! sim.funs.ProgramUtilitiesFun__Delayed_Function_Call_No_Return_Value has the_delay < 0.0 :" + the_delay);
	    
	  }
	  switch(the_function_name){
	    case "Animator3D_Hide":
	    case "Open_RT_Window":
	    case "TaskTemplateFun__Update_DriverCar_Accelbrake":
	    case "VocalizeSentence":
	    case "Plugin_MedicalDecisionTask_TrailDoneAfterFeedback":
	    case "Plugin_MemoryTask_StartSubTrial":
	    {
	      //create a new entity, change from and to properly, 
	      Entity Temp_Entity = sim.funs.createEntity( "Delayed Function Call No Return Value" , "", "Delayed Function Call No Return Value", the_function_name, 0.0);
//	      Entity Temp_Entity = new Entity();  
//	      Temp_Entity.ID = "601"; //directly send to Delayed_Function_Call_No_Return_Value
//	      Temp_Entity.Time = Clock;
//	      Temp_Entity.Tag = Entity_Number; //give it an entity number, init. 1
//	      Entity_Number++;
//	      Temp_Entity.From = ""; //tag from and to
//	      Temp_Entity.To = "Delayed_Function_Call_No_Return_Value";
//	      Temp_Entity.Entity_Type = the_function_name; //function name
	      Temp_Entity.Scheduled_Task_Enter_Clock_Time = SimSystem.clock() + the_delay;
	      Temp_Entity.Response_Item = the_parameters;  // function parameters in an object

	      break;
	    }
	    
	    default :{
	      System.err.println("Error! sim.funs.ProgramUtilitiesFun__Delayed_Function_Call_No_Return_Value has undefined the_function_name: " + the_function_name);
	      break;
	    }
	  }
	  
	}
	
	/**
	 * add elements of linkedList_2 to the end of linkedList_1, and then return linkedList_1
	 * @param linkedList_1
	 * @param linkedList_2
	 * @return
	 */
	public  LinkedList<Entity> ProgramUtilitiesFun__LinkedListEntity_Append(LinkedList<Entity> linkedList_1, LinkedList<Entity> linkedList_2){
	  
	  if(linkedList_2 == null || linkedList_2.size() == 0) return linkedList_1;
	  
	  Enumeration<Entity> Enum = Collections.enumeration(linkedList_2); 
	  while(Enum.hasMoreElements()){
	    linkedList_1.addLast ((Entity)Enum.nextElement() );
	  }
	  return linkedList_1;
	}
	
	/**
   * add elements of linkedList_2 to the end of linkedList_1, and then return linkedList_1
   * @param linkedList_1
   * @param linkedList_2
   * @return
   */
  public  LinkedList<String> ProgramUtilitiesFun__LinkedListString_Append(LinkedList<String> linkedList_1, LinkedList<String> linkedList_2){
    
    //LinkedList<String> linkedList_1 = (LinkedList<String>) ob1;
    //LinkedList<String> linkedList_2 = (LinkedList<String>) ob2;
    if(linkedList_2 == null || linkedList_2.size() == 0) return linkedList_1;
    
    Enumeration<String> Enum = Collections.enumeration(linkedList_2); 
    while(Enum.hasMoreElements()){
      linkedList_1.addLast ((String)Enum.nextElement() );
    }
    return linkedList_1;
  }
  
	public String ProgramUtilitiesFun__LinkedListDouble_To_String(LinkedList<Double> the_linkedlist){
	  
	  //LinkedList<double> linkedlist = the_linkedlist;
		// Yelly modifies this method to deal with the case where the_linkedlist could be empty.

		  int count = the_linkedlist.size();
		  if(count < 1) return "";
	  double node = the_linkedlist.getFirst();
	  String return_string = "";
	  int i;
	  for (i=0; i< count; i++){
	    return_string = return_string + " " + Double.toString(node);
	    if (i+1 < count) node = the_linkedlist.get(i);
	  }
	  
	  return return_string;
	}
	
	public  boolean ProgramUtilitiesFun__Is_String_Int(String the_string){
	  
	  @SuppressWarnings("unused")
    int Num;
	  boolean tempBool;
	  try
	  {
	    Num=Integer.parseInt(the_string);
	    tempBool=true;
	  }
	  catch (NumberFormatException nfe){
	    tempBool=false;
	  }
	  return tempBool;
	}

	public  LinkedList<String> ProgramUtilitiesFun__StringArray_To_LinkedList_String(String[] the_string_array ){
	  
	  int i;
	  LinkedList<String> return_list = new LinkedList<String>();
	  for (i=0; (i < the_string_array.length && !the_string_array[i].equals("") )  ; i++){
	    return_list.addLast ( the_string_array[i] );
	  }
	  return return_list;
	}
	
	public  double ProgramUtilitiesFun__Absolute_Angle_Radian_Within_Zero_To_2PI(double angle_radian){
	  
	  double abs_angle_radian = Math.abs(angle_radian);
	  while( abs_angle_radian >= Math.PI * 2.0){
	    abs_angle_radian -= Math.PI * 2.0;
	  }
	  return abs_angle_radian;
	}
	
	public  String ProgramUtilitiesFun__ListDouble_To_String(List<Double> the_list){
	  
	  String return_string = "";
	  for(double a_double : the_list ){
	    return_string = return_string + Double.toString(a_double) + "   ";
	  }
	  return return_string;
	}
	
	public  Three_Tuple ProgramUtilitiesFun__World3D_Local_Loc_And_Angle_To_Global(String road_world3d_id,double road_distance, double lateral_position, double local_heading_angle){
	  
	  World3D_Road the_start_road = (World3D_Road)sim.vars.world3DTemplate.World.Objects.get(road_world3d_id);
	  Three_Tuple return_tuple = new Three_Tuple();
	  double road_center_X;
	  double road_center_Z;
	  double road_center_heading_global_angle;
	  if(road_distance == 0.0){
	    road_center_X = the_start_road.Start_Loc_X ; 
	    road_center_Z = the_start_road.Start_Loc_Z ;
	    road_center_heading_global_angle = the_start_road.Start_Heading_Angle ;
	  }
	  else if(road_distance > 0.0){
	    //find the segment that contains the point of road_distance
	    World3D_Road_Segment the_segment = new World3D_Road_Segment();
	    for( World3D_Road_Segment a_segment: the_start_road.Segments){
	      if( road_distance > a_segment.Distance_Start && road_distance <= a_segment.Distance_End){
	        the_segment = 	a_segment;
	        break;
	      }
	    }
	    
	    //System.out.println("Local_Loc_And_Angle_To_Global: the_segment " + the_segment.Distance_Start + " "  + the_segment.Distance_End);
	    
	    //consider road_distance
	    World3D_Road_Fragment a_fragment = new World3D_Road_Fragment ();
	    a_fragment.Distance_Start = the_segment.Distance_Start;
	    a_fragment.Distance_End   = road_distance;
	    a_fragment.Length       = road_distance - the_segment.Distance_Start;
	    a_fragment.Start_Heading_Angle = the_segment.Start_Heading_Angle;
	    a_fragment.Start_Loc_X = the_segment.Start_Loc_X;
	    a_fragment.Start_Loc_Z = the_segment.Start_Loc_Z;
	    a_fragment.Turn_Angle = (double)(the_segment.Turn_Angle / the_segment.Length * a_fragment.Length); 
	    
	    double turn_angle_radian = a_fragment.Turn_Angle / 180.0  * Math.PI ;
	    double turn_radius;
	    
	    double turn_angle_radian_magnitude = sim.funs.ProgramUtilitiesFun__Absolute_Angle_Radian_Within_Zero_To_2PI((double) turn_angle_radian); //absolute value within 0 - 2 PI
	    
	    double direct_line_length;	
	    if(turn_angle_radian_magnitude == 0.0){
	      turn_radius = a_fragment.Length;
	      direct_line_length = turn_radius;
	    }
	    else{
	      turn_radius = a_fragment.Length / turn_angle_radian_magnitude;
	      direct_line_length = Math.abs( 2.0 * turn_radius * Math.sin( turn_angle_radian / 2.0) );
	    }
	    
	    
	    
	    //System.out.println("Local_Loc_And_Angle_To_Global: the_segment " + turn_radius + " "  + turn_angle_radian );
	    
	    a_fragment.End_Loc_X = (double) (a_fragment.Start_Loc_X + direct_line_length * Math.sin( (a_fragment.Start_Heading_Angle + a_fragment.Turn_Angle / 2.0) / 180.0  * Math.PI ));
	    a_fragment.End_Loc_Z = (double) (a_fragment.Start_Loc_Z + direct_line_length * Math.cos( (a_fragment.Start_Heading_Angle + a_fragment.Turn_Angle / 2.0) / 180.0  * Math.PI ));
	    
	    road_center_X = a_fragment.End_Loc_X ; 
	    road_center_Z = a_fragment.End_Loc_Z ;
	    road_center_heading_global_angle = a_fragment.Start_Heading_Angle + a_fragment.Turn_Angle ;
	    
	  }
	  else{
	    System.err.println("Error! 	ProgramUtilitiesFun__World3D_Local_Loc_And_Angle_To_Global has road_distance < 0.0: " + road_distance );
	    
	    return null;
	  }
	  
	  //consider lateral_position
	  double road_center_heading_global_angle_radian = road_center_heading_global_angle / 180.0 * Math.PI;
	  
	  double x_offset = lateral_position * Math.cos(road_center_heading_global_angle_radian);
	  double z_offset = lateral_position * Math.sin(road_center_heading_global_angle_radian);
	  
	  return_tuple.Ob1 = road_center_X + x_offset; 
	  return_tuple.Ob2 = road_center_Z - z_offset;
	  
	  //consider local_heading_angle
	  return_tuple.Ob3 = road_center_heading_global_angle + local_heading_angle;
	  
	  return return_tuple;
	  
	}
	
	public double ProgramUtilitiesFun__World3D_Get_2D_Vector_Angle_Degree(double from_X, double from_Z, double to_X, double to_Z){
	  
	  
	  double delta_X = to_X - from_X;
	  double delta_Z = to_Z - from_Z;
	  
	  if(delta_X == 0.0 && delta_Z == 0.0) return 0.0;
	  
	  double angle_in_radian = Math.atan( delta_X / delta_Z);
	  double return_angle_in_degree = angle_in_radian / Math.PI * 180.0;
	  if(delta_X > 0 && delta_Z < 0) return_angle_in_degree  += 180.0;
	  else if(delta_X < 0 && delta_Z < 0) return_angle_in_degree  -= 180.0;
	  else if(delta_X == 0 && delta_Z < 0) return_angle_in_degree  = 180.0;
	  
	  if(return_angle_in_degree > 180 || return_angle_in_degree <= -180){
	    System.out.println("WARNING! sim.funs.ProgramUtilitiesFun__World3D_Get_2D_Vector_Angle_Degree has return_angle_in_degree > 180 || return_angle_in_degree <= -180. return_angle_in_degree: " + return_angle_in_degree);
	  }
	  return (double) return_angle_in_degree;
	  
	}
	
	public  double ProgramUtilitiesFun__Rand_Time(double the_time){
	  
	  String randomize_time_string = sim.vars.centralParametersModule.randomize_time;
	  
	  /*
(if (or (not rand) (zerop time))
time
	   */
	  if( randomize_time_string.equals( "nil") || the_time == 0.0 ) return the_time ;
	  
	  //  (let* ((tscale (if (numberp rand) rand 3)))  ;; default when t is 3
	  int tscale;
	  if ( sim.funs.ProgramUtilitiesFun__Is_String_Int(randomize_time_string) ) tscale = Integer.parseInt (randomize_time_string);
	  else if ( randomize_time_string.equals( "t") ) tscale = 3;
	  else {
	    System.err.println("Error! sim.funs.ProgramUtilitiesFun__Rand_Time has sim.vars.centralParametersModule.randomize_time that is neither an integer nor t, but: " + sim.vars.centralParametersModule.randomize_time);
	    return (double) 0.0;
	  }
	  
	  
	  // (* (/ time tscale) (+ tscale -1 (act-r-random 2.0))))))
	  double return_time =  the_time / (double) tscale *  ( tscale - 1 + sim.funs.ProgramUtilitiesFun__Act_R_Random_Double( (double) 2.0) );
	  if ( return_time < 0.0 ){
	    System.err.println("Error! sim.funs.ProgramUtilitiesFun__Rand_Time has  return_time < 0,  return_time : " +  return_time  );
	    return (double) 0.0;
	  }
	  else{
	    return (double) return_time;
	  }
	}
	
	public  double ProgramUtilitiesFun__Normalize_Angle_Degree_Within_Plus_Minus_180(double the_angle_degree){
	  
	  while ( the_angle_degree > 180.0 ) {
	    the_angle_degree -= 360.0;
	  }
	  while ( the_angle_degree <= -180.0 ) {
	    the_angle_degree += 360.0;
	  }
	  return the_angle_degree;
	}
	
	public  Two_Tuple ProgramUtilitiesFun__Polar_Move_XY(int the_x_in_pixel, int the_y_in_pixel, double polar_r_in_pixel, double polar_theta){
	  
	  Two_Tuple return_tuple = new Two_Tuple ();
	  return_tuple.Ob1 = (GlobalUtilities.round ( ( the_x_in_pixel + polar_r_in_pixel * Math.cos( polar_theta ) ), 0)).intValue();
	  return_tuple.Ob2 =  (GlobalUtilities.round ( ( the_y_in_pixel + polar_r_in_pixel * Math.sin( polar_theta ) ), 0)).intValue();
	  return return_tuple;
	}
	
	public  Two_Tuple ProgramUtilitiesFun__XY_To_Polar(int from_x, int from_y, int to_x, int to_y){
	  
	  Two_Tuple return_tuple = new Two_Tuple ();
	  double distance = ProgramUtilitiesFun__Distance_Between_Two_Points ( from_x, from_y, to_x, to_y  ) ;
	  return_tuple.Ob1 = distance;
	  
	  if( distance == 0.0 ) return_tuple.Ob2 = 0.0;
	  else {
	    return_tuple.Ob2 = Math.atan2( (to_y - from_y)  ,  (to_x - from_x) ) ;
	  }
	  
	  return return_tuple;
	}
	
	public  String ProgramUtilitiesFun__LinkedListString_To_String_Show_Empty(LinkedList<String> the_linkedlist){
	  
	  return ProgramUtilitiesFun__StringArray_To_String_Show_Empty(sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString (the_linkedlist) );
	}
	
	public  String ProgramUtilitiesFun__StringArray_To_String_Stop_If_Empty(String[] the_string_array){
	  
	  int i ;
	  String return_string = "";
	  for (i=0; (i < the_string_array.length && !the_string_array[i].equals("") )  ; i++){
	    return_string += the_string_array[i] + "   ";
	  }
	  return return_string;
	}
	
	public  ArrayList<String> ProgramUtilitiesFun__StringArray_To_ArrayListString(String[] the_string_array){
    
    ArrayList<String> returnList = new ArrayList<String>();
    for (int i=0; i < the_string_array.length  ; i++){
      returnList.add(the_string_array[i]);
    }
    return returnList;
  }
	
	public  String ProgramUtilitiesFun__LinkedListString_To_String(LinkedList<String> the_linkedlist){
	  return ProgramUtilitiesFun__StringArray_To_String_Stop_If_Empty(sim.funs.ProgramUtilitiesFun__LinkedListString_To_ArrayString (the_linkedlist) );
	}
	
	public  Three_Tuple ProgramUtilitiesFun__World3D_Global_Loc_And_Angle_To_Local(String road_world3d_id, double global_X, double global_Z, double global_Yaw, double min_distance){
	  
	  // .Simulation
//	  System.out.println("TODO ProgramUtilitiesFun__World3D_Global_Loc_And_Angle_To_Local the_start_road.Simulation, Get_Loc_At_Segment");
//	  return null;
	  
	  
	  
	  World3D_Road the_start_road = (World3D_Road)sim.vars.world3DTemplate.World.Objects.get(road_world3d_id);
	  Three_Tuple return_tuple = new Three_Tuple();
	  
	  //first find out the road segment on which that the point is.
	  
	  
	  
	  //the_start_road.Simulation = this;
	  the_start_road.sim = this.sim; // link the sim object
	  
	  Two_Tuple loc_at_seg = the_start_road.Get_Loc_At_Segment( global_X, global_Z , min_distance);
	  
	  if (loc_at_seg == null) return return_tuple;
	  
	  World3D_Road_Segment the_segment =  (World3D_Road_Segment) loc_at_seg.Ob1;
	  double angle_difference_with_start = (double) loc_at_seg.Ob2;
	  double start_X = the_segment.Start_Loc_X;
	  double start_Z = the_segment.Start_Loc_Z;
	  double end_X = the_segment.End_Loc_X;
	  double end_Z = the_segment.End_Loc_Z;
	  
	  //compute distance, lateral distance, and angle_to_road_direction
	  if(the_segment.Type.equals( "straight")){
	    double the_lateral_distance_sign;
	    if ( angle_difference_with_start > 0 ) the_lateral_distance_sign = 1.0; // +, point right of road center
	    else the_lateral_distance_sign = -1.0; // - point left of road center
	    double lateral_distance_magnitude = ProgramUtilitiesFun__Geometry2D_Point_Line_Distance( (double)start_X, (double)start_Z, (double)end_X, (double)end_Z, (double)global_X, (double)global_Z  );
	    return_tuple.Ob2 = the_lateral_distance_sign * lateral_distance_magnitude;
	    
	    double distance_from_seg_start;
	    if ( angle_difference_with_start == 0.0) distance_from_seg_start = ProgramUtilitiesFun__Geometry2D_Point_Point_Distance((double)start_X, (double)start_Z, (double)global_X, (double)global_Z );
	    else	distance_from_seg_start = lateral_distance_magnitude / 	Math.abs ( Math.abs(angle_difference_with_start ) / 180 * Math.PI) ;
	    return_tuple.Ob1 = the_segment.Distance_Start + distance_from_seg_start; 
	    //System.out.println("the_segment.Distance_Start: " + the_segment.Distance_Start );	
	    //System.out.println("distance_from_seg_start: " + distance_from_seg_start );		
	    return_tuple.Ob3 = ProgramUtilitiesFun__Normalize_Angle_Degree_Within_Plus_Minus_180( global_Yaw - the_segment.Start_Heading_Angle );
	    
	    //System.out.println("Str. Dist.: " + return_tuple.Ob1 + ", lateral: " + return_tuple.Ob2 + ", angle_between_road_direction: " + return_tuple.Ob3);	
	    
	  }
	  else if (the_segment.Type.equals( "left") || the_segment.Type.equals( "right")){ //curve segment
	    double delta_heading;
	    if( the_segment.Type.equals( "left") ) delta_heading = - 90.0;
	    else if (the_segment.Type.equals( "right")) delta_heading = 90.0;
	    else {
	      System.err.println("Error! ProgramUtilitiesFun__World3D_Global_Loc_And_Angle_To_Local has the_segment.Type undefined");
	      delta_heading = 0.0;
	      return null;
	    }
	    
	    double curve_center_heading_angle = the_segment.Start_Heading_Angle + delta_heading; //the global angle for the vector from segment start point to the segment's curve center.
	    double curve_center_heading_angle_in_radian = curve_center_heading_angle / 180 * Math.PI;
	    double segment_turn_angle_in_radian = the_segment.Turn_Angle / 180 * Math.PI;
	    double curve_radius = the_segment.Length / Math.abs( segment_turn_angle_in_radian );
	    double center_X = start_X + curve_radius * Math.sin( curve_center_heading_angle_in_radian);
	    double center_Z = start_Z + curve_radius * Math.cos( curve_center_heading_angle_in_radian);
	    
	    double angle_degree_center_to_the_point = ProgramUtilitiesFun__World3D_Get_2D_Vector_Angle_Degree((double)center_X, (double)center_Z, (double)global_X, (double)global_Z);
	    double angle_degree_center_to_start     = ProgramUtilitiesFun__World3D_Get_2D_Vector_Angle_Degree((double)center_X, (double)center_Z, (double)start_X,  (double)start_Z);
	    
	    double abs_delta_center_angle_degree = Math.abs(   ProgramUtilitiesFun__Normalize_Angle_Degree_Within_Plus_Minus_180( (double) (angle_degree_center_to_the_point - angle_degree_center_to_start)) );
	    double delta_center_angle_radian = abs_delta_center_angle_degree / 180.0 * Math.PI;
	    
	    double distance_moved_beyond_segment_start = curve_radius * delta_center_angle_radian;
	    //System.out.println("curve_radius: " + curve_radius + ", 	delta_center_angle_radian: " + delta_center_angle_radian);	
	    double abs_distance_between_center_and_the_point = ProgramUtilitiesFun__Geometry2D_Point_Point_Distance((double) center_X, (double)center_Z, (double)global_X, (double)global_Z );
	    
	    //double raw_lateral_distance = curve_radius - abs_distance_between_center_and_the_point;
	    
	    double road_heading_at_target_road_center;
	    if( the_segment.Type.equals( "left") ) road_heading_at_target_road_center = the_segment.Start_Heading_Angle - abs_delta_center_angle_degree;
	    else if (the_segment.Type.equals( "right")) road_heading_at_target_road_center = the_segment.Start_Heading_Angle + abs_delta_center_angle_degree;
	    else {
	      System.err.println("Error! ProgramUtilitiesFun__World3D_Global_Loc_And_Angle_To_Local has the_segment.Type undefined");
	      road_heading_at_target_road_center = 0.0;
	      return null;
	    }
	    road_heading_at_target_road_center = ProgramUtilitiesFun__Normalize_Angle_Degree_Within_Plus_Minus_180((double) road_heading_at_target_road_center);
	    double angle_between_road_direction = ProgramUtilitiesFun__Normalize_Angle_Degree_Within_Plus_Minus_180((double) global_Yaw) - road_heading_at_target_road_center;
	    angle_between_road_direction = ProgramUtilitiesFun__Normalize_Angle_Degree_Within_Plus_Minus_180((double) (angle_between_road_direction));
	    
	    return_tuple.Ob1 = the_segment.Distance_Start + distance_moved_beyond_segment_start;
	    
	    double lateral_sign;
	    if( the_segment.Type.equals( "left") ) lateral_sign = -1.0;
	    else if (the_segment.Type.equals( "right")) lateral_sign = 1.0;
	    else {
	      System.err.println("Error! ProgramUtilitiesFun__World3D_Global_Loc_And_Angle_To_Local has the_segment.Type undefined");
	      lateral_sign = 0.0;
	      return null;
	    }
	    
	    //if(angle_between_road_direction >= 0.0) lateral_sign = 1.0;
	    //else lateral_sign = -1.0;
	    
	    double raw_lateral_distance = curve_radius - abs_distance_between_center_and_the_point;
	    double lateral_distance = lateral_sign * raw_lateral_distance;
	    
	    return_tuple.Ob2 = lateral_distance;
	    
	    return_tuple.Ob3 = angle_between_road_direction;
	    
	    //System.out.println("Dist.: " + return_tuple.Ob1 + ", lateral: " + lateral_distance + ", angle_between_road_direction: " + angle_between_road_direction);	
	    //System.out.println(", distance_moved_beyond_segment_start: " + distance_moved_beyond_segment_start + ", curve_radius: " + curve_radius + ", delta_center_angle_radian: " + delta_center_angle_radian);
	  }
	  
	  else {
	    System.err.println("Error! ProgramUtilitiesFun__World3D_Global_Loc_And_Angle_To_Local has undefined the_segment.Type: " + the_segment.Type);
	    return null;
	  }
	  
	  
	  
	  return return_tuple ;
	}
	
	public  Three_Tuple ProgramUtilitiesFun__World3D_Get_3D_Vector_Angle_Degree (Point3d point0, Point3d pointx, Point3d pointy, Point3d pointz){
	  /*
double alpha = ProgramUtilitiesFun__World3D_Get_2D_Vector_Angle_Degree( point0.ax, point0.ay, pointz.ax, pointz.ay);

double beta = Math.Acos( pointz.az - point0.az);

double gamma = ProgramUtilitiesFun__World3D_Get_2D_Vector_Angle_Degree( point0.az, point0.az, pointx.az, pointy.az);

Three_Tuple return_tuple = new Three_Tuple();
return_tuple.Ob1 = alpha;
return_tuple.Ob2 = beta;
return_tuple.Ob3 = gamma;
return return_tuple;
	   */
	  
	  //not sure whether the computation here is 100% correct. Check with people who knows.
	  
	  //pitch, compute in (Z, Y) plane
	  double pitch = -1.0 * ProgramUtilitiesFun__World3D_Get_2D_Vector_Angle_Degree( (double)point0.ay, (double)point0.az, (double)pointz.ay, (double)pointz.az); //this 2D function is basically arc tan
	  if (Double.isNaN (pitch) ) {
	    System.err.println("Error! ProgramUtilitiesFun__World3D_Get_3D_Vector_Angle_Degree has (double.IsNaN (pitch) )");
	    //break;
	  }
	  
	  //yaw, compute in (X, Z) plane
	  double yaw = ProgramUtilitiesFun__World3D_Get_2D_Vector_Angle_Degree( (double)point0.ax, (double)point0.az, (double)pointz.ax, (double)pointz.az);
	  if (Double.isNaN (yaw) ) {
	    System.err.println("Error! ProgramUtilitiesFun__World3D_Get_3D_Vector_Angle_Degree has (double.IsNaN (yaw) )");
	    //break;
	  }
	  
	  //roll, compute in (Y, X) plane
	  double roll = -1.0 * ProgramUtilitiesFun__World3D_Get_2D_Vector_Angle_Degree( (double)point0.ax, (double)point0.ay, (double)pointy.ax, (double)pointy.ay);
	  if (Double.isNaN (roll) ) {
	    System.err.println("Error! ProgramUtilitiesFun__World3D_Get_3D_Vector_Angle_Degree has (double.IsNaN (roll) )");
	    //break;
	  }
	  
	  Three_Tuple return_tuple = new Three_Tuple();
	  return_tuple.Ob1 = pitch;
	  return_tuple.Ob2 = yaw;
	  return_tuple.Ob3 = roll;
	  return return_tuple;
	  
	  
	  /*

double pitch = -1.0 * ProgramUtilitiesFun__World3D_Get_2D_Vector_Angle_Degree( from_Y, from_Z, to_Y, to_Z);


double yaw = ProgramUtilitiesFun__World3D_Get_2D_Vector_Angle_Degree( from_X, from_Z, to_X, to_Z);


Three_Tuple return_tuple = new Three_Tuple();
return_tuple.Ob1 = pitch;
return_tuple.Ob2 = yaw;
return_tuple.Ob3 = roll;
return return_tuple;

	   */
	}
	
	public  String[] ProgramUtilitiesFun__Subst_String_Array (String[] the_string_array, Hashtable the_hashtable){
	  int i, length = the_string_array.length;
	  String[] string_array_substituted = new String[length];
	  
	  for (i=0; i< length; i ++){
	    
//	    System.out.println("ProgramUtilitiesFun__Subst_String_Array has: " + the_hashtable.containsKey(the_string_array[i])  );
      
	    
	    if (!the_hashtable.containsKey(the_string_array[i] )){
	      string_array_substituted[i] = the_string_array[i];
	    }
	    else{ 
	      string_array_substituted[i] = (String)the_hashtable.get(the_string_array[i] );
	      
//	      System.out.println("ProgramUtilitiesFun__Subst_String_Array has: " + the_string_array[i] + ", " + string_array_substituted[i]  );
	      
	    }
	  }
	  return string_array_substituted;
	}
	
	public  String[] ProgramUtilitiesFun__String_To_StringArray_With_Quote(String input_string){
	  input_string = input_string + " ";
	  int head = 0;
	  int tail = 0;
	  boolean quote_open = false;
	  String[] temp_string_array = new String[ input_string.length() ];
	  int number_of_return_string = 0;
	  while (head < input_string.length() && tail < input_string.length() ){
	    while ( tail < input_string.length()){ 
	      if(quote_open == false && input_string.charAt(tail)==('\"') ) quote_open = true;
	      else if ( quote_open && input_string.charAt(tail)==('\"') )quote_open = false;
	      
	      if(quote_open){
	        tail ++;
	      }
	      else{ //quote closed.
	        if(input_string.charAt(tail)==('\n') || input_string.charAt(tail) == '\t' || input_string.charAt(tail) == ' ') break;
	        tail ++;
	      }
	    }
	    if (head != tail) {
	      temp_string_array[number_of_return_string] = input_string.substring(head, (tail) );
	      number_of_return_string ++;
	    }
	    head = tail + 1;
	    while ( head < input_string.length() && (input_string.charAt(head) == '\n' || input_string.charAt(head) == '\t' || input_string.charAt(head) == ' ') ){
	      head ++;
	    }
	    tail = head;
	  }
	  
	  String[] return_string_array = new String[ number_of_return_string];
	  int i = 0;
	  //System.out.println("number_of_return_string: " + number_of_return_string);
	  while ( i < number_of_return_string){
	    return_string_array[i] = temp_string_array[i];
	    i++;
	  }	
	  return return_string_array;
	}
	
	public  LinkedList<String> ProgramUtilitiesFun__String_To_LinkedListString_By_Quote (String input_string){
	  //System.out.println("input_string: " + input_string.Length + " , " + input_string);
	  LinkedList<String> return_list = new LinkedList<String>();
	  input_string.trim();
	  while( input_string.length() > 2 ){
	    
	    int first_quote = input_string.indexOf('"');
	    if (first_quote < 0 ) {
	      System.err.println("Error! ProgramUtilitiesFun__String_To_LinkedListString_By_Quote has part not started with a quote. : " + input_string);
	      break;
	    }
	    int second_quote = input_string.indexOf('"', first_quote + 1);
	    if (second_quote < 0 ) {
	      System.err.println("Error! ProgramUtilitiesFun__String_To_LinkedListString_By_Quote has part not ended with a quote. : " + input_string);
	      break;
	    }
	    String a_string = input_string.substring(first_quote, second_quote + 1 +first_quote);
	    
	    //System.out.println("input_string: " + input_string.Length + " , " + input_string + " first_quote:" + first_quote + " second_quote:" + second_quote);
	    //System.out.println("ProgramUtilitiesFun__String_To_LinkedListString_By_Quote, a_string: ___" + a_string + "___");
	    
	    return_list.addLast(a_string);
	    input_string = input_string.substring(second_quote + 1);
	    input_string.trim();
	    int next_first_quote = input_string.indexOf('"');
	    if (next_first_quote < 0 ) break;
	    input_string = input_string.substring(next_first_quote);
	  }
	  
	  return return_list;
	}
	
	public  String ProgramUtilitiesFun__String_Remove_Space_And_Tab_From_The_Beginning (String the_line){
	  if (the_line.equals( "" )) return "";
	  int i;
	  for(i = 0; i < the_line.length() ; i++){
	    if(the_line.charAt(i) != ' ' && the_line.charAt(i) != '\t')break;  //find the first place that is not a space nor a tab
	  }
	  
	  return the_line.substring(i); //return the sub-line start from the first non-space place
	}
	
	public  String[] ProgramUtilitiesFun__Hashtable_To_Array_String (Hashtable<Object, Object> the_hashtable,String the_switch){
	  String [] return_string = new String [ the_hashtable.size()];
	  int i =0;
	  Enumeration<Object> temp_enum;
	  if (the_switch.toLowerCase().equals( "key") || the_switch.toLowerCase().equals( "keys")){
	    temp_enum = the_hashtable.keys();
	  }
	  else if (the_switch.toLowerCase().equals( "value") ||   the_switch.toLowerCase().equals( "values")){
	    temp_enum = java.util.Collections.enumeration(the_hashtable.values());
	  }
	  else {
	    System.err.println("Error! ProgramUtilitiesFun__Hashtable_To_Array_String error. the_switch is undefined: " + the_switch);
	    return null;
	  }
	  
	  while(temp_enum.hasMoreElements()){
	    Object currentOb = temp_enum.nextElement();
	    if(currentOb instanceof String)			return_string[i] = (String) currentOb;
	    else if(currentOb instanceof Double)	return_string[i] = Double.toString((double)currentOb);
	    else if(currentOb instanceof Integer)		return_string[i] = Integer.toString((int)currentOb);  
	    else System.out.println("WARNING! ProgramUtilitiesFun__Hashtable_To_Array_String has undefined Class of object: " + currentOb );
	    
	    i++;
	  }
	  
	  return return_string;
	  
	  
	  
	}
	
	public  Hashtable<Object, Object> ProgramUtilitiesFun__Reverse_Hashtable_String (Hashtable<Object, Object> the_hashtable){
	  String[] keys  = sim.funs.ProgramUtilitiesFun__Hashtable_To_Array_String(the_hashtable, "key");
	  String[] values  = sim.funs.ProgramUtilitiesFun__Hashtable_To_Array_String(the_hashtable, "values");
	  Hashtable<Object, Object> return_hashtable = new Hashtable<Object, Object>();
	  int i;
	  for (i=0;i< the_hashtable.size(); i ++){
	    return_hashtable.put(values[i], keys[i] ); //TODO: here there is problem when one two keys have the same value
	  }
	  return return_hashtable;
	}
	
	public  Object ProgramUtilitiesFun__Response_Item_Clone (Object item){
	  if(item instanceof  Response_Item_Key_Press){
	    Response_Item_Key_Press return_object = new Response_Item_Key_Press();
	    return_object.Clock_Time = ((Response_Item_Key_Press)item).Clock_Time;
	    return_object.Key = ((Response_Item_Key_Press)item).Key ;
	    return_object.Reaction_Time = ((Response_Item_Key_Press)item).Reaction_Time;
	    return_object.Response_Correctness = ((Response_Item_Key_Press)item).Response_Correctness;
	    return_object.Mouse_Cursor_X = ((Response_Item_Key_Press)item).Mouse_Cursor_X;
	    return_object.Mouse_Cursor_Y = ((Response_Item_Key_Press)item).Mouse_Cursor_Y;
	    
	    return return_object;
	  }
	  else if( item instanceof Response_Item_Speech){
	    Response_Item_Speech return_object = new Response_Item_Speech();
	    return_object.Clock_Time = ((Response_Item_Speech)item).Clock_Time;
	    return_object.Speech = ((Response_Item_Speech)item).Speech ;
	    return_object.Reaction_Time = ((Response_Item_Speech)item).Reaction_Time;
	    return_object.Response_Correctness = ((Response_Item_Speech)item).Response_Correctness;
	    
	    return return_object;
	  }
	  else if( item instanceof Response_Item_Move_Cursor){
	    Response_Item_Move_Cursor return_object = new Response_Item_Move_Cursor();
	    return_object.Clock_Time = ((Response_Item_Move_Cursor)item).Clock_Time;
	    return_object.Duration = ((Response_Item_Move_Cursor)item).Duration ;
	    return_object.End_X = ((Response_Item_Move_Cursor)item).End_X ;
	    return_object.End_Y = ((Response_Item_Move_Cursor)item).End_Y ;
	    return_object.Reaction_Time = ((Response_Item_Move_Cursor)item).Reaction_Time;
	    return_object.Response_Correctness = ((Response_Item_Move_Cursor)item).Response_Correctness;
	    return_object.Start_X = ((Response_Item_Move_Cursor)item).Start_X ;
	    return_object.Start_Y = ((Response_Item_Move_Cursor)item).Start_Y ;
	    
	    return return_object;
	  }
	  else {
	    System.err.println("ProgramUtilitiesFun__Response_Item_Clone has undefined object type");
	    return null;
	  }
	  
	}
	
	public Production_Rule ProgramUtilitiesFun__Production_Rule_Clone (Production_Rule the_rule){
	  Production_Rule temp_rule = ProductionModuleFun__Make_Production_Rule_From_Descriptors( ProductionModuleFun__Get_Rule_Descriptors_From_Production_Rule(the_rule) );
	  temp_rule.Compilation_Note_For_New_Rule = the_rule.Compilation_Note_For_New_Rule;
	  temp_rule.Compilation_Father = the_rule.Compilation_Father;
	  temp_rule.Compilation_Sons = sim.funs.ProgramUtilitiesFun__LinkedListString_Clone(the_rule.Compilation_Sons);
	  temp_rule.Action_Time = the_rule.Action_Time;
	  
	  return temp_rule;
	}
	
	public  void ProgramUtilitiesFun__Output_Rule_Descriptors_Trace_Txt (String[] new_rule_descriptor){
	  
	  ProgramUtilitiesFun__Output_Trace_Txt("(p " + new_rule_descriptor[1]);
	  for(int i = 2; i < new_rule_descriptor.length; i++){
	    String s = new_rule_descriptor[i];
	    if ( s.substring(s.length()-1).equals( ">") ){ //buffer operator or ==>
	      if (s.equals( "==>")){
	        ProgramUtilitiesFun__Output_Trace_Txt(" ==>");
	      }
	      else{ //buffer operator
	        ProgramUtilitiesFun__Output_Trace_Txt("    " + s);
	      }
	    }
	    else{ //slot_name, slot_value
	      i++;
	      String s2 = new_rule_descriptor[i];
	      ProgramUtilitiesFun__Output_Trace_Txt("        " + s +"    " + s2);
	    }
	  }
	  
	  
//	  Enumeration<String> enum_new_rule_descriptors =  Collections.enumeration(new_rule_descriptor.);
//	  enum_new_rule_descriptors.nextElement();
//	  enum_new_rule_descriptors.nextElement();
//	  ProgramUtilitiesFun__Output_Trace_Txt("(p " + (String)enum_new_rule_descriptors.nextElement());
//	  while(enum_new_rule_descriptors.hasMoreElements()){
//	    String s = (String)enum_new_rule_descriptors.nextElement();
//	    if ( s.substring(s.length()-1).equals( ">") ){ //buffer operator or ==>
//	      if (s.equals( "==>")){
//	        ProgramUtilitiesFun__Output_Trace_Txt(" ==>");
//	      }
//	      else{ //buffer operator
//	        ProgramUtilitiesFun__Output_Trace_Txt("    " + s);
//	      }
//	    }
//	    else{ //slot_name, slot_value
//	      enum_new_rule_descriptors.nextElement();
//	      String s2 = (String)enum_new_rule_descriptors.nextElement();
//	      ProgramUtilitiesFun__Output_Trace_Txt("        " + s +"    " + s2);
//	    }
//	  }
	  
	  
	  ProgramUtilitiesFun__Output_Trace_Txt(")");
	}
	
	public  void ProgramUtilitiesFun__Output_Response_Results_Txt (String The_Output){
	  
	  // communication?
	  
	  if (sim.vars.printingModule.Response_Results){
	    
	    sim.files.Results_results_response.writeLine(The_Output);
	    
	    //Communication.Response_Results.SetLine(The_Output, sim.vars.centralParametersModule.Response_Results_Line_Number);
	    
	    sim.vars.centralParametersModule.Response_Results_Line_Number++;
	    
	  }
	}
	
	public  void ProgramUtilitiesFun__Output_Initialized_Experiment_Trial_Parameter_List_To_Experiment_Trial_Parameter_List_Txt (){
	  if ( sim.vars.centralParametersModule.Experiment_Trial_Parameter_List.size() == 0) {
	    return;
	  }
	  
	  String parameter_names = sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty( ProgramUtilitiesFun__Hashtable_To_Array_String( sim.vars.centralParametersModule.Experiment_Trial_Parameter_List.getFirst(), "key" ) ) ;
	  ProgramUtilitiesFun__Output_Experiment_Trial_Parameter_List_Txt(parameter_names );
//	  Enumeration a_hashtable= sim.vars.centralParametersModule.Experiment_Trial_Parameter_List.elements();
	  Iterator<Hashtable> itr = sim.vars.centralParametersModule.Experiment_Trial_Parameter_List.iterator();
	  while (itr.hasNext()){
	    Hashtable a_hashtable = itr.next();
	    String new_parameter_names = sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty( ProgramUtilitiesFun__Hashtable_To_Array_String( a_hashtable, "key" ) ) ;
	    //if ( !new_parameter_names.equals(parameter_names)) System.out.println("WARNING! ProgramUtilitiesFun__Output_Initialized_Experiment_Trial_Parameter_List_To_Experiment_Trial_Parameter_List_Txt has new_parameter_names != parameter_names");
	    String parameter_values = sim.funs.ProgramUtilitiesFun__StringArray_To_String_Show_Empty( ProgramUtilitiesFun__Hashtable_To_Array_String( a_hashtable, "value" ) ) ;
	    
	    //System.out.println(parameter_values);
	    ProgramUtilitiesFun__Output_Experiment_Trial_Parameter_List_Txt(parameter_values );
	    
	  }
	  
	  
	  
	  //need to check if all trials have the same parameter name list. otherwise, error
	  
	}
	
	public  void ProgramUtilitiesFun__Output_Human_Drive_Results_Txt (String The_Output){

	  if (sim.vars.printingModule.Human_Drive_Results){
	    
	    sim.files.Results_results_human_drive.writeLine(The_Output);
//	    Communication.Human_Drive_Results.SetLine(The_Output, sim.vars.centralParametersModule.Human_Drive_Results_Line_Number);
//	    sim.vars.centralParametersModule.Human_Drive_Results_Line_Number++;
	    
	  }
	}
	
	public void ProgramUtilitiesFun__Output_Foot_Results_Txt (String The_Output){
	  
	  if (sim.vars.printingModule.Foot_Results){
	    sim.files.Results_results_foot.writeLine(The_Output);
//	    Communication.Foot_Results.SetLine(The_Output, sim.vars.centralParametersModule.Foot_Results_Line_Number);
//	    sim.vars.centralParametersModule.Foot_Results_Line_Number++;
	    
	  }
	}
	
	public void ProgramUtilitiesFun__Output_Eye_Movement_Results_Txt (String The_Output){
	  
	  if (sim.vars.printingModule.Eye_Movement_Results){
	    
	    sim.files.Results_results_eye_movement.writeLine(The_Output);
//	    Communication.Eye_Movement_Results.SetLine(The_Output, sim.vars.centralParametersModule.Eye_Movement_Results_Line_Number);
//	    sim.vars.centralParametersModule.Eye_Movement_Results_Line_Number++;
	    
	  }
	}
	
	public  void ProgramUtilitiesFun__Output_Experiment_Trial_Parameter_List_Txt (String The_Output){
	  
	  sim.files.Results_Experiment_Trial_Parameter_List.writeLine(The_Output);
//	  Communication.Experiment_Trial_Parameter_List.SetLine(The_Output, sim.vars.centralParametersModule.Experiment_Trial_Parameter_List_Line_Number);
//	  sim.vars.centralParametersModule.Experiment_Trial_Parameter_List_Line_Number++;
	}
	
	public  LinkedList<String> ProgramUtilitiesFun__Merge_Two_LinkedListString (LinkedList<String> linkedList_1,LinkedList<String> linkedList_2){
	  //LinkedList<String> linkedList_1 = (LinkedList<String>) ob1;
	  //LinkedList<String> linkedList_2 = (LinkedList<String>) ob2;
	  Enumeration Enum = Collections.enumeration(linkedList_2); 
	  while(Enum.hasMoreElements()){
	    String currentItem =  (String)Enum.nextElement();
	    if (!linkedList_1.contains( currentItem )) linkedList_1.addLast ( currentItem );
	  }
	  return linkedList_1;
	}
	
	public  List<String> ProgramUtilitiesFun__LinkedListString_To_ListString (LinkedList<String> the_linkedList){
	  List<String> return_list = new ArrayList<String>();
	  for( String a_string : the_linkedList){
	    return_list.add( a_string); //to the end
	  }
	  return return_list;
	  
	}
	
	public  String ProgramUtilitiesFun__LinkedListString_Remove_and_Return_i_th_String (LinkedList<String> the_counter_string_list, int i_th){
	  if (i_th <= 0 || i_th > the_counter_string_list.size()) {
	    System.err.println("Error ProgramUtilitiesFun__LinkedListString_Remove_and_Return_i_th_String has i_th <= 0 || i_th > the_counter_string_list.Count");
	    return null;
	  }
	  
	  String return_string = null;
	  int i = 1;
	  Enumeration enum_a_node = Collections.enumeration(the_counter_string_list);
	  Object a_node = enum_a_node.nextElement();
	  for (String a_string : the_counter_string_list) {
	    if(i == i_th) {
	      return_string = a_string;
	      the_counter_string_list.remove( a_node );
	      break;
	    }
	    i++;
	    a_node = enum_a_node.nextElement();
	  }
	  
	  return return_string;
	}
	
	public  String ProgramUtilitiesFun__LinkedListString_Get_i_th_String (LinkedList<String> string_list, int i_th){
	  if (i_th <= 0 || i_th > string_list.size()) {
	    System.err.println("Error ProgramUtilitiesFun__LinkedListString_Get_i_th_String has i_th <= 0 || i_th > string_list.Count");
	    return null;
	  }
	  
	  int i = 1;
	  for (String a_string : string_list) {
	    if(i == i_th) return a_string;
	    i++;
	  }
	  
	  return null;
	}
	
	public  boolean ProgramUtilitiesFun__LinkedListString_Equal (LinkedList<String> the_linkedlist1,LinkedList<String> the_linkedlist2){
	  LinkedList<String> linkedlist1 = sim.funs.ProgramUtilitiesFun__LinkedListString_Clone (the_linkedlist1);
	  LinkedList<String> linkedlist2 = sim.funs.ProgramUtilitiesFun__LinkedListString_Clone (the_linkedlist2);
	  Enumeration enum_string = Collections.enumeration(linkedlist1);
	  while(enum_string.hasMoreElements()){
	    String currentItem = (String)enum_string.nextElement() ;
	    if(linkedlist2.contains( currentItem )){
	      linkedlist2.remove( currentItem );
	    }
	    else{
	      return false;
	    }
	  }
	  
	  if (linkedlist2.size() == 0){
	    return true;
	  }
	  else{
	    return false;
	  }
	}
	
	public  Object ProgramUtilitiesFun__LinkedListObject_Get_i_th_Object (Object input_list, int i_th){
	  int i = 1;
	  if(input_list instanceof LinkedList){
	    LinkedList<Hashtable> object_list = (LinkedList<Hashtable> ) input_list ;
	    if (i_th <= 0 || i_th > object_list.size()) {
	      System.err.println("Error ProgramUtilitiesFun__LinkedListObject_Get_i_th_Object has i_th <= 0 || i_th > object_list.Count");
	      return null;
	    }
	    for (Object an_object : object_list) {
	      if(i == i_th) return an_object;
	      i++;
	    }
	    return null;
	  } //LinkedList<Hashtable>
	  else if(input_list instanceof LinkedList){
	    LinkedList<Object> object_list = (LinkedList<Object> ) input_list ;
	    if (i_th <= 0 || i_th > object_list.size()) {
	      System.err.println("Error ProgramUtilitiesFun__LinkedListObject_Get_i_th_Object has i_th <= 0 || i_th > object_list.Count");
	      return null;
	    }
	    for (Object an_object : object_list) {
	      if(i == i_th) return an_object;
	      i++;
	    }
	    return null;
	  }  //LinkedList<object>
	  else if(input_list instanceof LinkedList){
	    LinkedList<LinkedList<Object>> object_list = ( LinkedList<LinkedList<Object>> ) input_list ;
	    if (i_th <= 0 || i_th > object_list.size()) {
	      System.err.println("Error ProgramUtilitiesFun__LinkedListObject_Get_i_th_Object has i_th <= 0 || i_th > object_list.Count");
	      return null;
	    }
	    for (Object an_object : object_list) {
	      if(i == i_th) return an_object;
	      i++;
	    }
	    return null;
	  } //LinkedList<LinkedList<object>>
	  else{
	    System.err.println("Error ProgramUtilitiesFun__LinkedListObject_Get_i_th_Object has undefined LinkedList< ?? > type. " );
	    return null;
	  }
	  
	  
	}
	
	public  double[] ProgramUtilitiesFun__LinkedListDouble_To_Double_Array (LinkedList<Double> the_list){
	  double [] return_array = new double [ the_list.size() ] ;
	  
	  int i = 0;
	  for (double num : the_list){
	    return_array[i] = num;
	    i++;
	  }
	  
	  return return_array;
	}
	
	public  double ProgramUtilitiesFun__LinkedListDouble_Get_Sum (LinkedList<Double> the_list){
	  if(the_list.size() == 0 ) {
	    //System.out.println("ProgramUtilitiesFun__LinkedListDouble_Get_Sum gets an empty list");
	    return 0;
	  }
	  double sum = 0.0;
	  for( double a_double : the_list){
	    sum += a_double;
	  }
	  return sum;
	}
	
	public  double ProgramUtilitiesFun__LinkedListDouble_Get_Stdev (LinkedList<Double> the_list){
	  if(the_list == null) {
	    System.err.println("Error! ProgramUtilitiesFun__LinkedListDouble_Get_Average gets an empty list");
	    return -10000000;
	  }
	  
	  double average = sim.funs.ProgramUtilitiesFun__LinkedListDouble_Get_Average(the_list);
	  double sum_of_square = 0.0;
	  for( double a_double : the_list){
	    sum_of_square += (a_double - average) * (a_double - average);
	  }
	  if(the_list.size() == 0 ) {
	    System.err.println("Error! ProgramUtilitiesFun__LinkedListDouble_Get_Stdev gets an empty list");
	    return -20000000;
	  }
	  return Math.sqrt(sum_of_square / the_list.size());
	}
	
	public  double ProgramUtilitiesFun__LinkedListDouble_Get_Min (LinkedList<Double> the_list){
	  if(the_list.size() == 0 ) {
	    //System.out.println("ProgramUtilitiesFun__LinkedListDouble_Get_Min gets an empty list");
	    return -10000000;	
	  }
	  double min = (double)the_list.getFirst();
	  if (the_list.size() == 1) return min;
	  
	  for (double number : the_list){
	    if (number < min) min = number;
	  }
	  return min;
	}
			
	public  double ProgramUtilitiesFun__LinkedListDouble_Get_Median (LinkedList<Double> the_list){
	  if ( the_list == null ) return -10000000; 
	  int count = the_list.size();
	  if ( count == 0) return -20000000; 
	  if (count == 1) return (double) the_list.getFirst();
	  
	  LinkedList<Double> ascending_sorted = sim.funs.ProgramUtilitiesFun__LinkedListDouble_Get_Ascending_Sorted (the_list);
	  double [] double_array = sim.funs.ProgramUtilitiesFun__LinkedListDouble_To_Double_Array (ascending_sorted);
	  if (  ProgramUtilitiesFun__Mod( count , 2 ) == 0 ){ // even
	    int i = ( count / 2 );
	    int j = i + 1;
	    return (double_array[i-1] + double_array[j-1] ) / 2.0 ;
	  }
	  else if (  ProgramUtilitiesFun__Mod( count , 2 ) == 1 ){
	    int i = ( count +  1 ) / 2;
	    //System.out.println(i-1);
	    return double_array[i-1];
	  }
	  else {
	    System.err.println("ProgramUtilitiesFun__LinkedListDouble_Get_Median has ProgramUtilitiesFun__Mod error " );
	    return 0;
	  }
	}
		
	
	public  double ProgramUtilitiesFun__LinkedListDouble_Get_Average (LinkedList<Double> the_list){
	  if(the_list == null) {
	    System.err.println("Error! ProgramUtilitiesFun__LinkedListDouble_Get_Average gets an empty list");
	    return -10000000;
	  }
	  if(the_list.size() == 0 ) {
	    System.err.println("Error! ProgramUtilitiesFun__LinkedListDouble_Get_Average gets an empty list");
	    return -20000000;
	  }
	  double sum = sim.funs.ProgramUtilitiesFun__LinkedListDouble_Get_Sum(the_list);
	  return sum / the_list.size();
	}
	
			
	public  LinkedList<Double> ProgramUtilitiesFun__LinkedListDouble_Get_Ascending_Sorted (LinkedList<Double> the_list){
	  if (the_list.size() <= 1){
	    return the_list;
	  }
	  LinkedList<Double> clone_list = sim.funs.ProgramUtilitiesFun__LinkedListDouble_Clone(the_list);
	  LinkedList<Double> return_list = new LinkedList<Double>();
	  while ( clone_list.size() > 0 ) {
	    double min = sim.funs.ProgramUtilitiesFun__LinkedListDouble_Get_Min( clone_list );
	    return_list.addLast ( min );
	    clone_list.remove (min); //if more than one number = min, remove the first one, which is ok here
	  }
	  return return_list;
	}
			
	
	public  LinkedList<Double>  ProgramUtilitiesFun__LinkedListDouble_Each_Minus_From_ADouble (double the_double, LinkedList<Double> the_linkedlist){
	  LinkedList<Double>  return_linkedList = new LinkedList<Double>();
	  
	  Enumeration Enum = Collections.enumeration(the_linkedlist); 
	  while(Enum.hasMoreElements()){
	    return_linkedList.addLast (the_double - (double)Enum.nextElement() );
	  }
	  
	  return return_linkedList;
	}
			
	public  boolean ProgramUtilitiesFun__Is_Buffer_Empty (String the_buffer_code){
	  boolean retu;
	  switch (the_buffer_code.toLowerCase()){
	    case "aural" :{
	      if(sim.vars.auralBuffer.Aural_Buffer_Chunk.Chunk_Name.equals( "" ) && sim.vars.auralBuffer.Aural_Buffer_Chunk.Chunk_Type.equals( "" ) )retu = true;
	      else retu = false;
	      break;
	    }
	    case "aural-location":{
	      if(sim.vars.auralLocationBuffer.Aural_Location_Buffer_Chunk.Chunk_Name.equals( "" ) && sim.vars.auralLocationBuffer.Aural_Location_Buffer_Chunk.Chunk_Type.equals( "" ) )retu = true;
	      else retu = false;
	      break;
	    }
	    case "goal": {
	      if(sim.vars.goalBuffer.Goal_Buffer_Chunk.Chunk_Name.equals( "" ) && sim.vars.goalBuffer.Goal_Buffer_Chunk.Chunk_Type.equals( "" ))retu=true;
	      else retu = false;
	      break;
	    }
	    case "goal-2" : {
	      if(sim.vars.goalBuffer.Goal_Buffer_Chunk_2.Chunk_Name.equals( "" ) && sim.vars.goalBuffer.Goal_Buffer_Chunk_2.Chunk_Type.equals( "" ))retu = true;
	      else retu = false;
	      break;
	    }
	    case "imaginal":{
	      if(sim.vars.imaginalBuffer.Imaginal_Buffer_Chunk.Chunk_Name.equals( "" ) && sim.vars.imaginalBuffer.Imaginal_Buffer_Chunk.Chunk_Type.equals( "" ) )retu = true;
	      else retu = false;
	      break;
	    }
	    case "retrieval":{
	      if(sim.vars.retrievalBuffer.Retrieval_Buffer_Chunk.Chunk_Name.equals( "" ) && sim.vars.retrievalBuffer.Retrieval_Buffer_Chunk.Chunk_Type.equals( "" ) )retu = true;
	      else retu = false;
	      break;
	    }
	    case "visual":{
	      if(sim.vars.visualBuffer.Visual_Buffer_Chunk.Chunk_Name.equals( "" ) && sim.vars.visualBuffer.Visual_Buffer_Chunk.Chunk_Type.equals( "" ) )retu = true;
	      else retu = false;
	      break;
	    }
	    case "visual-location":{
	      if(sim.vars.visualLocationBuffer.Visual_Location_Buffer_Chunk.Chunk_Name.equals( "" ) && sim.vars.visualLocationBuffer.Visual_Location_Buffer_Chunk.Chunk_Type.equals( "" ) )retu = true;
	      else retu = false;
	      break;
	    }
	    case "temporal":
	      retu = sim.vars.temporalBuffer.Temporal_Buffer_Chunk.Chunk_Name.equals( "" ) && sim.vars.temporalBuffer.Temporal_Buffer_Chunk.Chunk_Type.equals( "" );
	      break;
	    default:
	    {
	      System.err.println("ProgramUtilitiesFun__Is_Buffer_Empty has undefined buffer code : " + the_buffer_code);
	      retu = false;
	    }
	    
	    
	    
	  }
	  return retu;
	}
			
	public  LinkedList<String> ProgramUtilitiesFun__Hashtable_To_LinkedListString (Hashtable<Object, Object> the_hashtable, String the_switch){
	  return sim.funs.ProgramUtilitiesFun__StringArray_To_LinkedList_String(  sim.funs.ProgramUtilitiesFun__Hashtable_To_Array_String( the_hashtable, the_switch )  );
	}
			
	public  Hashtable<Object, Object> ProgramUtilitiesFun__Hashtable_Clone (Hashtable<Object, Object> the_hashtable){

	  
	  Hashtable<Object, Object> return_table = new Hashtable<Object, Object>();
	  
	  Iterator<Entry<Object, Object>>itrObjects = the_hashtable.entrySet().iterator();
	  while(itrObjects.hasNext()){
	    Entry<Object, Object> currentEntry = itrObjects.next(); 
	    return_table.put( currentEntry.getKey(), currentEntry.getValue()) ; 
	  }
	  return return_table;
	}
			
	public  void ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value_From_Another_Hashtable (Hashtable<Object, Object> to_hashtable, Hashtable<Object, Object> from_hashtable){
	  
	  
	  Iterator<Entry<Object, Object>>itrObjects = from_hashtable.entrySet().iterator();
	  while(itrObjects.hasNext()){
	    Entry<Object, Object> currentEntry = itrObjects.next(); 
	    sim.funs.ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(to_hashtable, currentEntry.getKey(), currentEntry.getValue() );
	  }
	}
		
	public  void ProgramUtilitiesFun__Halt_Simulation(){
	  //TODO
	  System.out.println("TODO ProgramUtilitiesFun__Halt_Simulation");
	}
			
	public String ProgramUtilitiesFun__Get_Compilation_Oldest_Grandfather_Name (String the_rule_name){
	  Production_Rule rule_pointer = ProductionModuleFun__Find_Production_Rule_Pointer_By_Rule_Name(the_rule_name);
	  if(rule_pointer.Compilation_Father.equals( "" )){ //If the rule has no father, return self.
	    return the_rule_name;
	  }
	  else return sim.funs.ProgramUtilitiesFun__Get_Compilation_Oldest_Grandfather_Name(rule_pointer.Compilation_Father);
	}
			
	public  Two_Tuple ProgramUtilitiesFun__Get_A_Two_Tuple_String_From_Randomizing_A_Pair_Of_String_Lists (LinkedList<String> original_full_string_list_1, LinkedList<String> original_full_string_list_2, LinkedList<String> string_list_counter_1, LinkedList<String> string_list_counter_2, String random_method){
	  
	  
	  //just use the same random number to two String lists, in comparision to the sim.funs.ProgramUtilitiesFun__Get_A_String_From_Randomizing_A_String_List
	  if( original_full_string_list_1.size() == 0 || original_full_string_list_2.size() == 0 ) {
	    System.out.println("WARNING! sim.funs.ProgramUtilitiesFun__Get_A_Two_Tuple_String_From_Randomizing_A_Pair_Of_String_Lists has original_full_string_list_1.Count == 0 || original_full_string_list_2.Count == 0 . ");
	    return null;
	  }
	  
	  //error if two lists have different length
	  if( original_full_string_list_1.size() != original_full_string_list_2.size()){
	    System.err.println("Error! sim.funs.ProgramUtilitiesFun__Get_A_Two_Tuple_String_From_Randomizing_A_Pair_Of_String_Lists has two original lists with different length." );
	    return null;
	  }
	  
	  //counter 1 and 2 must have the same length
	  if( string_list_counter_1.size() != string_list_counter_2.size()){
	    System.err.println("Error! sim.funs.ProgramUtilitiesFun__Get_A_Two_Tuple_String_From_Randomizing_A_Pair_Of_String_Lists has two counter lists with different length." );
	    return null;
	  }
	  
	  //refill the counter lists if they are empty
	  if (string_list_counter_1.size() == 0 ){
	    for (String a_string  :  original_full_string_list_1) {
	      string_list_counter_1.addLast (a_string);
	    }
	  }
	  
	  if (string_list_counter_2.size() == 0 ){
	    for (String a_string  :  original_full_string_list_2) {
	      string_list_counter_2.addLast (a_string);
	    }
	  }
	  
	  if (random_method.equals( "fixed_order")){
	    Two_Tuple return_tuple = new Two_Tuple ();
	    return_tuple.Ob1 = string_list_counter_1.getFirst();
	    string_list_counter_1.removeFirst();
	    
	    return_tuple.Ob2 = string_list_counter_2.getFirst();
	    string_list_counter_2.removeFirst();
	    
	    return return_tuple;
	  }
	  else if(random_method.equals( "with_replacement")){
	    //Combined_Linear_Congruential_Generators
	    Three_Tuple rand_tuple = sim.funs.ProgramUtilitiesFun__Combined_Linear_Congruential_Generators((int) sim.vars.programGlobalVar__Rand1_Seed1, (int)sim.vars.programGlobalVar__Rand1_Seed2);
	    double rand = (double) rand_tuple.Ob1;
	    sim.vars.programGlobalVar__Rand1_Seed1 = (int) rand_tuple.Ob2; 
	    sim.vars.programGlobalVar__Rand1_Seed2 = (int) rand_tuple.Ob3;
	    //end Combined_Linear_Congruential_Generators -> rand "	Pseudo random number between (0,1)
	    int order_number = (int) Math.floor(rand * (double)(original_full_string_list_1.size()) ) + 1 ;  //this gets 1 to N. list 1 and list 2 must have the same length
	    
	    Two_Tuple return_tuple = new Two_Tuple ();
	    return_tuple.Ob1 = sim.funs.ProgramUtilitiesFun__LinkedListString_Get_i_th_String( original_full_string_list_1, order_number ); //no change to the string_list
	    return_tuple.Ob2 = sim.funs.ProgramUtilitiesFun__LinkedListString_Get_i_th_String( original_full_string_list_2, order_number ); //no change to the string_list
	    return return_tuple;
	  }
	  else if (random_method.equals( "without_replacement")){
	    //Combined_Linear_Congruential_Generators
	    Three_Tuple rand_tuple = sim.funs.ProgramUtilitiesFun__Combined_Linear_Congruential_Generators((int)sim.vars.programGlobalVar__Rand1_Seed1, (int)sim.vars.programGlobalVar__Rand1_Seed2);
	    double rand = (double) rand_tuple.Ob1;
	    sim.vars.programGlobalVar__Rand1_Seed1 = (int) rand_tuple.Ob2; 
	    sim.vars.programGlobalVar__Rand1_Seed2 = (int) rand_tuple.Ob3;
	    //end Combined_Linear_Congruential_Generators -> rand "	Pseudo random number between (0,1)
	    int order_number = (int) Math.floor(rand * (double)(string_list_counter_1.size()) ) + 1 ;  //this gets 1 to N. counter 1 and 2 must have the same length
	    
	    Two_Tuple return_tuple = new Two_Tuple ();
	    return_tuple.Ob1 = sim.funs.ProgramUtilitiesFun__LinkedListString_Remove_and_Return_i_th_String( string_list_counter_1, order_number  ); //change the string_list
	    return_tuple.Ob2 = sim.funs.ProgramUtilitiesFun__LinkedListString_Remove_and_Return_i_th_String( string_list_counter_2, order_number  ); //change the string_list
	    return return_tuple;
	  }
	  else {
	    System.err.println("Error, sim.funs.ProgramUtilitiesFun__Get_A_Two_Tuple_String_From_Randomizing_A_Pair_Of_String_Lists has undefined method: " + random_method);
	    return null;
	  }
	}
			
	public  Three_Tuple ProgramUtilitiesFun__Get_A_Three_Tuple_String_From_Randomizing_Three_String_Lists (LinkedList<String> original_full_string_list_1, LinkedList<String> original_full_string_list_2, LinkedList<String> original_full_string_list_3, LinkedList<String> string_list_counter_1, LinkedList<String> string_list_counter_2, LinkedList<String> string_list_counter_3,String random_method){
	  
	  //System.out.println(original_full_string_list_1);
	  
	  //System.out.println(original_full_string_list_2);
	  
	  //System.out.println(original_full_string_list_3);
	  
	  if( original_full_string_list_1.size() == 0 || original_full_string_list_2.size() == 0 || original_full_string_list_3.size() == 0) {
	    System.out.println("WARNING! sim.funs.ProgramUtilitiesFun__Get_A_Three_Tuple_String_From_Randomizing_Three_String_Lists has an original_full_string_list.Count == 0");
	    return null;
	  }
	  
	  //error if three lists have different length
	  if( original_full_string_list_1.size() != original_full_string_list_2.size()  ||  original_full_string_list_1.size() != original_full_string_list_3.size() || original_full_string_list_2.size() != original_full_string_list_3.size()){
	    System.err.println("Error! sim.funs.ProgramUtilitiesFun__Get_A_Three_Tuple_String_From_Randomizing_Three_String_Lists has at least two original lists with different length." );
	    System.out.println("original_full_string_list_1.Count: " + original_full_string_list_1.size() + ", original_full_string_list_2.Count" + original_full_string_list_2.size() + ", original_full_string_list_3.Count" + original_full_string_list_3.size());
	    return null;
	  }
	  
	  //counter 1 and 2 and 3 must have the same length
	  if( string_list_counter_1.size() != string_list_counter_2.size() || string_list_counter_1.size() != string_list_counter_3.size() || string_list_counter_2.size() != string_list_counter_3.size()){
	    System.err.println("Error! sim.funs.ProgramUtilitiesFun__Get_A_Three_Tuple_String_From_Randomizing_Three_String_Lists has at least two counter lists with different length." );
	    return null;
	  }
	  
	  
	  //refill the counter lists if they are empty
	  if (string_list_counter_1.size() == 0 ){
	    for (String a_string  :  original_full_string_list_1) {
	      string_list_counter_1.addLast (a_string);
	    }
	  }
	  
	  if (string_list_counter_2.size() == 0 ){
	    for (String a_string  :  original_full_string_list_2) {
	      string_list_counter_2.addLast (a_string);
	    }
	  }
	  
	  if (string_list_counter_3.size() == 0 ){
	    for (String a_string  :  original_full_string_list_3) {
	      string_list_counter_3.addLast (a_string);
	    }
	  }
	  
	  
	  
	  if (random_method.equals( "fixed_order")){
	    Three_Tuple return_tuple = new Three_Tuple ();
	    return_tuple.Ob1 = string_list_counter_1.getFirst();
	    string_list_counter_1.removeFirst();
	    
	    return_tuple.Ob2 = string_list_counter_2.getFirst();
	    string_list_counter_2.removeFirst();
	    
	    return_tuple.Ob3 = string_list_counter_3.getFirst();
	    string_list_counter_3.removeFirst();
	    
	    return return_tuple;
	  }
	  else if(random_method.equals( "with_replacement")){
	    //Combined_Linear_Congruential_Generators
	    Three_Tuple rand_tuple = sim.funs.ProgramUtilitiesFun__Combined_Linear_Congruential_Generators(sim.vars.programGlobalVar__Rand1_Seed1, sim.vars.programGlobalVar__Rand1_Seed2);
	    double rand = (double) rand_tuple.Ob1;
	    sim.vars.programGlobalVar__Rand1_Seed1 = (int) rand_tuple.Ob2; 
	    sim.vars.programGlobalVar__Rand1_Seed2 = (int) rand_tuple.Ob3;
	    //end Combined_Linear_Congruential_Generators -> rand "	Pseudo random number between (0,1)
	    int order_number = (int) Math.floor(rand * (double)(original_full_string_list_1.size()) ) + 1 ;  //this gets 1 to N. list 1 and list 2 must have the same length
	    
	    Three_Tuple return_tuple = new Three_Tuple ();
	    return_tuple.Ob1 = sim.funs.ProgramUtilitiesFun__LinkedListString_Get_i_th_String( original_full_string_list_1, order_number ); //no change to the string_list
	    return_tuple.Ob2 = sim.funs.ProgramUtilitiesFun__LinkedListString_Get_i_th_String( original_full_string_list_2, order_number ); //no change to the string_list
	    return_tuple.Ob3 = sim.funs.ProgramUtilitiesFun__LinkedListString_Get_i_th_String( original_full_string_list_3, order_number ); //no change to the string_list
	    return return_tuple;
	  }
	  else if (random_method.equals( "without_replacement")){
	    //Combined_Linear_Congruential_Generators
	    Three_Tuple rand_tuple = sim.funs.ProgramUtilitiesFun__Combined_Linear_Congruential_Generators(sim.vars.programGlobalVar__Rand1_Seed1, sim.vars.programGlobalVar__Rand1_Seed2);
	    double rand = (double) rand_tuple.Ob1;
	    sim.vars.programGlobalVar__Rand1_Seed1 = (int) rand_tuple.Ob2; 
	    sim.vars.programGlobalVar__Rand1_Seed2 = (int) rand_tuple.Ob3;
	    //end Combined_Linear_Congruential_Generators -> rand "	Pseudo random number between (0,1)
	    int order_number = (int) Math.floor(rand * (double)(string_list_counter_1.size()) ) + 1 ;  //this gets 1 to N. counter 1 and 2 must have the same length
	    
	    Three_Tuple return_tuple = new Three_Tuple ();
	    return_tuple.Ob1 = sim.funs.ProgramUtilitiesFun__LinkedListString_Remove_and_Return_i_th_String( string_list_counter_1, order_number  ); //change the string_list
	    return_tuple.Ob2 = sim.funs.ProgramUtilitiesFun__LinkedListString_Remove_and_Return_i_th_String( string_list_counter_2, order_number  ); //change the string_list
	    return_tuple.Ob3 = sim.funs.ProgramUtilitiesFun__LinkedListString_Remove_and_Return_i_th_String( string_list_counter_3, order_number  ); //change the string_list
	    return return_tuple;
	  }
	  else {
	    System.err.println("Error, sim.funs.ProgramUtilitiesFun__Get_A_Three_Tuple_String_From_Randomizing_Three_String_Lists has undefined method: " + random_method);
	    return null;
	  }
	  
	}
			
	public  String ProgramUtilitiesFun__Get_A_String_From_Randomizing_A_String_List (LinkedList<String> original_full_string_list,LinkedList<String> string_list_counter, String random_method){
	  
	  //LinkedList<String> original_full_string_list_clone = sim.funs.ProgramUtilitiesFun__LinkedListString_Clone (original_full_string_list); //play it safe
	  //is already cloned outside
	  
	  if( original_full_string_list.size() == 0 ) {
	    System.out.println("WARNING! sim.funs.ProgramUtilitiesFun__Get_A_String_From_Randomizing_A_String_List has original_full_string_list.Count == 0 . ");
	    return null;
	  }
	  
	  //refill the counter list if it is empty
	  if (string_list_counter.size() == 0 ){
	    for (String a_string  :  original_full_string_list) {
	      string_list_counter.addLast (a_string);
	    }
	  }
	  
	  if (random_method.equals( "fixed_order")){
	    String return_string = string_list_counter.getFirst();
	    string_list_counter.removeFirst();
	    
	    return return_string;
	  }
	  else if(random_method.equals( "with_replacement")){
	    //Combined_Linear_Congruential_Generators
	    Three_Tuple rand_tuple = sim.funs.ProgramUtilitiesFun__Combined_Linear_Congruential_Generators(sim.vars.programGlobalVar__Rand1_Seed1, sim.vars.programGlobalVar__Rand1_Seed2);
	    double rand = (double) rand_tuple.Ob1;
	    sim.vars.programGlobalVar__Rand1_Seed1 = (int) rand_tuple.Ob2; 
	    sim.vars.programGlobalVar__Rand1_Seed2 = (int) rand_tuple.Ob3;
	    //end Combined_Linear_Congruential_Generators -> rand "	Pseudo random number between (0,1)
	    int order_number = (int) (Math.floor(rand * ((double) original_full_string_list.size()) ) + 1) ;  //this gets 1 to N.
	    return sim.funs.ProgramUtilitiesFun__LinkedListString_Get_i_th_String( original_full_string_list, order_number ); //no change to the string_list
	  }
	  else if (random_method.equals( "without_replacement")){
	    //Combined_Linear_Congruential_Generators
	    Three_Tuple rand_tuple = sim.funs.ProgramUtilitiesFun__Combined_Linear_Congruential_Generators(sim.vars.programGlobalVar__Rand1_Seed1, sim.vars.programGlobalVar__Rand1_Seed2);
	    double rand = (double) rand_tuple.Ob1;
	    sim.vars.programGlobalVar__Rand1_Seed1 = (int) rand_tuple.Ob2; 
	    sim.vars.programGlobalVar__Rand1_Seed2 = (int) rand_tuple.Ob3;
	    //end Combined_Linear_Congruential_Generators -> rand "	Pseudo random number between (0,1)
	    int order_number = (int) Math.floor(rand * (double)(string_list_counter.size()) ) + 1 ;  //this gets 1 to N.
	    return sim.funs.ProgramUtilitiesFun__LinkedListString_Remove_and_Return_i_th_String( string_list_counter, order_number  ); //change the string_list
	  }
	  
	  else if (random_method.charAt(0) == '=' ){ // refer to another method's random seed
	    String referred_method_name = random_method.substring(1);
	    if (!sim.vars.programGlobalVar__Block_Variable_Common_RandomMethod_Last_Seed.containsKey(referred_method_name)){
	      System.err.println("Error! sim.funs.ProgramUtilitiesFun__Get_A_String_From_Randomizing_A_String_List !sim.vars.programGlobalVar__Block_Variable_Common_RandomMethod_Last_Seed.containsKey(referred_method_name) : " + referred_method_name );
	      
	    }
	    Three_Tuple record = (Three_Tuple) sim.vars.programGlobalVar__Block_Variable_Common_RandomMethod_Last_Seed.get(referred_method_name);
	    String true_random_method = (String) record.Ob1;
	    int seed1 = (int) record.Ob2;
	    int seed2 = (int) record.Ob3;
	    
	    if (true_random_method.equals( "fixed_order")){
	      String return_string = string_list_counter.getFirst();
	      string_list_counter.removeFirst();
	      
	      return return_string;
	    }
	    else if(true_random_method.equals( "with_replacement")){
	      //Combined_Linear_Congruential_Generators
	      Three_Tuple rand_tuple = sim.funs.ProgramUtilitiesFun__Combined_Linear_Congruential_Generators(seed1, seed2);
	      double rand = (double) rand_tuple.Ob1;
	      //end Combined_Linear_Congruential_Generators -> rand "	Pseudo random number between (0,1)
	      int order_number = (int) Math.floor(rand * (double)(original_full_string_list.size()) ) + 1 ;  //this gets 1 to N.
	      return sim.funs.ProgramUtilitiesFun__LinkedListString_Get_i_th_String( original_full_string_list, order_number ); //no change to the string_list
	    }
	    else if (true_random_method.equals( "without_replacement")){
	      //Combined_Linear_Congruential_Generators
	      Three_Tuple rand_tuple = sim.funs.ProgramUtilitiesFun__Combined_Linear_Congruential_Generators(seed1, seed2);
	      double rand = (double) rand_tuple.Ob1;
	      //end Combined_Linear_Congruential_Generators -> rand "	Pseudo random number between (0,1)
	      int order_number = (int) Math.floor(rand * (double)(string_list_counter.size()) ) + 1 ;  //this gets 1 to N.
	      return sim.funs.ProgramUtilitiesFun__LinkedListString_Remove_and_Return_i_th_String( string_list_counter, order_number  ); //change the string_list
	    }
	    else {
	      System.err.println("Error, sim.funs.ProgramUtilitiesFun__Get_A_String_From_Randomizing_A_String_List has undefined true_random_method for referred case: " + random_method);
	      
	      return null;
	    }
	  }
	  
	  else {
	    System.err.println("Error, sim.funs.ProgramUtilitiesFun__Get_A_String_From_Randomizing_A_String_List has undefined method: " + random_method);
	    
	    return null;
	  }
	  
	  
	}			
		
	public  Six_Tuple ProgramUtilitiesFun__Get_A_Six_Tuple_String_From_Randomizing_Six_String_Lists (LinkedList<String> original_full_string_list_1, LinkedList<String> original_full_string_list_2, LinkedList<String> original_full_string_list_3, LinkedList<String> original_full_string_list_4, LinkedList<String> original_full_string_list_5,LinkedList<String> original_full_string_list_6,LinkedList<String> string_list_counter_1,LinkedList<String> string_list_counter_2,LinkedList<String> string_list_counter_3,LinkedList<String> string_list_counter_4,LinkedList<String> string_list_counter_5,LinkedList<String> string_list_counter_6, String random_method){
	  
	  if( original_full_string_list_1.size() == 0 || original_full_string_list_2.size() == 0 || original_full_string_list_3.size() == 0 || original_full_string_list_4.size() == 0 || original_full_string_list_5.size() == 0 || original_full_string_list_6.size() == 0) {
	    System.out.println("WARNING! sim.funs.ProgramUtilitiesFun__Get_A_Six_Tuple_String_From_Randomizing_Six_String_Lists has an original_full_string_list.Count == 0");
	    return null;
	  }
	  
	  //error if original lists have different length
	  if( !( (original_full_string_list_1.size() == original_full_string_list_2.size())  &&  (original_full_string_list_2.size() == original_full_string_list_3.size() ) && ( original_full_string_list_3.size() == original_full_string_list_4.size() ) && ( original_full_string_list_4.size() == original_full_string_list_5.size() ) && ( original_full_string_list_5.size() == original_full_string_list_6.size() ) ) ){
	    System.err.println("Error! sim.funs.ProgramUtilitiesFun__Get_A_Six_Tuple_String_From_Randomizing_Six_String_Lists has at least two original lists with different length." );
	    System.out.println("original_full_string_list_1.Count: " + original_full_string_list_1.size() + ", original_full_string_list_2.Count" + original_full_string_list_2.size() + ", original_full_string_list_3.Count" + original_full_string_list_3.size() + ", original_full_string_list_4.Count" + original_full_string_list_4.size() + ", original_full_string_list_5.Count" + original_full_string_list_5.size() + ", original_full_string_list_6.Count" + original_full_string_list_6.size());
	    return null;
	  }
	  
	  //counter lists must have the same length
	  if( !( (string_list_counter_1.size() == string_list_counter_2.size())  &&  (string_list_counter_2.size() == string_list_counter_3.size() ) && ( string_list_counter_3.size() == string_list_counter_4.size() ) && ( string_list_counter_4.size() == string_list_counter_5.size() ) && ( string_list_counter_5.size() == string_list_counter_6.size() ) ) ){
	    System.err.println("Error! sim.funs.ProgramUtilitiesFun__Get_A_Six_Tuple_String_From_Randomizing_Six_String_Lists has at least two counter lists with different length." );
	    return null;
	  }
	  
	  
	  //refill the counter lists if they are empty
	  if (string_list_counter_1.size() == 0 ){
	    for (String a_string  :  original_full_string_list_1) {
	      string_list_counter_1.addLast (a_string);
	    }
	  }
	  
	  if (string_list_counter_2.size() == 0 ){
	    for (String a_string  :  original_full_string_list_2) {
	      string_list_counter_2.addLast (a_string);
	    }
	  }
	  
	  if (string_list_counter_3.size() == 0 ){
	    for (String a_string  :  original_full_string_list_3) {
	      string_list_counter_3.addLast (a_string);
	    }
	  }
	  
	  if (string_list_counter_4.size() == 0 ){
	    for (String a_string  :  original_full_string_list_4) {
	      string_list_counter_4.addLast (a_string);
	    }
	  }
	  
	  if (string_list_counter_5.size() == 0 ){
	    for (String a_string  :  original_full_string_list_5) {
	      string_list_counter_5.addLast (a_string);
	    }
	  }
	  
	  if (string_list_counter_6.size() == 0 ){
	    for (String a_string  :  original_full_string_list_6) {
	      string_list_counter_6.addLast (a_string);
	    }
	  }
	  
	  
	  
	  if (random_method.equals( "fixed_order")){
	    Six_Tuple return_tuple = new Six_Tuple ();
	    return_tuple.Ob1 = string_list_counter_1.removeFirst();
	    
	    return_tuple.Ob2 = string_list_counter_2.removeFirst();
	    
	    return_tuple.Ob3 = string_list_counter_3.removeFirst();
	    
	    return_tuple.Ob4 = string_list_counter_4.removeFirst();
	    
	    return_tuple.Ob5 = string_list_counter_5.removeFirst();
	    
	    return_tuple.Ob6 = string_list_counter_6.removeFirst();
	    
	    return return_tuple;
	  }
	  else if(random_method.equals( "with_replacement")){
	    //Combined_Linear_Congruential_Generators
	    Three_Tuple rand_tuple = sim.funs.ProgramUtilitiesFun__Combined_Linear_Congruential_Generators(sim.vars.programGlobalVar__Rand1_Seed1, sim.vars.programGlobalVar__Rand1_Seed2);
	    double rand = (double) rand_tuple.Ob1;
	    sim.vars.programGlobalVar__Rand1_Seed1 = (int) rand_tuple.Ob2; 
	    sim.vars.programGlobalVar__Rand1_Seed2 = (int) rand_tuple.Ob3;
	    //end Combined_Linear_Congruential_Generators -> rand "	Pseudo random number between (0,1)
	    
	    int order_number =  ((Double)(rand * original_full_string_list_1.size())).intValue() + 1 ;  //this gets 1 to N. list 1 and list 2 must have the same length
	    
	    Six_Tuple return_tuple = new Six_Tuple ();
	    return_tuple.Ob1 = sim.funs.ProgramUtilitiesFun__LinkedListString_Get_i_th_String( original_full_string_list_1, order_number ); //no change to the string_list
	    return_tuple.Ob2 = sim.funs.ProgramUtilitiesFun__LinkedListString_Get_i_th_String( original_full_string_list_2, order_number ); //no change to the string_list
	    return_tuple.Ob3 = sim.funs.ProgramUtilitiesFun__LinkedListString_Get_i_th_String( original_full_string_list_3, order_number ); //no change to the string_list
	    return_tuple.Ob4 = sim.funs.ProgramUtilitiesFun__LinkedListString_Get_i_th_String( original_full_string_list_4, order_number ); //no change to the string_list
	    return_tuple.Ob5 = sim.funs.ProgramUtilitiesFun__LinkedListString_Get_i_th_String( original_full_string_list_5, order_number ); //no change to the string_list
	    return_tuple.Ob6 = sim.funs.ProgramUtilitiesFun__LinkedListString_Get_i_th_String( original_full_string_list_6, order_number ); //no change to the string_list
	    
	    return return_tuple;
	  }
	  else if (random_method.equals( "without_replacement")){
	    //Combined_Linear_Congruential_Generators
	    Three_Tuple rand_tuple = sim.funs.ProgramUtilitiesFun__Combined_Linear_Congruential_Generators(sim.vars.programGlobalVar__Rand1_Seed1, sim.vars.programGlobalVar__Rand1_Seed2);
	    double rand = (double) rand_tuple.Ob1;
	    sim.vars.programGlobalVar__Rand1_Seed1 = (int) rand_tuple.Ob2; 
	    sim.vars.programGlobalVar__Rand1_Seed2 = (int) rand_tuple.Ob3;
	    //end Combined_Linear_Congruential_Generators -> rand "	Pseudo random number between (0,1)
	    //int order_number = (int) Math.Floor(rand * Double.parseDouble(string_list_counter_1.size()) ) + 1 ;  //this gets 1 to N. counter 1 and 2 must have the same length
	    int order_number =  ((Double)(rand * original_full_string_list_1.size())).intValue() + 1 ;  //this gets 1 to N. list 1 and list 2 must have the same length
      
	    Six_Tuple return_tuple = new Six_Tuple ();
	    return_tuple.Ob1 = sim.funs.ProgramUtilitiesFun__LinkedListString_Remove_and_Return_i_th_String( string_list_counter_1, order_number  ); //change the string_list
	    return_tuple.Ob2 = sim.funs.ProgramUtilitiesFun__LinkedListString_Remove_and_Return_i_th_String( string_list_counter_2, order_number  ); //change the string_list
	    return_tuple.Ob3 = sim.funs.ProgramUtilitiesFun__LinkedListString_Remove_and_Return_i_th_String( string_list_counter_3, order_number  ); //change the string_list
	    return_tuple.Ob4 = sim.funs.ProgramUtilitiesFun__LinkedListString_Remove_and_Return_i_th_String( string_list_counter_4, order_number  ); //change the string_list
	    return_tuple.Ob5 = sim.funs.ProgramUtilitiesFun__LinkedListString_Remove_and_Return_i_th_String( string_list_counter_5, order_number  ); //change the string_list
	    return_tuple.Ob6 = sim.funs.ProgramUtilitiesFun__LinkedListString_Remove_and_Return_i_th_String( string_list_counter_6, order_number  ); //change the string_list
	    
	    return return_tuple;
	  }
	  else {
	    System.err.println("Error, sim.funs.ProgramUtilitiesFun__Get_A_Six_Tuple_String_From_Randomizing_Six_String_Lists has undefined method: " + random_method);
	    return null;
	  }
	  
	}
			
	public  double ProgramUtilitiesFun__Geometry2D_Point_Line_Distance (double line_x1,double line_y1,double line_x2,double line_y2,double point_x0,double point_y0){
	  return Math.abs( 	(line_x2   -  line_x1   ) * (line_y1 - point_y0)   	- 		(line_x1 - point_x0) * (line_y2 - line_y1) 	) 		/  		Math.sqrt( (line_x2 - line_x1)*(line_x2 - line_x1)  +  (line_y2 - line_y1) * (line_y2 - line_y1)   ) ;
	}
		
	public  LinkedList<String> ProgramUtilitiesFun__Combine_Quotation_In_LinkedList_String (LinkedList<String> parameter_list){
	  LinkedList<String> parameter_list_clone =  	ProgramUtilitiesFun__LinkedListString_Clone(parameter_list);
	  parameter_list.clear();
	  boolean quotation_open = false;
	  LinkedList<String> temp_string_list = new LinkedList<String> ();
	  String temp_string_alternative_method = "";
	  for (String a_string : parameter_list_clone){
	    if( quotation_open == false){
	      if (a_string.equals( "\"") || ( a_string.charAt(0) == '\"' && a_string.charAt(a_string.length()-1) != '\"') ){ // e.g., (... "x1 ... )
	        // don't add a_string to parameter_list
	        quotation_open = true;
	        temp_string_list.addLast(a_string);
	        temp_string_alternative_method += a_string;
	      }
	      else if ( a_string.charAt(0) != '\"' && a_string.charAt(a_string.length()-1) == '\"'){ // e.g., ( ... x3" ...)
	        //error
	        System.err.println("Error! TaskTemplateFun__Add_Trials_From_discrete_display_feedback_two_stages_method has :visual_text close quotation without previous open quotation: " + sim.funs.ProgramUtilitiesFun__LinkedListString_To_String_Show_Empty(parameter_list_clone));
	        break;
	      }
	      else { // e.g., (... "x" ...) ( a_string[0] == '\"' && a_string[a_string.Length-1] == '\"')  or  // e.g., (... x ...)  != !=
	        parameter_list.addLast(a_string);
	        //keep quotation_open = false
	        temp_string_list.clear();
	        temp_string_alternative_method = "";
	      }
	    }
	    else{ // quotation_open == true
	      if (!a_string.equals( "\"") && ( a_string.charAt(0) == '\"' && a_string.charAt(a_string.length()-1) != '\"') && (a_string.charAt(0) == '\"' && a_string.charAt(a_string.length()-1) == '\"') ){ // e.g., (..."x0  "x1 ... )  or (..."x0  "x1" ... ) 
	        //error
	        System.err.println("Error! TaskTemplateFun__Add_Trials_From_discrete_display_feedback_two_stages_method has :visual_text open quotation with previous open quotation: " + sim.funs.ProgramUtilitiesFun__LinkedListString_To_String_Show_Empty(parameter_list_clone));
	        break;
	      }
	      else if (a_string.equals( "\"") || ( a_string.charAt(0) != '\"' && a_string.charAt(a_string.length()-1) == '\"') ){ // e.g., ( .."x0 ... x3" ...)
	        temp_string_list.addLast(a_string); // "x0 ... x3"
	        temp_string_alternative_method += " " + a_string;
	        String temp_string = sim.funs.ProgramUtilitiesFun__LinkedListString_To_String_Show_Empty(temp_string_list);
	        
	        parameter_list.addLast( temp_string_alternative_method);
	        //parameter_list.addLast(temp_string);
	        temp_string_list.clear();
	        temp_string_alternative_method = "";
	        
	        quotation_open = false;
	      }
	      else { // e.g., (... x ...)  != !=
	        temp_string_list.addLast(a_string);
	        temp_string_alternative_method += " " + a_string;
	        //keep quotation_open = true
	        
	      }
	    }
	  }
	  if (quotation_open == true) {
	    //error
	    System.err.println("Error! TaskTemplateFun__Add_Trials_From_discrete_display_feedback_two_stages_method has :visual_text end without close quotation: " + sim.funs.ProgramUtilitiesFun__LinkedListString_To_String_Show_Empty(parameter_list_clone));
	    //break;	Not sure of this change
	  }
	  
	  //System.out.println("TaskTemplateFun__Add_Trials_From_discrete_display_feedback_two_stages_method: " + );
	  
	  return parameter_list;
	}
			
	public  void ProgramUtilitiesFun__Clear_Experiment_Trial_Parameter_List (){
	  
	  sim.files.Results_Experiment_Trial_Parameter_List.clear();
	  
//	  int i=1;
//	  int empty_lines = 0; //track continuously empty lines
//	  while ( true ){
//	    String temp_line = Communication.Experiment_Trial_Parameter_List.GetLine(i);
//	    if(temp_line.equals( "" )){
//	      empty_lines++;
//	    }
//	    else { //reset 
//	      empty_lines = 0;
//	    }
//	    if(empty_lines < 100){ // Trace output should not have more than 99 lines empty continously
//	      Communication.Experiment_Trial_Parameter_List.SetLine ("", i);
//	    }
//	    else break;
//	    i++;
//	  }
	  
	}
			
	public List<String> ProgramUtilitiesFun__Add_Sons_And_Sons_Of_A_Father_Rule_Into_ListString (String the_rule_name,List<String> the_result_list){
	  
	  Production_Rule rule_pointer = ProductionModuleFun__Find_Production_Rule_Pointer_By_Rule_Name(the_rule_name);
	  if(rule_pointer.Compilation_Sons.size() == 0){//if the rule has no son, return the_result_list. 
	    return the_result_list;
	  }
	  else{
	    //Else (has son), add all son names into the result list,
	    for (String a_son_name : rule_pointer.Compilation_Sons){
	      if(!the_result_list.contains(a_son_name)){
	        the_result_list.add(a_son_name);
	      }
	      //and call this function with each son鑼呴垾鏂猴拷姣仮閾板ソ銉嫹绡撹寘閿熻剼鐭靛槑銉冿腹锟芥鎳娾斁锟芥緹璇ヮ灎寰奉櫑me and the current result list.
	      the_result_list = sim.funs.ProgramUtilitiesFun__Add_Sons_And_Sons_Of_A_Father_Rule_Into_ListString(a_son_name, the_result_list);
	    }
	    
	    //  Return the result list.
	    return the_result_list;
	  }
	  
	}
			
	public  List<String> ProgramUtilitiesFun__Add_Fathers_And_Fathers_Of_A_Rule_Into_ListString (String the_rule_name,List<String> the_result_list){
	  
	  Production_Rule rule_pointer = ProductionModuleFun__Find_Production_Rule_Pointer_By_Rule_Name(the_rule_name);
	  if(rule_pointer.Compilation_Father.equals( "" )){ //If the rule has no father, return the result list.
	    return the_result_list;
	  }
	  else{
	    //	Else (has a father), add the father name (that is not already in the result list) into the result list, 
	    if(!the_result_list.contains(rule_pointer.Compilation_Father)){
	      the_result_list.add(rule_pointer.Compilation_Father);
	      //and call this function with the father name and the current result list.
	      the_result_list = sim.funs.ProgramUtilitiesFun__Add_Fathers_And_Fathers_Of_A_Rule_Into_ListString(rule_pointer.Compilation_Father, the_result_list);
	    }
	    
	    // Return the result list.
	    return the_result_list;
	  }
	}
			
	public  int ProgramUtilitiesFun__Act_R_Random_Integer (double limit){
	  
	  // sim.vars.programGlobalVar__Rand2_Seed1?
	  
	  // get a random in [0,1]
	  Three_Tuple rand_tuple = sim.funs.ProgramUtilitiesFun__Combined_Linear_Congruential_Generators(sim.vars.programGlobalVar__Rand2_Seed1, sim.vars.programGlobalVar__Rand2_Seed2);
	  double rand = (double) rand_tuple.Ob1;
	  sim.vars.programGlobalVar__Rand2_Seed1 = (int) rand_tuple.Ob2;
	  sim.vars.programGlobalVar__Rand2_Seed2 = (int) rand_tuple.Ob3;
	  // return random integer less than limit
	  return (int)(limit * rand);
	}
	
	
  public boolean ProgramUtilitiesFun__StringsEqualByStringOrDouble(String str1, String Str2){

    if(ProgramUtilitiesFun__Is_String_Double(str1) && ProgramUtilitiesFun__Is_String_Double(Str2)){ // compare value
      if(Double.parseDouble(str1) == Double.parseDouble(Str2) ){ 
        return true;
      }
      else return false;
    }
    else{ // compare String
      if(str1.equals(Str2) ){ 
        return true;
      }
      else return false;
    }               
  
}
	
  public void ProgramUtilitiesFun__SimulationFinalizationCode(){
    PrintingFun__Print_At_Simulation_End();

    //display some customized result output
    
    //Hashtable dynamic_items = TaskTemplateFun__Get_Current_Dynamic_Items();
    //Model.Message(dynamic_items.ContainsKey("text_gender"));
    
  }
  
	//SpeechModuleFun
		
  /**
   *
   *  
// set an explicit time to articulate a string in the current model.  That time will be used by the audio module as the duration of such a string if it is heard by the model and will be the length of time that the model requires to speak such a string using the speech module. 
Get-articulation-time returns the time it takes to articulate a string of text for the current model.  That time will be either the explicit time that was set using register-articulation-time if one was set, or computed based on the length of the string and the values of the parameters :syllable-rate and :char-per-syllable using this equation:
AT = r * L / c

AT := articulation time for the string
r := value of the :syllable-rate parameter
L := the length of the string
c := value of the :char-per-syllable parameter 

If the string is invalid or there is no current model then a warning is printed and nil is returned instead.
   * @param the_text
   * @return
   */
	public double SpeechModuleFun__Get_Articulation_Time(String the_text){
	  
	  if (sim.vars.speechModule.Articulation_Time_Table.containsKey( the_text ) == true){
	    return (double)sim.vars.speechModule.Articulation_Time_Table.get(the_text);
	  }
	  else{
	    double r = sim.vars.speechModule.Syllable_Rate;
	    double L = (double) the_text.length();
	    double c = sim.vars.speechModule.Char_Per_Syllable;
	    return (double) (r * L / c);
	  }
	}
		
  public double SpeechModuleFun__Compute_Finish_Time (Chunk the_chunk_spec){
	  String command_type = the_chunk_spec.Chunk_Type;
	  switch(command_type){
	    case "speak":{ 
	      command_type = "subvocalize";
	    }
	    case "subvocalize":{ 
	      /* 
		(defmethod compute-finish-time ((spch-mod speech-module) (mvmt speak))
		  (+ (exec-time mvmt) (get-art-time spch-mod (text mvmt))))
	       */
	      String text = sim.funs.ChunkFun__Get_Chunk_Slot_Value(the_chunk_spec, "string");
	      //System.out.println("SpeechModuleFun__Compute_Finish_Time subvocalize text: " + text);
	      if (text.equals( "_No_Such_Slot_Name_")) return 0.0;
	      else  return  SpeechModuleFun__Get_Articulation_Time(text);
	    }
	    case "":{
	      System.err.println("SpeechModuleFun__Compute_Finish_Time has an empty ISA command type.");
	      break;
	    }
	    default: {
	      System.err.println("SpeechModuleFun__Compute_Finish_Time has undefined command_type case: " + command_type);
	      break;
	    }	
	  }
	  return 0.0;
	}
			
	public double SpeechModuleFun__Compute_Preparation_Time (Chunk the_chunk_spec){
	  //ACT-R reference manual: If there is no previous String which has been spoken, then the module takes .15 seconds in preparation.
	  if(sim.vars.speechModule.Last_Command.Chunk_Type.equals( "" ) || sim.vars.speechModule.Last_Command.Slot.containsKey("string") == false || ((String)sim.vars.speechModule.Last_Command.Slot.get("string")).equals( "" )) {
	    if (sim.vars.speechModule.Last_Command.Slot.containsKey("string") && ((String)sim.vars.speechModule.Last_Command.Slot.get("string")).equals( "" )) System.out.println("SpeechModuleFun__Compute_Preparation_Time has last speak empty String, check ACT-R to see which case this is.");
	    //System.out.println("_"+ sim.vars.speechModule.Last_Command.Chunk_Type + "_"  + sim.vars.speechModule.Last_Command.Slot["string"] + "_" + the_chunk_spec.Chunk_Type + "_" + the_chunk_spec.Slot["string"] + "_");
	    return 0.15;
	  }
	  else{//If there is a previously spoken String, then the preparation time is 0 seconds if the same String is being output again and .1 seconds if it is a different String.
	    if ( the_chunk_spec.Slot.containsKey("string") == false ) {
	      System.out.println("SpeechModuleFun__Compute_Preparation_Time has input chunk_spec does not have a String slot-name");
	      return 0.0;
	    }
	    if (((String)the_chunk_spec.Slot.get("string")).equals( "" )){
	      System.out.println("SpeechModuleFun__Compute_Preparation_Time has input a String that is empty.");
	      return 0.0;
	    }
	    if ( ((String)the_chunk_spec.Slot.get("string")).equals((String)sim.vars.speechModule.Last_Command.Slot.get("string") ) ) return 0.0;
	    else {
	      return 0.1;
	    }
	    
	    
	    
	    
	  }
	}
	
	
	//TaskTemplateFun
	
	public  void TaskTemplateFun__Add_Other_Car_To_World3D (LinkedList<String> Parameter_List){
	  LinkedList<String> Parameter_List_Clone = sim.funs.ProgramUtilitiesFun__LinkedListString_Clone (Parameter_List);
	  
	  World3D_OtherCar a_car = new World3D_OtherCar();
	  
	  String a_parameter;
	  while ( Parameter_List_Clone.size() > 0 ) {
	    switch (Parameter_List_Clone.getFirst().toLowerCase()) {
	      
	      case ":start_road_name" : {//String
	        String parameter_name = Parameter_List_Clone.getFirst().toLowerCase();
	        Parameter_List_Clone.removeFirst(); // remove the parameter name
	        if ( Parameter_List_Clone.size() < 1 ) { System.err.println ("Error! TaskTemplateFun__Add_Other_Car_To_World3D " + parameter_name + " needs 1 parameter"); }
	        a_parameter = Parameter_List_Clone.getFirst();  //needs a single parameter
	        Parameter_List_Clone.removeFirst();
	        if ( a_parameter.charAt(0) == ':' || a_parameter.charAt(0) == '(' || a_parameter.charAt(0) == ')' ){ System.out.println ("Error! TaskTemplateFun__Add_Other_Car_To_World3D " + parameter_name + " needs 1 parameter. not " + a_parameter);}
	        
	        a_car.Start_Road_Name = a_parameter ;
	        
	        break;
	      }
	      
	      case ":start_distance" : 
	      case ":max_speed":
	      case ":speed":
	      { //double
	        String parameter_name = Parameter_List_Clone.getFirst().toLowerCase();
	        Parameter_List_Clone.removeFirst(); // remove the parameter name
	        if ( Parameter_List_Clone.size() < 1 ) { System.err.println ("Error! TaskTemplateFun__Add_Other_Car_To_World3D " + parameter_name + " needs 1 parameter"); }
	        a_parameter = Parameter_List_Clone.getFirst();  //needs a single parameter
	        Parameter_List_Clone.removeFirst();
	        if ( a_parameter.charAt(0) == ':' || a_parameter.charAt(0) == '(' || a_parameter.charAt(0) == ')' ){ System.out.println ("Error! TaskTemplateFun__Add_Other_Car_To_World3D " + parameter_name + " needs 1 parameter. not " + a_parameter);}
	        
	        if ( (sim.funs.ProgramUtilitiesFun__Is_String_Double(a_parameter) == false)) System.err.println ("Error TaskTemplateFun__Add_Other_Car_To_World3D " + parameter_name + " needs a double number. not " + a_parameter);
	        
	        if(parameter_name.equals( ":start_distance"))a_car.Start_Distance = (double) Double.parseDouble (a_parameter) ;
	        if(parameter_name.equals( ":max_speed"))a_car.Max_Speed = (double) Double.parseDouble (a_parameter) ;
	        if(parameter_name.equals( ":speed"))a_car.Speed = (double) Double.parseDouble (a_parameter) ;
	        
	        break;
	      }
	      
	      case ":start_lane_num" : {// int
	        String parameter_name = Parameter_List_Clone.getFirst().toLowerCase();
	        Parameter_List_Clone.removeFirst(); // remove the parameter name
	        if ( Parameter_List_Clone.size() < 1 ) { System.err.println ("Error! TaskTemplateFun__Add_Other_Car_To_World3D " + parameter_name + " needs 1 parameter"); }
	        a_parameter = Parameter_List_Clone.getFirst();  //needs a single parameter
	        Parameter_List_Clone.removeFirst();
	        if ( a_parameter.charAt(0) == ':' || a_parameter.charAt(0) == '(' || a_parameter.charAt(0) == ')' ){ System.err.println ("Error! TaskTemplateFun__Add_Other_Car_To_World3D " + parameter_name + " needs 1 parameter. not " + a_parameter);}
	        
	        if ( (sim.funs.ProgramUtilitiesFun__Is_String_Int(a_parameter) == false)) System.err.println ("Error TaskTemplateFun__Add_Other_Car_To_World3D " + parameter_name + " needs a integer number. not " + a_parameter);
	        
	        a_car.Start_Lane_Num = Integer.parseInt (a_parameter) ;
	        
	        break;
	      }
	      default:
	      {
	        if(sim.vars.printingModule.Popout_Message) System.out.println ("WARNING! TaskTemplateFun__Add_Other_Car_To_World3D. the Key is undefined: " + Parameter_List_Clone.getFirst());
	        Parameter_List_Clone.removeFirst();
	        break;
	      }
	      
	    }
	  }		
	  
	  String world3d_id = Integer.toString(sim.vars.world3DTemplate.World.Object_Num); //start from 0
	  sim.vars.world3DTemplate.World.Object_Num ++;
	  sim.vars.world3DTemplate.World.Objects.put(world3d_id, a_car );
	  a_car.World3D_ID = world3d_id;
	  if( sim.vars.world3DTemplate.Method_Object != null && (sim.vars.world3DTemplate.Method_Object instanceof World3D_Template_Driving_Method)) {
	    World3D_Template_Driving_Method the_method = (World3D_Template_Driving_Method) sim.vars.world3DTemplate.Method_Object;
	    the_method.OtherCar_World3D_ID.add(a_car.World3D_ID);
	  }
	  
	}
	
	public  void TaskTemplateFun__Add_Road_To_World3D (LinkedList<String> Parameter_List){
	  	  
	  LinkedList<String> Parameter_List_Clone = sim.funs.ProgramUtilitiesFun__LinkedListString_Clone ( Parameter_List );
	  
	  World3D_Road a_road = new World3D_Road();
	  
	  
	  String a_parameter;
	  while ( Parameter_List_Clone.size() > 0 ) {
	    switch (Parameter_List_Clone.getFirst().toLowerCase()) {
	      
	      //String cases
	      case ":name" : 
	      case ":hide":
	      {
	        String parameter_name = Parameter_List_Clone.getFirst().toLowerCase();
	        Parameter_List_Clone.removeFirst(); // remove the parameter name
	        if ( Parameter_List_Clone.size() < 1 ) { System.err.println ("Error! TaskTemplateFun__Add_Road_To_World3D " + parameter_name + " needs 1 parameter"); }
	        a_parameter = Parameter_List_Clone.getFirst();  //needs a single parameter
	        Parameter_List_Clone.removeFirst();
	        if ( a_parameter.charAt(0) == ':' || a_parameter.charAt(0) == '(' || a_parameter.charAt(0) == ')' ){ System.out.println ("Error! TaskTemplateFun__Add_Road_To_World3D " + parameter_name + " needs 1 parameter. not " + a_parameter);}
	        
	        switch(parameter_name){
	          case ":name":{
	            a_road.Name = a_parameter ;
	            break;
	          }
	          case ":hide":{
	            if ( a_parameter.equals( "t") ) a_road.hide = true;
	            else if (a_parameter.equals( "nil")) a_road.hide = false;
	            else {
	              System.out.println("WARNING! TaskTemplateFun__Add_Road_To_World3D has parameter_name undefined value: " + a_parameter);
	            }
	            break;
	          }
	          default:{
	            System.err.println ("Error! TaskTemplateFun__Add_Road_To_World3D has undefined parameter_name" + parameter_name );
	            break;
	          }
	        }
	        break;
	      }
	      
	      case ":start_loc_x" : {
	        String parameter_name = Parameter_List_Clone.getFirst().toLowerCase();
	        Parameter_List_Clone.removeFirst(); // remove the parameter name
	        if ( Parameter_List_Clone.size() < 1 ) { System.err.println ("Error! TaskTemplateFun__Add_Road_To_World3D " + parameter_name + " needs 1 parameter"); }
	        a_parameter = Parameter_List_Clone.getFirst();  //needs a single parameter
	        Parameter_List_Clone.removeFirst();
	        if ( a_parameter.charAt(0) == ':' || a_parameter.charAt(0) == '(' || a_parameter.charAt(0) == ')' ){ System.out.println ("Error! TaskTemplateFun__Add_Road_To_World3D " + parameter_name + " needs 1 parameter. not " + a_parameter);}
	        
	        if ( (sim.funs.ProgramUtilitiesFun__Is_String_Double(a_parameter) == false)) System.out.println ("Error TaskTemplateFun__Add_Road_To_World3D " + parameter_name + " needs a double number. not " + a_parameter);
	        
	        a_road.Start_Loc_X = Double.parseDouble (a_parameter) ;
	        
	        break;
	      }		
	      
	      case ":start_loc_z" : {
	        String parameter_name = Parameter_List_Clone.getFirst().toLowerCase();
	        Parameter_List_Clone.removeFirst(); // remove the parameter name
	        if ( Parameter_List_Clone.size() < 1 ) { System.err.println ("Error! TaskTemplateFun__Add_Road_To_World3D " + parameter_name + " needs 1 parameter"); }
	        a_parameter = Parameter_List_Clone.getFirst();  //needs a single parameter
	        Parameter_List_Clone.removeFirst();
	        if ( a_parameter.charAt(0) == ':' || a_parameter.charAt(0) == '(' || a_parameter.charAt(0) == ')' ){ System.err.println ("Error! TaskTemplateFun__Add_Road_To_World3D " + parameter_name + " needs 1 parameter. not " + a_parameter);}
	        
	        if ( (sim.funs.ProgramUtilitiesFun__Is_String_Double(a_parameter) == false)) System.err.println ("Error TaskTemplateFun__Add_Road_To_World3D " + parameter_name + " needs a double number. not " + a_parameter);
	        
	        a_road.Start_Loc_Z = Double.parseDouble (a_parameter) ;
	        
	        break;
	      }
	      
	      case ":start_heading_angle" : {
	        String parameter_name = Parameter_List_Clone.getFirst().toLowerCase();
	        Parameter_List_Clone.removeFirst(); // remove the parameter name
	        if ( Parameter_List_Clone.size() < 1 ) { System.err.println ("Error! TaskTemplateFun__Add_Road_To_World3D " + parameter_name + " needs 1 parameter"); }
	        a_parameter = Parameter_List_Clone.getFirst();  //needs a single parameter
	        Parameter_List_Clone.removeFirst();
	        if ( a_parameter.charAt(0) == ':' || a_parameter.charAt(0) == '(' || a_parameter.charAt(0) == ')' ){ System.err.println ("Error! TaskTemplateFun__Add_Road_To_World3D " + parameter_name + " needs 1 parameter. not " + a_parameter);}
	        
	        if ( (sim.funs.ProgramUtilitiesFun__Is_String_Double(a_parameter) == false)) System.err.println ("Error TaskTemplateFun__Add_Road_To_World3D " + parameter_name + " needs a double number. not " + a_parameter);
	        
	        a_road.Start_Heading_Angle = Double.parseDouble (a_parameter) ;
	        
	        break;
	      }
	      
	      case ":lane_width" : {
	        String parameter_name = Parameter_List_Clone.getFirst().toLowerCase();
	        Parameter_List_Clone.removeFirst(); // remove the parameter name
	        if ( Parameter_List_Clone.size() < 1 ) { System.err.println ("Error! TaskTemplateFun__Add_Road_To_World3D " + parameter_name + " needs 1 parameter"); }
	        a_parameter = Parameter_List_Clone.getFirst();  //needs a single parameter
	        Parameter_List_Clone.removeFirst();
	        if ( a_parameter.charAt(0) == ':' || a_parameter.charAt(0) == '(' || a_parameter.charAt(0) == ')' ){ System.err.println ("Error! TaskTemplateFun__Add_Road_To_World3D " + parameter_name + " needs 1 parameter. not " + a_parameter);}
	        
	        if ( (sim.funs.ProgramUtilitiesFun__Is_String_Double(a_parameter) == false)) System.err.println ("Error TaskTemplateFun__Add_Road_To_World3D " + parameter_name + " needs a double number. not " + a_parameter);
	        
	        a_road.Lane_Width = Double.parseDouble (a_parameter) ;
	        
	        break;
	      }
	      
	      case ":lane_num_left" : {
	        String parameter_name = Parameter_List_Clone.getFirst().toLowerCase();
	        Parameter_List_Clone.removeFirst(); // remove the parameter name
	        if ( Parameter_List_Clone.size() < 1 ) { System.err.println ("Error! TaskTemplateFun__Add_Road_To_World3D " + parameter_name + " needs 1 parameter"); }
	        a_parameter = Parameter_List_Clone.getFirst();  //needs a single parameter
	        Parameter_List_Clone.removeFirst();
	        if ( a_parameter.charAt(0) == ':' || a_parameter.charAt(0) == '(' || a_parameter.charAt(0) == ')' ){ System.err.println ("Error! TaskTemplateFun__Add_Road_To_World3D " + parameter_name + " needs 1 parameter. not " + a_parameter);}
	        
	        if ( (sim.funs.ProgramUtilitiesFun__Is_String_Int(a_parameter) == false)) System.err.println ("Error TaskTemplateFun__Add_Road_To_World3D " + parameter_name + " needs a integer number. not " + a_parameter);
	        
	        a_road.Lane_Num_Left = Integer.parseInt (a_parameter) ;
	        
	        break;
	      }
	      
	      case ":lane_num_right" : {
	        String parameter_name = Parameter_List_Clone.getFirst().toLowerCase();
	        Parameter_List_Clone.removeFirst(); // remove the parameter name
	        if ( Parameter_List_Clone.size() < 1 ) { System.err.println ("Error! TaskTemplateFun__Add_Road_To_World3D " + parameter_name + " needs 1 parameter"); }
	        a_parameter = Parameter_List_Clone.getFirst();  //needs a single parameter
	        Parameter_List_Clone.removeFirst();
	        if ( a_parameter.charAt(0) == ':' || a_parameter.charAt(0) == '(' || a_parameter.charAt(0) == ')' ){ System.err.println ("Error! TaskTemplateFun__Add_Road_To_World3D " + parameter_name + " needs 1 parameter. not " + a_parameter);}
	        
	        if ( (sim.funs.ProgramUtilitiesFun__Is_String_Int(a_parameter) == false)) System.err.println ("Error TaskTemplateFun__Add_Road_To_World3D " + parameter_name + " needs a integer number. not " + a_parameter);
	        
	        a_road.Lane_Num_Right = Integer.parseInt (a_parameter) ;
	        
	        break;
	      }
	      
	      case "(" : { //here means the () of multiple () parentheses, each representing the method to generate each road segment.
	        LinkedList<String> a_list = sim.funs.ParametersFun__Remove_A_List_From_Initialization_Lists	(Parameter_List_Clone);  // the first () is poped out without () from the list
	        if (a_list == null) { 
	          System.err.println ("Error! TaskTemplateFun__Add_Road_To_World3D the parameters for each item displayed needs parameters");  
	          break;
	        }
	        
	        World3D_Road_Segment a_segment = new World3D_Road_Segment();
	        
	        //initilize the method details from outside .txt file setting: a_list loaded here
	        while ( a_list.size() > 0 ) {
	          switch (a_list.getFirst().toLowerCase()) {
	            case ":segment_type" : {
	              String parameter_name = a_list.getFirst().toLowerCase();
	              a_list.removeFirst();
	              if ( a_list.size() < 1 ) { System.err.println ("Error TaskTemplateFun__Add_Road_To_World3D " + parameter_name + " needs 1 parameter"); }
	              String parameter_value = a_list.getFirst().toLowerCase();
	              if ( (parameter_value.charAt(0) == ':' ) ||  parameter_value.charAt(0) == '(' || parameter_value.charAt(0) == ')' ){
	                System.err.println ("Error TaskTemplateFun__Add_Road_To_World3D " + parameter_name + " needs 1 parameter. not " + parameter_value);
	                break;
	              }
	              if ( !parameter_value.equals( "straight") && !parameter_value.equals( "left" ) && !parameter_value.equals( "right" )  ){
	                System.err.println ("Error TaskTemplateFun__Add_Road_To_World3D " + parameter_name + " needs straight, OR left, OR right, not " + parameter_value);
	                break;
	              }
	              a_list.removeFirst();
	              
	              a_segment.Type = parameter_value;
	              
	              break;
	            }
	            
	            case ":length" : {
	              String parameter_name = a_list.getFirst().toLowerCase();
	              a_list.removeFirst();
	              if ( a_list.size() < 1 ) { System.err.println ("Error TaskTemplateFun__Add_Road_To_World3D " + parameter_name + " needs 1 parameter"); }
	              String parameter_value = a_list.getFirst().toLowerCase();
	              if ( (parameter_value.charAt(0) == ':' ) ||  parameter_value.charAt(0) == '(' || parameter_value.charAt(0) == ')' ){
	                System.err.println ("Error TaskTemplateFun__Add_Road_To_World3D " + parameter_name + " needs 1 parameter. not " + parameter_value);
	                break;
	              }
	              if (!ProgramUtilitiesFun__Is_String_Double(parameter_value)){
	                System.err.println ("Error TaskTemplateFun__Add_Road_To_World3D " + parameter_name + " needs double number. not " + parameter_value);
	                break;
	              }
	              a_list.removeFirst();
	              
	              a_segment.Length = Float.parseFloat(parameter_value);
	              
	              break;
	            }
	            
	            case ":turn_angle" : {
	              String parameter_name = a_list.getFirst().toLowerCase();
	              a_list.removeFirst();
	              if ( a_list.size() < 1 ) { System.out.println ("Error TaskTemplateFun__Add_Road_To_World3D " + parameter_name + " needs 1 parameter"); }
	              String parameter_value = a_list.getFirst().toLowerCase();
	              if ( (parameter_value.charAt(0) == ':' ) ||  parameter_value.charAt(0) == '(' || parameter_value.charAt(0) == ')' ){
	                System.err.println ("Error TaskTemplateFun__Add_Road_To_World3D " + parameter_name + " needs 1 parameter. not " + parameter_value);
	                break;
	              }
	              if (!ProgramUtilitiesFun__Is_String_Double(parameter_value)){
	                System.err.println ("Error TaskTemplateFun__Add_Road_To_World3D " + parameter_name + " needs double number. not " + parameter_value);
	                break;
	              }
	              a_list.removeFirst();
	              
	              a_segment.Turn_Angle = (double) Double.parseDouble(parameter_value);
	              
	              break;
	            }					
	            
	            
	            default:
	            {
	              System.err.println ("Error! TaskTemplateFun__Add_Road_To_World3D error! parameters for an road segment, the Key is undefined: " + a_list.getFirst());
	              
	              SimSystem.abort();
	              
	              a_list.removeFirst();
	              
	              break;
	            }
	          }
	        }
	        a_road.Segments.addLast(a_segment);
	        break;
	      } //end of a () parentheses pair for a segment
	      
	      
	      default:
	      {
	        if(sim.vars.printingModule.Popout_Message) System.out.println ("WARNING! TaskTemplateFun__Add_Road_To_World3D. the Key is undefined: " + Parameter_List_Clone.getFirst());
	        Parameter_List_Clone.removeFirst();
	        break;
	      }
	      
	    }
	  }
	  
	  //compute fragments
	  double current_loc_x = a_road.Start_Loc_X;
	  double current_loc_z = a_road.Start_Loc_Z;
	  double current_heading_angle = a_road.Start_Heading_Angle;
	  double current_distance = 0.0;
	  
	  for (World3D_Road_Segment a_segment : a_road.Segments){
	    //for the segment
	    a_segment.Distance_Start = (double) current_distance;
	    a_segment.Distance_End = a_segment.Distance_Start + a_segment.Length;
	    a_segment.Start_Heading_Angle = (double) current_heading_angle;
	    a_segment.Start_Loc_X = (double) current_loc_x;
	    a_segment.Start_Loc_Z = (double) current_loc_z;
	    
	    //generate fragments	Hashtable< double start_distance, World3D_Road_Fragment> 
	    if(a_segment.Type.equals( "straight")){ // just one fragment
	      if (a_segment.Turn_Angle != 0.0){
	        System.err.println("Error! TaskTemplateFun__Add_Road_To_World3D left turn segment needs Turn_Angle == 0, not: " + a_segment.Turn_Angle);
	        break;
	      }
	      World3D_Road_Fragment a_fragment = new World3D_Road_Fragment ();
	      a_fragment.Distance_Start = a_segment.Distance_Start;
	      a_fragment.Distance_End   = a_segment.Distance_End;
	      a_fragment.Length        = a_segment.Length;
	      a_fragment.Start_Heading_Angle = a_segment.Start_Heading_Angle;
	      a_fragment.Start_Loc_X = a_segment.Start_Loc_X;
	      a_fragment.Start_Loc_Z = a_segment.Start_Loc_Z;
	      a_fragment.Turn_Angle = (double) a_segment.Turn_Angle; // 0,0
	      a_fragment.End_Loc_X = (double) (a_fragment.Start_Loc_X + a_fragment.Length * Math.sin( a_fragment.Start_Heading_Angle / 180.0  * Math.PI ));
	      a_fragment.End_Loc_Z = (double) (a_fragment.Start_Loc_Z + a_fragment.Length * Math.cos( a_fragment.Start_Heading_Angle / 180.0  * Math.PI ));
	      
	      a_road.Fragments.put(a_fragment.Distance_Start, a_fragment);
	      
	      //update current
	      current_loc_x = a_fragment.End_Loc_X;
	      current_loc_z = a_fragment.End_Loc_Z;
	      current_heading_angle = a_fragment.Start_Heading_Angle + a_fragment.Turn_Angle;
	      current_distance = a_fragment.Distance_End;
	      
	      a_segment.End_Loc_X = (double) current_loc_x;
	      a_segment.End_Loc_Z = (double) current_loc_z;
	    } //end of straight segment
	    else if (a_segment.Type.equals( "left") || a_segment.Type.equals( "right")){ //curve segment
	      if (a_segment.Type.equals( "left") && a_segment.Turn_Angle >= 0.0){
	        System.err.println("Error! TaskTemplateFun__Add_Road_To_World3D left turn segment needs Turn_Angle < 0");
	        break;
	      }
	      if (a_segment.Type.equals( "right") && a_segment.Turn_Angle <= 0.0){
	        System.err.println("Error! TaskTemplateFun__Add_Road_To_World3D right turn segment needs Turn_Angle > 0");
	        break;
	      }
	      
	      double fragment_length_default = sim.vars.programGlobalVar__World3D_Curve_Fragment_Length;
	      if(a_segment.Length < fragment_length_default){
	        System.err.println("Error! TaskTemplateFun__Add_Road_To_World3D left turn segment has a_segment.length() < fragment_length_default");
	        break;
	      }
	      
	      while( current_distance < a_segment.Distance_End ){ //add fragment, each fragment is straight
	        double fragment_length;
	        if( current_distance + fragment_length_default <= a_segment.Distance_End ) fragment_length = fragment_length_default;
	        else fragment_length = a_segment.Distance_End - current_distance;
	        World3D_Road_Fragment a_fragment = new World3D_Road_Fragment ();
	        a_fragment.Distance_Start = (double) current_distance;
	        a_fragment.Distance_End   = (double) (a_fragment.Distance_Start + fragment_length);
	        a_fragment.Length       = (double) fragment_length;
	        a_fragment.Start_Heading_Angle = (double) current_heading_angle;
	        a_fragment.Start_Loc_X = (double) current_loc_x;
	        a_fragment.Start_Loc_Z = (double) current_loc_z;
	        a_fragment.Turn_Angle = (double) (a_segment.Turn_Angle / a_segment.Length * a_fragment.Length); 
	        
	        double turn_angle_radian = a_fragment.Turn_Angle / 180.0  * Math.PI ;
	        
	        
	        //double turn_radius = a_fragment.length() / turn_angle_radian;
	        double turn_radius ;
	        double turn_angle_radian_magnitude = sim.funs.ProgramUtilitiesFun__Absolute_Angle_Radian_Within_Zero_To_2PI(turn_angle_radian);
	        double direct_line_length;
	        if(turn_angle_radian_magnitude == 0.0){
	          turn_radius = a_fragment.Length;
	          direct_line_length = turn_radius;
	        }
	        else{
	          turn_radius = a_fragment.Length / turn_angle_radian_magnitude;
	          direct_line_length =  Math.abs( 2.0 * turn_radius * Math.sin( turn_angle_radian / 2.0) );
	        }
	        
	        
	        
	        a_fragment.End_Loc_X = (double) (a_fragment.Start_Loc_X + direct_line_length * Math.sin( (a_fragment.Start_Heading_Angle + a_fragment.Turn_Angle / 2.0) / 180.0  * Math.PI ));
	        a_fragment.End_Loc_Z = (double) (a_fragment.Start_Loc_Z + direct_line_length * Math.cos( (a_fragment.Start_Heading_Angle + a_fragment.Turn_Angle / 2.0) / 180.0  * Math.PI ));
	        
	        //if( current_distance> 500 && current_distance < 550) System.out.println(a_fragment.Turn_Angle + " " + a_fragment.Start_Loc_Z	+ " " + a_fragment.End_Loc_Z		);
	        
	        a_road.Fragments.put(a_fragment.Distance_Start, a_fragment);
	        
	        //update current
	        current_loc_x = a_fragment.End_Loc_X;
	        current_loc_z = a_fragment.End_Loc_Z;
	        current_heading_angle = a_fragment.Start_Heading_Angle + a_fragment.Turn_Angle;
	        current_distance = a_fragment.Distance_End;
	        
	      }// end of adding fragment
	      
	      a_segment.End_Loc_X = (double) current_loc_x;
	      a_segment.End_Loc_Z = (double) current_loc_z;
	    } // end of curve segment
	    else {
	      System.err.println("Error! TaskTemplateFun__Add_Road_To_World3D has undefined a_segment.Type: " + a_segment.Type);
	      break;
	    }
	    
	  }
	  
	  a_road.Distance_Total = (double) current_distance;
	  
	  String world3d_id = Integer.toString(sim.vars.world3DTemplate.World.Object_Num); //start from 0
	  sim.vars.world3DTemplate.World.Object_Num ++;
	  a_road.World3D_ID = world3d_id;
	  sim.vars.world3DTemplate.World.Objects.put(world3d_id, a_road );
	  
	  
	  
	}
	
	public  void TaskTemplateFun__Add_Trials_From_discrete_display_feedback_two_stages_method (LinkedList<String> Parameter_List){
	  
	  LinkedList<String> Parameter_List_Clone = sim.funs.ProgramUtilitiesFun__LinkedListString_Clone ( Parameter_List );
	  Task_Template_Discrete_Display_Feedback_Two_Stages_Method a_template = new Task_Template_Discrete_Display_Feedback_Two_Stages_Method ();
	  
	  //set default values for LinkedList<> that cannot be set in object definition.
	  a_template.Display_And_Response_Duration.addLast ( "-1.0" );
	  a_template.Feedback_Duration.addLast ( "0.0" );
	  
	  String a_parameter;
	  while ( Parameter_List_Clone.size() > 0 ) {
	    switch (Parameter_List_Clone.getFirst().toLowerCase()) {
	      
	      case ":add_number_of_days" : {
	        String parameter_name = Parameter_List_Clone.getFirst().toLowerCase();
	        Parameter_List_Clone.removeFirst(); // remove the parameter name
	        if ( Parameter_List_Clone.size() < 1 ) { System.err.println ("Error TaskTemplateFun__Add_Trials_From_discrete_display_feedback_two_stages_method " + parameter_name + " needs 1 parameter"); }
	        a_parameter = Parameter_List_Clone.getFirst();  //needs a single parameter
	        Parameter_List_Clone.removeFirst();
	        if ( a_parameter.charAt(0) == ':' || a_parameter.charAt(0) == '(' || a_parameter.charAt(0) == ')' ){ System.out.println ("Error TaskTemplateFun__Add_Trials_From_discrete_display_feedback_two_stages_method " + parameter_name + " needs 1 parameter. not " + a_parameter);}
	        if ( (sim.funs.ProgramUtilitiesFun__Is_String_Double(a_parameter) == false)) System.out.println ("Error TaskTemplateFun__Add_Trials_From_discrete_display_feedback_two_stages_method " + parameter_name + " needs a number. not " + a_parameter);
	        a_template.Add_Number_Of_Days = Integer.parseInt (a_parameter) ;
	        break;
	      }
	      
	      case ":add_number_of_blocks_per_day" : {
	        String parameter_name = Parameter_List_Clone.getFirst().toLowerCase();
	        Parameter_List_Clone.removeFirst(); // remove the parameter name
	        if ( Parameter_List_Clone.size() < 1 ) { System.err.println ("Error TaskTemplateFun__Add_Trials_From_discrete_display_feedback_two_stages_method " + parameter_name + " needs 1 parameter"); }
	        a_parameter = Parameter_List_Clone.getFirst();  //needs a single parameter
	        Parameter_List_Clone.removeFirst();
	        if ( a_parameter.charAt(0) == ':' || a_parameter.charAt(0) == '(' || a_parameter.charAt(0) == ')' ){ System.out.println ("Error TaskTemplateFun__Add_Trials_From_discrete_display_feedback_two_stages_method " + parameter_name + " needs 1 parameter. not " + a_parameter);}
	        if ( (sim.funs.ProgramUtilitiesFun__Is_String_Double(a_parameter) == false)) System.err.println ("Error TaskTemplateFun__Add_Trials_From_discrete_display_feedback_two_stages_method " + parameter_name + " needs a number. not " + a_parameter);
	        a_template.Add_Number_Of_Blocks_Per_Day = Integer.parseInt (a_parameter) ;
	        break;
	      }
	      
	      case ":add_number_of_trials_per_block" : {
	        String parameter_name = Parameter_List_Clone.getFirst().toLowerCase();
	        Parameter_List_Clone.removeFirst(); // remove the parameter name
	        if ( Parameter_List_Clone.size() < 1 ) { System.err.println ("Error TaskTemplateFun__Add_Trials_From_discrete_display_feedback_two_stages_method " + parameter_name + " needs 1 parameter"); }
	        a_parameter = Parameter_List_Clone.getFirst();  //needs a single parameter
	        Parameter_List_Clone.removeFirst();
	        if ( (a_parameter.charAt(0) == ':' && a_parameter.length() <= 16) || (a_parameter.charAt(0) == ':' && a_parameter.length() > 16  && !a_parameter.substring(0,16).equals( ":block_variable_") ) || a_parameter.charAt(0) == '(' || a_parameter.charAt(0) == ')' ){ System.out.println ("Error TaskTemplateFun__Add_Trials_From_discrete_display_feedback_two_stages_method " + parameter_name + " needs 1 parameter. not " + a_parameter);}
	        if ( (sim.funs.ProgramUtilitiesFun__Is_String_Double(a_parameter) == false)) System.err.println ("Error TaskTemplateFun__Add_Trials_From_discrete_display_feedback_two_stages_method " + parameter_name + " needs a number. not " + a_parameter);
	        a_template.Add_Number_Of_Trials_Per_Block = (a_parameter) ;
	        break;
	      }
	      
	      case ":display_and_response_duration" : 
	      {
	        String parameter_name = Parameter_List_Clone.getFirst().toLowerCase();
	        Parameter_List_Clone.removeFirst();// remove the parameter name
	        if ( Parameter_List_Clone.size() < 3 ) {  System.err.println ("Error! TaskTemplateFun__Add_Trials_From_discrete_display_feedback_two_stages_method " + parameter_name + " needs 1 parameter in addition to () "); }
	        if ( Parameter_List_Clone.getFirst().charAt(0) != '(' ){ System.err.println ("Error TaskTemplateFun__Add_Trials_From_discrete_display_feedback_two_stages_method " + parameter_name + " needs List of String parameter. not " + Parameter_List_Clone.getFirst());}
	        a_template.Display_And_Response_Duration =  sim.funs.ParametersFun__Remove_A_List_From_Initialization_Lists	(Parameter_List_Clone);  // the first () is poped out without () from the list
	        break;
	      }
	      
	      case ":feedback_duration" : 
	      {
	        String parameter_name = Parameter_List_Clone.getFirst().toLowerCase();
	        Parameter_List_Clone.removeFirst();// remove the parameter name
	        if ( Parameter_List_Clone.size() < 3 ) {  System.err.println ("Error! TaskTemplateFun__Add_Trials_From_discrete_display_feedback_two_stages_method " + parameter_name + " needs 1 parameter in addition to () "); }
	        if ( Parameter_List_Clone.getFirst().charAt(0)!= '(' ){ System.err.println ("Error TaskTemplateFun__Add_Trials_From_discrete_display_feedback_two_stages_method " + parameter_name + " needs List of String parameter. not " + Parameter_List_Clone.getFirst());}
	        a_template.Feedback_Duration =  sim.funs.ParametersFun__Remove_A_List_From_Initialization_Lists	(Parameter_List_Clone);  // the first () is poped out without () from the list
	        break;
	      }
	      
	      case ":how_many_display_items_to_use_in_a_trial" : {
	        String parameter_name = Parameter_List_Clone.getFirst().toLowerCase();
	        Parameter_List_Clone.removeFirst(); // remove the parameter name
	        if ( Parameter_List_Clone.size() < 1 ) { System.err.println ("Error TaskTemplateFun__Add_Trials_From_discrete_display_feedback_two_stages_method " + parameter_name + " needs 1 parameter"); }
	        a_parameter = Parameter_List_Clone.getFirst();  //needs a single parameter
	        Parameter_List_Clone.removeFirst();
	        if ( (a_parameter.charAt(0) == ':' && a_parameter.length() <= 16) || (a_parameter.charAt(0) == ':' && a_parameter.length() > 16  && !a_parameter.substring(0,16).equals( ":block_variable_") )  || a_parameter.charAt(0) == '(' || a_parameter.charAt(0) == ')' ){ System.out.println ("Error TaskTemplateFun__Add_Trials_From_discrete_display_feedback_two_stages_method " + parameter_name + " needs 1 parameter. not " + a_parameter);}
	        a_template.How_Many_Display_Items_To_Use_In_A_Trial = (a_parameter) ;
	        break;
	      }
	      
	      case ":number_of_responses_per_trial" : {
	        String parameter_name = Parameter_List_Clone.getFirst().toLowerCase();
	        Parameter_List_Clone.removeFirst(); // remove the parameter name
	        if ( Parameter_List_Clone.size() < 1 ) { System.err.println ("Error TaskTemplateFun__Add_Trials_From_discrete_display_feedback_two_stages_method " + parameter_name + " needs 1 parameter"); }
	        a_parameter = Parameter_List_Clone.getFirst();  //needs a single parameter
	        Parameter_List_Clone.removeFirst();
	        if ( (a_parameter.charAt(0) == ':' && a_parameter.length() <= 16) || (a_parameter.charAt(0) == ':' && a_parameter.length() > 16  && !a_parameter.substring(0,16).equals( ":block_variable_") )  || a_parameter.charAt(0) == '(' || a_parameter.charAt(0) == ')' ){ System.out.println ("Error TaskTemplateFun__Add_Trials_From_discrete_display_feedback_two_stages_method " + parameter_name + " needs 1 parameter. not " + a_parameter);}
	        if ( (sim.funs.ProgramUtilitiesFun__Is_String_Double(a_parameter) == false)) System.err.println ("Error TaskTemplateFun__Add_Trials_From_discrete_display_feedback_two_stages_method " + parameter_name + " needs a number. not " + a_parameter);
	        if ( (Double.parseDouble(a_parameter) < 0) && Double.parseDouble(a_parameter) != -1 ) System.err.println ("Error TaskTemplateFun__Add_Trials_From_discrete_display_feedback_two_stages_method " + parameter_name + " needs -1 or a non-negative number. not " + a_parameter);
	        a_template.Number_Of_Responses_Per_Trial = (a_parameter) ;
	        break;
	      }
	      
	      case "(" : { //here means the () of multiple () parentheses, each representing the method to generate each item displayed for trials.
	        LinkedList<String> a_list = sim.funs.ParametersFun__Remove_A_List_From_Initialization_Lists	(Parameter_List_Clone);  // the first () is poped out without () from the list
	        if (a_list == null) { if(sim.vars.printingModule.Popout_Message) System.err.println ("Error TaskTemplateFun__Add_Trials_From_discrete_display_feedback_two_stages_method the parameters for each item displayed needs parameters");  }
	        Hashtable parameters_table_for_an_item  = new Hashtable ();
	        
	        /*
		//do not need to set default here. If a parameter key cannot be found from the hashtable, then it means to use the default, which is implemented in the trial making function

		//old
		//set item generating parameter default here:
		ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value( parameters_table_for_an_item, ":text_randomization" , "fixed_order" );
		ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value( parameters_table_for_an_item, ":screen_location_x_randomization" , "fixed_order" );
		ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value( parameters_table_for_an_item, ":screen_location_y_randomization" , "fixed_order" );
		LinkedList<String> default_color = new LinkedList<String>();
		default_color.addLast ("black");
		ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value( parameters_table_for_an_item, ":color" , default_color );
		ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value( parameters_table_for_an_item, ":color_randomization" , "fixed_order" );
	         */
	        
	        //initilize the method details from outside .txt file setting: a_list loaded here
	        while ( a_list.size() > 0 ) {
	          switch (a_list.getFirst().toLowerCase()) {
	            //set all String parameters with the same method
	            case ":item_type" :  
	            case ":item_name" :
	            case ":button_click_event" :
	            case ":key_press_event" :
	            case ":hide" :
	            case ":text_randomization" : 
	            case ":display_item_screen_location_x_randomization" : 
	            case ":display_item_screen_location_y_randomization" : 
	            case ":display_item_color_randomization" : 
	            case ":display_item_delay_randomization" : 
	            case ":display_item_duration_randomization" : 
	            case ":feedback_item_screen_location_x_randomization" : 
	            case ":feedback_item_screen_location_y_randomization" : 
	            case ":feedback_item_color_randomization" : 
	            case ":feedback_item_delay_randomization" : 
	            case ":feedback_item_duration_randomization" : 
	            case ":frequency_randomization" :
	            case ":digit_randomization" :
	            case ":start_and_end_points_screen_location_randomization" :
	            case ":display_button_color_randomization" :
	            case ":display_item_height_randomization" :
	            case ":display_item_width_randomization" :
	            case ":paragraph_char_per_line" :  //obsolete
	            case ":paragraph_line_num" :		//obsolete
	            case ":as_paragraph" :	
	            case ":word_randomization" :
	            case ":as_sentence":
	            {
	              String parameter_name = a_list.getFirst().toLowerCase();
	              a_list.removeFirst();
	              if ( a_list.size() < 1 ) { if(sim.vars.printingModule.Popout_Message) System.err.println ("Error TaskTemplateFun__Add_Trials_From_discrete_display_feedback_two_stages_method " + parameter_name + " needs 1 parameter"); }
	              String parameter_value = a_list.getFirst().toLowerCase();
	              if ( (parameter_value.charAt(0) == ':' && parameter_value.length() <= 16) || (parameter_value.charAt(0) == ':' && parameter_value.length() > 16  && !parameter_value.substring(0,16).equals( ":block_variable_") )  || parameter_value.charAt(0) == '(' || parameter_value.charAt(0) == ')' ){ if(sim.vars.printingModule.Popout_Message) System.out.println ("Error TaskTemplateFun__Add_Trials_From_discrete_display_feedback_two_stages_method " + parameter_name + " needs 1 parameter. not " + parameter_value);}
	              a_list.removeFirst();
	              
	              
	              //check dynamic trigger name duplication
	              if ( parameter_name.equals( ":button_click_event") || parameter_name.equals( ":key_press_event")){ //may add more dynamic trigger event keywords
	                if(a_template.Dynamic_Trigger_Names.contains(parameter_value)){
	                  System.err.println("Error! TaskTemplateFun__Add_Trials_From_discrete_display_feedback_two_stages_method has duplicate dynamic trigger name from: " + parameter_name + ", " + parameter_value);
	                  break;
	                }
	                else a_template.Dynamic_Trigger_Names.addLast(parameter_value);
	              }
	              
	              //check dynamic item name duplication
	              if ( parameter_name.equals( ":item_name")){ 
	                if(a_template.Dynamic_Item_Names.contains(parameter_value)){
	                  System.err.println("Error! TaskTemplateFun__Add_Trials_From_discrete_display_feedback_two_stages_method has duplicate dynamic item name from: " + parameter_name + ", " + parameter_value);
	                  break;
	                }
	                else a_template.Dynamic_Item_Names.addLast(parameter_value);
	              }
	              
	              //check hide type t or nil
	              
	              
	              //check parameters
	              switch (parameter_name){
	                case ":paragraph_char_per_line" :
	                case ":paragraph_line_num" :	
	                  //int type 
	                {
	                  if ( sim.funs.ProgramUtilitiesFun__Is_String_Int(parameter_value) == false  ){
	                    System.err.println("Error! TaskTemplateFun__Add_Trials_From_discrete_display_feedback_two_stages_method has " + parameter_name + " not integer but: " + parameter_value);
	                  }
	                  break;
	                }
	                
	                case ":hide":
	                case ":as_paragraph" :	
	                case ":as_sentence":
	                  //bool t or nil type
	                {
	                  if ( !parameter_value.equals( "t" ) && !parameter_value.equals( "nil" ) ){
	                    System.err.println("Error! TaskTemplateFun__Add_Trials_From_discrete_display_feedback_two_stages_method has " + parameter_name + " neither t nor nil but: " + parameter_value);
	                  }
	                  break;
	                }
	                
	                default: { //do nothing for others
	                  break;
	                }
	              }
	              
	              sim.funs.ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value( parameters_table_for_an_item, parameter_name , parameter_value );
	              
	              break;
	            }
	            
	            //set all LinkedList<String (number is treated as String here) > parameters with the same method
	            case ":visual_text" : 
	            case ":correct_response_to_each_visual_text" : 
	            case ":feedback_to_each_visual_text" : 
	            case ":display_item_screen_location_x" : 
	            case ":display_item_screen_location_y" : 
	            case ":display_item_color" : 
	            case ":display_item_delay" : 
	            case ":display_item_duration" : 
	            case ":feedback_item_screen_location_x" : 
	            case ":feedback_item_screen_location_y" : 
	            case ":feedback_item_color" : 
	            case ":feedback_item_delay" : 
	            case ":feedback_item_duration" : 
	            case ":frequency" :
	            case ":digit" :
	            case ":start_point_screen_location_x" :
	            case ":start_point_screen_location_y" :
	            case ":end_point_screen_location_x" :
	            case ":end_point_screen_location_y" :
	            case ":correct_response" :
	            case ":feedback_content" :
	            case ":display_button_color" :
	            case ":display_item_height":
	            case ":display_item_width":
	            case ":word" :	
	            {
	              String parameter_name = a_list.getFirst().toLowerCase();
	              a_list.removeFirst();
	              if ( a_list.size() < 3 ) { if(sim.vars.printingModule.Popout_Message) System.err.println ("Error TaskTemplateFun__Add_Trials_From_discrete_display_feedback_two_stages_method " + parameter_name + " needs 1 parameter in addition to () "); }
	              if ( a_list.getFirst().charAt(0)  != '(' ){ 
	                if(sim.vars.printingModule.Popout_Message) System.err.println ("Error TaskTemplateFun__Add_Trials_From_discrete_display_feedback_two_stages_method " + parameter_name + " needs List of String parameter. not " + a_list.getFirst());
	                break;
	              }
	              LinkedList<String> parameter_list = sim.funs.ParametersFun__Remove_A_List_From_Initialization_Lists	(a_list);  // the first () is poped out without () from the list
	              
	              if(parameter_name.equals( ":visual_text") || parameter_name.equals(":word")){ //special handling. ( "para1  word1" )   should be one String rather than two: 鑼呴垾鏂猴拷姣仮閾板ソ銉嫹绡撹寘閿熻剼鐭剠鎹栴優顬犵寽顒尖敒梅鈭额啘鎾�绔�1 and word1鑼呴垾鏂猴拷姣仮閾板ソ銉嫹绡撹寘閿熻剼鐭儌鈹♀埗銉傜櫢鎷疯寘閳ユ緹璇ヮ嚪鏌拷
	                parameter_list = sim.funs.ProgramUtilitiesFun__Combine_Quotation_In_LinkedList_String		(parameter_list);	
	              } //end of special handling.
	              
	              sim.funs.ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value( parameters_table_for_an_item, parameter_name , sim.funs.ProgramUtilitiesFun__LinkedListString_Clone( parameter_list) );
	              break;
	            }
	            
	            default:
	            {
	              
	              if(sim.vars.printingModule.Popout_Message) {
	                System.err.println ("Error! TaskTemplateFun__Add_Trials_From_discrete_display_feedback_two_stages_method error! parameters for an item, the Key is undefined: " + a_list.getFirst());
	                break;
	              }
	              a_list.removeFirst();
	              
	              break;
	            }
	          }
	        }
	        a_template.Generating_Method_For_Each_Item_Over_Trials.addLast (parameters_table_for_an_item);
	        break;
	      }
	      
	      
	      default:
	      {
	        String parameter_name = Parameter_List_Clone.getFirst().toLowerCase();
	        
	        if ( parameter_name.length() >= 30  && parameter_name.substring(0, 30).equals( ":block_variable_randomization_" ) ){ //":block_variable_randomization_"
	          Parameter_List_Clone.removeFirst();// remove the parameter name
	          if ( Parameter_List_Clone.size() < 1 ) { System.err.println ("Error TaskTemplateFun__Add_Trials_From_discrete_display_feedback_two_stages_method " + parameter_name + " needs 1 parameter"); }
	          a_parameter = Parameter_List_Clone.getFirst();  //needs a single parameter
	          Parameter_List_Clone.removeFirst();
	          if ( a_parameter.charAt(0) == ':' || a_parameter.charAt(0) == '(' || a_parameter.charAt(0) == ')' ){ System.err.println ("Error TaskTemplateFun__Add_Trials_From_discrete_display_feedback_two_stages_method " + parameter_name + " needs 1 parameter. not " + a_parameter);}
	          if ( a_template.Block_Variable_Randomization.containsKey( parameter_name ) ) System.err.println("Error TaskTemplateFun__Add_Trials_From_discrete_display_feedback_two_stages_method has a_template.Block_Variable_Randomization.containsKey( parameter_name ) : " + parameter_name);
	          a_template.Block_Variable_Randomization.put( parameter_name ,a_parameter);
	          a_template.Block_Variable_Randomization_Ordered_Name.addLast ( parameter_name );
	          
	          if (a_parameter.charAt(0) == '=') {
	            String referred_name = a_parameter.substring(1);
	            if (!sim.vars.programGlobalVar__Block_Variable_Common_RandomMethod_Last_Seed.containsKey(referred_name)) sim.vars.programGlobalVar__Block_Variable_Common_RandomMethod_Last_Seed.put(referred_name, new Three_Tuple());
	            //safety check, the referred_name must have been defined
	            if (!a_template.Block_Variable_Randomization_Ordered_Name.contains(referred_name)){
	              System.err.println("Error! TaskTemplateFun__Add_Trials_From_discrete_display_feedback_two_stages_method has !a_template.Block_Variable_Randomization_Ordered_Name.Contains(referred_name): " + referred_name );
	              break;
	            }
	          }
	          
	        }
	        else if(  parameter_name.length() >= 16 && parameter_name.substring(0, 16).equals( ":block_variable_" ) ){ //":block_variable_"  but not ":block_variable_randomization_"
	          Parameter_List_Clone.removeFirst();// remove the parameter name
	          if ( Parameter_List_Clone.size() < 3 ) {  System.err.println ("Error! TaskTemplateFun__Add_Trials_From_discrete_display_feedback_two_stages_method " + parameter_name + " needs 1 parameter in addition to () "); }
	          if ( Parameter_List_Clone.getFirst().charAt(0) != '(' ){ System.err.println ("Error TaskTemplateFun__Add_Trials_From_discrete_display_feedback_two_stages_method " + parameter_name + " needs List of String parameter. not " + Parameter_List_Clone.getFirst());}
	          
	          if ( a_template.Block_Variable.containsKey( parameter_name ) ) System.err.println("Error TaskTemplateFun__Add_Trials_From_discrete_display_feedback_two_stages_method has a_template.Block_Variable.containsKey( parameter_name ) : " + parameter_name);
	          LinkedList<String> parameters = sim.funs.ParametersFun__Remove_A_List_From_Initialization_Lists	(Parameter_List_Clone) ;
	          
	          parameters = ProgramUtilitiesFun__Combine_Quotation_In_LinkedList_String		(parameters);	
	          
	          a_template.Block_Variable.put (parameter_name,  parameters );  // the first () is poped out without () from the list
	          //a_template.Block_Variable_Counter.Add (parameter_name,  ProgramUtilitiesFun__LinkedListString_Clone (parameters) );
	        }
	        else{
	          System.err.println ("TaskTemplateFun__Add_Trials_From_discrete_display_feedback_two_stages_method error! the Key is undefined: " + Parameter_List_Clone.getFirst());
	          Parameter_List_Clone.removeFirst();
	        }
	        break;
	      }
	    }
	  }
	  
	  sim.vars.taskTemplate.Trial_Generating_Methods.addLast (a_template);
	}
	
	public  void TaskTemplateFun__Catch_Key_Press_Event (Object the_response_object){

	  if ( !(the_response_object instanceof Response_Item_Key_Press )) {
	    System.err.println("Error! TaskTemplateFun__Catch_Key_Press_Event need input to be Response_Item_Key_Press" );
	    return;
	  }
	  
	  Response_Item_Key_Press the_response_item = (Response_Item_Key_Press) the_response_object;
	  
	  boolean debug = false;
	  if(debug) System.out.println("Debug TaskTemplateFun__Catch_Key_Press_Event");
	  int global_trial_num = sim.vars.centralParametersModule.Experiment_Trial_Result_List.size();
	  LinkedList<Object> all_display_items_in_this_trial = (LinkedList<Object>) ProgramUtilitiesFun__LinkedListObject_Get_i_th_Object( sim.vars.centralParametersModule.Experiment_Trial_Display_Item_List, global_trial_num) ;
	  for (Object a_display_item : all_display_items_in_this_trial){
	    if(debug) System.out.println("Debug TaskTemplateFun__Catch_Key_Press_Event" + (a_display_item instanceof Display_Item_Visual_Text) );	
	    
	    // check all user-declared :button_click_event from display_item_visual_text_button in the current trial. 
	    if ( a_display_item instanceof Display_Item_Visual_Text_Button){
	      if(!((Display_Item_Visual_Text_Button)a_display_item).Button_Click_Event.equals( "" ) ){
	        Display_Item_Visual_Text_Button the_button =  (Display_Item_Visual_Text_Button)a_display_item;
	        //check mouse cursor location
	        if ( the_response_item.Mouse_Cursor_X >= (the_button.Display_Item_Screen_Location_X - GlobalUtilities.round( ((double) the_button.Display_Item_Width / 2.0 ) ,0 ).intValue() ) && the_response_item.Mouse_Cursor_X <= (the_button.Display_Item_Screen_Location_X + GlobalUtilities.round( ((double) the_button.Display_Item_Width / 2.0 ) ,0).intValue()) && the_response_item.Mouse_Cursor_Y >= (the_button.Display_Item_Screen_Location_Y - GlobalUtilities.round( ((double) the_button.Display_Item_Height / 2.0 ),0 ).intValue()) && the_response_item.Mouse_Cursor_Y <= (the_button.Display_Item_Screen_Location_Y + GlobalUtilities.round( ((double) the_button.Display_Item_Height / 2.0 ),0 ).intValue()) ){
	          //is a user-declared :button_click_event
	          Entity Temp_Entity = sim.funs.createEntity( "Dynamic Events" , "TaskTemplateFun__Catch_Key_Press_Event", "Dynamic Events", the_button.Button_Click_Event, 0.0);
//	          Entity Temp_Entity = new Entity();  
//	          Temp_Entity.ID = "242"; // Dynamic Events
//	          Temp_Entity.Time = Clock;
//	          Temp_Entity.Tag = Entity_Number; //give it an entity number, init. 1
//	          Entity_Number++;
//	          
//	          Temp_Entity.From = "TaskTemplateFun__Catch_Key_Press_Event";
//	          Temp_Entity.To = "Dynamic Events";
//	          Temp_Entity.Entity_Type = the_button.Button_Click_Event	; //user-declared :button_click_event name
	          Temp_Entity.Response_Item = the_response_item;

	        }
	      }
	    }
	    
	    else if (a_display_item instanceof Display_Item_Visual_Text){
	      Display_Item_Visual_Text the_display_item = (Display_Item_Visual_Text)a_display_item;
	      if(!the_display_item.Key_Press_Event.equals( "" )){
	        Entity Temp_Entity = sim.funs.createEntity( "Dynamic Events" , "TaskTemplateFun__Catch_Key_Press_Event", "Dynamic Events", the_display_item.Key_Press_Event, 0.0);
//	        Entity Temp_Entity = new Entity();  
//	        Temp_Entity.ID = "242"; // Dynamic Events
//	        Temp_Entity.Time = Clock;
//	        Temp_Entity.Tag = Entity_Number; //give it an entity number, init. 1
//	        Entity_Number++;
//	        
//	        Temp_Entity.From = "TaskTemplateFun__Catch_Key_Press_Event";
//	        Temp_Entity.To = "Dynamic Events";
//	        Temp_Entity.Entity_Type = the_display_item.Key_Press_Event	; //user-declared :key_press_event name
	        Temp_Entity.Response_Item = the_response_item;
	      
	      }
	    }
	    
	  }
	}
	
	public  void TaskTemplateFun__Catch_Mouse_L_Click_Event (Object the_response_object){

	  if ( !(the_response_object instanceof Response_Item_Key_Press )) {
	    System.err.println("Error! TaskTemplateFun__Catch_Mouse_L_Click_Event need input to be Response_Item_Key_Press" );
	    return;
	  }
	  
	  Response_Item_Key_Press the_response_item = (Response_Item_Key_Press) the_response_object;
	  
	  if (!the_response_item.Key.equals( "mouse-L" ) ) {
	    System.err.println("Error! TaskTemplateFun__Catch_Mouse_L_Click_Event need the_response_item.Key = moust-L rather than: " + the_response_item.Key);
	    return;
	  }
	  
	  boolean debug = false;
	  if(debug) System.out.println("Debug TaskTemplateFun__Catch_Mouse_L_Click_Event");
	  
	  // check all user-declared :button_click_event from display_item_visual_text_button in the current trial. may check more events later
	  int global_trial_num = sim.vars.centralParametersModule.Experiment_Trial_Result_List.size();
	  LinkedList<Object> all_display_items_in_this_trial = (LinkedList<Object>) ProgramUtilitiesFun__LinkedListObject_Get_i_th_Object( sim.vars.centralParametersModule.Experiment_Trial_Display_Item_List, global_trial_num) ;
	  for (Object a_display_item : all_display_items_in_this_trial){
	    if ( a_display_item instanceof Display_Item_Visual_Text_Button){
	      if(!((Display_Item_Visual_Text_Button)a_display_item).Button_Click_Event.equals( ""  )){
	        Display_Item_Visual_Text_Button the_button =  (Display_Item_Visual_Text_Button)a_display_item;
	        //check mouse cursor location
	        if ( the_response_item.Mouse_Cursor_X >= (the_button.Display_Item_Screen_Location_X - GlobalUtilities.round( ((double) the_button.Display_Item_Width / 2.0 ),3 )) && the_response_item.Mouse_Cursor_X <= (the_button.Display_Item_Screen_Location_X + GlobalUtilities.round( ((double) the_button.Display_Item_Width / 2.0 ),0 ).intValue()) && the_response_item.Mouse_Cursor_Y >= (the_button.Display_Item_Screen_Location_Y - GlobalUtilities.round( ((double) the_button.Display_Item_Height / 2.0 ) ,0).intValue()) && the_response_item.Mouse_Cursor_Y <= (the_button.Display_Item_Screen_Location_Y + GlobalUtilities.round( ((double) the_button.Display_Item_Height / 2.0 ) ,0).intValue()) ){
	          //is a user-declared :button_click_event
	          Entity Temp_Entity = sim.funs.createEntity( "Dynamic Events" , "TaskTemplateFun__Catch_Mouse_L_Click_Event", "Dynamic Events", the_button.Button_Click_Event, 0.0);
//	          Entity Temp_Entity = new Entity();  
//	          Temp_Entity.ID = "242"; // Dynamic Events
//	          Temp_Entity.Time = Clock;
//	          Temp_Entity.Tag = Entity_Number; //give it an entity number, init. 1
//	          Entity_Number++;
//	          
//	          Temp_Entity.From = "TaskTemplateFun__Catch_Mouse_L_Click_Event";
//	          Temp_Entity.To = "Dynamic Events";
//	          Temp_Entity.Entity_Type = the_button.Button_Click_Event	; //user-declared :button_click_event name
	          Temp_Entity.Response_Item = the_response_item;
	          
	        }
	      }
	    }
	  }
	}
	
	public  void TaskTemplateFun__Events_At_The_End_Of_Each_Trial(){
	  
	  System.out.println("TODO TaskTemplateFun__Events_At_The_End_Of_Each_Trial PluginFunctions");
	  
	  // PluginFunctions?
//	 
//	  
//	  if(sim.vars.taskTemplate.Method.equals( "discrete_display_feedback_two_stages_method" )) {
//	    int this_is_the_end_of_trial_num = sim.vars.taskTemplate.Task_1_Current_Trial_Number;
//	    if (this_is_the_end_of_trial_num == 0 ) return; //this is before the start of the first trial.
//	    
//	    //for this trial
//	    //load common parameters for the trial, a trial must have these parameters at least. 
//	    Hashtable parameters_for_this_trial  = (Hashtable) ProgramUtilitiesFun__LinkedListObject_Get_i_th_Object ( sim.vars.centralParametersModule.Experiment_Trial_Parameter_List, this_is_the_end_of_trial_num );
//	    int day_num = 					(int) parameters_for_this_trial.get("day-num");
//	    int block_num = 				(int) parameters_for_this_trial.get("block-num");
//	    int trial_num_within_block = 	(int) parameters_for_this_trial.get("trial-num-within-block");
//	    
//	    
//	    //for the next trial
//	    Hashtable parameters_for_the_next_trial;
//	    int next_day_num ;
//	    int next_block_num ;
//	    int next_trial_num_within_block ;
//	    if( sim.vars.centralParametersModule.Experiment_Trial_Parameter_List.size()  == this_is_the_end_of_trial_num){ // this is the final trial, no more trial
//	      next_day_num = -999;
//	      next_block_num = -999;
//	      next_trial_num_within_block = -999;
//	    }
//	    else{ //this is not the final trial
//	      parameters_for_the_next_trial = (Hashtable) ProgramUtilitiesFun__LinkedListObject_Get_i_th_Object ( sim.vars.centralParametersModule.Experiment_Trial_Parameter_List, this_is_the_end_of_trial_num + 1 );
//	      next_day_num = 					(int) parameters_for_the_next_trial.get("day-num");
//	      next_block_num = 				(int) parameters_for_the_next_trial.get("block-num");
//	      next_trial_num_within_block = 	(int) parameters_for_the_next_trial.get("trial-num-within-block");
//	    }
//	    
//	    String trial_case = "";
//	    if( day_num ==  next_day_num - 1 || next_day_num == -999) trial_case = "end_of_day";
//	    else if ( day_num == next_day_num && block_num == next_block_num - 1) trial_case = "same_day_end_of_block";
//	    else if ( day_num == next_day_num && block_num == next_block_num && trial_num_within_block == next_trial_num_within_block - 1) trial_case = "same_day_same_block_end_of_trial";
//	    else {
//	      System.out.println("Error! TaskTemplateFun__Events_At_The_End_Of_Each_Trial has undefined trial_case");
//	      break;
//	      trial_case = "Error!";
//	    }
//	    
//	    
//	    
//	    //add events here:
//	    if(sim.vars.programGlobalVar__Use_Predefined_Model_Setup == 	"experiment_driving_and_comprehension"){
//	      if ( block_num >= 2 &&  ((boolean)sim.vars.programGlobalVar__Hashtable_Experiment_Specific_Data.get("Bool_Comp_Block")) ){
//	        //System.out.println("End_Of_ block_num: " + block_num);
//	        
//	        //at the end of each comprehension trial
//	        PluginFunctions.Experiment_Specifics_Close_RT_Window( "driving_comprehension");
//	        //System.out.println("Events_At_The_End_Of_Each_Trial, PluginFunctions.trial_RT: " + PluginFunctions.trial_RT);
//	        
//	        //block results
//	        ((LinkedList<Double>)sim.vars.programGlobalVar__Hashtable_Experiment_Specific_Data.get("Block_Results_CR")).addLast ( Double.parseDouble (PluginFunctions.trial_Reaction_Correctness) ); // 1 or 0
//	        if( PluginFunctions.trial_Reaction_Correctness.equals( "1")){
//	          ((LinkedList<Double>)sim.vars.programGlobalVar__Hashtable_Experiment_Specific_Data .get("Block_Results_RT")).addLast ( Double.parseDouble (PluginFunctions.trial_RT) );
//	        }
//	        
//	        //detailed data
//	        //System.out.println();
//	        String language = PluginFunctions.ExperimentSpecifics_Language;
//	        String set = (String)parameters_for_this_trial.get(":block_variable_set");
//	        String setblock = (String)parameters_for_this_trial.get(":block_variable_setblock");
//	        String groupnum = (String)parameters_for_this_trial.get(":block_variable_groupnum");
//	        String typenum = (String)parameters_for_this_trial.get(":block_variable_typenum");
//	        String input = (String)parameters_for_this_trial.get(":block_variable_input");
//	        String probe = (String)parameters_for_this_trial.get(":block_variable_probe");
//	        String correctresponse = PluginFunctions.trial_Correct_Reaction; // Yes or No
//	        
//	        String search_for_session_num_in_excel = PluginFunctions.ExperimentSpecifics_SessionNum.ToString();
//	        // change: session num 2 -> 4
//	        if (PluginFunctions.ExperimentSpecifics_SessionNum == 3) search_for_session_num_in_excel = "2";
//	        if (PluginFunctions.ExperimentSpecifics_SessionNum == 4) search_for_session_num_in_excel = "1";
//	        
//	        
//	        String LeftButtonMean = PluginFunctions.GetExperimentSpecificsTrialDetailsParameterValue(PluginFunctions.ExperimentSpecifics_SubjectNum.ToString(), search_for_session_num_in_excel, "LeftButtonMean");
//	        String correctresponse_button;
//	        if (correctresponse.toLowerCase().equals( LeftButtonMean.toLowerCase() )) correctresponse_button = "left_button";
//	        else correctresponse_button = "right_button";
//	        
//	        String[] Comprehension_Raw_line = new String[] { language , set, setblock, groupnum, typenum, input , probe, correctresponse, correctresponse_button, PluginFunctions.trial_RT , PluginFunctions.trial_Reaction , PluginFunctions.trial_Reaction_Correctness };
//	        String Comprehension_Raw_Data = (String)sim.vars.programGlobalVar__Hashtable_Experiment_Specific_Data.get("Comprehension_Raw_Data") +ProgramUtilitiesFun__StringArray_To_String_Show_Empty(Comprehension_Raw_line) + "\n";
//	        ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.programGlobalVar__Hashtable_Experiment_Specific_Data, "Comprehension_Raw_Data", Comprehension_Raw_Data ); // to be output into .txt
//	      }
//	      
//	      
//	      if(trial_case.equals( "end_of_day")){
//	        //Session 1 or 2:	T1	T2	Dual	Dual	T2	T1	T1	T2	Dual	Dual	T2	T1
//	        //Session block #	1	2	3		4		5	6	7	8	9		10		11	12
//	        
//	        if ( day_num == 1 || day_num == 6 || day_num == 7 || day_num == 12  ){ //T1 only
//	          //output BlockResults to excel
//	          double average_LP = ProgramUtilitiesFun__LinkedListDouble_Get_Average ( ((LinkedList<Double>)sim.vars.programGlobalVar__Hashtable_Experiment_Specific_Data.get("Block_Results_LP")) );
//	          PluginFunctions.Output_Experiment_Specifics_Block_Results_By_Column_Name_Static("driving_comprehension", "B" + day_num + "_LP", Double.toString(average_LP) );
//	          double SDLP = ProgramUtilitiesFun__LinkedListDouble_Get_Stdev ( ((LinkedList<Double>)sim.vars.programGlobalVar__Hashtable_Experiment_Specific_Data.get("Block_Results_LP")) );
//	          PluginFunctions.Output_Experiment_Specifics_Block_Results_By_Column_Name_Static("driving_comprehension", "B" + day_num + "_SDLP", Double.toString(SDLP) );
//	          
//	          //output T1 raw data to txt file
//	          String T1_raw_data_file_name = "B" + day_num + "_Driv_Raw";
//	          PluginFunctions.Output_Experiment_Specifics_Raw_Data( T1_raw_data_file_name, (String)sim.vars.programGlobalVar__Hashtable_Experiment_Specific_Data.get( "Driving_Raw_Data" ));
//	        }
//	        else if( day_num == 2 || day_num == 5 || day_num == 8 || day_num == 11  ){ //T2 only session blocks
//	          //output BlockResults to excel
//	          if( ((LinkedList<Double>)sim.vars.programGlobalVar__Hashtable_Experiment_Specific_Data.get("Block_Results_RT")).size() == 0){ // not a single correct response in a block
//	            //System.out.println( ((LinkedList<double>)sim.vars.programGlobalVar__Hashtable_Experiment_Specific_Data["Block_Results_RT"]).size() );
//	            //System.out.println(  "B" + day_num + "_RT" );
//	            PluginFunctions.Output_Experiment_Specifics_Block_Results_By_Column_Name_Static( "driving_comprehension", "B" + day_num + "_RT", "-99999" );
//	          }
//	          else{
//	            double average_RT = ProgramUtilitiesFun__LinkedListDouble_Get_Average ( ((LinkedList<Double>)sim.vars.programGlobalVar__Hashtable_Experiment_Specific_Data.get("Block_Results_RT")) );
//	            PluginFunctions.Output_Experiment_Specifics_Block_Results_By_Column_Name_Static("driving_comprehension", "B" + day_num + "_RT", Double.toString(average_RT) );
//	          }
//	          
//	          if ( ((LinkedList<Double>)sim.vars.programGlobalVar__Hashtable_Experiment_Specific_Data.get("Block_Results_CR")).size() == 0){ //no trial in the block
//	            PluginFunctions.Output_Experiment_Specifics_Block_Results_By_Column_Name_Static("driving_comprehension", "B" + day_num + "_CR", "-99999" );
//	          }
//	          else{
//	            double average_CR = ProgramUtilitiesFun__LinkedListDouble_Get_Average ( ((LinkedList<Double>)sim.vars.programGlobalVar__Hashtable_Experiment_Specific_Data.get("Block_Results_CR")) );
//	            PluginFunctions.Output_Experiment_Specifics_Block_Results_By_Column_Name_Static("driving_comprehension", "B" + day_num + "_CR", Double.toString(average_CR) );
//	          }
//	          
//	          
//	          //output T2 raw data to txt file
//	          String T2_raw_data_file_name = "B" + day_num + "_Comp_Raw";
//	          PluginFunctions.Output_Experiment_Specifics_Raw_Data( T2_raw_data_file_name, (String)sim.vars.programGlobalVar__Hashtable_Experiment_Specific_Data.get( "Comprehension_Raw_Data" ));
//	          
//	        }
//	        else { // dual
//	          //output BlockResults to excel
//	          double average_LP = ProgramUtilitiesFun__LinkedListDouble_Get_Average ( ((LinkedList<Double>)sim.vars.programGlobalVar__Hashtable_Experiment_Specific_Data.get("Block_Results_LP")) );
//	          PluginFunctions.Output_Experiment_Specifics_Block_Results_By_Column_Name_Static("driving_comprehension", "B" + day_num + "_LP", Double.toString(average_LP) );
//	          double SDLP = ProgramUtilitiesFun__LinkedListDouble_Get_Stdev ( ((LinkedList<Double>)sim.vars.programGlobalVar__Hashtable_Experiment_Specific_Data.get("Block_Results_LP")) );
//	          PluginFunctions.Output_Experiment_Specifics_Block_Results_By_Column_Name_Static("driving_comprehension", "B" + day_num + "_SDLP", Double.toString(SDLP) );
//	          
//	          if( ((LinkedList<Double>)sim.vars.programGlobalVar__Hashtable_Experiment_Specific_Data.get("Block_Results_RT")).size() == 0){ // not a single correct response in a block
//	            PluginFunctions.Output_Experiment_Specifics_Block_Results_By_Column_Name_Static("driving_comprehension", "B" + day_num + "_RT", "-99999" );
//	          }
//	          else{
//	            double average_RT = ProgramUtilitiesFun__LinkedListDouble_Get_Average ( ((LinkedList<Double>)sim.vars.programGlobalVar__Hashtable_Experiment_Specific_Data.get("Block_Results_RT")) );
//	            PluginFunctions.Output_Experiment_Specifics_Block_Results_By_Column_Name_Static("driving_comprehension", "B" + day_num + "_RT", Double.toString(average_RT) );
//	          }
//	          if ( ((LinkedList<Double>)sim.vars.programGlobalVar__Hashtable_Experiment_Specific_Data.get("Block_Results_CR")).size() == 0){ //no trial in the block
//	            PluginFunctions.Output_Experiment_Specifics_Block_Results_By_Column_Name_Static("driving_comprehension", "B" + day_num + "_CR", "-99999" );
//	          }
//	          else{
//	            double average_CR = ProgramUtilitiesFun__LinkedListDouble_Get_Average ( ((LinkedList<Double>)sim.vars.programGlobalVar__Hashtable_Experiment_Specific_Data.get("Block_Results_CR")) );
//	            PluginFunctions.Output_Experiment_Specifics_Block_Results_By_Column_Name_Static("driving_comprehension", "B" + day_num + "_CR", Double.toString(average_CR) );
//	          }
//	          
//	          
//	          
//	          //output T1 and T2 raw data to txt file
//	          String T1_raw_data_file_name = "B" + day_num + "_Driv_Raw";
//	          PluginFunctions.Output_Experiment_Specifics_Raw_Data( T1_raw_data_file_name, (String)sim.vars.programGlobalVar__Hashtable_Experiment_Specific_Data.get( "Driving_Raw_Data" ));
//	          
//	          String T2_raw_data_file_name = "B" + day_num + "_Comp_Raw";
//	          PluginFunctions.Output_Experiment_Specifics_Raw_Data( T2_raw_data_file_name, (String)sim.vars.programGlobalVar__Hashtable_Experiment_Specific_Data.get( "Comprehension_Raw_Data" ));
//	          
//	        }
//	        
//	        //end of experiment
//	        if( PluginFunctions.ExperimentSpecifics_Practice && day_num == 3){
//	          System.out.println("End of practice.");
//	          break;
//	        }
//	        
//	        if (day_num == 6) { // change: session num 2 -> 4
//	          System.out.println("End of experiment.");
//	          break;
//	        }
//	        
//	      }
//	      
//	      
//	      
//	      
//	    }
//	    
//	    
//	  }
//	  else {
//	    System.out.println("WARNING! TaskTemplateFun__Events_At_The_End_Of_Each_Trial has undefined sim.vars.taskTemplate.Method: " + sim.vars.taskTemplate.Method);
//	  }
	  
	}
	
	
	public  void TaskTemplateFun__Events_Before_The_Start_Of_Each_Trial (){
	  
	  
	  
	  //check whether to reset modules before each trial.
	  //common to all sim.vars.taskTemplate.Method
	  if(sim.vars.taskTemplate.Reset_All_Modules_Before_Each_Trial) FrameworkFun__Reset_All_Modules();	// random seeds were not reset.
	  else{
	    if(sim.vars.taskTemplate.Reset_Vision_Module_Before_Each_Trial) FrameworkFun__Reset_PM_Module("vision");
	    if(sim.vars.taskTemplate.Reset_Audio_Module_Before_Each_Trial)	FrameworkFun__Reset_PM_Module("audio");
	    
	    if(sim.vars.taskTemplate.ReInitialize_Intentional_Module_Before_Each_Trial) FrameworkFun__ReInitialize_Intentional_Module(); //goal buffers, goal-focus
	    if(sim.vars.taskTemplate.ReInitialize_Goal_1_Before_Each_Trial)  FrameworkFun__ReInitialize_Goal_1 ();
	    
	    if(sim.vars.taskTemplate.Clear_Retrieval_Buffer_And_Reset_Declarative_Module_State) FrameworkFun__Clear_Retrieval_Buffer_And_Reset_Declarative_Module_State();
	    
	    if(sim.vars.taskTemplate.Reset_Imaginary_Module_Before_Each_Trial) FrameworkFun__Reset_Imaginary_Module();
	    //if(sim.vars.taskTemplate.Obsolete_ReInitialize_Goal_Focus_Before_Each_Trial )	FrameworkFun__ReInitialize_Goal_Focus(); 
	    //may add more parts of the reset all modules function
	  }
	  
	  
	  
	  if(sim.vars.taskTemplate.Method.equals( "discrete_display_feedback_two_stages_method" )) {
	    int this_is_before_the_start_of_trial_num = sim.vars.taskTemplate.Task_1_Current_Trial_Number + 1;
	    if ( sim.vars.centralParametersModule.Experiment_Trial_Parameter_List.size() < this_is_before_the_start_of_trial_num ) return; //all trials have been done.
	    
	    //for the to-be-started trial
	    //load common parameters for the trial, a trial must have these parameters at least. 
	    Hashtable parameters_for_this_trial  = (Hashtable) ProgramUtilitiesFun__LinkedListObject_Get_i_th_Object ( sim.vars.centralParametersModule.Experiment_Trial_Parameter_List, this_is_before_the_start_of_trial_num );
	    int day_num = 					(int) parameters_for_this_trial.get("day-num");
	    int block_num = 				(int) parameters_for_this_trial.get("block-num");
	    int trial_num_within_block = 	(int) parameters_for_this_trial.get("trial-num-within-block");
	    
	    //for the last trial
	    Hashtable parameters_for_the_last_trial;
	    int last_day_num ;
	    int last_block_num ;
	    int last_trial_num_within_block ;
	    if( this_is_before_the_start_of_trial_num == 1){ // this is the first total trial
	      last_day_num = 0;
	      last_block_num = 0;
	      last_trial_num_within_block = 0;
	    }
	    else{ //this is not the first total trial
	      parameters_for_the_last_trial = (Hashtable) ProgramUtilitiesFun__LinkedListObject_Get_i_th_Object ( sim.vars.centralParametersModule.Experiment_Trial_Parameter_List, this_is_before_the_start_of_trial_num - 1 );
	      last_day_num = 					(int) parameters_for_the_last_trial.get("day-num");
	      last_block_num = 				(int) parameters_for_the_last_trial.get("block-num");
	      last_trial_num_within_block = 	(int) parameters_for_the_last_trial.get("trial-num-within-block");
	    }
	    
	    String trial_case = "";
	    if( day_num ==  last_day_num + 1) trial_case = "new_day";
	    else if ( day_num == last_day_num && block_num == last_block_num + 1) trial_case = "same_day_new_block";
	    else if ( day_num == last_day_num && block_num == last_block_num && trial_num_within_block == last_trial_num_within_block + 1) trial_case = "same_day_same_block_new_trial";
	    else {
	      System.err.println("Error! TaskTemplateFun__Events_Before_The_Start_Of_Each_Trial has undefined trial_case");
	      trial_case = "Error!";
	    }
	    
	    
	    //add events here:
	    //System.out.println("TaskTemplateFun__Events_Before_The_Start_Of_Each_Trial: " + day_num + ", " + block_num + ", " + trial_num_within_block);
	    if(sim.vars.programGlobalVar__Use_Predefined_Model_Setup.equals( 	"experiment_driving_and_comprehension" )){
	      
	      if( day_num == 1 && block_num == 1 && trial_num_within_block == 1){ // before the very first trial in the experiment
	        //some simulation performance setting
	        World3D_Template_Driving_Method the_method = TaskTemplateFun__Get_World3D_Driving_Method_Object();
	        if( the_method.Who_Drive.toLowerCase().equals( "human") ){ //disable many model computation
	          //System.out.println("TaskTemplateFun__Events_Before_The_Start_Of_Each_Trial experiment_driving_and_comprehension");
	          
	        }
	        
	      }
	      
	      
	      
	      if(trial_case.equals( "new_day")){
	        //System.out.println("experiment_driving_and_comprehension before the start of a new Experiment Block. need to reset cars' location and heading in TaskTemplateFun__Events_Before_The_Start_Of_Each_Trial.");
	        //Session 1 or 2:	T1	T2	Dual	Dual	T2	T1	T1	T2	Dual	Dual	T2	T1
	        //Session block #	1	2	3		4		5	6	7	8	9		10		11	12
	        World3D_Template_Driving_Method the_method = TaskTemplateFun__Get_World3D_Driving_Method_Object();
	        World3D_DriverCar the_driver_car = (World3D_DriverCar) sim.vars.world3DTemplate.World.Objects.get(the_method.DriverCar_World3D_ID);
	        LinkedList<World3D_OtherCar> other_cars = new LinkedList<World3D_OtherCar>();
	        for (String an_ID : the_method.OtherCar_World3D_ID){
	          other_cars.addLast(  (World3D_OtherCar)sim.vars.world3DTemplate.World.Objects.get(an_ID) );
	        }
	        
	        
	        TaskTemplateFun__World3D_Reset_DriverCar_To_Start_Position(the_driver_car);
	        the_driver_car.Vehicle_Basic.Frozen = true;
	        for (World3D_OtherCar a_car : other_cars){
	          TaskTemplateFun__World3D_Reset_OtherCar_To_Start_Position(a_car);
	          a_car.Vehicle_Basic.Frozen = true;
	        }
	        
	        if ( day_num == 1 || day_num == 6 || day_num == 7 || day_num == 12  ){ //T1 only
	          ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value( sim.vars.programGlobalVar__Hashtable_Experiment_Specific_Data, "Bool_Comp_Block", false);
	          
	        }
	        else if( day_num == 2 || day_num == 5 || day_num == 8 || day_num == 11  ){ //T2 only session blocks
	          the_driver_car.Vehicle_Basic.Yaw += 179.9; //face white space rather than the road.
	          ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value( sim.vars.programGlobalVar__Hashtable_Experiment_Specific_Data, "Bool_Comp_Block", true);
	          
	        }
	        else { // dual
	          ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value( sim.vars.programGlobalVar__Hashtable_Experiment_Specific_Data, "Bool_Comp_Block", true);
	          
	        }
	      }
	      else if(trial_case.equals( "same_day_new_block")){
	        if( block_num == 2 ){ //after "start" being said, 
	          
	          //reset block results data storage
	          ((LinkedList<Double>) sim.vars.programGlobalVar__Hashtable_Experiment_Specific_Data.get( "Block_Results_LP")).clear();
	          ((LinkedList<Double>) sim.vars.programGlobalVar__Hashtable_Experiment_Specific_Data.get( "Block_Results_RT")).clear();
	          ((LinkedList<Double>) sim.vars.programGlobalVar__Hashtable_Experiment_Specific_Data.get( "Block_Results_CR")).clear();
	          
	          String[] Driving_Raw_titles = new String[] {"Clock_Time(s)", "Distance_On_Road(m)", "Lateral_Distance(m)", "Speed(m/s)", "Head_Angle_Between_Road_Direction(degreeRight+)", "Steer(degreeRight+)", "Accelerator(0-1)", "Brake(0-1)"};
	          String Driving_Raw_Data = ProgramUtilitiesFun__StringArray_To_String_Show_Empty(Driving_Raw_titles) + "\n";
	          String[] Comprehension_Raw_titles = new String[] {"Lang.", "Set", "SetBlock", "Group", "Trial", "input_text", "probe_text", "Correct_Response_Text", "Correct_Response_Button", "Reaction_Time(s)", "Response", "Correctness"};
	          String Comprehension_Raw_Data = ProgramUtilitiesFun__StringArray_To_String_Show_Empty(Comprehension_Raw_titles) + "\n";
	          ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.programGlobalVar__Hashtable_Experiment_Specific_Data, "Driving_Raw_Data", Driving_Raw_Data ); // to be output into .txt
	          ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.programGlobalVar__Hashtable_Experiment_Specific_Data, "Comprehension_Raw_Data", Comprehension_Raw_Data ); // to be output into .txt
	          
	          
	          
	          boolean cars_frozen; //for with driving blocks to start.
	          if( day_num == 2 || day_num == 5 || day_num == 8 || day_num == 11  ) cars_frozen = true;
	          else { //T1 only and Dual
	            cars_frozen = false;
	            
	            World3D_Template_Driving_Method the_method = TaskTemplateFun__Get_World3D_Driving_Method_Object();
	            World3D_DriverCar the_driver_car = (World3D_DriverCar) sim.vars.world3DTemplate.World.Objects.get(the_method.DriverCar_World3D_ID);
	            LinkedList<World3D_OtherCar> other_cars = new LinkedList<World3D_OtherCar>();
	            for (String an_ID : the_method.OtherCar_World3D_ID){
	              other_cars.addLast(  (World3D_OtherCar)sim.vars.world3DTemplate.World.Objects.get(an_ID));
	            }
	            
	            the_driver_car.Vehicle_Basic.Frozen = cars_frozen;
	            for (World3D_OtherCar a_car : other_cars){
	              a_car.Vehicle_Basic.Frozen = cars_frozen;
	            }
	            
	            
	          }
	        }
	        
	      }
	      
	      System.out.println("TODO TaskTemplateFun__Events_Before_The_Start_Of_Each_Trial plugin functions");
	      
//	      if ( block_num >= 2 &&  ((boolean)sim.vars.programGlobalVar__Hashtable_Experiment_Specific_Data.get("Bool_Comp_Block")) ){
//	        String delay = Plugin_Functions.Substitute_Experiment_Specifics_Conditions("driving_comprehension$common_value$probe_sentense_delay$");
//	        //System.out.println("Driv_Comp_Open_RT_Window start delay: " + delay);
//	        ProgramUtilitiesFun__Delayed_Function_Call_No_Return_Value( Double.parseDouble(delay), "Open_RT_Window", "driving_comprehension");
//	        String correct_response =  ((String) parameters_for_this_trial.get(":block_variable_correct_response"));
//	        if (correct_response.charAt(0) == '"') correct_response = correct_response.substring(1);
//	        if (correct_response.charAt(correct_response.length()-1) == '"') correct_response = correct_response.substring(0,correct_response.length()-1);
//	        //System.out.println(correct_response);
//	        PluginFunctions.Experiment_Specifics_Set_Trial_Correct_Reaction( correct_response );
//	        
//	      }
	      
	      
	      
	    }
	    
	    
	    
	  }
	  else {
	    System.out.println("WARNING! TaskTemplateFun__Events_At_The_End_Of_Each_Trial has undefined sim.vars.taskTemplate.Method: " + sim.vars.taskTemplate.Method);
	  }
	}
	
	/**
	 * return a two-tuple stores 1. parameter list (LinkedList<Hashtable>) for an item, different hashtables for different trials; 2. display item list LinkedList<object>, listed over trials  , listed over trials
	 * the default values of a display_item object are set here rather than the class definition
	 * 
	 * @param add_number_of_days
	 * @param add_number_of_blocks_per_day
	 * @param add_number_of_trials_per_block
	 * @param generating_method_for_an_item_over_trials
	 * @param the_template
	 * @param item_id_num
	 * @return 
	 */
	public  Two_Tuple TaskTemplateFun__Generate_An_Item_For_Trials_Using_Generating_Methods (int add_number_of_days, int add_number_of_blocks_per_day, int add_number_of_trials_per_block, Hashtable generating_method_for_an_item_over_trials, Object the_template, int item_id_num){
	  
	  if(the_template instanceof Task_Template_Discrete_Display_Feedback_Two_Stages_Method){
	    Task_Template_Discrete_Display_Feedback_Two_Stages_Method a_template = (Task_Template_Discrete_Display_Feedback_Two_Stages_Method) the_template;
	    Hashtable current_block_variable_content_by_day_block_variable_name = a_template.Block_Variable_Content_By_Day_Block_VName;
	    
	    int all_day_added = add_number_of_days;
	    if (all_day_added == 0) all_day_added = 1; //here minimal is 1
	    int blocks_added_per_day = add_number_of_blocks_per_day;
	    if (blocks_added_per_day == 0) blocks_added_per_day = 1; //here minimal is 1
	    int trials_added_per_block = add_number_of_trials_per_block;
	    int day_i;
	    int block_i;
	    int trial_i;
	    
	    LinkedList<Hashtable> item_parameter_over_trials = new LinkedList<Hashtable> ();
	    LinkedList<Object> item_display_over_trials = new LinkedList<Object>();
	    
	    if( generating_method_for_an_item_over_trials.containsKey(":item_type") == false) System.err.println("Error. TaskTemplateFun__Generate_An_Item_For_Trials_Using_Generating_Methods has generating_method_for_an_item_over_trials.containsKey( :item_type ) == false"); //checks for the case there is no ":item_type" key
	    String item_type = (String) generating_method_for_an_item_over_trials.get(":item_type");
	    
	    
	    
	    //depending on the item_type, make the return tuple.
	    
	    
	    if ( item_type.equals( "display_item_visual_text") ) {
	      
	      //initialize source lists storing the user-defined information for trials // these source lists must not be changed.
	      //these are defined by item_type.equals( "display_item_visual_text" )
	      LinkedList<String> keywords_with_LinkedListString_values = new LinkedList<String> ();
	      keywords_with_LinkedListString_values.addLast(":visual_text");                              //these three share the same random method, have a random method ":text_randomization鑼呴垾鏂猴拷姣仮閾板ソ銉嫹绡撹寘閿熻剼鐭儻鎷烽垾鎳婎灎顐傝鈺嬫嫹閳モ埗锛枴鈭讹腹鍔夎祩鑼呴垾鎾�妫笛�锟解檧锟芥锔癸拷瀛わ拷	      keywords_with_LinkedListString_values.addLast(":correct_response_to_each_visual_text");     //these three share the same random method, NO random method
	      keywords_with_LinkedListString_values.addLast(":correct_response_to_each_visual_text");     //these three share the same random method, NO random method
	      keywords_with_LinkedListString_values.addLast(":feedback_to_each_visual_text");             //these three share the same random method, No random method
	      keywords_with_LinkedListString_values.addLast(":display_item_screen_location_x");
	      keywords_with_LinkedListString_values.addLast(":display_item_screen_location_y");
	      keywords_with_LinkedListString_values.addLast(":display_item_color");
	      keywords_with_LinkedListString_values.addLast(":display_item_delay");
	      keywords_with_LinkedListString_values.addLast(":display_item_duration");
	      keywords_with_LinkedListString_values.addLast(":feedback_item_screen_location_x");
	      keywords_with_LinkedListString_values.addLast(":feedback_item_screen_location_y");
	      keywords_with_LinkedListString_values.addLast(":feedback_item_color");
	      keywords_with_LinkedListString_values.addLast(":feedback_item_delay");
	      keywords_with_LinkedListString_values.addLast(":feedback_item_duration");
	      
	      //initialize source_list
	      Hashtable<String, LinkedList<String>> source_list = new Hashtable<String, LinkedList<String>> (); // Hashtable of (String, LinkedList<String>)
	      for(String keyword : keywords_with_LinkedListString_values){
	        if ( generating_method_for_an_item_over_trials.containsKey(keyword)) {
	          source_list.put( keyword, 	(LinkedList<String>) generating_method_for_an_item_over_trials.get( keyword ) );
	        }
	        else { //set default values
	          LinkedList<String> a_source = new LinkedList<String> ();
	          switch( keyword ){//some cases with numbers
	            case ":display_item_screen_location_x":
	            case ":display_item_screen_location_y":
	            case ":display_item_delay":
	            case ":feedback_item_screen_location_x":
	            case ":feedback_item_screen_location_y":
	            case ":feedback_item_delay":
	            case ":feedback_item_duration":
	            {
	              a_source.addLast ("0");
	              break;
	            }
	            
	            case ":display_item_duration":				
	            {
	              a_source.addLast ("-1.0");
	              break;
	            }
	            
	            case ":display_item_color":	
	            case ":feedback_item_color": { //some special default values
	              a_source.addLast ("black");
	              break;
	            }
	            case ":correct_response_to_each_visual_text":
	            case ":feedback_to_each_visual_text": { //need list .size() to be the same with ":visual_text"
	              int number_of_visual_text_alternatives = ((LinkedList<String> ) generating_method_for_an_item_over_trials.get( ":visual_text" )).size();
	              int i;
	              for (i = 0; i < number_of_visual_text_alternatives ; i ++ ){
	                a_source.addLast ("");
	              }
	              break;
	            }
	            default: { //other cases, String
	              a_source.addLast ("");
	              break;
	            }
	            
	          }
	          source_list.put( keyword,  a_source );	
	        }
	        
	      }
	      
	      //initialize random method list
	      Hashtable random_method_list = new Hashtable (); // Hashtable of (String, String)
	      for(String keyword : keywords_with_LinkedListString_values){
	        if ( generating_method_for_an_item_over_trials.containsKey( keyword  + "_randomization"      )) { //e.g., :display_item_screen_location_x_randomization //have a method by definition and was assigned by the user
	          random_method_list.put(  keyword    ,   (String) generating_method_for_an_item_over_trials.get( keyword  + "_randomization" )   );
	        }
	        else if ( keyword.equals( ":visual_text" )){//special case
	          if ( generating_method_for_an_item_over_trials.containsKey( ":text_randomization" )  ){ //user specified
	            random_method_list.put(  keyword    ,   (String) generating_method_for_an_item_over_trials.get( ":text_randomization" ) );
	          }
	          else{ //use default value
	            random_method_list.put(  keyword    , "fixed_order" );
	          }
	        }
	        else if ( keyword.equals( ":correct_response_to_each_visual_text")  ||  keyword.equals( ":feedback_to_each_visual_text")) { //do nothing, because their random methods are bounded with other keywords
	          continue;
	        }
	        else {	//have definition, but not specified by the user, use default values
	          random_method_list.put(  keyword    , "fixed_order" );
	        }
	        
	      }
	      
	      
	      for ( day_i = 1; day_i <= all_day_added; day_i ++){
	        for (block_i = 1; block_i <= blocks_added_per_day; block_i ++ ){
	          //initialize counter lists for random_without_replacement method before each block // use clone here because they will be manipulated
	          Hashtable counter_list = new Hashtable (); // Hashtable of LinkedList<String>
	          for(String keyword : keywords_with_LinkedListString_values){
	            counter_list.put ( keyword,        ProgramUtilitiesFun__LinkedListString_Clone( (LinkedList<String> )source_list.get(keyword)  )        );
	          }
	          
	          for (trial_i = 1; trial_i <= trials_added_per_block; trial_i ++){
	            //start to generate parameters of this item in this trial.
	            Hashtable a_random_string_table = new Hashtable (); //each value is a random String generated for the key. including default values
	            for(String keyword : keywords_with_LinkedListString_values) {
	              if ( keyword.equals( ":visual_text" )){//special case
	                //three lists are bound together, using the same random method. 
	                Three_Tuple text_and_correct_response_and_feedback = ProgramUtilitiesFun__Get_A_Three_Tuple_String_From_Randomizing_Three_String_Lists ( (LinkedList<String>) source_list.get(":visual_text") , (LinkedList<String>) source_list.get(":correct_response_to_each_visual_text") , (LinkedList<String>) source_list.get(":feedback_to_each_visual_text"),             (LinkedList<String>) counter_list.get(":visual_text"), (LinkedList<String>) counter_list.get(":correct_response_to_each_visual_text") , (LinkedList<String>) counter_list.get(":feedback_to_each_visual_text") ,  (String) random_method_list.get(":visual_text")); //original full String list1, original full String list2, and list3 with the same length, String list counter1, String list counter2, and counter3, one random method (may include fixed_order)
	                a_random_string_table.put(":visual_text", (String) text_and_correct_response_and_feedback.Ob1 );
	                a_random_string_table.put(":correct_response_to_each_visual_text", (String) text_and_correct_response_and_feedback.Ob2 );
	                a_random_string_table.put(":feedback_to_each_visual_text", (String) text_and_correct_response_and_feedback.Ob3 );
	              }
	              else if ( keyword.equals( ":correct_response_to_each_visual_text")  ||  keyword.equals( ":feedback_to_each_visual_text")) { //do nothing, because their values are bounded with other keywords
	                continue;
	              }
	              else { //common method
	                String a_random_string = ProgramUtilitiesFun__Get_A_String_From_Randomizing_A_String_List (  (LinkedList<String>) source_list.get(keyword) , (LinkedList<String>) counter_list.get(keyword),   (String)random_method_list.get(keyword)   ); //original full String list, String list counter, random method (may include fixed_order)
	                a_random_string_table.put( keyword, a_random_string   );
	              }
	            }
	            
	            
	            //substitue every block_variable name in a_random_string_table.Value to their specific String for this block.
	            TaskTemplateFun__Substitute_Hashtable_Values_With_Block_Variables( Integer.toString(day_i), Integer.toString(block_i) ,  a_random_string_table, current_block_variable_content_by_day_block_variable_name  ); 
	            
	            
	            
	            //prepare the display item
	            Display_Item_Visual_Text a_display_item = new Display_Item_Visual_Text ();
	            a_display_item.Correct_Response 				= (String) a_random_string_table.get(":correct_response_to_each_visual_text");
	            a_display_item.Display_Item_Color        		= (String) a_random_string_table.get(":display_item_color" ) ;
	            a_display_item.Display_Item_Delay         		= (double) Double.parseDouble ( (String) a_random_string_table.get( ":display_item_delay") );
	            a_display_item.Display_Item_Duration      	    = (double) Double.parseDouble ( (String) a_random_string_table.get( ":display_item_duration") ) ;
	            a_display_item.Display_Item_Screen_Location_X   = Integer.parseInt ( (String) a_random_string_table.get( ":display_item_screen_location_x") );
	            a_display_item.Display_Item_Screen_Location_Y   = Integer.parseInt ( (String) a_random_string_table.get( ":display_item_screen_location_y") );
	            a_display_item.Feedback          				= (String) a_random_string_table.get( ":feedback_to_each_visual_text") ;
	            a_display_item.Feedback_Item_Color    	 	    = (String) a_random_string_table.get( ":feedback_item_color" ) ;
	            a_display_item.Feedback_Item_Delay       		= (double) Double.parseDouble ( (String) a_random_string_table.get( ":feedback_item_delay") );
	            a_display_item.Feedback_Item_Duration     	    = (double) Double.parseDouble ( (String) a_random_string_table.get( ":feedback_item_duration") ) ;
	            a_display_item.Feedback_Item_Screen_Location_X  = Integer.parseInt ( (String) a_random_string_table.get( ":feedback_item_screen_location_x") );
	            a_display_item.Feedback_Item_Screen_Location_Y  = Integer.parseInt ( (String) a_random_string_table.get( ":feedback_item_screen_location_y") );
	            a_display_item.Visual_Text          			= (String) a_random_string_table.get(":visual_text" ) ;
	            a_display_item.Item_ID = "item-" +  Integer.toString(item_id_num);
	            if( generating_method_for_an_item_over_trials.containsKey(":hide") && ((String) generating_method_for_an_item_over_trials.get(":hide")).equals( "t") ) {
	              a_display_item.Hide = true; //false by default
	            }
	            if( generating_method_for_an_item_over_trials.containsKey(":paragraph_char_per_line") ){
	              String temp_parameter =	(String) generating_method_for_an_item_over_trials.get(":paragraph_char_per_line") ;
	              a_display_item.Paragraph_Char_Per_Line = Integer.parseInt(temp_parameter);
	            }
	            if( generating_method_for_an_item_over_trials.containsKey(":paragraph_line_num") ){
	              String temp_parameter =	(String) generating_method_for_an_item_over_trials.get(":paragraph_line_num");
	              a_display_item.Paragraph_Line_Num = Integer.parseInt(temp_parameter);
	            }
	            if( generating_method_for_an_item_over_trials.containsKey(":as_paragraph") ){
	              String temp_parameter =	(String) generating_method_for_an_item_over_trials.get(":as_paragraph") ;
	              if(temp_parameter.toLowerCase().equals( "nil"))a_display_item.As_Paragraph = false;
	              else a_display_item.As_Paragraph = true;
	            }
	            /*
		//prepare the lean version of parameter hashtable, in this way, Start_Trial_Display needs to check, if some parameter is not there, use default. This way makes the external parameter file look simpler, but requires more work in Start_Trial_Display
		Hashtable a_random_string_table_with_only_user_specified_values = new Hashtable ();
		for(String keyword in keywords_with_LinkedListString_values) {
		if( generating_method_for_an_item_over_trials.containsKey(keyword) ){
		a_random_string_table_with_only_user_specified_values.put( keyword, a_random_string_table[ keyword ] );
		}
		}
		a_random_string_table_with_only_user_specified_values.put(":item_type", item_type );

		item_parameter_over_trials.addLast ( a_random_string_table_with_only_user_specified_values );
	             */
	            
	            //check dynamic tigger events for "display_item_visual_text"
	            if( generating_method_for_an_item_over_trials.containsKey(":key_press_event") ) {
	              a_display_item.Key_Press_Event = (String) generating_method_for_an_item_over_trials.get(":key_press_event");
	            }
	            
	            
	            //check dynamic item name 
	            if( generating_method_for_an_item_over_trials.containsKey(":item_name") ) {
	              a_display_item.Item_Name = (String) generating_method_for_an_item_over_trials.get(":item_name");
	            }
	            
	            //add prepared trial info into the return list.
	            a_random_string_table.put(":item_type", item_type );
	            item_parameter_over_trials.addLast ( a_random_string_table );
	            
	            item_display_over_trials.addLast ( a_display_item);
	          }//end trial_i	
	        }//end block_i
	      } //end day_i
	      
	      
	      
	    } //end of item_type.equals( "display_item_visual_text")
	    
	    else if ( item_type.equals( "display_item_visual_text_button") ) { 
	      
	      //initialize source lists storing the user-defined information for trials // these source lists must not be changed.
	      //these are defined by item_type.equals( "display_item_visual_text_button" )
	      LinkedList<String> keywords_with_LinkedListString_values = new LinkedList<String> ();
	      keywords_with_LinkedListString_values.addLast(":visual_text");                              //these three share the same random method, have a random method ":text_randomization鑼呴垾鏂猴拷姣仮閾板ソ銉嫹绡撹寘閿熻剼鐭儻鎷烽垾鎳婎灎顐傝鈺嬫嫹閳モ埗锛枴鈭讹腹鍔夎祩鑼呴垾鎾�妫笛�锟解檧锟芥锔癸拷瀛わ拷	      keywords_with_LinkedListString_values.addLast(":correct_response_to_each_visual_text");     //these three share the same random method, NO random method
	      keywords_with_LinkedListString_values.addLast(":correct_response_to_each_visual_text");     //these three share the same random method, NO random method
	      keywords_with_LinkedListString_values.addLast(":feedback_to_each_visual_text");             //these three share the same random method, No random method
	      keywords_with_LinkedListString_values.addLast(":display_item_screen_location_x");
	      keywords_with_LinkedListString_values.addLast(":display_item_screen_location_y");
	      keywords_with_LinkedListString_values.addLast(":display_item_width");
	      keywords_with_LinkedListString_values.addLast(":display_item_height");
	      keywords_with_LinkedListString_values.addLast(":display_item_color");
	      keywords_with_LinkedListString_values.addLast(":display_item_delay");
	      keywords_with_LinkedListString_values.addLast(":display_item_duration");
	      keywords_with_LinkedListString_values.addLast(":feedback_item_screen_location_x");
	      keywords_with_LinkedListString_values.addLast(":feedback_item_screen_location_y");
	      keywords_with_LinkedListString_values.addLast(":feedback_item_color");
	      keywords_with_LinkedListString_values.addLast(":feedback_item_delay");
	      keywords_with_LinkedListString_values.addLast(":feedback_item_duration");
	      keywords_with_LinkedListString_values.addLast(":display_button_color");
	      
	      
	      //initialize source_list
	      Hashtable source_list = new Hashtable (); // Hashtable of (String, LinkedList<String>)
	      for(String keyword : keywords_with_LinkedListString_values){
	        if ( generating_method_for_an_item_over_trials.containsKey(keyword)) {
	          source_list.put( keyword, 	(LinkedList<String> ) generating_method_for_an_item_over_trials.get( keyword) );
	        }
	        else { //set default values
	          LinkedList<String> a_source = new LinkedList<String> ();
	          switch( keyword ){//some cases with numbers
	            case ":display_item_screen_location_x":
	            case ":display_item_screen_location_y":
	            case ":display_item_delay":
	            case ":feedback_item_screen_location_x":
	            case ":feedback_item_screen_location_y":
	            case ":feedback_item_delay":
	            case ":feedback_item_duration":
	            {
	              a_source.addLast ("0");
	              break;
	            }
	            
	            case ":display_item_duration":				
	            {
	              a_source.addLast ("-1.0");
	              break;
	            }
	            case ":display_item_width":
	            case ":display_item_height":
	            {
	              a_source.addLast ("20");
	              break;
	            }
	            case ":display_item_color":	
	            case ":feedback_item_color": { //some special default values
	              a_source.addLast ("black");
	              break;
	            }
	            
	            case ":display_button_color": { //some special default values
	              a_source.addLast ("gray");
	              break;
	            }
	            
	            case ":correct_response_to_each_visual_text":
	            case ":feedback_to_each_visual_text": { //need list .size() to be the same with ":visual_text"
	              int number_of_visual_text_alternatives = ((LinkedList<String> ) generating_method_for_an_item_over_trials.get( ":visual_text" )).size();
	              int i;
	              for (i = 0; i < number_of_visual_text_alternatives ; i ++ ){
	                a_source.addLast ("");
	              }
	              break;
	            }
	            default: { //other cases, String
	              a_source.addLast ("");
	              break;
	            }
	            
	          }
	          source_list.put( keyword,  a_source );	
	        }
	        
	      }
	      
	      //initialize random method list
	      Hashtable random_method_list = new Hashtable (); // Hashtable of (String, String)
	      for(String keyword : keywords_with_LinkedListString_values){
	        if ( generating_method_for_an_item_over_trials.containsKey( keyword  + "_randomization"      )) { //e.g., :display_item_screen_location_x_randomization //have a method by definition and was assigned by the user
	          random_method_list.put(  keyword    ,   (String) generating_method_for_an_item_over_trials .get( keyword  + "_randomization" )   );
	        }
	        else if ( keyword.equals( ":visual_text") ){//special case
	          if ( generating_method_for_an_item_over_trials.containsKey( ":text_randomization" )  ){ //user specified
	            random_method_list.put(  keyword    ,   (String) generating_method_for_an_item_over_trials.get( ":text_randomization" ) );
	          }
	          else{ //use default value
	            random_method_list.put(  keyword    , "fixed_order" );
	          }
	        }
	        else if ( keyword.equals( ":correct_response_to_each_visual_text")  ||  keyword.equals( ":feedback_to_each_visual_text")) { //do nothing, because their random methods are bounded with other keywords
	          continue;
	        }
	        else {	//have definition, but not specified by the user, use default values
	          random_method_list.put(  keyword    , "fixed_order" );
	        }
	        
	      }
	      
	      
	      for ( day_i = 1; day_i <= all_day_added; day_i ++){
	        for (block_i = 1; block_i <= blocks_added_per_day; block_i ++ ){
	          //initialize counter lists for random_without_replacement method before each block // use clone here because they will be manipulated
	          Hashtable counter_list = new Hashtable (); // Hashtable of LinkedList<String>
	          for (String keyword : keywords_with_LinkedListString_values){
	            counter_list.put ( keyword,        ProgramUtilitiesFun__LinkedListString_Clone( (LinkedList<String> )source_list.get(keyword)  )        );
	          }
	          
	          for (trial_i = 1; trial_i <= trials_added_per_block; trial_i ++){
	            //start to generate parameters of this item in this trial.
	            Hashtable a_random_string_table = new Hashtable (); //each value is a random String generated for the key. including default values
	            for(String keyword : keywords_with_LinkedListString_values) {
	              if ( keyword.equals( ":visual_text") ){//special case
	                //three lists are bound together, using the same random method. 
	                Three_Tuple text_and_correct_response_and_feedback = ProgramUtilitiesFun__Get_A_Three_Tuple_String_From_Randomizing_Three_String_Lists ( (LinkedList<String>) source_list.get(":visual_text") , (LinkedList<String>) source_list.get(":correct_response_to_each_visual_text") , (LinkedList<String>) source_list.get(":feedback_to_each_visual_text"),             (LinkedList<String>) counter_list.get(":visual_text"), (LinkedList<String>) counter_list.get(":correct_response_to_each_visual_text") , (LinkedList<String>) counter_list.get(":feedback_to_each_visual_text") ,  (String) random_method_list.get(":visual_text")); //original full String list1, original full String list2, and list3 with the same length, String list counter1, String list counter2, and counter3, one random method (may include fixed_order)
	                a_random_string_table.put(":visual_text", (String) text_and_correct_response_and_feedback.Ob1 );
	                a_random_string_table.put(":correct_response_to_each_visual_text", (String) text_and_correct_response_and_feedback.Ob2 );
	                a_random_string_table.put(":feedback_to_each_visual_text", (String) text_and_correct_response_and_feedback.Ob3 );
	              }
	              else if ( keyword.equals( ":correct_response_to_each_visual_text" ) ||  keyword.equals( ":feedback_to_each_visual_text")) { //do nothing, because their values are bounded with other keywords
	                continue;
	              }
	              else { //common method
	                String a_random_string = ProgramUtilitiesFun__Get_A_String_From_Randomizing_A_String_List (  (LinkedList<String>) source_list.get(keyword) , (LinkedList<String>) counter_list.get(keyword),   (String)random_method_list.get(keyword)   ); //original full String list, String list counter, random method (may include fixed_order)
	                a_random_string_table.put( keyword, a_random_string   );
	              }
	            }
	            
	            
	            //substitue every block_variable name in a_random_string_table.Value to their specific String for this block.
	            TaskTemplateFun__Substitute_Hashtable_Values_With_Block_Variables( Integer.toString(day_i), Integer.toString(block_i) ,  a_random_string_table, current_block_variable_content_by_day_block_variable_name  ); 
	            
	            
	            
	            //prepare the display item
	            Display_Item_Visual_Text_Button a_display_item = new Display_Item_Visual_Text_Button ();
	            a_display_item.Correct_Response 				= (String) a_random_string_table.get(":correct_response_to_each_visual_text");
	            a_display_item.Display_Item_Width				= Integer.parseInt ( (String) a_random_string_table.get(":display_item_width" ) ) ;
	            a_display_item.Display_Item_Height				= Integer.parseInt ( (String) a_random_string_table.get(":display_item_height" ) );
	            a_display_item.Display_Item_Color        		= (String) a_random_string_table.get(":display_item_color" ) ;
	            a_display_item.Display_Button_Color        		= (String) a_random_string_table.get(":display_button_color" ) ;
	            a_display_item.Display_Item_Delay         		= (double) Double.parseDouble ( (String) a_random_string_table.get( ":display_item_delay") );
	            a_display_item.Display_Item_Duration      	    = (double) Double.parseDouble ( (String) a_random_string_table.get( ":display_item_duration") ) ;
	            a_display_item.Display_Item_Screen_Location_X   = Integer.parseInt ( (String) a_random_string_table.get( ":display_item_screen_location_x") );
	            a_display_item.Display_Item_Screen_Location_Y   = Integer.parseInt ( (String) a_random_string_table.get( ":display_item_screen_location_y") );
	            a_display_item.Feedback          				= (String) a_random_string_table.get( ":feedback_to_each_visual_text") ;
	            a_display_item.Feedback_Item_Color    	 	    = (String) a_random_string_table.get( ":feedback_item_color" ) ;
	            a_display_item.Feedback_Item_Delay       		= (double) Double.parseDouble ( (String) a_random_string_table.get( ":feedback_item_delay") );
	            a_display_item.Feedback_Item_Duration     	    = (double) Double.parseDouble ( (String) a_random_string_table.get( ":feedback_item_duration") ) ;
	            a_display_item.Feedback_Item_Screen_Location_X  = Integer.parseInt ( (String) a_random_string_table.get( ":feedback_item_screen_location_x") );
	            a_display_item.Feedback_Item_Screen_Location_Y  = Integer.parseInt ( (String) a_random_string_table.get( ":feedback_item_screen_location_y") );
	            a_display_item.Visual_Text          			= (String) a_random_string_table.get(":visual_text" ) ;
	            a_display_item.Item_ID = "item-" +  Integer.toString(item_id_num);
	            if( generating_method_for_an_item_over_trials.containsKey(":hide") && ((String) generating_method_for_an_item_over_trials.get(":hide")).equals( "t") ) {
	              a_display_item.Hide = true; //false by default
	            }
	            
	            //check dynamic tigger events for "display_item_visual_text_button"
	            if( generating_method_for_an_item_over_trials.containsKey(":button_click_event") ) {
	              a_display_item.Button_Click_Event = (String) generating_method_for_an_item_over_trials.get(":button_click_event");
	            }
	            
	            //check dynamic item name 
	            if( generating_method_for_an_item_over_trials.containsKey(":item_name") ) {
	              a_display_item.Item_Name = (String) generating_method_for_an_item_over_trials.get(":item_name");
	            }
	            
	            //add prepared trial info into the return list.
	            a_random_string_table.put(":item_type", item_type );
	            item_parameter_over_trials.addLast ( a_random_string_table );
	            
	            item_display_over_trials.addLast ( a_display_item);
	          }//end trial_i	
	        }//end block_i
	      } //end day_i
	      
	      
	      
	    } //end of item_type.equals( "display_item_visual_text_button")
	    
	    else if ( item_type.equals( "display_item_visual_line") ) {
	      
	      //initialize source lists storing the user-defined information for trials // these source lists must not be changed.
	      //these are defined by item_type.equals( "display_item_visual_line" )
	      
	      
	      LinkedList<String> keywords_with_LinkedListString_values = new LinkedList<String> ();
	      keywords_with_LinkedListString_values.addLast(":start_point_screen_location_x");            //these six share the same random method, have a random method ":text_randomization鑼呰棝妤煎繖娼炴埉鑼傞┐闄嗚寕椹撮檰
	      keywords_with_LinkedListString_values.addLast(":start_point_screen_location_y");            //these six share the same random method, have a random method ":text_randomization鑼呰棝妤煎繖娼炴埉鑼傞┐闄嗚寕椹撮檰
	      keywords_with_LinkedListString_values.addLast(":end_point_screen_location_x");              //these six share the same random method, have a random method ":text_randomization鑼呰棝妤煎繖娼炴埉鑼傞┐闄嗚寕椹撮檰
	      keywords_with_LinkedListString_values.addLast(":end_point_screen_location_y");              //these six share the same random method, have a random method ":text_randomization鑼呰棝妤煎繖娼炴埉鑼傞┐闄嗚寕椹撮檰
	      keywords_with_LinkedListString_values.addLast(":correct_response");     //these six share the same random method, NO random method
	      keywords_with_LinkedListString_values.addLast(":feedback_content");             //these six share the same random method, No random method
	      
	      keywords_with_LinkedListString_values.addLast(":display_item_color");
	      keywords_with_LinkedListString_values.addLast(":display_item_delay");
	      keywords_with_LinkedListString_values.addLast(":display_item_duration");
	      keywords_with_LinkedListString_values.addLast(":feedback_item_screen_location_x");
	      keywords_with_LinkedListString_values.addLast(":feedback_item_screen_location_y");
	      keywords_with_LinkedListString_values.addLast(":feedback_item_color");
	      keywords_with_LinkedListString_values.addLast(":feedback_item_delay");
	      keywords_with_LinkedListString_values.addLast(":feedback_item_duration");
	      
	      //initialize source_list
	      Hashtable source_list = new Hashtable (); // Hashtable of (String, LinkedList<String>)
	      for(String keyword : keywords_with_LinkedListString_values){
	        if ( generating_method_for_an_item_over_trials.containsKey(keyword)) {
	          source_list.put( keyword, 	(LinkedList<String> ) generating_method_for_an_item_over_trials.get( keyword ) );
	        }
	        else { //set default values
	          LinkedList<String> a_source = new LinkedList<String> ();
	          switch( keyword ){//some cases with numbers
	            case ":start_point_screen_location_x":
	            case ":start_point_screen_location_y":
	            case ":end_point_screen_location_x":
	            case ":end_point_screen_location_y":
	              
	            case ":display_item_delay":
	            case ":feedback_item_screen_location_x":
	            case ":feedback_item_screen_location_y":
	            case ":feedback_item_delay":
	            case ":feedback_item_duration":
	            {
	              a_source.addLast ("0");
	              break;
	            }
	            
	            case ":display_item_duration":				
	            {
	              a_source.addLast ("-1.0");
	              break;
	            }
	            
	            case ":display_item_color":	
	            case ":feedback_item_color": { //some special default values
	              a_source.addLast ("black");
	              break;
	            }
	            case ":correct_response":
	            case ":feedback_content": { //need list .size() to be the same with ":start_point_screen_location_x"
	              int number_of_visual_text_alternatives = ((LinkedList<String> ) generating_method_for_an_item_over_trials.get( ":start_point_screen_location_x" )).size();
	              int i;
	              for (i = 0; i < number_of_visual_text_alternatives ; i ++ ){
	                a_source.addLast ("");
	              }
	              break;
	            }
	            default: { //other cases, String
	              a_source.addLast ("");
	              break;
	            }
	            
	          }
	          source_list.put( keyword,  a_source );	
	        }
	        
	      }
	      
	      //initialize random method list
	      Hashtable random_method_list = new Hashtable (); // Hashtable of (String, String)
	      for(String keyword : keywords_with_LinkedListString_values){
	        if ( generating_method_for_an_item_over_trials.containsKey( keyword  + "_randomization"      )) { //e.g., :display_item_screen_location_x_randomization //have a method by definition and was assigned by the user
	          random_method_list.put(  keyword    ,   (String) generating_method_for_an_item_over_trials .get( keyword  + "_randomization" )   );
	        }
	        else if ( keyword.equals( ":start_point_screen_location_x") ){//special case
	          if ( generating_method_for_an_item_over_trials.containsKey( ":start_and_end_points_screen_location_randomization" )  ){ //user specified
	            random_method_list.put(  keyword    ,   (String) generating_method_for_an_item_over_trials .get( ":start_and_end_points_screen_location_randomization" ) );
	          }
	          else{ //use default value
	            random_method_list.put(  keyword    , "fixed_order" );
	          }
	        }
	        else if ( keyword.equals( ":start_point_screen_location_y") || keyword.equals( ":end_point_screen_location_x") || keyword.equals( ":end_point_screen_location_y") || keyword.equals( ":correct_response" )  ||  keyword.equals( ":feedback_content")) { //do nothing, because their random methods are bounded with other keywords
	          continue;
	        }
	        else {	//have definition, but not specified by the user, use default values
	          random_method_list.put(  keyword    , "fixed_order" );
	        }
	        
	      }
	      
	      
	      for ( day_i = 1; day_i <= all_day_added; day_i ++){
	        for (block_i = 1; block_i <= blocks_added_per_day; block_i ++ ){
	          //initialize counter lists for random_without_replacement method before each block // use clone here because they will be manipulated
	          Hashtable counter_list = new Hashtable (); // Hashtable of LinkedList<String>
	          for(String keyword : keywords_with_LinkedListString_values){
	            counter_list.put ( keyword,        ProgramUtilitiesFun__LinkedListString_Clone( (LinkedList<String> )source_list.get(keyword) )        );
	          }
	          
	          for (trial_i = 1; trial_i <= trials_added_per_block; trial_i ++){
	            //start to generate parameters of this item in this trial.
	            Hashtable a_random_string_table = new Hashtable (); //each value is a random String generated for the key. including default values
	            for(String keyword : keywords_with_LinkedListString_values) {
	              if ( keyword.equals( ":start_point_screen_location_x" ) ){//special case
	                //six lists are bound together, using the same random method. 
	                
	                Six_Tuple startX_Y_endX_Y_and_correct_response_and_feedback = ProgramUtilitiesFun__Get_A_Six_Tuple_String_From_Randomizing_Six_String_Lists ( (LinkedList<String>) source_list.get(":start_point_screen_location_x") , (LinkedList<String>) source_list.get(":start_point_screen_location_y") , (LinkedList<String>) source_list.get(":end_point_screen_location_x"), (LinkedList<String>) source_list.get(":end_point_screen_location_y"), (LinkedList<String>) source_list.get(":correct_response") , (LinkedList<String>) source_list.get(":feedback_content"),            (LinkedList<String>) counter_list.get(":start_point_screen_location_x") , (LinkedList<String>) counter_list.get(":start_point_screen_location_y") , (LinkedList<String>) counter_list.get(":end_point_screen_location_x"), (LinkedList<String>) counter_list.get(":end_point_screen_location_y"), (LinkedList<String>) counter_list.get(":correct_response") , (LinkedList<String>) counter_list.get(":feedback_content"),         (String) random_method_list.get(":start_point_screen_location_x")); //original full String list1, original full String list2, and list3 with the same length, String list counter1, String list counter2, and counter3, ... , one random method (may include fixed_order)
	                //Three_Tuple text_and_correct_response_and_feedback = ProgramUtilitiesFun__Get_A_Three_Tuple_String_From_Randomizing_Three_String_Lists ( (LinkedList<String>) source_list[":visual_text"] , (LinkedList<String>) source_list[":correct_response_to_each_visual_text"] , (LinkedList<String>) source_list[":feedback_to_each_visual_text"],             (LinkedList<String>) counter_list[":visual_text"], (LinkedList<String>) counter_list[":correct_response_to_each_visual_text"] , (LinkedList<String>) counter_list[":feedback_to_each_visual_text"] ,  (String) random_method_list[":visual_text"]); //original full String list1, original full String list2, and list3 with the same length, String list counter1, String list counter2, and counter3, one random method (may include fixed_order)
	                a_random_string_table.put(":start_point_screen_location_x", (String) startX_Y_endX_Y_and_correct_response_and_feedback.Ob1 );
	                a_random_string_table.put(":start_point_screen_location_y", (String) startX_Y_endX_Y_and_correct_response_and_feedback.Ob2 );
	                a_random_string_table.put(":end_point_screen_location_x", (String) startX_Y_endX_Y_and_correct_response_and_feedback.Ob3 );
	                a_random_string_table.put(":end_point_screen_location_y", (String) startX_Y_endX_Y_and_correct_response_and_feedback.Ob4 );
	                a_random_string_table.put(":correct_response", (String) startX_Y_endX_Y_and_correct_response_and_feedback.Ob5 );
	                a_random_string_table.put(":feedback_content", (String) startX_Y_endX_Y_and_correct_response_and_feedback.Ob6 );
	              }
	              else if ( keyword.equals( ":start_point_screen_location_y" ) || keyword.equals( ":end_point_screen_location_x" ) || keyword.equals( ":end_point_screen_location_y") || keyword.equals( ":correct_response") ||  keyword.equals( ":feedback_content") ) { //do nothing, because their values are bounded with other keywords
	                continue;
	              }
	              else { //common method
	                String a_random_string = ProgramUtilitiesFun__Get_A_String_From_Randomizing_A_String_List (  (LinkedList<String>) source_list.get(keyword) , (LinkedList<String>) counter_list.get(keyword),   (String)random_method_list.get(keyword)   ); //original full String list, String list counter, random method (may include fixed_order)
	                a_random_string_table.put( keyword, a_random_string   );
	              }
	            }
	            
	            
	            //substitue every block_variable name in a_random_string_table.Value to their specific String for this block.
	            TaskTemplateFun__Substitute_Hashtable_Values_With_Block_Variables( Integer.toString(day_i), Integer.toString(block_i) ,  a_random_string_table, current_block_variable_content_by_day_block_variable_name  ); 
	            
	            
	            
	            //prepare the display item
	            Display_Item_Visual_Line   a_display_item = new Display_Item_Visual_Line ();
	            a_display_item.Correct_Response 				= (String) a_random_string_table.get(":correct_response");
	            a_display_item.Display_Item_Color        		= (String) a_random_string_table.get(":display_item_color" ) ;
	            a_display_item.Display_Item_Delay         		= (double) Double.parseDouble ( (String) a_random_string_table.get( ":display_item_delay") );
	            a_display_item.Display_Item_Duration      	    = (double) Double.parseDouble ( (String) a_random_string_table.get( ":display_item_duration") ) ;
	            
	            //System.out.println ( (String) a_random_string_table[ ":end_point_screen_location_x"] );
	            
	            a_display_item.End_Point_Screen_Location_X		= Integer.parseInt ( (String) a_random_string_table.get( ":end_point_screen_location_x") );
	            a_display_item.End_Point_Screen_Location_Y		= Integer.parseInt ( (String) a_random_string_table.get( ":end_point_screen_location_y") );
	            a_display_item.Feedback          				= (String) a_random_string_table.get( ":feedback_to_each_visual_text") ;
	            a_display_item.Feedback_Item_Color    	 	    = (String) a_random_string_table.get( ":feedback_item_color" ) ;
	            a_display_item.Feedback_Item_Delay       		= (double) Double.parseDouble ( (String) a_random_string_table.get( ":feedback_item_delay") );
	            a_display_item.Feedback_Item_Duration     	    = (double) Double.parseDouble ( (String) a_random_string_table.get( ":feedback_item_duration") ) ;
	            a_display_item.Feedback_Item_Screen_Location_X  = Integer.parseInt ( (String) a_random_string_table.get( ":feedback_item_screen_location_x") );
	            a_display_item.Feedback_Item_Screen_Location_Y  = Integer.parseInt ( (String) a_random_string_table.get( ":feedback_item_screen_location_y") );
	            a_display_item.Start_Point_Screen_Location_X	= Integer.parseInt ( (String) a_random_string_table.get( ":start_point_screen_location_x") );
	            a_display_item.Start_Point_Screen_Location_Y	= Integer.parseInt ( (String) a_random_string_table.get( ":start_point_screen_location_y") );
	            a_display_item.Item_ID = "item-" +  Integer.toString(item_id_num);
	            a_display_item.Length = (double) Math.sqrt( (double)( (a_display_item.End_Point_Screen_Location_X - a_display_item.Start_Point_Screen_Location_X) * (a_display_item.End_Point_Screen_Location_X - a_display_item.Start_Point_Screen_Location_X) + (a_display_item.End_Point_Screen_Location_Y - a_display_item.Start_Point_Screen_Location_Y) * (a_display_item.End_Point_Screen_Location_Y - a_display_item.Start_Point_Screen_Location_Y) ) ) ;
	            if( generating_method_for_an_item_over_trials.containsKey(":hide") && ((String) generating_method_for_an_item_over_trials.get(":hide")).equals( "t") ) {
	              a_display_item.Hide = true; //false by default
	            }
	            
	            //check dynamic item name 
	            if( generating_method_for_an_item_over_trials.containsKey(":item_name") ) {
	              a_display_item.Item_Name = (String) generating_method_for_an_item_over_trials.get(":item_name");
	            }
	            
	            //add prepared trial info into the return list.
	            a_random_string_table.put(":item_type", item_type );
	            item_parameter_over_trials.addLast ( a_random_string_table );
	            
	            item_display_over_trials.addLast ( a_display_item);
	          }//end trial_i	
	        }//end block_i
	      } //end day_i
	      
	      
	    } // end of display_item_visual_line
	    
	    else if ( item_type.equals( "display_item_audio_tone_sound") ){
	      //initialize source lists storing the user-defined information for trials // these source lists must not be changed.
	      //these are all possible keyworks for linkedlist String inputs defined by item_type.equals( "display_item_audio_tone_sound" )
	      LinkedList<String> keywords_with_LinkedListString_values = new LinkedList<String> ();
	      keywords_with_LinkedListString_values.addLast(":frequency");                    //these three share the same random method, have a random method ":frequency_randomization"
	      keywords_with_LinkedListString_values.addLast(":correct_response");     		//these three share the same random method, NO random method
	      keywords_with_LinkedListString_values.addLast(":feedback_content");             //these three share the same random method, No random method
	      keywords_with_LinkedListString_values.addLast(":display_item_delay");
	      keywords_with_LinkedListString_values.addLast(":display_item_duration");
	      keywords_with_LinkedListString_values.addLast(":channel");
	      keywords_with_LinkedListString_values.addLast(":feedback_item_duration");
	      
	      /* // ToDO may add feedback here
		keywords_with_LinkedListString_values.addLast(":feedback_item_screen_location_x");
		keywords_with_LinkedListString_values.addLast(":feedback_item_screen_location_y");
		keywords_with_LinkedListString_values.addLast(":feedback_item_color");
		keywords_with_LinkedListString_values.addLast(":feedback_item_delay");

	       */
	      
	      
	      //initialize source_list
	      Hashtable source_list = new Hashtable (); // Hashtable of (String, LinkedList<String>)
	      for(String keyword : keywords_with_LinkedListString_values){
	        if ( generating_method_for_an_item_over_trials.containsKey(keyword)) {
	          source_list.put( keyword, 	(LinkedList<String> ) generating_method_for_an_item_over_trials.get( keyword ) );
	        }
	        else { //set default values
	          LinkedList<String> a_source = new LinkedList<String> ();
	          switch( keyword ){//some cases with numbers
	            //case ":display_item_screen_location_x":
	            //case ":display_item_screen_location_y":
	            case ":display_item_delay":
	              //case ":feedback_item_screen_location_x":
	              //case ":feedback_item_screen_location_y":
	            case ":feedback_item_delay":
	            case ":frequency":
	            case ":feedback_item_duration":
	            {
	              a_source.addLast ("0");
	              break;
	            }
	            
	            case ":display_item_duration":
	              
	            {
	              a_source.addLast ("-1.0");
	              break;
	            }
	            
	            /*
		case ":display_item_color":	
		case ":feedback_item_color": { //some special default values
		a_source.addLast ("black");
		break;
		}
	             */
	            case ":channel":	{ //some special default values
	              a_source.addLast ("left_and_right");
	              break;
	            }
	            
	            case ":correct_response":
	            case ":feedback_content": { 
	              int number_of_alternatives = ((LinkedList<String> ) generating_method_for_an_item_over_trials.get( ":frequency" )).size();
	              int i;
	              for (i = 0; i < number_of_alternatives ; i ++ ){
	                a_source.addLast ("");
	              }
	              break;
	            }
	            default: { //other cases, String
	              a_source.addLast ("");
	              break;
	            }
	            
	          }
	          source_list.put( keyword,  a_source );	
	        }
	      } //end of initialize source_list
	      
	      
	      //initialize random method list
	      Hashtable random_method_list = new Hashtable (); // Hashtable of (String, String)
	      for(String keyword : keywords_with_LinkedListString_values){
	        if ( generating_method_for_an_item_over_trials.containsKey( keyword  + "_randomization"      )) { //e.g., :display_item_screen_location_x_randomization //have a method by definition and was assigned by the user
	          random_method_list.put(  keyword    ,   (String) generating_method_for_an_item_over_trials .get( keyword  + "_randomization" )   );
	        }
	        /*
		else if ( keyword.equals( ":frequency" )){//special case
		if ( generating_method_for_an_item_over_trials.containsKey( ":frequency_randomization" )  ){ //user specified
		random_method_list.put(  keyword    ,   (String) generating_method_for_an_item_over_trials [ ":frequency_randomization" ] );
		}
		else{ //use default value
		random_method_list.put(  keyword    , "fixed_order" );
		}
		}
	         */
	        else if ( keyword.equals( ":correct_response")  ||  keyword.equals( ":feedback_content")) { //do nothing, because their random methods are bounded with other keywords
	          continue;
	        }
	        else {	//have definition, but not specified by the user, use default values
	          random_method_list.put(  keyword    , "fixed_order" );
	        }
	      } //end of initialize random method list
	      
	      
	      for ( day_i = 1; day_i <= all_day_added; day_i ++){
	        for (block_i = 1; block_i <= blocks_added_per_day; block_i ++ ){
	          //initialize counter lists for random_without_replacement method before each block // use clone here because they will be manipulated
	          Hashtable counter_list = new Hashtable (); // Hashtable of LinkedList<String>
	          for(String keyword : keywords_with_LinkedListString_values){
	            counter_list.put ( keyword,        ProgramUtilitiesFun__LinkedListString_Clone( (LinkedList<String> )source_list.get(keyword)  )        );
	          }
	          
	          for (trial_i = 1; trial_i <= trials_added_per_block; trial_i ++){
	            //start to generate parameters of this item in this trial.
	            Hashtable a_random_string_table = new Hashtable (); //each value is a random String generated for the key. including default values
	            for(String keyword : keywords_with_LinkedListString_values) {
	              if ( keyword.equals( ":frequency") ){//special case
	                //three lists are bound together, using the same random method. 
	                Three_Tuple text_and_correct_response_and_feedback = ProgramUtilitiesFun__Get_A_Three_Tuple_String_From_Randomizing_Three_String_Lists ( (LinkedList<String>) source_list.get(":frequency") , (LinkedList<String>) source_list.get(":correct_response") , (LinkedList<String>) source_list.get(":feedback_content"),             (LinkedList<String>) counter_list.get(":frequency"), (LinkedList<String>) counter_list.get(":correct_response") , (LinkedList<String>) counter_list.get(":feedback_content") ,  (String) random_method_list.get(":frequency")); //original full String list1, original full String list2, and list3 with the same length, String list counter1, String list counter2, and counter3, one random method (may include fixed_order)
	                a_random_string_table.put(":frequency", (String) text_and_correct_response_and_feedback.Ob1 );
	                a_random_string_table.put(":correct_response", (String) text_and_correct_response_and_feedback.Ob2 );
	                a_random_string_table.put(":feedback_content", (String) text_and_correct_response_and_feedback.Ob3 );
	              }
	              else if ( keyword.equals( ":correct_response" ) ||  keyword.equals( ":feedback_content")) { //do nothing, because their values are bounded with other keywords
	                continue;
	              }
	              else { //common method
	                String a_random_string = ProgramUtilitiesFun__Get_A_String_From_Randomizing_A_String_List (  (LinkedList<String>) source_list.get(keyword) , (LinkedList<String>) counter_list.get(keyword),   (String)random_method_list.get(keyword)   ); //original full String list, String list counter, random method (may include fixed_order)
	                a_random_string_table.put( keyword, a_random_string   );
	              }
	            }
	            
	            
	            //substitue every block_variable name in a_random_string_table.Value to their specific String for this block.
	            TaskTemplateFun__Substitute_Hashtable_Values_With_Block_Variables( Integer.toString(day_i), Integer.toString(block_i) ,  a_random_string_table, current_block_variable_content_by_day_block_variable_name  ); 
	            
	            
	            //prepare the display item
	            Display_Item_Audio_Tone_Sound a_display_item = new Display_Item_Audio_Tone_Sound();
	            a_display_item.Channel					=	(String) a_random_string_table.get(":channel" ) ;
	            a_display_item.Correct_Response			= 	(String) a_random_string_table.get(":correct_response");
	            a_display_item.Display_Item_Delay		= (double) Double.parseDouble ( (String) a_random_string_table.get( ":display_item_delay") );
	            a_display_item.Display_Item_Duration	= (double) Double.parseDouble ( (String) a_random_string_table.get( ":display_item_duration") ) ;
	            a_display_item.Feedback					= (String) a_random_string_table.get( ":feedback_content") ;
	            a_display_item.Frequency				= Integer.parseInt ( (String) a_random_string_table.get( ":frequency") );
	            a_display_item.Item_ID = "item-" +  Integer.toString(item_id_num);
	            
	            /*
		Display_Item_Visual_Text a_display_item = new Display_Item_Visual_Text ();
		a_display_item.Correct_Response 				= (String) a_random_string_table[":correct_response_to_each_visual_text"];
		a_display_item.Display_Item_Color        		= (String) a_random_string_table[":display_item_color" ] ;
		a_display_item.Display_Item_Delay         		= Double.parseDouble ( (String) a_random_string_table[ ":display_item_delay"] );
		a_display_item.Display_Item_Duration      	    = Double.parseDouble ( (String) a_random_string_table[ ":display_item_duration"] ) ;
		a_display_item.Display_Item_Screen_Location_X   = Integer.parseInt ( (String) a_random_string_table[ ":display_item_screen_location_x"] );
		a_display_item.Display_Item_Screen_Location_Y   = Integer.parseInt ( (String) a_random_string_table[ ":display_item_screen_location_y"] );
		a_display_item.Feedback          				= (String) a_random_string_table[ ":feedback_to_each_visual_text"] ;
		a_display_item.Feedback_Item_Color    	 	    = (String) a_random_string_table[ ":feedback_item_color" ] ;
		a_display_item.Feedback_Item_Delay       		= Double.parseDouble ( (String) a_random_string_table[ ":feedback_item_delay"] );
		a_display_item.Feedback_Item_Duration     	    = Double.parseDouble ( (String) a_random_string_table[ ":feedback_item_duration"] ) ;
		a_display_item.Feedback_Item_Screen_Location_X  = Integer.parseInt ( (String) a_random_string_table[ ":feedback_item_screen_location_x"] );
		a_display_item.Feedback_Item_Screen_Location_Y  = Integer.parseInt ( (String) a_random_string_table[ ":feedback_item_screen_location_y"] );
		a_display_item.Visual_Text          			= (String) a_random_string_table[":visual_text" ] ;
	             */
	            
	            
	            //add prepared trial info into the return list.
	            a_random_string_table.put(":item_type", item_type );
	            item_parameter_over_trials.addLast ( a_random_string_table );
	            
	            item_display_over_trials.addLast ( a_display_item);
	          }//end trial_i	
	        }//end block_i
	      } //end day_i
	      
	    } //end of		 display_item_audio_tone_sound
	    
	    else if ( item_type.equals( "display_item_audio_digit_sound" )){  
	      //initialize source lists storing the user-defined information for trials // these source lists must not be changed.
	      //these are all possible keyworks for linkedlist String inputs defined by item_type.equals( "display_item_audio_digit_sound" )
	      LinkedList<String> keywords_with_LinkedListString_values = new LinkedList<String> ();
	      keywords_with_LinkedListString_values.addLast(":digit");                    //these three share the same random method, have a random method ":digit_randomization"
	      keywords_with_LinkedListString_values.addLast(":correct_response");     		//these three share the same random method, NO random method
	      keywords_with_LinkedListString_values.addLast(":feedback_content");             //these three share the same random method, No random method
	      keywords_with_LinkedListString_values.addLast(":display_item_delay");
	      //keywords_with_LinkedListString_values.addLast(":display_item_duration");	//ACT-R has fixed duration for digit sound.
	      keywords_with_LinkedListString_values.addLast(":channel");
	      keywords_with_LinkedListString_values.addLast(":feedback_item_duration");
	      
	      /* // ToDO may add feedback here
		keywords_with_LinkedListString_values.addLast(":feedback_item_screen_location_x");
		keywords_with_LinkedListString_values.addLast(":feedback_item_screen_location_y");
		keywords_with_LinkedListString_values.addLast(":feedback_item_color");
		keywords_with_LinkedListString_values.addLast(":feedback_item_delay");

	       */
	      
	      
	      //initialize source_list
	      Hashtable source_list = new Hashtable (); // Hashtable of (String, LinkedList<String>)
	      for(String keyword : keywords_with_LinkedListString_values){
	        if ( generating_method_for_an_item_over_trials.containsKey(keyword)) {
	          source_list.put( keyword, 	(LinkedList<String> ) generating_method_for_an_item_over_trials.get( keyword ) );
	        }
	        else { //set default values
	          LinkedList<String> a_source = new LinkedList<String> ();
	          switch( keyword ){//some cases with numbers
	            //case ":display_item_screen_location_x":
	            //case ":display_item_screen_location_y":
	            case ":display_item_delay":
	              //case ":feedback_item_screen_location_x":
	              //case ":feedback_item_screen_location_y":
	            case ":feedback_item_delay":
	              //case ":frequency":
	            case ":feedback_item_duration":
	            {
	              a_source.addLast ("0");
	              break;
	            }
	            
	            case ":digit":
	            {
	              a_source.addLast ("");
	              break;
	            }
	            
	            /*
		case ":display_item_duration":

		{
		a_source.addLast ("-1.0");
		break;
		}
		case ":display_item_color":	
		case ":feedback_item_color": { //some special default values
		a_source.addLast ("black");
		break;
		}
	             */
	            case ":channel":	{ //some special default values
	              a_source.addLast ("left_and_right");
	              break;
	            }
	            
	            case ":correct_response":
	            case ":feedback_content": { 
	              int number_of_alternatives = ((LinkedList<String> ) generating_method_for_an_item_over_trials.get( ":digit" )).size();
	              int i;
	              for (i = 0; i < number_of_alternatives ; i ++ ){
	                a_source.addLast ("");
	              }
	              break;
	            }
	            default: { //other cases, String
	              a_source.addLast ("");
	              break;
	            }
	            
	          }
	          source_list.put( keyword,  a_source );	
	        }
	      } //end of initialize source_list
	      
	      
	      //initialize random method list
	      Hashtable random_method_list = new Hashtable (); // Hashtable of (String, String)
	      for(String keyword : keywords_with_LinkedListString_values){
	        if ( generating_method_for_an_item_over_trials.containsKey( keyword  + "_randomization"      )) { //e.g., :display_item_screen_location_x_randomization //have a method by definition and was assigned by the user
	          random_method_list.put(  keyword    ,   (String) generating_method_for_an_item_over_trials .get( keyword  + "_randomization" )   );
	        }
	        /*
		else if ( keyword.equals( ":frequency") ){//special case
		if ( generating_method_for_an_item_over_trials.containsKey( ":frequency_randomization" )  ){ //user specified
		random_method_list.put(  keyword    ,   (String) generating_method_for_an_item_over_trials [ ":frequency_randomization" ] );
		}
		else{ //use default value
		random_method_list.put(  keyword    , "fixed_order" );
		}
		}
	         */
	        else if ( keyword.equals( ":correct_response" )  ||  keyword.equals( ":feedback_content" )) { //do nothing, because their random methods are bounded with other keywords
	          continue;
	        }
	        else {	//have definition, but not specified by the user, use default values
	          random_method_list.put(  keyword    , "fixed_order" );
	        }
	      } //end of initialize random method list
	      
	      
	      for ( day_i = 1; day_i <= all_day_added; day_i ++){
	        for (block_i = 1; block_i <= blocks_added_per_day; block_i ++ ){
	          //initialize counter lists for random_without_replacement method before each block // use clone here because they will be manipulated
	          Hashtable counter_list = new Hashtable (); // Hashtable of LinkedList<String>
	          for(String keyword : keywords_with_LinkedListString_values){
	            counter_list.put ( keyword,        ProgramUtilitiesFun__LinkedListString_Clone( (LinkedList<String> )source_list.get(keyword) )        );
	          }
	          
	          for (trial_i = 1; trial_i <= trials_added_per_block; trial_i ++){
	            //start to generate parameters of this item in this trial.
	            Hashtable a_random_string_table = new Hashtable (); //each value is a random String generated for the key. including default values
	            for(String keyword : keywords_with_LinkedListString_values) {
	              if ( keyword.equals( ":digit" ) ){//special case
	                //three lists are bound together, using the same random method. 
	                Three_Tuple text_and_correct_response_and_feedback = ProgramUtilitiesFun__Get_A_Three_Tuple_String_From_Randomizing_Three_String_Lists ( (LinkedList<String>) source_list.get(":digit") , (LinkedList<String>) source_list.get(":correct_response") , (LinkedList<String>) source_list.get(":feedback_content"),             (LinkedList<String>) counter_list.get(":digit"), (LinkedList<String>) counter_list.get(":correct_response") , (LinkedList<String>) counter_list.get(":feedback_content") ,  (String) random_method_list.get(":digit")); //original full String list1, original full String list2, and list3 with the same length, String list counter1, String list counter2, and counter3, one random method (may include fixed_order)
	                a_random_string_table.put(":digit", (String) text_and_correct_response_and_feedback.Ob1 );
	                a_random_string_table.put(":correct_response", (String) text_and_correct_response_and_feedback.Ob2 );
	                a_random_string_table.put(":feedback_content", (String) text_and_correct_response_and_feedback.Ob3 );
	              }
	              else if ( keyword.equals( ":correct_response" )  ||  keyword.equals(":feedback_content")) { //do nothing, because their values are bounded with other keywords
	                continue;
	              }
	              else { //common method
	                String a_random_string = ProgramUtilitiesFun__Get_A_String_From_Randomizing_A_String_List (  (LinkedList<String>) source_list.get(keyword) , (LinkedList<String>) counter_list.get(keyword),   (String)random_method_list.get(keyword)   ); //original full String list, String list counter, random method (may include fixed_order)
	                a_random_string_table.put( keyword, a_random_string   );
	              }
	            }
	            
	            
	            //substitue every block_variable name in a_random_string_table.Value to their specific String for this block.
	            TaskTemplateFun__Substitute_Hashtable_Values_With_Block_Variables( Integer.toString(day_i), Integer.toString(block_i) ,  a_random_string_table, current_block_variable_content_by_day_block_variable_name  ); 
	            
	            
	            //prepare the display item
	            Display_Item_Audio_Digit_Sound a_display_item = new Display_Item_Audio_Digit_Sound();
	            a_display_item.Channel					=	(String) a_random_string_table.get(":channel" ) ;
	            a_display_item.Correct_Response			= 	(String) a_random_string_table.get(":correct_response");
	            a_display_item.Display_Item_Delay		= (double) Double.parseDouble ( (String) a_random_string_table.get( ":display_item_delay") );
	            //a_display_item.Display_Item_Duration	= Double.parseDouble ( (String) a_random_string_table[ ":display_item_duration"] ) ;
	            a_display_item.Feedback					= (String) a_random_string_table.get( ":feedback_content") ;
	            a_display_item.Digit					= ( (String) a_random_string_table.get( ":digit") );
	            a_display_item.Item_ID = "item-" +  Integer.toString(item_id_num);
	            
	            //add prepared trial info into the return list.
	            a_random_string_table.put(":item_type", item_type );
	            item_parameter_over_trials.addLast ( a_random_string_table );
	            
	            item_display_over_trials.addLast ( a_display_item);
	          }//end trial_i	
	        }//end block_i
	      } //end day_i
	      
	    } //end of display_item_audio_digit_sound
	    
	    else if ( item_type.equals( "display_item_audio_word_sound") ){  
	      //initialize source lists storing the user-defined information for trials // these source lists must not be changed.
	      //these are all possible keyworks for linkedlist String inputs defined by item_type.equals( "display_item_audio_word_sound" )
	      LinkedList<String> keywords_with_LinkedListString_values = new LinkedList<String> ();
	      keywords_with_LinkedListString_values.addLast(":word");                    //these three share the same random method, have a random method ":word_randomization"
	      keywords_with_LinkedListString_values.addLast(":correct_response");     		//these three share the same random method, NO random method
	      keywords_with_LinkedListString_values.addLast(":feedback_content");             //these three share the same random method, No random method
	      keywords_with_LinkedListString_values.addLast(":display_item_delay");
	      //keywords_with_LinkedListString_values.addLast(":display_item_duration");	//ACT-R has fixed duration for word sound computed by SpeechModuleFun__Get_Articulation_Time.
	      keywords_with_LinkedListString_values.addLast(":channel");
	      keywords_with_LinkedListString_values.addLast(":feedback_item_duration");
	      
	      /* // ToDO may add feedback here
		keywords_with_LinkedListString_values.addLast(":feedback_item_screen_location_x");
		keywords_with_LinkedListString_values.addLast(":feedback_item_screen_location_y");
		keywords_with_LinkedListString_values.addLast(":feedback_item_color");
		keywords_with_LinkedListString_values.addLast(":feedback_item_delay");

	       */
	      
	      
	      //initialize source_list
	      Hashtable source_list = new Hashtable (); // Hashtable of (String, LinkedList<String>)
	      for(String keyword : keywords_with_LinkedListString_values){
	        if ( generating_method_for_an_item_over_trials.containsKey(keyword)) {
	          source_list.put( keyword, 	(LinkedList<String> ) generating_method_for_an_item_over_trials.get( keyword ) );
	        }
	        else { //set default values
	          LinkedList<String> a_source = new LinkedList<String> ();
	          switch( keyword ){//some cases with numbers
	            //case ":display_item_screen_location_x":
	            //case ":display_item_screen_location_y":
	            case ":display_item_delay":
	              //case ":feedback_item_screen_location_x":
	              //case ":feedback_item_screen_location_y":
	            case ":feedback_item_delay":
	              //case ":frequency":
	            case ":feedback_item_duration":
	            {
	              a_source.addLast ("0");
	              break;
	            }
	            
	            case ":word":
	            {
	              a_source.addLast ("");
	              break;
	            }
	            
	            /*
		case ":display_item_duration":

		{
		a_source.addLast ("-1.0");
		break;
		}
		case ":display_item_color":	
		case ":feedback_item_color": { //some special default values
		a_source.addLast ("black");
		break;
		}
	             */
	            case ":channel":	{ //some special default values
	              a_source.addLast ("left_and_right");
	              break;
	            }
	            
	            case ":correct_response":
	            case ":feedback_content": { 
	              int number_of_alternatives = ((LinkedList<String> ) generating_method_for_an_item_over_trials.get( ":word" )).size();
	              int i;
	              for (i = 0; i < number_of_alternatives ; i ++ ){
	                a_source.addLast ("");
	              }
	              break;
	            }
	            default: { //other cases, String
	              a_source.addLast ("");
	              break;
	            }
	            
	          }
	          source_list.put( keyword,  a_source );	
	        }
	      } //end of initialize source_list
	      
	      
	      //initialize random method list
	      Hashtable random_method_list = new Hashtable (); // Hashtable of (String, String)
	      for(String keyword : keywords_with_LinkedListString_values){
	        if ( generating_method_for_an_item_over_trials.containsKey( keyword  + "_randomization"      )) { //e.g., :display_item_screen_location_x_randomization //have a method by definition and was assigned by the user
	          random_method_list.put(  keyword    ,   (String) generating_method_for_an_item_over_trials .get( keyword  + "_randomization" )   );
	        }
	        /*
		else if ( keyword.equals( ":frequency") ){//special case
		if ( generating_method_for_an_item_over_trials.containsKey( ":frequency_randomization" )  ){ //user specified
		random_method_list.put(  keyword    ,   (String) generating_method_for_an_item_over_trials [ ":frequency_randomization" ] );
		}
		else{ //use default value
		random_method_list.put(  keyword    , "fixed_order" );
		}
		}
	         */
	        else if ( keyword.equals( ":correct_response" )  ||  keyword.equals( ":feedback_content")) { //do nothing, because their random methods are bounded with other keywords
	          continue;
	        }
	        else {	//have definition, but not specified by the user, use default values
	          random_method_list.put(  keyword    , "fixed_order" );
	        }
	      } //end of initialize random method list
	      
	      
	      for ( day_i = 1; day_i <= all_day_added; day_i ++){
	        for (block_i = 1; block_i <= blocks_added_per_day; block_i ++ ){
	          //initialize counter lists for random_without_replacement method before each block // use clone here because they will be manipulated
	          Hashtable counter_list = new Hashtable (); // Hashtable of LinkedList<String>
	          for(String keyword : keywords_with_LinkedListString_values){
	            counter_list.put ( keyword,        ProgramUtilitiesFun__LinkedListString_Clone( (LinkedList<String> )source_list.get(keyword)  )        );
	          }
	          
	          for (trial_i = 1; trial_i <= trials_added_per_block; trial_i ++){
	            //start to generate parameters of this item in this trial.
	            Hashtable a_random_string_table = new Hashtable (); //each value is a random String generated for the key. including default values
	            for(String keyword : keywords_with_LinkedListString_values) {
	              if ( keyword.equals( ":word" )){//special case
	                //three lists are bound together, using the same random method. 
	                Three_Tuple text_and_correct_response_and_feedback = ProgramUtilitiesFun__Get_A_Three_Tuple_String_From_Randomizing_Three_String_Lists ( (LinkedList<String>) source_list.get(":word") , (LinkedList<String>) source_list.get(":correct_response") , (LinkedList<String>) source_list.get(":feedback_content"),             (LinkedList<String>) counter_list.get(":word"), (LinkedList<String>) counter_list.get(":correct_response") , (LinkedList<String>) counter_list.get(":feedback_content") ,  (String) random_method_list.get(":word")); //original full String list1, original full String list2, and list3 with the same length, String list counter1, String list counter2, and counter3, one random method (may include fixed_order)
	                a_random_string_table.put(":word", (String) text_and_correct_response_and_feedback.Ob1 );
	                a_random_string_table.put(":correct_response", (String) text_and_correct_response_and_feedback.Ob2 );
	                a_random_string_table.put(":feedback_content", (String) text_and_correct_response_and_feedback.Ob3 );
	              }
	              else if ( keyword.equals( ":correct_response" )  ||  keyword.equals( ":feedback_content" )) { //do nothing, because their values are bounded with other keywords
	                continue;
	              }
	              else { //common method
	                String a_random_string = ProgramUtilitiesFun__Get_A_String_From_Randomizing_A_String_List (  (LinkedList<String>) source_list.get(keyword) , (LinkedList<String>) counter_list.get(keyword),   (String)random_method_list.get(keyword)   ); //original full String list, String list counter, random method (may include fixed_order)
	                a_random_string_table.put( keyword, a_random_string   );
	              }
	            }
	            
	            
	            //substitue every block_variable name in a_random_string_table.Value to their specific String for this block.
	            TaskTemplateFun__Substitute_Hashtable_Values_With_Block_Variables( Integer.toString(day_i), Integer.toString(block_i) ,  a_random_string_table, current_block_variable_content_by_day_block_variable_name  ); 
	            
	            
	            //prepare the display item
	            Display_Item_Audio_Word_Sound a_display_item = new Display_Item_Audio_Word_Sound();
	            a_display_item.Channel					=	(String) a_random_string_table.get(":channel" ) ;
	            a_display_item.Correct_Response			= 	(String) a_random_string_table.get(":correct_response");
	            a_display_item.Display_Item_Delay		= (double) Double.parseDouble ( (String) a_random_string_table.get( ":display_item_delay") );
	            //a_display_item.Display_Item_Duration	= Double.parseDouble ( (String) a_random_string_table[ ":display_item_duration"] ) ;
	            a_display_item.Feedback					= (String) a_random_string_table.get( ":feedback_content") ;
	            a_display_item.Word					= ( (String) a_random_string_table.get( ":word") );
	            a_display_item.Item_ID = "item-" +  Integer.toString(item_id_num);
	            
	            if( generating_method_for_an_item_over_trials.containsKey(":as_sentence") ){
	              String temp_parameter =	(String) generating_method_for_an_item_over_trials.get(":as_sentence") ;
	              if(temp_parameter.toLowerCase().equals( "nil"))a_display_item.As_Sentence = false;
	              else a_display_item.As_Sentence = true;
	            }
	            
	            
	            //add prepared trial info into the return list.
	            a_random_string_table.put(":item_type", item_type );
	            item_parameter_over_trials.addLast ( a_random_string_table );
	            
	            item_display_over_trials.addLast ( a_display_item);
	          }//end trial_i	
	        }//end block_i
	      } //end day_i
	      
	    } //end of display_item_audio_word_sound
	    
	    
	    else {
	      System.err.println("Error. TaskTemplateFun__Generate_An_Item_For_Trials_Using_Generating_Methods has undefined :item_type: " + item_type);
	      return null;
	    }
	    
	    Two_Tuple return_tuple = new Two_Tuple ();
	    return_tuple.Ob1 = item_parameter_over_trials; //default values that are not specified by the user are not included in this, which is for Experiment_Trial_Parameter_List
	    return_tuple.Ob2 = item_display_over_trials;
	    
	    
	    return return_tuple;
	  }
	  else {
	    System.err.println("Error! TaskTemplateFun__Generate_An_Item_For_Trials_Using_Generating_Methods has the_template type undefined. " );
	    return null;
	  }
	}
	
	public  String TaskTemplateFun__Get_Correct_Response_From_Display_Item (Object display_object){
	  if( display_object instanceof Display_Item_Visual_Text){
	    return ((Display_Item_Visual_Text)display_object).Correct_Response;
	  }
	  else if ( display_object instanceof Display_Item_Visual_Line){
	    return ((Display_Item_Visual_Line)display_object).Correct_Response;
	  }
	  else if ( display_object instanceof Display_Item_Visual_Text_Button){
	    return ((Display_Item_Visual_Text_Button)display_object).Correct_Response;
	  }
	  else if ( display_object instanceof Display_Item_Audio_Tone_Sound){
	    return ((Display_Item_Audio_Tone_Sound)display_object).Correct_Response;
	  }
	  else if ( display_object instanceof Display_Item_Audio_Digit_Sound){
	    return ((Display_Item_Audio_Digit_Sound)display_object).Correct_Response;
	  }
	  
	  else System.err.println("TaskTemplateFun__Get_Correct_Response_From_Display_Item has undefined diaplay_object type" );
	  
	  return null;
	}
	
	public  Hashtable TaskTemplateFun__Get_Current_Dynamic_Items(){
	  Hashtable return_table = new Hashtable ();
	  int global_trial_num = sim.vars.centralParametersModule.Experiment_Trial_Result_List.size();
	  
	  if(sim.vars.centralParametersModule.Experiment_Trial_Display_Item_List == null || sim.vars.centralParametersModule.Experiment_Trial_Display_Item_List.size() == 0) return return_table;
	  
	  int trial_num = global_trial_num;
	  if(global_trial_num <= 0) trial_num = 1;
	  
	  LinkedList<Object> all_display_items_in_this_trial = (LinkedList<Object>) ProgramUtilitiesFun__LinkedListObject_Get_i_th_Object( sim.vars.centralParametersModule.Experiment_Trial_Display_Item_List, trial_num) ;
	  //System.out.println("TaskTemplateFun__Get_Current_Dynamic_Items: " + all_display_items_in_this_trial.size());
	  for(Object a_display_item : all_display_items_in_this_trial){
	    if( a_display_item instanceof Display_Item_Visual_Text ){
	      if ( !((Display_Item_Visual_Text)a_display_item).Item_Name.equals( "" )) {
	        return_table.put( 	((Display_Item_Visual_Text)a_display_item).Item_Name , a_display_item);
	      }
	    }
	    else if( a_display_item instanceof Display_Item_Visual_Text_Button ){
	      if ( !((Display_Item_Visual_Text_Button)a_display_item).Item_Name.equals( "" )) {
	        return_table.put( 	((Display_Item_Visual_Text_Button)a_display_item).Item_Name , a_display_item);
	      }
	    }
	    else if( a_display_item instanceof Display_Item_Visual_Line ){
	      if ( !((Display_Item_Visual_Line)a_display_item).Item_Name.equals( "" )) {
	        return_table.put( 	((Display_Item_Visual_Line)a_display_item).Item_Name , a_display_item);
	      }
	    }
	    //else ToDo
	  }
	  
	  return return_table;
	}
	
	public  World3D_DriverCar TaskTemplateFun__Get_World3D_DriverCar_Object(){
	  World3D_Template_Driving_Method driving_method_pointer = TaskTemplateFun__Get_World3D_Driving_Method_Object();
	  System.out.println("driving_method_pointer.DriverCar_World3D_ID=" + driving_method_pointer.DriverCar_World3D_ID);
	  System.out.println("sim.vars.world3DTemplate.World.Objects=" + sim.vars.world3DTemplate.World.Objects);
	  return ((World3D_DriverCar)sim.vars.world3DTemplate.World.Objects.get(driving_method_pointer.DriverCar_World3D_ID));
	  
	  
	}
	
	public World3D_Template_Driving_Method TaskTemplateFun__Get_World3D_Driving_Method_Object(){
	  if( sim.vars.world3DTemplate.Method_Object == null || !(sim.vars.world3DTemplate.Method_Object instanceof World3D_Template_Driving_Method)) {
	    System.out.println ("Error! TaskTemplateFun__Get_World3D_Driving_Method_Object sim.vars.world3DTemplate.Method_Object == null || !(sim.vars.world3DTemplate.Method_Object is World3D_Template_Driving_Method)");
	    return null;
	  }
	  
	  return (World3D_Template_Driving_Method) sim.vars.world3DTemplate.Method_Object;
	}
	
	public  void TaskTemplateFun__Initialize_Experiment_Trial_List_From_Template (){
	  
	  // DictionaryEntry?
	  // .last.value?
	  // missing class
	  
	  
	  //both of these should be empty
	  //sim.vars.centralParametersModule.Experiment_Trial_Parameter_List
	  //sim.vars.centralParametersModule.Experiment_Trial_Display_Item_List
	  
	  //set to output experiment trial list to external file
	  sim.vars.taskTemplate.Output_Initialized_Experiment_Trial_Parameter_List_To_Experiment_Trial_Parameter_List_Txt = "yes";
	  
	  
	  
	  for ( Object  template_object  : sim.vars.taskTemplate.Trial_Generating_Methods) { //each object will add certain amount of trials to a block or some blocks to a day, or some days of blocks and trials
	    
	    /*
			// should be set in the definition of each trial generating template 
			//set default values for variables that are common to any template_object
			int add_number_of_days = 0 ; //0 by default, which means adding to the last day in the current list. If it is 2 (an int > 0), it means adding two days to the end of the current list.
			int add_number_of_blocks_per_day = 0; // integer, 0 by default, which means adding to the last block. If it is 2 (an int > 0), then it means adding two blocks to the end of the currently in the same day.
			int add_number_of_trials_per_block = 1; // integer, 1 by default, which means adding 1 trial to the end of the current list in the same block same day.
	     */
	    
	    //results of each template_object
	    LinkedList<Hashtable> trial_parameter_list_generated_from_a_template = new LinkedList<Hashtable> (); // each Hashtable is a trial
	    LinkedList<LinkedList<Object>> trial_display_item_list_generated_from_a_template  = new LinkedList<LinkedList<Object>>  (); //each LinkedList<object> is a trial, each object is an item
	    //LinkedList<LinkedList<object>> trial_feedback_item_list_generated_from_a_template  = new LinkedList<LinkedList<object>>  (); //each LinkedList<object> is a trial, each object is an item
	    
	    //determine the above lists generated from a_template method
	    if ( template_object instanceof Task_Template_Discrete_Display_Feedback_Two_Stages_Method){
	      Task_Template_Discrete_Display_Feedback_Two_Stages_Method a_template = (Task_Template_Discrete_Display_Feedback_Two_Stages_Method)template_object ;
	      
	      //get day and block information, they cannot be substitued by block variables
	      int number_of_items_per_slide = a_template.Generating_Method_For_Each_Item_Over_Trials.size();
	      int add_number_of_days = 				a_template.Add_Number_Of_Days ;  //int >= 0
	      int add_number_of_blocks_per_day = 		a_template.Add_Number_Of_Blocks_Per_Day; //int >= 0 , when it is 0, add_number_of_days must be 0
	      if ( add_number_of_blocks_per_day == 0 && add_number_of_days != 0)System.err.println("Error. TaskTemplateFun__Initialize_Experiment_Trial_List_From_Template has add_number_of_blocks_per_day == 0 && add_number_of_days != 0");
	      
	      int all_day_added = add_number_of_days;
	      if (all_day_added == 0) all_day_added = 1; //here minimal is 1
	      int blocks_added_per_day = add_number_of_blocks_per_day;
	      if (blocks_added_per_day == 0) blocks_added_per_day = 1; //here minimal is 1
	      
	      int day_i;
	      int block_i;
	      int trial_i;
	      
	      //block variables safety check, every random method key must have its corresponding block_variable name. but a block_variable name may not have its random method, by dafault, fixed_order will be used
	      Iterator<Entry<String, String>> itr_Block_Variable_Randomization = a_template.Block_Variable_Randomization.entrySet().iterator();
	      while(itr_Block_Variable_Randomization.hasNext()){
	        Entry an_entry = itr_Block_Variable_Randomization.next();
	        String a_random_method_key = (String) an_entry.getKey();
          String corresponding_block_variable_name = ":block_variable_" + a_random_method_key.substring(30) ;
          //System.out.println(a_random_method_key + " " + corresponding_block_variable_name);
          if ( a_template.Block_Variable.containsKey( corresponding_block_variable_name ) == false )System.err.println("Error! TaskTemplateFun__Initialize_Experiment_Trial_List_From_Template has a_template.Block_Variable.containsKey( corresponding_block_variable_name ) == false corresponding_block_variable_name: " + corresponding_block_variable_name);
	      }
	      
//	      for ( DictionaryEntry an_entry : a_template.Block_Variable_Randomization ){
//	        String a_random_method_key = (String) an_entry.Key;
//	        String corresponding_block_variable_name = ":block_variable_" + a_random_method_key.substring(30) ;
//	        //System.out.println(a_random_method_key + " " + corresponding_block_variable_name);
//	        if ( a_template.Block_Variable.containsKey( corresponding_block_variable_name ) == false )System.out.println("Error! TaskTemplateFun__Initialize_Experiment_Trial_List_From_Template has a_template.Block_Variable.containsKey( corresponding_block_variable_name ) == false corresponding_block_variable_name: " + corresponding_block_variable_name);
//	      }
	      
	      //initialize block variable content table: Block_Variable_Content_By_Day_Block_VName
	      if( a_template.Block_Variable.size() > 0 ) {
	        for ( day_i = 1; day_i <= all_day_added; day_i ++){
	          
	          Hashtable block_variable_counter = new Hashtable() ; //Hashtable of <String, LinkedList <String> >	//< String is :block_variable_name,  LinkedList < String >  is the list of values  >
	          
	          Iterator<Entry<String, LinkedList<String>>> itr_Block_Variable = a_template.Block_Variable.entrySet().iterator();
	          while (itr_Block_Variable.hasNext()){
	              //DictionaryEntry an_entry : a_template.Block_Variable){  //since the value is a linkedlist, do not use one layer hashtable clone
	            Entry an_entry = itr_Block_Variable.next();
	            block_variable_counter.put ( an_entry.getKey(),   ProgramUtilitiesFun__LinkedListString_Clone( (LinkedList<String>) an_entry.getValue()) );
	          }
	          for (block_i = 1; block_i <= blocks_added_per_day; block_i ++ ){
	            
	            for ( String random_method_name : a_template.Block_Variable_Randomization_Ordered_Name){ //make sure to do defined random method in the defined order.
	              String variable_name = ":block_variable_" + random_method_name.substring(30) ;  //e.g., :block_variable_1
	              String variable_random_method_key = random_method_name;
	              //System.out.println( 		variable_name + " " + variable_random_method_key);
	              String random_method;
	              if( a_template.Block_Variable_Randomization.containsKey( variable_random_method_key ) ) random_method = (String) a_template.Block_Variable_Randomization.get(variable_random_method_key);
	              else random_method = "fixed_order"; //by default
	              
	              int last_seed1 = sim.vars.programGlobalVar__Rand1_Seed1;
	              int last_seed2 = sim.vars.programGlobalVar__Rand1_Seed2;
	              
	              String a_random_string = ProgramUtilitiesFun__Get_A_String_From_Randomizing_A_String_List (  (LinkedList<String>) a_template.Block_Variable.get(variable_name) , (LinkedList<String>) block_variable_counter.get(variable_name),   random_method    ); //original full String list, String list counter, random method (may include fixed_order)
	              
	              if(sim.vars.programGlobalVar__Block_Variable_Common_RandomMethod_Last_Seed.containsKey(random_method_name)){ //record
	                Three_Tuple record = (Three_Tuple) sim.vars.programGlobalVar__Block_Variable_Common_RandomMethod_Last_Seed.get(random_method_name);
	                record.Ob1 = random_method;
	                if (random_method.charAt(0) == '=') {
	                  System.err.println("Error! TaskTemplateFun__Initialize_Experiment_Trial_List_From_Template random_method of a referred method must be a defined method rather than: " + random_method);
	                  break;
	                }
	                record.Ob2 = last_seed1;
	                record.Ob3 = last_seed2;
	              }
	              
	              String the_key = Integer.toString(day_i) + "__" + Integer.toString(block_i) + "__" +  variable_name ; //e.g.,  < 1__2__:block_variable_1 ,   1.0 >
	              a_template.Block_Variable_Content_By_Day_Block_VName.put( the_key, a_random_string );
	            }
	            
	            itr_Block_Variable = a_template.Block_Variable.entrySet().iterator();
	            while (itr_Block_Variable.hasNext()){
//	            for ( DictionaryEntry an_entry : a_template.Block_Variable){ //then check other undefined random method
	              Entry an_entry = itr_Block_Variable.next();
	              String variable_name = (String) an_entry.getKey();  //e.g., :block_variable_1
	              String variable_random_method_key = ":block_variable_randomization_" + variable_name.substring(16);  //e.g., :block_variable_randomization_1
	              
	              if (a_template.Block_Variable_Randomization_Ordered_Name.contains(variable_random_method_key)) continue;
	              
	              //System.out.println( 		variable_name + " " + variable_random_method_key);
	              String random_method;
	              if( a_template.Block_Variable_Randomization.containsKey( variable_random_method_key ) ) random_method = (String) a_template.Block_Variable_Randomization.get(variable_random_method_key);
	              else random_method = "fixed_order"; //by default
	              
	              String a_random_string = ProgramUtilitiesFun__Get_A_String_From_Randomizing_A_String_List (  (LinkedList<String>) a_template.Block_Variable.get(variable_name) , (LinkedList<String>) block_variable_counter.get(variable_name),   random_method   ); //original full String list, String list counter, random method (may include fixed_order)
	              String the_key = Integer.toString(day_i) + "__" + Integer.toString(block_i) + "__" +  variable_name ; //e.g.,  < 1__2__:block_variable_1 ,   1.0 >
	              a_template.Block_Variable_Content_By_Day_Block_VName.put( the_key, a_random_string );
	            }
	            
	          }
	        }
	      }
	      
	      
	      //trial information may be substitued by block variables
	      if ( (sim.funs.ProgramUtilitiesFun__Is_String_Double(a_template.Add_Number_Of_Trials_Per_Block) == false)) System.err.println ("Error! TaskTemplateFun__Initialize_Experiment_Trial_List_From_Template  has a_template.Add_Number_Of_Trials_Per_Block String not a number but: " + a_template.Add_Number_Of_Trials_Per_Block );
	      int add_number_of_trials_per_block = Integer.parseInt(	a_template.Add_Number_Of_Trials_Per_Block ); //int >= 1
	      if (add_number_of_trials_per_block < 1) System.err.println("Error. TaskTemplateFun__Initialize_Experiment_Trial_List_From_Template has add_number_of_trials_per_block < 1");
	      int trials_added_per_block = add_number_of_trials_per_block;
	      
	      
	      Two_Tuple[]  two_tuple = new Two_Tuple[number_of_items_per_slide] ; //a two-tuple stores 1. parameter list (LinkedList<Hashtable>) for an item, different hashtables for different trials; 2. display item list LinkedList<object>, listed over trials
	      
	      
	      int item_i = 0;
	      for ( Hashtable generating_method_for_an_item_over_trials :  a_template.Generating_Method_For_Each_Item_Over_Trials) { //each hashtable is a generating method for an item over trials
	        two_tuple [item_i] = TaskTemplateFun__Generate_An_Item_For_Trials_Using_Generating_Methods( add_number_of_days, add_number_of_blocks_per_day, add_number_of_trials_per_block,  generating_method_for_an_item_over_trials , a_template, item_i); //no trial number information returned, but the three linkedlist must be in the order of trials starting from day 1 block 1 trial 1 in this adding group
	        item_i ++;
	      }
	      
	      
	      //change item * trial matrix  to  trial * item
	      
	      
	      
	      //get existing trial number info from the currently parameter list.
	      int number_of_total_existing_trials = sim.vars.centralParametersModule.Experiment_Trial_Parameter_List.size(); 
	      int current_day 		;
	      int current_block_in_day		;
	      int current_trial_in_block 		;
	      if ( number_of_total_existing_trials == 0){
	        current_day 			= 0;
	        current_block_in_day 	= 0;
	        current_trial_in_block 	= 0;
	      }
	      else{
	        current_day 			= (int) sim.vars.centralParametersModule.Experiment_Trial_Parameter_List.getLast().get("day-num");
	        if (a_template.Add_Number_Of_Days == 0){
	          current_block_in_day 	= (int) sim.vars.centralParametersModule.Experiment_Trial_Parameter_List.getLast().get("block-num");
	        }
	        else current_block_in_day = 0;
	        if (a_template.Add_Number_Of_Blocks_Per_Day == 0){
	          current_trial_in_block 	= (int) sim.vars.centralParametersModule.Experiment_Trial_Parameter_List.getLast().get("trial-num-within-block");
	        }
	        else current_trial_in_block  = 0;
	      }
	      
	      
	      int total_trial_i = 0; //total number i of trials in all days and blocks
	      for ( day_i = 1; day_i <= all_day_added; day_i ++){
	        for (block_i = 1; block_i <= blocks_added_per_day; block_i ++ ){
	          //initialize counter lists for random_without_replacement method before each block // use clone here because they will be manipulated
	          LinkedList<String> counter_display_and_response_duration = ProgramUtilitiesFun__LinkedListString_Clone(a_template.Display_And_Response_Duration );
	          LinkedList<String> counter_feedback_duration             = ProgramUtilitiesFun__LinkedListString_Clone(a_template.Feedback_Duration );
	          
	          for (trial_i = 1; trial_i <= trials_added_per_block; trial_i ++){
	            total_trial_i ++; //therefore the first total_trial_i is 1.
	            
	            Hashtable temp_trial_parameters = new Hashtable();
	            
	            //add block_variables
	            String block_identifier = day_i + "__" + block_i + "__";
	            
	            Iterator<Entry<String, String>> itr_Block_Variable_Content_By_Day_Block_VName = a_template.Block_Variable_Content_By_Day_Block_VName.entrySet().iterator();
	            while(itr_Block_Variable_Content_By_Day_Block_VName.hasNext()){
//	            for (DictionaryEntry an_entry : a_template.Block_Variable_Content_By_Day_Block_VName){
	              Entry an_entry = itr_Block_Variable_Content_By_Day_Block_VName.next();
	              String key = (String) an_entry.getKey();
	              if ( key.length() > block_identifier.length()  && ProgramUtilitiesFun__StringsEqualByStringOrDouble( key.substring(0, block_identifier.length()),  block_identifier ) ){
	                String block_variable_name = key.substring( block_identifier.length() );
	                String block_variable_value = (String) an_entry.getValue();
	                //System.out.println(  key + " " +block_variable_name + " " + block_variable_value  );
	                temp_trial_parameters.put( block_variable_name, block_variable_value);
	              }
	            }
	            
	            
	            //add common parameters to the trial parameter Hashtable
	            ////////////////////////day_num, no block variable
	            int day_num;
	            if( current_day == 0 && add_number_of_days == 0){ //this means to add blocks and trials to the current day, but there is no current day
	              day_num = 1; //must have only one day to add
	            }
	            else if (current_day != 0 && add_number_of_days == 0){ //this means to add blocks and trials to the current day, there is a current day
	              day_num = current_day + 0; //must have only one day to add
	            }
	            else if (current_day == 0 && add_number_of_days != 0){ //this means to add blocks and trials to new days, there is no current day
	              day_num = 0 + day_i; //have one or more days to add
	            }
	            else { // ( current_day != 0 && add_number_of_days != 0 ) //this means to add blocks and trials to new days, there is a current day
	              day_num = current_day + day_i;
	            }
	            temp_trial_parameters.put("day-num", day_num);		
	            
	            ////////////////////////block_num, no block variable
	            int block_num;
	            if (current_block_in_day == 0 && add_number_of_blocks_per_day == 0 ){ // to add trials to the current day current block, but there is no current block
	              block_num = 1; //must have only 1 block to add
	            }
	            else if (current_block_in_day != 0 && add_number_of_blocks_per_day == 0 ) { //to add trials to the current block
	              block_num = current_block_in_day + 0; //must have only 1 block to add
	            }
	            else if (current_block_in_day == 0 && add_number_of_blocks_per_day != 0){ // to add trials to new blocks, there is no current block
	              block_num = 0 + block_i ;
	            }
	            else { // (current_block_in_day != 0 && add_number_of_blocks_per_day != 0) //to add trials to new blocks, there is current blocks
	              block_num = current_block_in_day + block_i ;
	            }
	            temp_trial_parameters.put("block-num", block_num );
	            
	            ////////////////////////trial_num, no block variable
	            int trial_num = current_trial_in_block + trial_i; //because add_number_of_trials_per_block >= 1
	            temp_trial_parameters.put("trial-num-within-block", trial_num);
	            
	            //add all numbers as String, make it uniform , may have block variable
	            temp_trial_parameters.put("number-of-items" ,number_of_items_per_slide);  //implicitly computed from display items
	            
	            
	            String a_display_and_response_duration_string = ProgramUtilitiesFun__Get_A_String_From_Randomizing_A_String_List ( a_template.Display_And_Response_Duration , counter_display_and_response_duration ,  a_template.Display_And_Response_Duration_Randomization   ); //original full String list, String list counter, random method (may include fixed_order)
	            a_display_and_response_duration_string  =  TaskTemplateFun__Substitute_String_With_Block_Variables (Integer.toString(day_i), Integer.toString(block_i), a_display_and_response_duration_string, a_template.Block_Variable_Content_By_Day_Block_VName ) ;
	            if ( ProgramUtilitiesFun__Is_String_Double(a_display_and_response_duration_string) == false) System.err.println ("Error TaskTemplateFun__Initialize_Experiment_Trial_List_From_Template   a_display_and_response_duration_string  needs to be a number, not " + a_display_and_response_duration_string);
	            double a_display_and_response_duration_num = Double.parseDouble (a_display_and_response_duration_string);
	            temp_trial_parameters.put("display-and-response-duration" ,  a_display_and_response_duration_num);
	            
	            
	            String a_feedback_duration_string = ProgramUtilitiesFun__Get_A_String_From_Randomizing_A_String_List ( a_template.Feedback_Duration , counter_feedback_duration ,  a_template.Feedback_Duration_Randomization  ); //original full String list, String list counter, random method (may include fixed_order)
	            a_feedback_duration_string =  TaskTemplateFun__Substitute_String_With_Block_Variables (Integer.toString(day_i), Integer.toString(block_i), a_feedback_duration_string, a_template.Block_Variable_Content_By_Day_Block_VName ) ;
	            if ( ProgramUtilitiesFun__Is_String_Double(a_feedback_duration_string) == false) System.err.println ("Error TaskTemplateFun__Initialize_Experiment_Trial_List_From_Template   a_feedback_duration_string  needs to be a number, not " + a_feedback_duration_string);
	            double a_feedback_duration_num = Double.parseDouble ( a_feedback_duration_string );
	            temp_trial_parameters.put("feedback-duration" , a_feedback_duration_num);
	            
	            
	            String number_of_responses_needed_string = a_template.Number_Of_Responses_Per_Trial;
	            number_of_responses_needed_string =  TaskTemplateFun__Substitute_String_With_Block_Variables (Integer.toString(day_i), Integer.toString(block_i), number_of_responses_needed_string, a_template.Block_Variable_Content_By_Day_Block_VName ) ;
	            if( ProgramUtilitiesFun__Is_String_Double ( number_of_responses_needed_string ) == false) System.err.println("Error! TaskTemplateFun__Initialize_Experiment_Trial_List_From_Template has  ProgramUtilitiesFun__Is_String_Double ( number_of_responses_needed_string ) == false ");
	            int  number_of_responses_needed_int = Integer.parseInt( number_of_responses_needed_string);
	            temp_trial_parameters.put("number-of-responses-needed" ,  number_of_responses_needed_int );
	            
	            
	            LinkedList<Object> temp_trial_display_items = new LinkedList<Object>();
	            LinkedList<Object> temp_trial_feedback_items = new LinkedList<Object>();
	            
	            
	            //for each item in this trial:, only use the partial of items that is specified by :how_many_display_items_to_use_in_a_trial
	            String how_many_display_items_to_add_for_this_trial = TaskTemplateFun__Substitute_String_With_Block_Variables (Integer.toString(day_i), Integer.toString(block_i), a_template.How_Many_Display_Items_To_Use_In_A_Trial, a_template.Block_Variable_Content_By_Day_Block_VName ) ;
	            if ( how_many_display_items_to_add_for_this_trial.equals( "all" ))how_many_display_items_to_add_for_this_trial = Integer.toString(number_of_items_per_slide);
	            if(sim.funs.ProgramUtilitiesFun__Is_String_Double(how_many_display_items_to_add_for_this_trial) == false ) System.err.println ( "Error! TaskTemplateFun__Initialize_Experiment_Trial_List_From_Template has ProgramUtilitiesFun__Is_String_Double(how_many_display_items_to_add_for_this_trial) == false : " + how_many_display_items_to_add_for_this_trial);
	            int how_many_display_items_to_add_for_this_trial_int = Integer.parseInt( how_many_display_items_to_add_for_this_trial );
	            if ( how_many_display_items_to_add_for_this_trial_int > number_of_items_per_slide ) System.out.println("WARNING! TaskTemplateFun__Initialize_Experiment_Trial_List_From_Template has how_many_display_items_to_add_for_this_trial_int > number_of_items_per_slide : " + how_many_display_items_to_add_for_this_trial_int );
	            
	            temp_trial_parameters.put("how-many-display-items-to-use-in-a-trial" , Integer.toString(how_many_display_items_to_add_for_this_trial_int) );
	            
	            for (item_i = 0; item_i < number_of_items_per_slide ; item_i ++ ) { 
	              //a two-tuple stores 1. parameter list (LinkedList<Hashtable>) for an item, different hashtables for different trials; 2. display item list LinkedList<object>, listed over trials 
	              Hashtable parameters_for_trial_i_item_i = (Hashtable)  ProgramUtilitiesFun__LinkedListObject_Get_i_th_Object( two_tuple[item_i].Ob1 ,  total_trial_i) ;   //(LinkedList<Hashtable>)
	              
	              //ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value_From_Another_Hashtable ( temp_trial_parameters, parameters_for_trial_i_item_i); //this way cannot make different items look different in the Hashtable parameter list
	              //rename the key for each item
	              
	              
	              
	              
	              	              
	              Iterator<Entry> itrItems = parameters_for_trial_i_item_i.entrySet().iterator();
	              while( itrItems.hasNext()){
	                Entry anItem = itrItems.next();
	                String a_key = "item-" + Integer.toString(item_i) +  anItem.getKey();
	                
	                if (item_i < how_many_display_items_to_add_for_this_trial_int) { //normal add all items generated
	                  ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value( temp_trial_parameters, a_key , anItem.getValue() );
	                }
	                else { //only generate the first how_many_display_items_to_add_for_this_trial_int, for the rest, add [EMPTY]
	                  ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value( temp_trial_parameters, a_key , "[EMPTY]" );
	                }
	              }
	              
	              if (item_i < how_many_display_items_to_add_for_this_trial_int) { //normal add all items generated						
	                Object a_display_item_for_trial_i_item_i = (Object) ProgramUtilitiesFun__LinkedListObject_Get_i_th_Object( two_tuple[item_i].Ob2 ,  total_trial_i) ; 
	                temp_trial_display_items.addLast ( a_display_item_for_trial_i_item_i );
	              }
	              else { //only generate the first how_many_display_items_to_add_for_this_trial_int, for the rest, add [EMPTY]
	                //doing nothing
	              }
	              
	              //object a_feedback_item_for_trial_i_item_i = (object) ProgramUtilitiesFun__LinkedListObject_Get_i_th_Object( three_tuple[item_i].Ob3 ,  total_trial_i) ; 
	              //temp_trial_feedback_items.addLast ( a_feedback_item_for_trial_i_item_i );
	            }
	            
	            trial_parameter_list_generated_from_a_template.addLast ( temp_trial_parameters );
	            trial_display_item_list_generated_from_a_template.addLast (  temp_trial_display_items );
	            //trial_feedback_item_list_generated_from_a_template.addLast ( temp_trial_feedback_items );
	          }//end trial_i	
	        }//end block_i
	      } //end day_i
	      
	      
	    }//if ( template_object is Task_Template_Discrete_Display_Feedback_Two_Stages_Method)
	    else System.err.println ("Error. TaskTemplateFun__Initialize_Experiment_Trial_List_From_Template has undefined object type in  sim.vars.taskTemplate.Trial_Generating_Methods") ;
	    //end of determine the three lists generated from a_template method
	    
	    //add lists to Central_Parameters_Module data base
	    for (Hashtable  a_hashtable : trial_parameter_list_generated_from_a_template){
	      sim.vars.centralParametersModule.Experiment_Trial_Parameter_List.addLast (a_hashtable );
	    }
	    for (LinkedList<Object>  a_list_of_objects  :  trial_display_item_list_generated_from_a_template) {
	      sim.vars.centralParametersModule.Experiment_Trial_Display_Item_List.addLast( a_list_of_objects);
	    }
	    //for (LinkedList<object>  a_list_of_objects  in  trial_feedback_item_list_generated_from_a_template) {
	    //				sim.vars.centralParametersModule.Experiment_Trial_Feedback_Item_List.addLast( a_list_of_objects);
	    //}
	    
	  } //end of for ( object  template_object  in sim.vars.taskTemplate.Trial_Generating_Methods)
	  
	}
	
	public  void TaskTemplateFun__Initialize_Predefined_Model_Setup (){
	  	  
	  switch (sim.vars.programGlobalVar__Use_Predefined_Model_Setup){
	    case "experiment_driving_and_comprehension":
	    {
	      
	      sim.vars.programGlobalVar__Hashtable_Experiment_Specific_Data.put( "Block_Results_LP", new LinkedList<Double>()); //lateral position (m)
	      sim.vars.programGlobalVar__Hashtable_Experiment_Specific_Data.put( "Block_Results_RT", new LinkedList<Double>()); // reaction time (s) for correct trials
	      sim.vars.programGlobalVar__Hashtable_Experiment_Specific_Data.put( "Block_Results_CR", new LinkedList<Double>()); // correct response, 0 = incorrect, 1 = correct.
	      
	      String[] Driving_Raw_titles = new String[] {"Clock_Time(s)", "Distance_On_Road(m)", "Lateral_Distance(m)", "Speed(m/s)", "Head_Angle_Between_Road_Direction(degreeRight+)", "Steer(degreeRight+)", "Accelerator(0-1)", "Brake(0-1)"};
	      String Driving_Raw_Data = ProgramUtilitiesFun__StringArray_To_String_Show_Empty(Driving_Raw_titles) + "\n";
	      String[] Comprehension_Raw_titles = new String[] {"Lang." , "Set", "SetBlock", "Group", "TypeNum", "input_text", "probe_text", "Correct_Response_Text", "Correct_Response_Button", "Reaction_Time(s)", "Response", "Correctness"};
	      String Comprehension_Raw_Data = ProgramUtilitiesFun__StringArray_To_String_Show_Empty(Comprehension_Raw_titles) + "\n";
	      ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.programGlobalVar__Hashtable_Experiment_Specific_Data, "Driving_Raw_Data", Driving_Raw_Data ); // to be output into .txt
	      ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.programGlobalVar__Hashtable_Experiment_Specific_Data, "Comprehension_Raw_Data", Comprehension_Raw_Data ); // to be output into .txt
	      sim.vars.programGlobalVar__Hashtable_Experiment_Specific_Data.put( "Bool_Comp_Block", false); //session block needs comprehension trials or not.
	      
	      break;	
	    }

	    case "experiment_medical_decision_making":
	    {
	      
	      
	      // at the start of simulation
	      //Event_07_Extra_Predefined_Model_Setup
	      
	      break;
	    }
	    
	    case "model_drive_opends":
	    {
	    	//TODO add things need initiation here
	    	
	    	break;
	    }
	    
	    case "model_drive_torcs":
	    {
	    	//TODO add things need initiation here
	    	
	    	break;
	    }
	    
	    case "sample_bst_learn_model_in_actr":
	    {
	      //nothing
	      break;
	    }
	    case "touch_screen_typing":
	    {
	    	String a_result_line = "Clock(s)" + "\t" +  "TappedContent"  + "\t" + "OrderOfKeyTapped";
            sim.funs.ProgramUtilitiesFun__Output_Response_Results_Txt( a_result_line );

            sim.vars.motorModule.Motor_Output_Sequence_Required = true;
            
	      break;
	    }
	    
	    case "unity_tangtang_2015":
	    {
	    	try {	    		
				UnityJavaUdp unityUDPtool = new UnityJavaUdp(sim); //TODO link to some objects such as World3D. type
				unityUDPtool.frame.setVisible(true);
				sim.vars.world3DTemplate.Method_Object = unityUDPtool;
			} catch (Exception e) {
				e.printStackTrace();
			}
	    	
	    	break;
	    }
	    
	    
	    default:
	    {
	      System.out.println("WARNING! TaskTemplateFun__Initialize_Predefined_Model_Setup has undefined sim.vars.programGlobalVar__Use_Predefined_Model_Setup: " + sim.vars.programGlobalVar__Use_Predefined_Model_Setup);
	      break;	
	    }
	    
	    
	  }
	}
	
	public  Matrix3d TaskTemplateFun__Linear_Local_Value_To_Global (Matrix3d M_local, double Pitch, double Yaw, double Roll){
	  Matrix3d return_matrix = new Matrix3d();
	  for (int z=0; z<4; z++){
	    for (int x=0; x<4; x++){
	      return_matrix.Matrix[x][z]=0;
	    }
	  }
	  //Yaw first : look right +, look left -, based on y axis
	  Matrix3d yaw_rotation_matrix = new Matrix3d();
	  double Yaw_radian = Yaw / 180.0 * Math.PI;
	  for (int z=0; z<4; z++){
	    for (int x=0; x<4; x++){
	      if (z==x){
	        yaw_rotation_matrix.Matrix[x][z]=1;
	      }
	      else{
	        yaw_rotation_matrix.Matrix[x][z]=0;
	      }
	    }
	  }
	  yaw_rotation_matrix.Matrix[0][0] = Math.cos(Yaw_radian); yaw_rotation_matrix.Matrix[0][2] = -(Math.sin(Yaw_radian));
	  yaw_rotation_matrix.Matrix[2][0] = Math.sin(Yaw_radian); yaw_rotation_matrix.Matrix[2][2] =   Math.cos(Yaw_radian);
	  double[][] resultant2=new double[4][4];
	  for (int z=0; z<4; z++){
	    for (int x=0; x<4; x++){
	      for (int c=0; c<4; c++){
	        resultant2[z][x]+=M_local.Matrix[z][c]*yaw_rotation_matrix.Matrix[c][x];
	      }
	    }
	  }
	  return_matrix.Matrix = resultant2;
	  
	  //Pitch second : node head +, raise head -, based on x axis
	  Matrix3d pitch_rotation_matrix = new Matrix3d();
	  double Pitch_radian = Pitch / 180.0 * Math.PI;
	  for (int z=0; z<4; z++){
	    for (int x=0; x<4; x++){
	      if (z==x){
	        pitch_rotation_matrix.Matrix[x][z]=1;
	      }
	      else{
	        pitch_rotation_matrix.Matrix[x][z]=0;
	      }
	    }
	  }
	  pitch_rotation_matrix.Matrix[1][1] = Math.cos(Pitch_radian); pitch_rotation_matrix.Matrix[1][2] = Math.sin(Pitch_radian);
	  pitch_rotation_matrix.Matrix[2][1] = -(Math.sin(Pitch_radian)); pitch_rotation_matrix.Matrix[2][2] = Math.cos(Pitch_radian);
	  double[][] resultant1=new double[4][4];
	  for (int z=0; z<4; z++){
	    for (int x=0; x<4; x++){
	      for (int c=0; c<4; c++){
	        resultant1[z][x]+=return_matrix.Matrix[z][c]*pitch_rotation_matrix.Matrix[c][x];
	      }
	    }
	  }
	  return_matrix.Matrix = resultant1;
	  
	  //Roll last : lean left +, lean right -, based on z axis
	  Matrix3d roll_rotation_matrix = new Matrix3d();
	  
	  double Roll_radian = Roll / 180.0 * Math.PI;
	  for (int z=0; z<4; z++){
	    for (int x=0; x<4; x++){
	      if (z==x){
	        roll_rotation_matrix.Matrix[x][z]=1;
	      }
	      else{
	        roll_rotation_matrix.Matrix[x][z]=0;
	      }
	    }
	  }
	  roll_rotation_matrix.Matrix[0][0] = Math.cos(Roll_radian); roll_rotation_matrix.Matrix[0][1] = Math.sin(Roll_radian);
	  roll_rotation_matrix.Matrix[1][0] = -(Math.sin(Roll_radian)); roll_rotation_matrix.Matrix[1][1] = Math.cos(Roll_radian);
	  double[][] resultant=new double[4][4];
	  for (int z=0; z<4; z++){
	    for (int x=0; x<4; x++){
	      for (int c=0; c<4; c++){
	        resultant[z][x]+=return_matrix.Matrix[z][c]*roll_rotation_matrix.Matrix[c][x];
	      }
	    }
	  }
	  return_matrix.Matrix = resultant;
	  
	  return return_matrix; 
	}
	
	
	public  void TaskTemplateFun__Refresh_Dynamic_Item(Object an_object, double time_delay){
	  if(time_delay < 0){
	    System.err.println("Error! TaskTemplateFun__Refresh_Dynamic_Item has time_delay < 0: " + time_delay );
	    return;
	  }
	  
	  if ( an_object instanceof Display_Item_Visual_Text){
	    Display_Item_Visual_Text the_item = (Display_Item_Visual_Text) an_object; //different for each item type
	    
	    //update delay time
	    the_item.Display_Item_Delay = time_delay; 
	    
	    String item_id = the_item.Item_ID; // item-?
	    
	    //remove current visicon, if any, do in a delayed way.
	    
	    //ProgramUtilitiesFun__Delayed_Function_Call_No_Return_Value use this delayed function call?? no need, DeviceModuleFun__Visual_Display_Remove_Item_By_Visicon_Name can do delay as below.
	    
	    if( sim.vars.visualDisplay.Visicon_Names_Associated_With_A_Display_Item_ID.containsKey(item_id) ) { //the item was shown (not hidden)
	      //System.out.println("TaskTemplateFun__Refresh_Dynamic_Item. Visicon_Names_Associated_With_A_Display_Item_ID contain item#: " + sim.vars.visualDisplay.Visicon_Names_Associated_With_A_Display_Item_ID.size());
	      
	      LinkedList<String> associated_visicon_names = (LinkedList<String>)sim.vars.visualDisplay.Visicon_Names_Associated_With_A_Display_Item_ID.get(item_id);
	      //System.out.println("TaskTemplateFun__Refresh_Dynamic_Item. associated_visicon_names: " + ProgramUtilitiesFun__LinkedListString_To_String_Show_Empty( associated_visicon_names ) );
	      
	      for(String a_visicon_name : associated_visicon_names){ //the visicon was not gone
	        //System.out.println("TaskTemplateFun__Refresh_Dynamic_Item. a_visicon_name not gone: " + a_visicon_name + " for itemID: " + item_id);
	        
	        //if(VisionModuleFun__Find_The_Visicon_ID_By_Visicon_Name(a_visicon_name) != -1) DeviceModuleFun__Visual_Display_Remove_Item_By_Visicon_Name(a_visicon_name, time_delay);  // for a delayed appearing item, Find_The_Visicon_ID_By_Visicon_Name cannot find it.
	        //else System.err.println("Error! TaskTemplateFun__Refresh_Dynamic_Item. cannot find Visicon_ID_By_Visicon_Name: " + a_visicon_name);
	        
	        DeviceModuleFun__Visual_Display_Remove_Item_By_Visicon_Name(a_visicon_name, time_delay);  
	      }
	    }
	    else {
	      //System.out.println("TaskTemplateFun__Refresh_Dynamic_Item. Visicon_Names_Associated_With_A_Display_Item_ID contain item#: " + sim.vars.visualDisplay.Visicon_Names_Associated_With_A_Display_Item_ID.size());	
	    }
	    
	    //if hidden, unhide
	    the_item.Hide = false;
	    
	    
	    
	    //show updated display item, this below can handle delay.
	    int item_ID_num = Integer.parseInt( item_id.substring(5) );
	    TaskTemplateFun__Show_Display_Item_Display( the_item, item_ID_num);
	  }
	  
	  else if ( an_object instanceof Display_Item_Visual_Text_Button){  //basically, same as Display_Item_Visual_Text except for the item type.
		  Display_Item_Visual_Text_Button the_item = (Display_Item_Visual_Text_Button) an_object; //different for each item type
		    
		    //update delay time
		    the_item.Display_Item_Delay = time_delay; 
		    
		    String item_id = the_item.Item_ID; // item-?
		    
		    //remove current visicon, if any, do in a delayed way.
		    
		    if( sim.vars.visualDisplay.Visicon_Names_Associated_With_A_Display_Item_ID.containsKey(item_id) ) { //the item was shown (not hidden)
		      //System.out.println("TaskTemplateFun__Refresh_Dynamic_Item. Visicon_Names_Associated_With_A_Display_Item_ID contain item#: " + sim.vars.visualDisplay.Visicon_Names_Associated_With_A_Display_Item_ID.size());
		      
		      LinkedList<String> associated_visicon_names = (LinkedList<String>)sim.vars.visualDisplay.Visicon_Names_Associated_With_A_Display_Item_ID.get(item_id);
		      //System.out.println("TaskTemplateFun__Refresh_Dynamic_Item. associated_visicon_names: " + ProgramUtilitiesFun__LinkedListString_To_String_Show_Empty( associated_visicon_names ) );
		      
		      for(String a_visicon_name : associated_visicon_names){ //the visicon was not gone
		        //System.out.println("TaskTemplateFun__Refresh_Dynamic_Item. a_visicon_name not gone: " + a_visicon_name + " for itemID: " + item_id);
		        
		        //if(VisionModuleFun__Find_The_Visicon_ID_By_Visicon_Name(a_visicon_name) != -1) DeviceModuleFun__Visual_Display_Remove_Item_By_Visicon_Name(a_visicon_name, time_delay);  // for a delayed appearing item, Find_The_Visicon_ID_By_Visicon_Name cannot find it.
		        //else System.err.println("Error! TaskTemplateFun__Refresh_Dynamic_Item. cannot find Visicon_ID_By_Visicon_Name: " + a_visicon_name);
		        
		        DeviceModuleFun__Visual_Display_Remove_Item_By_Visicon_Name(a_visicon_name, time_delay);  
		      }
		    }
		    else {
		      //System.out.println("TaskTemplateFun__Refresh_Dynamic_Item. Visicon_Names_Associated_With_A_Display_Item_ID contain item#: " + sim.vars.visualDisplay.Visicon_Names_Associated_With_A_Display_Item_ID.size());	
		    }
		    
		    //if hidden, unhide
		    the_item.Hide = false;
		    
		    
		    
		    //show updated display item, this below can handle delay.
		    int item_ID_num = Integer.parseInt( item_id.substring(5) );
		    TaskTemplateFun__Show_Display_Item_Display( the_item, item_ID_num);
		  
		  
		  
		  
	  }
	  
	  else if ( an_object instanceof Display_Item_Visual_Line){
	    
	    Display_Item_Visual_Line the_item = (Display_Item_Visual_Line) an_object; //different for each item type
	    
	    
	    
	    //remove current visicon, if any
	    String item_id = the_item.Item_ID; // item-?
	    if( sim.vars.visualDisplay.Visicon_Names_Associated_With_A_Display_Item_ID.containsKey(item_id) ) { //the item was shown (not hidden)
	      LinkedList<String> associated_visicon_names = (LinkedList<String>)sim.vars.visualDisplay.Visicon_Names_Associated_With_A_Display_Item_ID.get(item_id);
	      for(String a_visicon_name : associated_visicon_names){ //the visicon was not gone
	        //if(VisionModuleFun__Find_The_Visicon_ID_By_Visicon_Name(a_visicon_name) != -1) DeviceModuleFun__Visual_Display_Remove_Item_By_Visicon_Name(a_visicon_name, time_delay);
	        DeviceModuleFun__Visual_Display_Remove_Item_By_Visicon_Name(a_visicon_name, time_delay);
	      }
	    }
	    
	    //update delay time
	    the_item.Display_Item_Delay = time_delay; 
	    
	    //if hidden, unhide
	    the_item.Hide = false;
	    
	    //show updated display item
	    int item_ID_num = Integer.parseInt( item_id.substring(5) );
	    TaskTemplateFun__Show_Display_Item_Display( the_item, item_ID_num);
	  }
	  else {
	    System.err.println("Error! TaskTemplateFun__Refresh_Dynamic_Item has undefined item type");	
	  }
	}
	



	
	public  void TaskTemplateFun__Set_World3D_Driving_Method (LinkedList<String> Parameter_List){
	  if( sim.vars.world3DTemplate.Method_Object == null || !(sim.vars.world3DTemplate.Method_Object instanceof World3D_Template_Driving_Method)) {
	    System.err.println ("Error! TaskTemplateFun__Use_sim.vars.world3DTemplate. sim.vars.world3DTemplate.Method_Object == null || !(sim.vars.world3DTemplate.Method_Object is World3D_Template_Driving_Method)");
	    
	    return;
	  }
	  
	  World3D_Template_Driving_Method the_method = (World3D_Template_Driving_Method) sim.vars.world3DTemplate.Method_Object;
	  World3D_DriverCar driver_car = new World3D_DriverCar();
	  
	  LinkedList<String> Parameter_List_Clone = ProgramUtilitiesFun__LinkedListString_Clone ( Parameter_List );
	  String a_parameter;
	  while ( Parameter_List_Clone.size() > 0 ) {
	    
	    switch (Parameter_List_Clone.getFirst().toLowerCase()) {
	      case ":driver_start_on_road_name" : {
	        Parameter_List_Clone.removeFirst(); // remove the parameter name
	        if ( Parameter_List_Clone.size() < 1 ) {   System.err.println ("Error! TaskTemplateFun__Set_World3D_Driving_Method " + Parameter_List_Clone.getFirst() + " needs 1 parameter"); }
	        a_parameter = Parameter_List_Clone.getFirst();  //needs has a single parameter
	        Parameter_List_Clone.removeFirst();
	        if ( a_parameter.charAt(0) == ':' || a_parameter.charAt(0) == '(' || a_parameter.charAt(0) == ')'){   System.out.println ("Error! TaskTemplateFun__Set_World3D_Driving_Method " + Parameter_List_Clone.getFirst() + " needs 1 parameter. not " + a_parameter);}
	        
	        //the_method.Driver_Start_On_Road_Name = a_parameter ;
	        driver_car.Start_Road_Name = a_parameter;
	        break;
	      }
	      case ":driver_camera_height" : 
	      case ":driver_start_distance" :
	      case ":driver_initial_global_x" :
	      case ":driver_initial_global_y" :
	      case ":driver_initial_global_z" :
	      case ":driver_initial_global_pitch" :
	      case ":driver_initial_global_yaw" :
	      case ":driver_initial_global_roll" :
	      case ":auto_speed":	
	      { //double numbers
	        String para_name = Parameter_List_Clone.getFirst().toLowerCase();
	        Parameter_List_Clone.removeFirst(); // remove the parameter name
	        if ( Parameter_List_Clone.size() < 1 ) {   System.err.println ("Error! TaskTemplateFun__Set_World3D_Driving_Method " + Parameter_List_Clone.getFirst() + " needs 1 parameter"); }
	        a_parameter = Parameter_List_Clone.getFirst();  //needs has a single parameter
	        Parameter_List_Clone.removeFirst();
	        if ( a_parameter.charAt(0) == ':' || a_parameter.charAt(0) == '(' || a_parameter.charAt(0) == ')'){   System.err.println ("Error! TaskTemplateFun__Set_World3D_Driving_Method " + Parameter_List_Clone.getFirst() + " needs 1 parameter. not " + a_parameter);}
	        if ( !ProgramUtilitiesFun__Is_String_Double(a_parameter)) { System.err.println ("Error! TaskTemplateFun__Set_World3D_Driving_Method " + Parameter_List_Clone.getFirst() + " needs to be double. not " + a_parameter);}
	        
	        switch (para_name){
	          case ":driver_camera_height" :{
	            driver_car.Vehicle_Basic.Camera_Height = (double) Double.parseDouble(a_parameter);
	            break;
	          }
	          
	          case ":driver_start_distance" :{
	            driver_car.Start_Distance = (double) Double.parseDouble(a_parameter);
	            break;
	          }
	          
	          case ":driver_initial_global_x" :{
	            driver_car.Vehicle_Basic.Loc_X = (double) Double.parseDouble(a_parameter);
	            break;
	          }
	          case ":driver_initial_global_y" :{
	            driver_car.Vehicle_Basic.Loc_Y = (double) Double.parseDouble(a_parameter);
	            break;
	          }
	          case ":driver_initial_global_z" :{
	            driver_car.Vehicle_Basic.Loc_Z = (double) Double.parseDouble(a_parameter);
	            break;
	          }
	          case ":driver_initial_global_pitch" :{
	            driver_car.Vehicle_Basic.Pitch = (double) Double.parseDouble(a_parameter);
	            break;
	          }
	          case ":driver_initial_global_yaw" :{
	            driver_car.Vehicle_Basic.Yaw = (double) Double.parseDouble(a_parameter);
	            break;
	          }
	          case ":driver_initial_global_roll" :{
	            driver_car.Vehicle_Basic.Roll = (double) Double.parseDouble(a_parameter);
	            break;
	          }
	          case ":auto_speed":	{
	            the_method.Auto_Speed = (double) Double.parseDouble(a_parameter);
	            break;	
	          }
	          default: {
	            System.err.println("Error! TaskTemplateFun__Set_World3D_Driving_Method double cases have undefined para_name: " + para_name);	
	            break;
	          }
	        }
	        break;
	      }	
	      default:
	      {
	        if(sim.vars.printingModule.Popout_Message) System.out.println ("WARNING! TaskTemplateFun__Set_World3D_Driving_Method. the Key is undefined: " + Parameter_List_Clone.getFirst());
	        Parameter_List_Clone.removeFirst();
	        break;
	      }
	    }
	    
	  }
	  
	  //add Driver_Car
	  String world3d_id = Integer.toString(sim.vars.world3DTemplate.World.Object_Num); //start from 0
	  sim.vars.world3DTemplate.World.Object_Num ++;
	  sim.vars.world3DTemplate.World.Objects.put(world3d_id, driver_car );
	  the_method.DriverCar_World3D_ID = world3d_id;
	  
	  /* //moved to server 501 beginning effect
		//output first row titles
		String[] titles = new String[] {"Clock_Time(s)", "Distance_On_Road(m)", "Lateral_Distance(m)", "Speed(m/s)", "Head_Angle_Between_Road_Direction(degreeRight+)", "Steer(degreeRight+)", "Accelerator(0-1)", "Brake(0-1)"};
		ProgramUtilitiesFun__Output_Human_Drive_Results_Txt(  ProgramUtilitiesFun__StringArray_To_String_Show_Empty(titles) );
	   */
	}
	
	public  LinkedList<String> TaskTemplateFun__Show_Display_Item_Display (Object a_display_item, int item_ID_num){
	  
	  // clock
	  
	  LinkedList<String> output_txt_trace_for_an_item_display = new LinkedList<String>();
	  if ( a_display_item instanceof Display_Item_Visual_Text ){
	    Display_Item_Visual_Text the_display_item = ((Display_Item_Visual_Text) a_display_item);
	    if (((Display_Item_Visual_Text) a_display_item).Hide) return output_txt_trace_for_an_item_display; // nothing to display
	    
	    double duration = ((Display_Item_Visual_Text) a_display_item).Display_Item_Duration;
	    if(duration == 0.0) return output_txt_trace_for_an_item_display;  //duration = 0 , means not to display
	    
	    String the_text = ((Display_Item_Visual_Text) a_display_item).Visual_Text;
	    
	    //System.out.println("TaskTemplateFun__Show_Display_Item_Display: " + the_text);
	    
	    if( the_text.equals( "" )) return output_txt_trace_for_an_item_display; // nothing to display
	    
	    String color = ((Display_Item_Visual_Text) a_display_item).Display_Item_Color;
	    int screen_location_x = ((Display_Item_Visual_Text) a_display_item).Display_Item_Screen_Location_X;
	    int screen_location_y = ((Display_Item_Visual_Text) a_display_item).Display_Item_Screen_Location_Y;
	    
	    double delay  = ((Display_Item_Visual_Text) a_display_item).Display_Item_Delay;
	    double onset_clock_time = SimSystem.clock() + delay;
	    
	    String duration_string; 
	    if  (duration < 0 ) duration_string = ""; //this means keep displaying
	    else duration_string = Double.toString(duration);
	    
	    
	    if( the_display_item.As_Paragraph == false){
	      int lengthForWidth = the_text.length();
	      if (the_text.charAt(0) == '\"' && the_text.charAt(the_text.length() - 1) == '\"') lengthForWidth -= 2;
	      
	      int width =  lengthForWidth * 7 ; // default letter width = 7, height = 11, per letter, not for animator but for text properties
	      int height = 11;
	      DeviceModuleFun__Visual_Display_Prepare_Text(item_ID_num, false, false, the_text , screen_location_x, screen_location_y, Double.toString(onset_clock_time), duration_string, color, width , height );
	    }
	    else{
	      
	      String paragraph_divide_method =  "by_word_with_wrap" ; // "by_word_with_wrap"; // "by_length", "by_word_no_wrap", "by_word_with_wrap", "by_word_and_length_with_wrap"
	      
	      int max_char_in_line_before_wrap = 75;  //however, will not cut within a word, wait until the end of the word.
	      if (paragraph_divide_method.equals( "by_length")){
	        int total_char_num = 0;
	        int line_num = 0;
	        int char_num_in_line = 0;
	        int char_num_in_a_group = 0;
	        int group_limit_num = sim.vars.visionModule.Text_Char_Group_Length;
	        String temp_text_group = "";
	        if(the_text.charAt(0) == '"') the_text = the_text.substring(1); //remove first "
	        if( the_text.charAt(the_text.length() - 1) == '"') the_text = the_text.substring(0, the_text.length() - 1); //remove last "
	        the_text = ProgramUtilitiesFun__String_Parser_Escape_Sequence(the_text);
	        for(int v=0; v< the_text.length(); v++){
	          char a_char=the_text.charAt(v);
	          boolean end_of_this_group = false;
	          boolean end_of_this_line = false;
	          if(a_char != '\n'){ // "abXc"
	            temp_text_group += a_char;
	            char_num_in_a_group++;
	            char_num_in_line++;
	          }
	          else{ //"ab\nc"  end of this line
	            temp_text_group += "\n";
	            char_num_in_a_group++;
	            char_num_in_line++;
	            end_of_this_group = true;
	            end_of_this_line = true;
	            
	          }
	          if( char_num_in_a_group >= group_limit_num)end_of_this_group = true;
	          if(end_of_this_group){
	            //make a text item
	            int width =  char_num_in_a_group * 7 ; // default letter width = 7, height = 11, per letter, not for animator but for text properties
	            int height = 11;
	            DeviceModuleFun__Visual_Display_Prepare_Text(item_ID_num, false, false, temp_text_group , screen_location_x + char_num_in_line * 7 - char_num_in_a_group * 7 / 2, screen_location_y + line_num * 11, Double.toString(onset_clock_time), duration_string, color, width , height );
	            //System.out.println("line: " + line_num + ", temp_text_group: " + temp_text_group + ", char_num_in_a_group: " + char_num_in_a_group);					
	            temp_text_group = "";
	            char_num_in_a_group = 0;
	          }
	          if(end_of_this_line){
	            char_num_in_line = 0;
	            line_num++;
	          }
	          total_char_num++; 
	        }
	      } //end of by_length
	      else if (paragraph_divide_method.equals( "by_word_no_wrap")){
	        int total_char_num = 0;
	        int line_num = 0;
	        int char_num_in_line = 0;
	        int char_num_in_a_group = 0;
	        int group_limit_num = sim.vars.visionModule.Text_Char_Group_Length;
	        String temp_text_group = "";
	        if(the_text.charAt(0) == '"') the_text = the_text.substring(1); //remove first "
	        if( the_text.charAt(the_text.length() - 1) == '"') the_text = the_text.substring(0, the_text.length() - 1); //remove last "
	        the_text = ProgramUtilitiesFun__String_Parser_Escape_Sequence(the_text);
	        //above is the same				
	        
	        for(int v=0; v< the_text.length(); v++){
	          char a_char=the_text.charAt(v);
	          boolean end_of_this_group = false;
	          boolean end_of_this_line = false;
	          if(a_char != '\n' && a_char != ' '){ // "abXc"
	            temp_text_group += a_char;
	            char_num_in_a_group++;
	            char_num_in_line++;
	          }
	          else if (a_char == ' '){
	            temp_text_group += a_char;
	            char_num_in_a_group++;
	            char_num_in_line++;
	            end_of_this_group = true;
	          }
	          else{ //"ab\nc"  end of this line
	            temp_text_group += "\n";
	            char_num_in_a_group++;
	            char_num_in_line++;
	            end_of_this_group = true;
	            end_of_this_line = true;
	            
	          }
	          //if( char_num_in_a_group >= group_limit_num)end_of_this_group = true;
	          if(end_of_this_group){
	            //make a text item
	            int width =  char_num_in_a_group * 7 ; // default letter width = 7, height = 11, per letter, not for animator but for text properties
	            int height = 11;
	            DeviceModuleFun__Visual_Display_Prepare_Text(item_ID_num, false, false, temp_text_group , screen_location_x + char_num_in_line * 7 - char_num_in_a_group * 7 / 2, screen_location_y + line_num * 11, Double.toString(onset_clock_time), duration_string, color, width , height );
	            //System.out.println("line: " + line_num + ", temp_text_group: " + temp_text_group + ", char_num_in_a_group: " + char_num_in_a_group);					
	            temp_text_group = "";
	            char_num_in_a_group = 0;
	          }
	          if(end_of_this_line){
	            char_num_in_line = 0;
	            line_num++;
	          }
	          total_char_num++; 
	        }
	      }//end of by_word_no_wrap
	      else if (paragraph_divide_method.equals( "by_word_with_wrap")){
	        int total_char_num = 0;
	        int line_num = 0;
	        int char_num_in_line = 0;
	        int char_num_in_a_group = 0;
	        int group_limit_num = sim.vars.visionModule.Text_Char_Group_Length;
	        String temp_text_group = "";
	        if(the_text.charAt(0) == '"') the_text = the_text.substring(1); //remove first "
	        if( the_text.charAt(the_text.length() - 1) == '"') the_text = the_text.substring(0, the_text.length() - 1); //remove last "
	        the_text = ProgramUtilitiesFun__String_Parser_Escape_Sequence(the_text);
	        //above is the same				
	        
	        for(int v=0; v< the_text.length(); v++){
	          char a_char=the_text.charAt(v);
	          boolean end_of_this_group = false;
	          boolean end_of_this_line = false;
	          if(a_char != '\n' && a_char != ' '){ // "abXc"
	            temp_text_group += a_char;
	            char_num_in_a_group++;
	            char_num_in_line++;
	          }
	          else if (a_char == ' '){
	            temp_text_group += a_char;
	            char_num_in_a_group++;
	            char_num_in_line++;
	            end_of_this_group = true;
	            if(char_num_in_line >= max_char_in_line_before_wrap) end_of_this_line = true;  
	          }
	          else{ //"ab\nc"  end of this line
	            temp_text_group += "\n";
	            char_num_in_a_group++;
	            char_num_in_line++;
	            end_of_this_group = true;
	            end_of_this_line = true;
	            
	          }
	          //if( char_num_in_a_group >= group_limit_num)end_of_this_group = true;
	          if(end_of_this_group){
	            String last_char_before_space_or_return;
	            if(temp_text_group.length() >= 2) last_char_before_space_or_return = temp_text_group.substring(temp_text_group.length()-2, 1 + temp_text_group.length()-2);
	            else last_char_before_space_or_return = "";
	            if( !last_char_before_space_or_return.equals( "," ) && !last_char_before_space_or_return.equals( "." ) && !last_char_before_space_or_return.equals( "?" ) ) {// no punctuation abc,[space]
	              //System.out.println(last_char_before_space_or_return);		
	              //make a text item
	              int width =  char_num_in_a_group * 7 ; // default letter width = 7, height = 11, per letter, not for animator but for text properties
	              int height = 11;
	              int space_between_lines = 4;
	              DeviceModuleFun__Visual_Display_Prepare_Text(item_ID_num, false, false, temp_text_group , screen_location_x + char_num_in_line * 7 - char_num_in_a_group * 7 / 2, screen_location_y + line_num * (height + space_between_lines), Double.toString(onset_clock_time), duration_string, color, width , height );
	              //System.out.println("line: " + line_num + ", temp_text_group: " + temp_text_group + ", char_num_in_a_group: " + char_num_in_a_group);					
	              temp_text_group = "";
	              char_num_in_a_group = 0;
	            }
	            else{ //considering punctuation
	              String pucntuation = last_char_before_space_or_return;
	              //System.out.println(pucntuation + " " + pucntuation.length() + " " + temp_text_group.Contains(pucntuation));							
	              String last_string = temp_text_group.substring(temp_text_group.length()-1);
	              temp_text_group = temp_text_group.substring(0, temp_text_group.length()-2) + last_string;
	              char_num_in_a_group--;
	              //System.out.println(		temp_text_group );					
	              
	              //make a text item
	              int width =  char_num_in_a_group * 7 ; // default letter width = 7, height = 11, per letter, not for animator but for text properties
	              int height = 11;
	              int space_between_lines = 4;
	              DeviceModuleFun__Visual_Display_Prepare_Text(item_ID_num, false, false, temp_text_group , screen_location_x + char_num_in_line * 7 - char_num_in_a_group * 7 / 2, screen_location_y + line_num * (height + space_between_lines), Double.toString(onset_clock_time), duration_string, color, width , height );
	              
	              char_num_in_a_group++;
	              //another visual display item for the punctuation
	              DeviceModuleFun__Visual_Display_Prepare_Text(item_ID_num, false, false, pucntuation , screen_location_x + char_num_in_line * 7 - 1 * 7 / 2, screen_location_y + line_num * (height + space_between_lines), Double.toString(onset_clock_time), duration_string, color, 1 * 7 , height );
	              //System.out.println("line: " + line_num + ", temp_text_group: " + temp_text_group + ", char_num_in_a_group: " + char_num_in_a_group);					
	              temp_text_group = "";
	              char_num_in_a_group = 0;
	            }
	          }
	          if(end_of_this_line){
	            char_num_in_line = 0;
	            line_num++;
	          }
	          total_char_num++; 
	        }
	      }//end of by_word_with_wrap
	      
	      
	      else if (paragraph_divide_method.equals( "by_word_and_length_with_wrap")){
	        int total_char_num = 0;
	        int line_num = 0;
	        int char_num_in_line = 0;
	        int char_num_in_a_group = 0;
	        int group_limit_num = sim.vars.visionModule.Text_Char_Group_Length;
	        String temp_text_group = "";
	        if(the_text.charAt(0) == '"') the_text = the_text.substring(1); //remove first "
	        if( the_text.charAt(the_text.length() - 1) == '"') the_text = the_text.substring(0, the_text.length() - 1); //remove last "
	        the_text = ProgramUtilitiesFun__String_Parser_Escape_Sequence(the_text);
	        //above is the same				
	        
	        for(int v=0; v< the_text.length(); v++){
	          char a_char=the_text.charAt(v);
	          boolean end_of_this_group = false;
	          boolean end_of_this_line = false;
	          if(a_char != '\n' && a_char != ' '){ // "abXc"
	            temp_text_group += a_char;
	            char_num_in_a_group++;
	            char_num_in_line++;
	          }
	          else if (a_char == ' '){
	            temp_text_group += a_char;
	            char_num_in_a_group++;
	            char_num_in_line++;
	            end_of_this_group = true;
	            if(char_num_in_line >= max_char_in_line_before_wrap) end_of_this_line = true;  
	          }
	          else{ //"ab\nc"  end of this line
	            temp_text_group += "\n";
	            char_num_in_a_group++;
	            char_num_in_line++;
	            end_of_this_group = true;
	            end_of_this_line = true;
	            
	          }
	          if( char_num_in_a_group >= group_limit_num)end_of_this_group = true;
	          if(end_of_this_group){
	            String last_char_before_space_or_return;
	            if(temp_text_group.length() >= 2) last_char_before_space_or_return = temp_text_group.substring(temp_text_group.length()-2, 1 +temp_text_group.length()-2);
	            else last_char_before_space_or_return = "";
	            if( !last_char_before_space_or_return.equals( "," ) && !last_char_before_space_or_return.equals( "." ) && !last_char_before_space_or_return.equals( "?"  ) ) {// no punctuation abc,[space]
	              //System.out.println(last_char_before_space_or_return);		
	              //make a text item
	              int width =  char_num_in_a_group * 7 ; // default letter width = 7, height = 11, per letter, not for animator but for text properties
	              int height = 11;
	              int space_between_lines = 4;
	              DeviceModuleFun__Visual_Display_Prepare_Text(item_ID_num, false, false, temp_text_group , screen_location_x + char_num_in_line * 7 - char_num_in_a_group * 7 / 2, screen_location_y + line_num * (height + space_between_lines), Double.toString(onset_clock_time), duration_string, color, width , height );
	              //System.out.println("line: " + line_num + ", temp_text_group: " + temp_text_group + ", char_num_in_a_group: " + char_num_in_a_group);					
	              temp_text_group = "";
	              char_num_in_a_group = 0;
	            }
	            else{ //considering punctuation
	              String pucntuation = last_char_before_space_or_return;
	              //System.out.println(pucntuation + " " + pucntuation.length() + " " + temp_text_group.Contains(pucntuation));							
	              String last_string = temp_text_group.substring(temp_text_group.length()-1);
	              temp_text_group = temp_text_group.substring(0, temp_text_group.length()-2) + last_string;
	              char_num_in_a_group--;
	              //System.out.println(		temp_text_group );					
	              
	              //make a text item
	              int width =  char_num_in_a_group * 7 ; // default letter width = 7, height = 11, per letter, not for animator but for text properties
	              int height = 11;
	              int space_between_lines = 4;
	              DeviceModuleFun__Visual_Display_Prepare_Text(item_ID_num, false, false, temp_text_group , screen_location_x + char_num_in_line * 7 - char_num_in_a_group * 7 / 2, screen_location_y + line_num * (height + space_between_lines), Double.toString(onset_clock_time), duration_string, color, width , height );
	              
	              char_num_in_a_group++;
	              //another visual display item for the punctuation
	              DeviceModuleFun__Visual_Display_Prepare_Text(item_ID_num, false, false, pucntuation , screen_location_x + char_num_in_line * 7 - 1 * 7 / 2, screen_location_y + line_num * (height + space_between_lines), Double.toString(onset_clock_time), duration_string, color, 1 * 7 , height );
	              //System.out.println("line: " + line_num + ", temp_text_group: " + temp_text_group + ", char_num_in_a_group: " + char_num_in_a_group);					
	              temp_text_group = "";
	              char_num_in_a_group = 0;
	            }
	          }
	          if(end_of_this_line){
	            char_num_in_line = 0;
	            line_num++;
	          }
	          total_char_num++; 
	        }
	      }//end of by_word_and_length_with_wrap
	      
	      
	    } //end of As_Paragraph = true
	    
	    output_txt_trace_for_an_item_display.addLast( "Display_Item_Visual_Text: " +  the_text + ", color: " + color + " at (" +  screen_location_x + "," + screen_location_y + ") onset_clock_time: " + onset_clock_time + ", duration: " + duration + " .  |||||    " );
	  } //end of Display_Item_Visual_Text
	  
	  else if ( a_display_item instanceof Display_Item_Visual_Line ) { 
	    if (((Display_Item_Visual_Line) a_display_item).Hide) return output_txt_trace_for_an_item_display; // nothing to display
	    
	    double duration = ((Display_Item_Visual_Line) a_display_item).Display_Item_Duration;
	    if(duration == 0.0) return output_txt_trace_for_an_item_display;  //duration = 0 , means not to display
	    
	    int start_point_screen_location_x = ((Display_Item_Visual_Line) a_display_item).Start_Point_Screen_Location_X;
	    int start_point_screen_location_y = ((Display_Item_Visual_Line) a_display_item).Start_Point_Screen_Location_Y;
	    int end_point_screen_location_x = ((Display_Item_Visual_Line) a_display_item).End_Point_Screen_Location_X;
	    int end_point_screen_location_y = ((Display_Item_Visual_Line) a_display_item).End_Point_Screen_Location_Y;
	    
	    //when the line is reduced to a point, should display it or not?? ToDo
	    
	    String color = ((Display_Item_Visual_Line) a_display_item).Display_Item_Color;
	    
	    double delay  = ((Display_Item_Visual_Line) a_display_item).Display_Item_Delay;
	    double onset_clock_time = SimSystem.clock() + delay;
	    
	    String duration_string; 
	    if  (duration < 0 ) duration_string = ""; //this means keep displaying
	    else duration_string = Double.toString(duration);
	    
	    DeviceModuleFun__Visual_Display_Prepare_Line(item_ID_num, false, false, start_point_screen_location_x, start_point_screen_location_y, end_point_screen_location_x, end_point_screen_location_y, Double.toString(onset_clock_time), duration_string, color);
	    
	    output_txt_trace_for_an_item_display.addLast( "Display_Item_Visual_Line, color: " + color + " from (" +  start_point_screen_location_x + "," + start_point_screen_location_y + ") to (" + end_point_screen_location_x + ", " + end_point_screen_location_y + "). onset_clock_time: " + onset_clock_time + ", duration: " + duration + " .  |||||    " );
	    
	  }//end of Display_Item_Visual_Line
	  
	  else if ( a_display_item instanceof Display_Item_Visual_Text_Button ){
	    if (((Display_Item_Visual_Text_Button) a_display_item).Hide) return output_txt_trace_for_an_item_display; // nothing to display
	    
	    double duration = ((Display_Item_Visual_Text_Button) a_display_item).Display_Item_Duration;
	    if(duration == 0.0) return output_txt_trace_for_an_item_display;  //duration = 0 , means not to display
	    
	    String the_text = ((Display_Item_Visual_Text_Button) a_display_item).Visual_Text;
	    if( the_text.equals( "" )) return output_txt_trace_for_an_item_display; // nothing to display
	    
	    String color = ((Display_Item_Visual_Text_Button) a_display_item).Display_Item_Color;
	    String button_color = ((Display_Item_Visual_Text_Button) a_display_item).Display_Button_Color;
	    int screen_location_x = ((Display_Item_Visual_Text_Button) a_display_item).Display_Item_Screen_Location_X;
	    int screen_location_y = ((Display_Item_Visual_Text_Button) a_display_item).Display_Item_Screen_Location_Y;
	    
	    double delay  = ((Display_Item_Visual_Text_Button) a_display_item).Display_Item_Delay;
	    double onset_clock_time = SimSystem.clock() + delay;
	    
	    String duration_string; 
	    if  (duration < 0 ) duration_string = ""; //this means keep displaying
	    else duration_string = Double.toString(duration);
	    
	    int height = ((Display_Item_Visual_Text_Button) a_display_item).Display_Item_Height ;
	    int width  = ((Display_Item_Visual_Text_Button) a_display_item).Display_Item_Width ;
	    
	    DeviceModuleFun__Visual_Display_Prepare_Text_Button(item_ID_num, false, false, the_text , screen_location_x, screen_location_y, Double.toString(onset_clock_time), duration_string, color, button_color, width, height);
	    
	    output_txt_trace_for_an_item_display.addLast( "Display_Item_Visual_Text_Button: " +  the_text + ", text color: " + color + ", button color: " + button_color + " at (" +  screen_location_x + "," + screen_location_y + ") onset_clock_time: " + onset_clock_time + ", duration: " + duration + " .  |||||    " );
	  } //end of Display_Item_Visual_Text_Button
	  
	  else if ( a_display_item instanceof Display_Item_Audio_Tone_Sound ){
	    double duration = ((Display_Item_Audio_Tone_Sound) a_display_item).Display_Item_Duration;
	    if(duration == 0.0) return output_txt_trace_for_an_item_display;  //duration = 0 , means not to display
	    
	    int frequency = ((Display_Item_Audio_Tone_Sound) a_display_item).Frequency;
	    if( frequency == 0) return output_txt_trace_for_an_item_display; // nothing to display
	    
	    String channel = ((Display_Item_Audio_Tone_Sound) a_display_item).Channel;
	    
	    double delay  = ((Display_Item_Audio_Tone_Sound) a_display_item).Display_Item_Delay;
	    double onset_clock_time = SimSystem.clock() + delay;
	    
	    if  (duration < 0 ) duration = (2^31)-1 ; //this means keep displaying
	    
	    DeviceModuleFun__Audio_Display_Prepare_Tone_Sound( frequency, duration , Double.toString(onset_clock_time) );
	    
	    output_txt_trace_for_an_item_display.addLast( "Display_Item_Audio_Tone_Sound: frequency:" +  frequency + " Hz, onset_clock_time: " + onset_clock_time + ", duration: " + duration + " .  |||||    " );
	  } //end of Display_Item_Audio_Tone_Sound
	  else if ( a_display_item instanceof Display_Item_Audio_Digit_Sound ){
	    String digit = ((Display_Item_Audio_Digit_Sound) a_display_item).Digit;
	    if( digit.equals( "" )) return output_txt_trace_for_an_item_display; // nothing to display
	    
	    String channel = ((Display_Item_Audio_Digit_Sound) a_display_item).Channel;
	    
	    double delay  = ((Display_Item_Audio_Digit_Sound) a_display_item).Display_Item_Delay;
	    double onset_clock_time = SimSystem.clock() + delay;
	    
	    DeviceModuleFun__Audio_Display_Prepare_Digit_Sound( digit,   Double.toString(onset_clock_time) );
	    
	    output_txt_trace_for_an_item_display.addLast( "Display_Item_Audio_Digit_Sound: digit:" +  digit + ", onset_clock_time: " + onset_clock_time + ", duration: " + sim.vars.audioModule.Digit_Duration + " .  |||||    " );
	    
	  } //end of Display_Item_Audio_Digit_Sound
	  
	  else if ( a_display_item instanceof Display_Item_Audio_Word_Sound ){
	    String word = ((Display_Item_Audio_Word_Sound) a_display_item).Word;
	    if( word.equals( "" )) return output_txt_trace_for_an_item_display; // nothing to display
	    String channel = ((Display_Item_Audio_Word_Sound) a_display_item).Channel;
	    double delay  = ((Display_Item_Audio_Word_Sound) a_display_item).Display_Item_Delay;
	    double onset_clock_time = SimSystem.clock() + delay;
	    double duration = SpeechModuleFun__Get_Articulation_Time(word);
	    
	    if( ((Display_Item_Audio_Word_Sound) a_display_item).As_Sentence == false){
	      DeviceModuleFun__Audio_Display_Prepare_Word_Sound( word,   Double.toString(onset_clock_time), "external" );
	    }
	    else{ // :as_sentence
	      //similar to :text :as_paragraph
	      
	      if(sim.vars.animatorModule.Vocalize_Speech){
	        //vocalize the whole sentence for human. cut it into individual words for the model.
	        ProgramUtilitiesFun__Delayed_Function_Call_No_Return_Value(delay, "VocalizeSentence", word);
	      }
	      
	      double word_onset_clock_time = onset_clock_time;
	      int total_char_num = 0;
	      int line_num = 0;
	      int char_num_in_line = 0;
	      int char_num_in_a_group = 0;
	      //int group_limit_num = sim.vars.visionModule.Text_Char_Group_Length;
	      String temp_text_group = "";
	      if(word.charAt(0) == '"') word = word.substring(1); //remove first "
	      if( word.charAt(word.length() - 1) == '"') word = word.substring(0, word.length() - 1); //remove last "
	      String the_text = ProgramUtilitiesFun__String_Parser_Escape_Sequence(word);
	      
	      for(int v=0; v< the_text.length(); v++){
	        char a_char=the_text.charAt(v);
	        boolean end_of_this_group = false;
	        boolean end_of_this_line = false;
	        if(a_char != '\n' && a_char != ' '){ // "abXc"
	          temp_text_group += a_char;
	          char_num_in_a_group++;
	          char_num_in_line++;
	        }
	        else if (a_char == ' '){
	          temp_text_group += a_char;
	          char_num_in_a_group++;
	          char_num_in_line++;
	          end_of_this_group = true;
	        }
	        else{ //"ab\nc"  end of this line
	          temp_text_group += "\n";
	          char_num_in_a_group++;
	          char_num_in_line++;
	          end_of_this_group = true;
	          end_of_this_line = true;
	          
	        }
	        //if( char_num_in_a_group >= group_limit_num)end_of_this_group = true;
	        if(end_of_this_group){
	          //make a word sound item
	          
	          DeviceModuleFun__Audio_Display_Prepare_Word_Sound( temp_text_group,   Double.toString(word_onset_clock_time), "external-from-sentence" );
	          word_onset_clock_time += SpeechModuleFun__Get_Articulation_Time(temp_text_group) + sim.vars.speechModule.Pause_Between_Words_In_Sentence;
	          
	          //System.out.println("line: " + line_num + ", temp_text_group: " + temp_text_group + ", char_num_in_a_group: " + char_num_in_a_group);					
	          temp_text_group = "";
	          char_num_in_a_group = 0;
	        }
	        if(end_of_this_line){
	          char_num_in_line = 0;
	          line_num++;
	        }
	        total_char_num++; 
	      }
	      
	    }
	    
	    output_txt_trace_for_an_item_display.addLast( "Display_Item_Audio_Word_Sound: word:" +  word + ", onset_clock_time: " + onset_clock_time + ", duration: " + duration + " .  |||||    " );
	    
	  } //end of Display_Item_Audio_Word_Sound
	  else {
	    System.err.println ( "TaskTemplateFun__Show_Display_Item_Display has undefined a_display_item type.");
	  }
	  
	  return output_txt_trace_for_an_item_display;
	}
	
	public  void TaskTemplateFun__Start_Trial_Display (){

	  TaskTemplateFun__Events_At_The_End_Of_Each_Trial();
	  
	  TaskTemplateFun__Events_Before_The_Start_Of_Each_Trial();
	  
	  if(sim.vars.taskTemplate.Method.equals( "discrete_display_feedback_two_stages_method" ) ) {
	    sim.vars.taskTemplate.Task_1_Current_Stage = "Display_And_Response";
	    sim.vars.taskTemplate.Task_1_Current_Trial_Number++; //initially is 0.
	    if ( sim.vars.centralParametersModule.Experiment_Trial_Parameter_List.size() < sim.vars.taskTemplate.Task_1_Current_Trial_Number){ //all trials done
	      //Method 1: signal the end of trials 
	      sim.vars.taskTemplate.Task_1_Current_Stage = "All_Trials_Done";
	      DeviceModuleFun__Visual_Display_Prepare_Clear_Visual_Display(0.0);
	      return;
	    }  
	    
	    //load common parameters for the trial, a trial must have these parameters at least. 
	    Hashtable parameters_for_this_trial  = (Hashtable) ProgramUtilitiesFun__LinkedListObject_Get_i_th_Object ( sim.vars.centralParametersModule.Experiment_Trial_Parameter_List, sim.vars.taskTemplate.Task_1_Current_Trial_Number );
	    
	    int day_num = 					(int) parameters_for_this_trial.get("day-num");
	    int block_num = 				(int) parameters_for_this_trial.get("block-num");
	    int trial_num_within_block = 	(int) parameters_for_this_trial.get("trial-num-within-block");
	    
	    //check whether to reset modules before each day.
	    if(!sim.vars.taskTemplate.Reset_All_Modules_Before_Each_Trial && sim.vars.taskTemplate.Reset_All_Modules_Before_Each_Day){
	      //if reset before each trial, no need to reset again before each day
	      if(block_num == 1 &&  trial_num_within_block == 1) FrameworkFun__Reset_All_Modules();  // random seeds were not reset.
	    }
	    
	    sim.vars.visualization__Day_Block_Trial = Integer.toString(day_num) + ", " + block_num + ", " + trial_num_within_block;
	    //visualize block variables
	    sim.vars.visualization__Block_Variables = "NONE";
	    
	    
	    Iterator<Entry> itrEntries = parameters_for_this_trial.entrySet().iterator();
	    while(itrEntries.hasNext()){
	      Entry anEntry = itrEntries.next();
	      String key = (String) anEntry.getKey();
	      if( key.length() > 16  && key.substring(0, 16 ).equals( ":block_variable_")){
	        if(sim.vars.visualization__Block_Variables.equals( "NONE") ) sim.vars.visualization__Block_Variables = "";
	        sim.vars.visualization__Block_Variables = sim.vars.visualization__Block_Variables + key + "    " + (String) anEntry.getValue() + "\n";
	      }
	    }
	    
	    double display_and_response_duration = (double) parameters_for_this_trial.get("display-and-response-duration");
	    double feedback_duration			 = (double) parameters_for_this_trial.get("feedback-duration");
	    int number_of_items  = 		 (int) parameters_for_this_trial.get("number-of-items");
	    
	    int total_trial_num =			sim.vars.taskTemplate.Task_1_Current_Trial_Number; //total_trial's current count
	    //int height = 					(int) parameters_for_this_trial["height"];
	    //int width = 					(int) parameters_for_this_trial["width"];
	    //String title = (String) parameters_for_this_trial["title"];
	    //double  = (double) parameters_for_this_trial[""];
	    
	    //send a clear visual display command to visual display. visual display will clear the screen, and send a notice to visual perception only if the screen was not previously blank (there are some visual items cleared from the screen.)
	    DeviceModuleFun__Visual_Display_Prepare_Clear_Visual_Display(0.0);
	    
	    //display the items
	    LinkedList<String> output_txt_trace_for_items_display = new LinkedList<String>();
	    LinkedList<Object> display_items_for_this_trial = (LinkedList<Object>) ProgramUtilitiesFun__LinkedListObject_Get_i_th_Object ( sim.vars.centralParametersModule.Experiment_Trial_Display_Item_List, sim.vars.taskTemplate.Task_1_Current_Trial_Number );
	    int item_ID_num = 0;
	    for (Object a_display_item : display_items_for_this_trial) {
	      LinkedList<String>  output_txt_trace_for_an_item_display = TaskTemplateFun__Show_Display_Item_Display( a_display_item, item_ID_num);
	      output_txt_trace_for_items_display = ProgramUtilitiesFun__LinkedListString_Append (output_txt_trace_for_items_display, output_txt_trace_for_an_item_display);
	      item_ID_num++;
	    } //end of each display item
	    
	    
	    //prepare to trigger feedback 
	    if ( display_and_response_duration >= 0 ){ //there is a limited duration, after that, show the feedback stages, otherwise, display duration is infinite, wait for control response signal
	      //start an entity in the timer
	      Entity Temp_Entity = sim.funs.createEntity( "Timer Triggering Feedback Or Display" , "", "", "Feedback Stage Trigger", 0.0);
//	      Entity Temp_Entity = new Entity();  
//	      Temp_Entity.ID = "203"; //Timer Triggering next Feedback or Display
//	      Temp_Entity.Time = SimSystem.clock();
//	      Temp_Entity.Tag = Entity_Number; //give it an entity number, init. 1
//	      Entity_Number++;

//	      Temp_Entity.Entity_Type =  "Feedback Stage Trigger";

	      Temp_Entity.Scheduled_Task_Enter_Clock_Time = display_and_response_duration + SimSystem.clock();
	    
	    }
	    
	    //output some traces
	    if ( sim.vars.printingModule.Show_Display_And_Feedback_In_Output_Trace_Txt ){
	      ProgramUtilitiesFun__Output_Trace_Txt("");
	      ProgramUtilitiesFun__Output_Trace_Txt("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Start_Trial_Display~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
	      ProgramUtilitiesFun__Output_Trace_Txt("TaskTemplateFun__Start_Trial_Display: total_trial_num " + total_trial_num + " , day_num: " + day_num + " , block_num: " +  block_num + ", trial_num_within_block " + trial_num_within_block );
	      ProgramUtilitiesFun__Output_Trace_Txt("Item(s) displayed:  " + ProgramUtilitiesFun__LinkedListString_To_String( output_txt_trace_for_items_display ) );
	      ProgramUtilitiesFun__Output_Trace_Txt("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
	      ProgramUtilitiesFun__Output_Trace_Txt("");	
	    }
	    
	    //prepare for result collection
	    Hashtable result_table = ProgramUtilitiesFun__Hashtable_Clone (parameters_for_this_trial ); 
	    result_table.put("display-stage-start-time", GlobalUtilities.round(SimSystem.clock(), 3));
	    result_table.put("global-trial-num", total_trial_num);
	    sim.vars.centralParametersModule.Experiment_Trial_Result_List.addLast(result_table);
	    sim.vars.centralParametersModule.Experiment_Trial_Response_Item_List.addLast( new LinkedList<Object>() );
	    
	  }
	  else {
	    System.out.println("WARNING! TaskTemplateFun__Start_Trial_Display has undefined sim.vars.taskTemplate.Method: " + sim.vars.taskTemplate.Method);
	  }
	}
	
	public  void TaskTemplateFun__Start_Trial_Feedback (){
	  
	  if(sim.vars.taskTemplate.Method.equals( "discrete_display_feedback_two_stages_method" )) {
	    sim.vars.taskTemplate.Task_1_Current_Stage = "Feedback";
	    //sim.vars.taskTemplate.Task_1_Current_Trial_Number //stays the unchanged
	    
	    //load common parameters for the trial, a trial must have these parameters at least. 
	    Hashtable parameters_for_this_trial  = (Hashtable) ProgramUtilitiesFun__LinkedListObject_Get_i_th_Object ( sim.vars.centralParametersModule.Experiment_Trial_Parameter_List, sim.vars.taskTemplate.Task_1_Current_Trial_Number );
	    
	    int day_num = 					(int) parameters_for_this_trial.get("day-num");
	    int block_num = 				(int) parameters_for_this_trial.get("block-num");
	    int trial_num_within_block = 	(int) parameters_for_this_trial.get("trial-num-within-block");
	    //double display_and_response_duration = (double) parameters_for_this_trial["display-and-response-duration"];
	    double feedback_duration			 = (double) parameters_for_this_trial.get("feedback-duration");
	    int number_of_items  = 		 (int) parameters_for_this_trial.get("number-of-items");
	    
	    int total_trial_num =			sim.vars.taskTemplate.Task_1_Current_Trial_Number; //total_trial's current count
	    
	    //send a clear visual display command to visual display. visual display will clear the screen, and send a notice to visual perception only if the screen was not previously blank (there are some visual items cleared from the screen.)
	    DeviceModuleFun__Visual_Display_Prepare_Clear_Visual_Display(0.0);
	    
	    //show the feeback items stored as the feedback for each display item
	    LinkedList<String> output_txt_trace_for_items_display = new LinkedList<String>();
	    LinkedList<Object> display_items_for_this_trial = (LinkedList<Object>) ProgramUtilitiesFun__LinkedListObject_Get_i_th_Object ( sim.vars.centralParametersModule.Experiment_Trial_Display_Item_List, sim.vars.taskTemplate.Task_1_Current_Trial_Number );
	    int item_ID_num = 0;
	    for (Object a_display_item : display_items_for_this_trial) {  //Currently a visual_text display item gives a visual text feedback. ToDo, add an attribute of feedback type that could be visual display text or auditory tone or speech
	      if ( a_display_item instanceof Display_Item_Visual_Text ){
	        if (((Display_Item_Visual_Text) a_display_item).Hide) continue; // nothing to display
	        
	        double duration = ((Display_Item_Visual_Text) a_display_item).Feedback_Item_Duration;
	        if(duration == 0.0) continue;  //duration = 0 , means not to display
	        
	        String feedback_content = ((Display_Item_Visual_Text) a_display_item).Feedback;
	        if( feedback_content.equals( "" )) continue; // nothing to display
	        
	        String color = ((Display_Item_Visual_Text) a_display_item).Feedback_Item_Color;
	        int screen_location_x = ((Display_Item_Visual_Text) a_display_item).Feedback_Item_Screen_Location_X;
	        int screen_location_y = ((Display_Item_Visual_Text) a_display_item).Feedback_Item_Screen_Location_Y;
	        
	        double delay  = ((Display_Item_Visual_Text) a_display_item).Feedback_Item_Delay;
	        double onset_clock_time = SimSystem.clock() + delay;
	        
	        String duration_string; 
	        if  (duration < 0 ) duration_string = ""; //this means keep displaying
	        else duration_string = Double.toString(duration);
	        
	        DeviceModuleFun__Visual_Display_Prepare_Text(item_ID_num,  false, false, feedback_content , screen_location_x, screen_location_y, Double.toString(onset_clock_time), duration_string, color, 7 , 11); //default width = 7 , height = 11
	        
	        String display_feedback_content = feedback_content;
	        //System.out.println(display_feedback_content);
	        if ( display_feedback_content.equals( "" ))  display_feedback_content = "[EMPTY]";
	        output_txt_trace_for_items_display.addLast( "Feedback_Item_Visual_Text: " +  display_feedback_content + ", color: " + color + " at (" +  screen_location_x + "," + screen_location_y + ") onset_clock_time: " + onset_clock_time + ", duration: " + duration + " .  |||||    " );
	      } //Display_Item_Visual_Text
	      else if ( a_display_item instanceof Display_Item_Visual_Line  ){
	        if (((Display_Item_Visual_Line) a_display_item).Hide) continue; // nothing to display
	        
	        Display_Item_Visual_Line the_display_item = (Display_Item_Visual_Line) a_display_item;
	        double duration = the_display_item.Feedback_Item_Duration;
	        if(duration == 0.0) continue;  //duration = 0 , means not to display
	        
	        String feedback_content = the_display_item.Feedback;
	        if( feedback_content.equals( "" )) continue; // nothing to display
	        
	        String color = the_display_item.Feedback_Item_Color;
	        int screen_location_x = the_display_item.Feedback_Item_Screen_Location_X;
	        int screen_location_y = the_display_item.Feedback_Item_Screen_Location_Y;
	        
	        double delay  = the_display_item.Feedback_Item_Delay;
	        double onset_clock_time = SimSystem.clock() + delay;
	        
	        String duration_string; 
	        if  (duration < 0 ) duration_string = ""; //this means keep displaying
	        else duration_string = Double.toString(duration);
	        
	        DeviceModuleFun__Visual_Display_Prepare_Text(item_ID_num, false, false, feedback_content , screen_location_x, screen_location_y, Double.toString(onset_clock_time), duration_string, color, 7 , 11); //default width = 7 , height = 11
	        
	        String display_feedback_content = feedback_content;
	        //System.out.println(display_feedback_content);
	        if ( display_feedback_content.equals( "" ))  display_feedback_content = "[EMPTY]";
	        output_txt_trace_for_items_display.addLast( "Feedback_Item_Visual_Line: " +  display_feedback_content + ", color: " + color + " at (" +  screen_location_x + "," + screen_location_y + ") onset_clock_time: " + onset_clock_time + ", duration: " + duration + " .  |||||    " );
	      } //Display_Item_Visual_Line
	      else if ( a_display_item instanceof Display_Item_Visual_Text_Button  ){
	        if (((Display_Item_Visual_Text_Button) a_display_item).Hide) continue; // nothing to display
	        
	        Display_Item_Visual_Text_Button the_display_item = (Display_Item_Visual_Text_Button) a_display_item;
	        double duration = the_display_item.Feedback_Item_Duration;
	        if(duration == 0.0) continue;  //duration = 0 , means not to display
	        
	        String feedback_content = the_display_item.Feedback;
	        if( feedback_content.equals( "" )) continue; // nothing to display
	        
	        String color = the_display_item.Feedback_Item_Color;
	        int screen_location_x = the_display_item.Feedback_Item_Screen_Location_X;
	        int screen_location_y = the_display_item.Feedback_Item_Screen_Location_Y;
	        
	        double delay  = the_display_item.Feedback_Item_Delay;
	        double onset_clock_time = SimSystem.clock() + delay;
	        
	        String duration_string; 
	        if  (duration < 0 ) duration_string = ""; //this means keep displaying
	        else duration_string = Double.toString(duration);
	        
	        DeviceModuleFun__Visual_Display_Prepare_Text(item_ID_num, false, false, feedback_content , screen_location_x, screen_location_y, Double.toString(onset_clock_time), duration_string, color, 7 , 11); //default width = 7 , height = 11
	        
	        String display_feedback_content = feedback_content;
	        //System.out.println(display_feedback_content);
	        if ( display_feedback_content.equals( "" ))  display_feedback_content = "[EMPTY]";
	        output_txt_trace_for_items_display.addLast( "Feedback_Item_Visual_Text_Button: " +  display_feedback_content + ", color: " + color + " at (" +  screen_location_x + "," + screen_location_y + ") onset_clock_time: " + onset_clock_time + ", duration: " + duration + " .  |||||    " );
	      } //Display_Item_Visual_Text_Button
	      else if( a_display_item instanceof Display_Item_Audio_Tone_Sound ){
	        double duration = ((Display_Item_Audio_Tone_Sound) a_display_item).Feedback_Item_Duration;
	        if(duration == 0.0) continue;  //duration = 0 , means not to display
	        
	        String feedback_content = ((Display_Item_Audio_Tone_Sound) a_display_item).Feedback;
	        if( feedback_content.equals( "" )) continue; // nothing to display
	        
	        //ToDo:
	        System.out.println("ToDo: TaskTemplateFun__Start_Trial_Feedback need display method for  a_display_item is Display_Item_Audio_Tone_Sound ");
	      }
	      
	      else if( a_display_item instanceof Display_Item_Audio_Digit_Sound ){
	        double duration = ((Display_Item_Audio_Digit_Sound) a_display_item).Feedback_Item_Duration;
	        if(duration == 0.0) continue;  //duration = 0 , means not to display
	        
	        String feedback_content = ((Display_Item_Audio_Digit_Sound) a_display_item).Feedback;
	        if( feedback_content.equals( "" )) continue; // nothing to display
	        
	        //ToDo:
	        System.out.println("ToDo: TaskTemplateFun__Start_Trial_Feedback need display method for  a_display_item is Display_Item_Audio_Digit_Sound ");
	        
	      }
	      
	      else if( a_display_item instanceof Display_Item_Audio_Word_Sound ){
	        double duration = ((Display_Item_Audio_Word_Sound) a_display_item).Feedback_Item_Duration;
	        if(duration == 0.0) continue;  //duration = 0 , means not to display
	        
	        String feedback_content = ((Display_Item_Audio_Word_Sound) a_display_item).Feedback;
	        if( feedback_content.equals( "" )) continue; // nothing to display
	        
	        //ToDo:
	        System.out.println("ToDo: TaskTemplateFun__Start_Trial_Feedback need display method for  a_display_item is Display_Item_Audio_Word_Sound ");
	        
	      }
	      
	      else {
	        System.err.println ( "TaskTemplateFun__Start_Trial_Feedback has undefined a_display_item type.");
	      }
	      
	      item_ID_num++;
	    } //end of for (object a_display_item in display_items_for_this_trial)
	    
	    //prepare to trigger the next trial display  
	    if ( feedback_duration >= 0 ){ //there is a limited duration, schedule a timer, otherwise, when the duration is infinite, wait for control response signal
	      
	      //start an entity in the timer
	      Entity Temp_Entity = sim.funs.createEntity( "Timer Triggering Feedback Or Display" , "", "", "Display Stage Trigger", 0.0);
//	      Entity Temp_Entity = new Entity();  
//	      Temp_Entity.ID = "203"; //Timer Triggering next Feedback or Display
//	      Temp_Entity.Time = SimSystem.clock();
//	      Temp_Entity.Tag = Entity_Number; //give it an entity number, init. 1
//	      Entity_Number++;
//	      Temp_Entity.Entity_Type =  "Display Stage Trigger";
//	      
	 
	      Temp_Entity.Scheduled_Task_Enter_Clock_Time = feedback_duration + SimSystem.clock();

	    }
	    
	    //output some traces
	    if ( sim.vars.printingModule.Show_Display_And_Feedback_In_Output_Trace_Txt ){
	      ProgramUtilitiesFun__Output_Trace_Txt("");
	      ProgramUtilitiesFun__Output_Trace_Txt("-----------------------------Start_Trial_Feedback------------------------------");
	      ProgramUtilitiesFun__Output_Trace_Txt("TaskTemplateFun__Start_Trial_Feedback: total_trial_num " + total_trial_num + " , day_num: " + day_num + " , block_num: " +  block_num + ", trial_num_within_block " + trial_num_within_block );
	      ProgramUtilitiesFun__Output_Trace_Txt("Feedback Item(s) displayed:  " + ProgramUtilitiesFun__LinkedListString_To_String( output_txt_trace_for_items_display ) );
	      ProgramUtilitiesFun__Output_Trace_Txt("-----------------------------------------------------------------------------------------");
	      ProgramUtilitiesFun__Output_Trace_Txt("");	
	    }
	    
	    
	  }
	  else {
	    System.out.println("WARNING! TaskTemplateFun__Start_Trial_Feedback has undefined sim.vars.taskTemplate.Method case");
	  }
	}
	
	public  void TaskTemplateFun__Substitute_Hashtable_Values_With_Block_Variables(String day_i_string, String block_i_string, Hashtable a_table, Hashtable the_block_variable_table){
	  Hashtable substitue_table = new Hashtable();
	  
	  
	  Iterator<Entry> itrEntries = a_table.entrySet().iterator();
	  while (itrEntries.hasNext()){
	    Entry anEntry = itrEntries.next();
	    String a_value = (String)anEntry.getValue();
	    String a_lookup_key = day_i_string + "__" + block_i_string + "__" + a_value;
	    if( the_block_variable_table.containsKey(a_lookup_key) ){
	      substitue_table.put (   (String)anEntry.getKey(),   (String) the_block_variable_table.get(a_lookup_key) );
	    }
	  }
	  if(substitue_table.size() > 0 ) ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value_From_Another_Hashtable( a_table, substitue_table );
	  
	}
	
	public  String TaskTemplateFun__Substitute_String_With_Block_Variables (String day_i_string, String block_i_string, String a_string, Hashtable the_block_variable_table){
	  if( a_string.length() > 16 && a_string.substring(0,16).equals( ":block_variable_" )){ //need to substitute
	    String variable_key = day_i_string + "__" + block_i_string + "__" + a_string; 
	    if( the_block_variable_table.containsKey( variable_key) == false) { 	
	      System.err.println(" Error! TaskTemplateFun__Substitute_String_With_Block_Variables does not contain variable_key: " + variable_key);
	      return null;
	    }
	    else return (String) the_block_variable_table.get(variable_key) ;
	  }
	  else return a_string; //no substitution
	}
	
	public  void TaskTemplateFun__Terminate_Display_Response_Stage_Of_This_Trial (double the_time_delay){

	  //create a new entity
	  Entity Temp_Entity = sim.funs.createEntity( "Entity Direct Cast Delay" , "Control To Display", "Visual and Audio Display Schedule", "", 0.0);
//	  Entity Temp_Entity = new Entity();  
//	  //for Visual and Audio Display Schedule to recognize this
//	  Temp_Entity.From = "Control To Display";
//	  Temp_Entity.To = "Visual and Audio Display Schedule";
//	  Temp_Entity.ID = "101"; //send to Entity Direct Cast Delay
//	  Temp_Entity.Time = SimSystem.clock();
//	  Temp_Entity.Tag = Entity_Number; //give it an entity number, init. 1
//	  Entity_Number++;
	  Temp_Entity.Direct_Cast_Delay = the_time_delay;
	  
	  
	  
	}
	
	public  void TaskTemplateFun__Update_DriverCar_Accelbrake (double new_accelbrake){
		  
		if (sim.vars.programGlobalVar__Use_Predefined_Model_Setup.equals( "model_drive_opends" )){
  		  World3D_Template_Driving_Method the_method = null;
            if(sim.vars.world3DTemplate.Method_Object != null && sim.vars.world3DTemplate.Method_Object instanceof World3D_Template_Driving_Method) the_method = sim.funs.TaskTemplateFun__Get_World3D_Driving_Method_Object();
            
            if (new_accelbrake >= 0) {
            	the_method.opendsControlBrake  = 0;
            	the_method.opendsControlAccelerator = new_accelbrake;			    
            	the_method.Accelbrake_Foot_On = "accel";
			  }
			  else {
				  the_method.opendsControlAccelerator = 0;
				  the_method.opendsControlBrake = Math.abs ( new_accelbrake );
				  the_method.Accelbrake_Foot_On = "brake";
			  }
            
		}
		else if (sim.vars.programGlobalVar__Use_Predefined_Model_Setup.equals( "model_drive_torcs" )){
  		  World3D_Template_Driving_Method the_method = null;
            if(sim.vars.world3DTemplate.Method_Object != null && sim.vars.world3DTemplate.Method_Object instanceof World3D_Template_Driving_Method) the_method = sim.funs.TaskTemplateFun__Get_World3D_Driving_Method_Object();
            
            if (new_accelbrake >= 0) {
            	the_method.torcsControlBrake  = 0;
            	the_method.torcsControlAccelerator = new_accelbrake;			    
            	the_method.Accelbrake_Foot_On = "accel";
			  }
			  else {
				  the_method.torcsControlAccelerator = 0;
				  the_method.torcsControlBrake = Math.abs ( new_accelbrake );
				  the_method.Accelbrake_Foot_On = "brake";
			  }
            
		}
		else{
			  if( sim.vars.world3DTemplate.Method_Object == null || !(sim.vars.world3DTemplate.Method_Object instanceof World3D_Template_Driving_Method)) {
			    System.err.println ("Error! TaskTemplateFun__Update_DriverCar_Accelbrake sim.vars.world3DTemplate.Method_Object == null || !(sim.vars.world3DTemplate.Method_Object is World3D_Template_Driving_Method)");
			    
			  }
			  World3D_DriverCar the_driver_car = ((World3D_DriverCar)sim.vars.world3DTemplate.World.Objects.get(  ((World3D_Template_Driving_Method)sim.vars.world3DTemplate.Method_Object).DriverCar_World3D_ID  ));
			  if (new_accelbrake >= 0) {
			    the_driver_car.Brake_Pedal = 0;
			    the_driver_car.Accelerator_Pedal = new_accelbrake;
			    ((World3D_Template_Driving_Method)sim.vars.world3DTemplate.Method_Object).Accelbrake_Foot_On = "accel";
			  }
			  else {
			    the_driver_car.Accelerator_Pedal = 0;
			    the_driver_car.Brake_Pedal = Math.abs ( new_accelbrake );
			    ((World3D_Template_Driving_Method)sim.vars.world3DTemplate.Method_Object).Accelbrake_Foot_On = "brake";
			  }
		}
	}
	
	public  void TaskTemplateFun__Update_DriverCar_Steer_And_Wheel_With_Delta_Steer (double the_delta_steer_degree){
		if (sim.vars.programGlobalVar__Use_Predefined_Model_Setup.equals( "model_drive_opends" )){
	  		  World3D_Template_Driving_Method the_method = null;
	            if(sim.vars.world3DTemplate.Method_Object != null && sim.vars.world3DTemplate.Method_Object instanceof World3D_Template_Driving_Method) the_method = sim.funs.TaskTemplateFun__Get_World3D_Driving_Method_Object();
	            
	            the_method.opendsControlSteerAngleDegree += the_delta_steer_degree;
	            
		}
		else if (sim.vars.programGlobalVar__Use_Predefined_Model_Setup.equals( "model_drive_torcs" )){
	  		  World3D_Template_Driving_Method the_method = null;
	            if(sim.vars.world3DTemplate.Method_Object != null && sim.vars.world3DTemplate.Method_Object instanceof World3D_Template_Driving_Method) the_method = sim.funs.TaskTemplateFun__Get_World3D_Driving_Method_Object();
	            
	            the_method.torcsControlSteerAngleDegree += the_delta_steer_degree;
	            
		}
		else{
		  World3D_DriverCar the_driver_car_pointer = TaskTemplateFun__Get_World3D_DriverCar_Object();
		  the_driver_car_pointer.Steer_Angle += the_delta_steer_degree;
		  
		  the_driver_car_pointer.Wheel_Angle = the_driver_car_pointer.Steer_Angle / the_driver_car_pointer.Steering_Ratio;
		}
	}
	
	public  void TaskTemplateFun__Update_DriverCar_Steer_And_Wheel_With_New_Steer (double the_new_steer_degree){
	  World3D_DriverCar the_driver_car_pointer = TaskTemplateFun__Get_World3D_DriverCar_Object();
	  the_driver_car_pointer.Steer_Angle = the_new_steer_degree;
	  
	  the_driver_car_pointer.Wheel_Angle = the_driver_car_pointer.Steer_Angle / the_driver_car_pointer.Steering_Ratio;
	  
	}
	
	public  void TaskTemplateFun__Update_Text_Dynamic_Item_Text (String item_name, String new_text, double delay){
	  Hashtable dynamic_items = TaskTemplateFun__Get_Current_Dynamic_Items();
	  
	  if( dynamic_items.containsKey(item_name) == false){
	    System.err.println("Error! TaskTemplateFun__Update_Text_Dynamic_Item_Text has undefined item_name: " + item_name);	
	    return;
	  }
	  
	  Display_Item_Visual_Text text_item = (Display_Item_Visual_Text)dynamic_items.get(item_name) ;
	  text_item.Visual_Text = new_text;
	  TaskTemplateFun__Refresh_Dynamic_Item( text_item , delay);
	}
	
	public  void TaskTemplateFun__Update_World3D_Road_Fragments_Animator3D_Show_Or_Hide (double ref_X,double ref_Z,double range, World3D_Road road){
	  
	  // Animator3D
	  
	  System.out.println("TODO TaskTemplateFun__Update_World3D_Road_Fragments_Animator3D_Show_Or_Hide, Animator3D");
	  
	  if(road.hide)return;
	  ArrayList<Double> fragment_distance_points = new ArrayList<Double>();
	  Enumeration an_entryValue = road.Fragments.elements();
	  Enumeration an_entryKey = road.Fragments.keys();
	  while(an_entryValue.hasMoreElements()){
	    fragment_distance_points.add( (Double)an_entryKey.nextElement() );
	  }
	  Collections.sort(fragment_distance_points);
	
	  for (double fragment_start_distance : fragment_distance_points){
	    World3D_Road_Fragment a_fragment = (World3D_Road_Fragment)road.Fragments.get(fragment_start_distance);
	    double center_start_x = a_fragment.Start_Loc_X;
	    double center_start_z = a_fragment.Start_Loc_Z;
	    /*
		double center_end_x = a_fragment.End_Loc_X;
		double center_end_z = a_fragment.End_Loc_Z;
		double start_angle_radian = a_fragment.Start_Heading_Angle / 180.0 * Math.PI;
		double end_angle_radian = ( a_fragment.Start_Heading_Angle + a_fragment.Turn_Angle ) / 180.0 * Math.PI;

		double start_x_offset = road.Lane_Width/2.0 * Math.Cos(start_angle_radian);
		double start_z_offset = road.Lane_Width/2.0 * Math.Sin(start_angle_radian);

		double center_lane_left_edge_start_x = center_start_x - start_x_offset; 
		double center_lane_left_edge_start_z = center_start_z + start_z_offset;
		double center_lane_right_edge_start_x = center_start_x + start_x_offset; 
		double center_lane_right_edge_start_z = center_start_z - start_z_offset;

		double end_x_offset = road.Lane_Width/2.0 * Math.Cos(end_angle_radian);
		double end_z_offset = road.Lane_Width/2.0 * Math.Sin(end_angle_radian);

		double center_lane_left_edge_end_x = center_end_x - end_x_offset; 
		double center_lane_left_edge_end_z = center_end_z + end_z_offset;
		double center_lane_right_edge_end_x = center_end_x + end_x_offset; 
		double center_lane_right_edge_end_z = center_end_z - end_z_offset;
	     */
	    
//	    double distance = ProgramUtilitiesFun__Geometry2D_Point_Point_Distance ( center_start_x, center_start_z, ref_X, ref_Z);
//	    if(distance < range){
//	      Enumeration an_entry = a_fragment.Animator3D_IDs.elements();
//	      while(an_entry.hasMoreElements()){
//	        Animator3D.Show(  (String)an_entry.nextElement() ); //String an_animator3d_id 
//	      }
//	    }
//	    else{
//	      Enumeration an_entry = a_fragment.Animator3D_IDs.elements();
//	      while(an_entry.hasMoreElements()){
//	        Animator3D.Hide(  (String)an_entry.nextElement() ); //String an_animator3d_id 
//	      }
//	    }
	    
	    /*
		if(!road.Hide){
		String center_left_edge_animator3d_id = Animator3D.Create3DLine(center_lane_left_edge_start_x, 0.0, center_lane_left_edge_start_z,     center_lane_left_edge_end_x, 0.0, center_lane_left_edge_end_z );
		a_fragment.Animator3D_IDs.Add("0_left", center_left_edge_animator3d_id );
		Animator3D.Hide(center_left_edge_animator3d_id);
		}

		if(!road.Hide){
		String center_right_edge_animator3d_id = Animator3D.Create3DLine(center_lane_right_edge_start_x, 0.0, center_lane_right_edge_start_z,   center_lane_right_edge_end_x, 0.0, center_lane_right_edge_end_z);
		a_fragment.Animator3D_IDs.Add("0_right", center_right_edge_animator3d_id);
		Animator3D.Hide3DLineEndPoint(center_right_edge_animator3d_id);
		}

		if( road.Lane_Num_Left > 0 ){
		int i;
		for(i = 1 ; i <= road.Lane_Num_Left ; i++) {
		double the_lane_left_edge_start_x = center_start_x - (1 + 2*i) * start_x_offset; 
		double the_lane_left_edge_start_z = center_start_z + (1 + 2*i) * start_z_offset;
		//double the_lane_right_edge_start_x = center_start_x + (1 + 2*i) * start_x_offset; 
		//double the_lane_right_edge_start_z = center_start_z - (1 + 2*i) * start_z_offset;

		double the_lane_left_edge_end_x = center_end_x - (1 + 2*i) * end_x_offset; 
		double the_lane_left_edge_end_z = center_end_z + (1 + 2*i) * end_z_offset;
		//double the_lane_right_edge_end_x = center_end_x + (1 + 2*i) * end_x_offset; 
		//double the_lane_right_edge_end_z = center_end_z - (1 + 2*i) * end_z_offset;

		if(!road.Hide){
		String the_left_edge_animator3d_id = Animator3D.Create3DLine(the_lane_left_edge_start_x, 0.0, the_lane_left_edge_start_z,     the_lane_left_edge_end_x, 0.0, the_lane_left_edge_end_z );
		a_fragment.Animator3D_IDs.Add("-" + i.ToString() + "_left", the_left_edge_animator3d_id );
		Animator3D.Hide3DLineEndPoint(the_left_edge_animator3d_id);
		}
		//String the_right_edge_animator3d_id = Animator3D.Create3DLine(the_lane_right_edge_start_x, 0.0, the_lane_right_edge_start_z,   the_lane_right_edge_end_x, 0.0, the_lane_right_edge_end_z);
		//a_fragment.Animator3D_IDs.Add(?? + "_right", the_right_edge_animator3d_id);						

		}

		}//end of adding left other lanes

		if (road.Lane_Num_Right > 0){
		int i;
		for(i = 1 ; i <= road.Lane_Num_Left ; i++) {
		//double the_lane_left_edge_start_x = center_start_x - (1 + 2*i) * start_x_offset; 
		//double the_lane_left_edge_start_z = center_start_z + (1 + 2*i) * start_z_offset;
		double the_lane_right_edge_start_x = center_start_x + (1 + 2*i) * start_x_offset; 
		double the_lane_right_edge_start_z = center_start_z - (1 + 2*i) * start_z_offset;

		//double the_lane_left_edge_end_x = center_end_x - (1 + 2*i) * end_x_offset; 
		//double the_lane_left_edge_end_z = center_end_z + (1 + 2*i) * end_z_offset;
		double the_lane_right_edge_end_x = center_end_x + (1 + 2*i) * end_x_offset; 
		double the_lane_right_edge_end_z = center_end_z - (1 + 2*i) * end_z_offset;

		//String the_left_edge_animator3d_id = Animator3D.Create3DLine(the_lane_left_edge_start_x, 0.0, the_lane_left_edge_start_z,     the_lane_left_edge_end_x, 0.0, the_lane_left_edge_end_z );
		//a_fragment.Animator3D_IDs.Add(?? + "_left", the_left_edge_animator3d_id );

		if(!road.Hide){
		String the_right_edge_animator3d_id = Animator3D.Create3DLine(the_lane_right_edge_start_x, 0.0, the_lane_right_edge_start_z,   the_lane_right_edge_end_x, 0.0, the_lane_right_edge_end_z);
		a_fragment.Animator3D_IDs.Add(i.ToString() + "_right", the_right_edge_animator3d_id);	
		Animator3D.Hide3DLineEndPoint(the_right_edge_animator3d_id);
		}
		}

		}//end of adding right other lanes
	     */
	  }
	}
	
	public  void TaskTemplateFun__Update_World3D_Vehicle_3D_Dynamics_With_Constant_Accel (World3D_Vehicle_Basic the_vehicle_basic_pointer, double time_step){
	  
	  double new_Angular_Speed_Pitch = the_vehicle_basic_pointer.Speed_Pitch + the_vehicle_basic_pointer.Local_Acc_Pitch * time_step; // for rotation, 3D Animator rotation angles can be directly set
	  double new_Angular_Speed_Yaw   = the_vehicle_basic_pointer.Speed_Yaw   + the_vehicle_basic_pointer.Local_Acc_Yaw   * time_step; 
	  double new_Angular_Speed_Roll  = the_vehicle_basic_pointer.Speed_Roll  + the_vehicle_basic_pointer.Local_Acc_Roll  * time_step; 
	  
	  double average_Angular_Speed_Pitch = (the_vehicle_basic_pointer.Speed_Pitch + new_Angular_Speed_Pitch ) / 2.0;
	  double average_Angular_Speed_Yaw = (the_vehicle_basic_pointer.Speed_Yaw + new_Angular_Speed_Yaw ) / 2.0;
	  double average_Angular_Speed_Roll = (the_vehicle_basic_pointer.Speed_Roll + new_Angular_Speed_Roll ) / 2.0;
	  
	  //compute 6DOF global delta speed based on 6DOF local delta speed (local acc * time)
	  double local_delta_speed_X = the_vehicle_basic_pointer.Local_Acc_X * time_step; 
	  double local_delta_speed_Y = the_vehicle_basic_pointer.Local_Acc_Y * time_step; 
	  double local_delta_speed_Z = the_vehicle_basic_pointer.Local_Acc_Z * time_step; 
	  
	  Matrix3d m_local = new Matrix3d();
	  Matrix3d return_matrix = new Matrix3d();
	  for (int z=0; z<4; z++){
	    for (int x=0; x<4; x++){
	      return_matrix.Matrix[x][z]=0;
	    }
	  }
	  
	  m_local.Matrix[0][0] = local_delta_speed_X;
	  m_local.Matrix[0] [1] = local_delta_speed_Y;
	  m_local.Matrix[0] [2] = local_delta_speed_Z;
	  m_local.Matrix[0] [3] = 1.0;
	  
	  double average_Pitch = the_vehicle_basic_pointer.Pitch + average_Angular_Speed_Pitch * time_step / 2.0; // do not wrap into +- 180 degree, otherwise will jerk almost 360 from -179 to 179
	  double average_Yaw   = the_vehicle_basic_pointer.Yaw   + average_Angular_Speed_Yaw   * time_step / 2.0; 
	  double average_Roll  = the_vehicle_basic_pointer.Roll  + average_Angular_Speed_Roll  * time_step / 2.0;
	  
	  Matrix3d m_global = TaskTemplateFun__Linear_Local_Value_To_Global(m_local, average_Pitch, average_Yaw, average_Roll);
	  
	  double global_delta_speed_X = m_global.Matrix[0][ 0];
	  double global_delta_speed_Y = m_global.Matrix[0][ 1];
	  double global_delta_speed_Z = m_global.Matrix[0][ 2];
	  
	  double new_Speed_X = the_vehicle_basic_pointer.Speed_X + global_delta_speed_X; 
	  double new_Speed_Y = the_vehicle_basic_pointer.Speed_Y + global_delta_speed_Y; 
	  double new_Speed_Z = the_vehicle_basic_pointer.Speed_Z + global_delta_speed_Z; 
	  
	  double average_Speed_X = ( the_vehicle_basic_pointer.Speed_X + new_Speed_X ) / 2.0;
	  double average_Speed_Y = ( the_vehicle_basic_pointer.Speed_Y + new_Speed_Y ) / 2.0;
	  double average_Speed_Z = ( the_vehicle_basic_pointer.Speed_Z + new_Speed_Z ) / 2.0;
	  
	  
	  //update 1st order values
	  the_vehicle_basic_pointer.Loc_X += average_Speed_X * time_step;
	  the_vehicle_basic_pointer.Loc_Y += average_Speed_Y * time_step;
	  the_vehicle_basic_pointer.Loc_Z += average_Speed_Z * time_step;
	  
	  the_vehicle_basic_pointer.Pitch += average_Angular_Speed_Pitch * time_step; // do not wrap into +- 180 degree, otherwise will jerk almost 360 from -179 to 179
	  the_vehicle_basic_pointer.Yaw += average_Angular_Speed_Yaw * time_step; 
	  the_vehicle_basic_pointer.Roll += average_Angular_Speed_Roll * time_step;
	  
	  //update 2nd order values
	  the_vehicle_basic_pointer.Speed_X = (double) new_Speed_X ; 
	  the_vehicle_basic_pointer.Speed_Y = (double) new_Speed_Y ; 
	  the_vehicle_basic_pointer.Speed_Z = (double) new_Speed_Z ; 
	  
	  the_vehicle_basic_pointer.Speed_Pitch = (double) new_Angular_Speed_Pitch;
	  the_vehicle_basic_pointer.Speed_Yaw   = (double) new_Angular_Speed_Yaw;
	  the_vehicle_basic_pointer.Speed_Roll  = (double) new_Angular_Speed_Roll;
	}
	
	public  void TaskTemplateFun__Use_Task_DBT_Template (LinkedList<String> Parameter_List){
	  LinkedList<String> Parameter_List_Clone = ProgramUtilitiesFun__LinkedListString_Clone ( Parameter_List );
	  String a_parameter;
	  while ( Parameter_List_Clone.size() > 0 ) {
	    
	    switch (Parameter_List_Clone.getFirst().toLowerCase()) {
	      case ":auto_compute_default_reaction_time" : {
	        Parameter_List_Clone.removeFirst(); // remove the parameter name
	        if ( Parameter_List_Clone.size() < 1 ) { System.err.println ("Error TaskTemplateFun__Use_Task_DBT_Template " + Parameter_List_Clone.getFirst() + " needs 1 parameter"); }
	        a_parameter = Parameter_List_Clone.getFirst();  //needs has a single parameter
	        Parameter_List_Clone.removeFirst();
	        if ( a_parameter.charAt(0) == ':' || a_parameter.charAt(0) == '(' || a_parameter.charAt(0) == ')'){  System.out.println ("Error TaskTemplateFun__Use_Task_DBT_Template " + Parameter_List_Clone.getFirst() + " needs 1 parameter. not " + a_parameter);}
	        if (a_parameter.equals( "t")) sim.vars.taskTemplate.Auto_Compute_Default_Reaction_Time = true ;
	        else if (a_parameter.equals( "nil")) sim.vars.taskTemplate.Auto_Compute_Default_Reaction_Time = false ;
	        else System.err.println ("Error! TaskTemplateFun__Use_Task_DBT_Template :auto_compute_default_response_correctness has a parameter not t or nil but: " +  a_parameter );
	        break;
	      }
	      case ":auto_compute_default_response_correctness" : {
	        Parameter_List_Clone.removeFirst(); // remove the parameter name
	        if ( Parameter_List_Clone.size() < 1 ) { System.out.println ("Error TaskTemplateFun__Use_Task_DBT_Template " + Parameter_List_Clone.getFirst() + " needs 1 parameter"); }
	        a_parameter = Parameter_List_Clone.getFirst();  //needs has a single parameter
	        Parameter_List_Clone.removeFirst();
	        if ( a_parameter.charAt(0) == ':' || a_parameter.charAt(0) == '(' || a_parameter.charAt(0) == ')'){  System.out.println ("Error TaskTemplateFun__Use_Task_DBT_Template " + Parameter_List_Clone.getFirst() + " needs 1 parameter. not " + a_parameter);}
	        if (a_parameter.equals( "t")) sim.vars.taskTemplate.Auto_Compute_Default_Response_Correctness = true ;
	        else if (a_parameter.equals( "nil")) sim.vars.taskTemplate.Auto_Compute_Default_Response_Correctness = false ;
	        else System.err.println ("Error! TaskTemplateFun__Use_Task_DBT_Template :auto_compute_default_response_correctness has a parameter not t or nil but: " +  a_parameter );
	        break;
	      }
	      case ":method" : {
	        Parameter_List_Clone.removeFirst(); // remove the parameter name
	        if ( Parameter_List_Clone.size() < 1 ) {   System.err.println ("Error TaskTemplateFun__Use_Task_DBT_Template " + Parameter_List_Clone.getFirst() + " needs 1 parameter"); }
	        a_parameter = Parameter_List_Clone.getFirst();  //needs has a single parameter
	        Parameter_List_Clone.removeFirst();
	        if ( a_parameter.charAt(0) == ':' || a_parameter.charAt(0) == '(' || a_parameter.charAt(0) == ')'){   System.err.println ("Error TaskTemplateFun__Use_Task_DBT_Template " + Parameter_List_Clone.getFirst() + " needs 1 parameter. not " + a_parameter);}
	        sim.vars.taskTemplate.Method = a_parameter ;
	        break;
	      }
	      
	      /*
		case ":response" : {
		Parameter_List_Clone.removeFirst(); // remove the parameter name
		if ( Parameter_List_Clone.size() < 1 ) { if(sim.vars.printingModule.Popout_Message) System.out.println ("Error TaskTemplateFun__Use_Task_DBT_Template " + Parameter_List_Clone.getFirst() + " needs 1 parameter"); }
		a_parameter = Parameter_List_Clone.getFirst();  //needs a single parameter
		Parameter_List_Clone.removeFirst();
		if ( a_parameter.charAt(0) == ':' || a_parameter.charAt(0) == '(' || a_parameter.charAt(0) == ')'){ if(sim.vars.printingModule.Popout_Message) System.out.println ("Error TaskTemplateFun__Use_Task_DBT_Template " + Parameter_List_Clone.getFirst() + " needs 1 parameter. not " + a_parameter);}
		sim.vars.taskTemplate.Obsolete_Response = a_parameter ;
		break;
		}
	       */
	      
	      case ":reset_vision_module_before_each_trial" : {
	        String parameter_name = Parameter_List_Clone.getFirst();
	        Parameter_List_Clone.removeFirst(); // remove the parameter name
	        if ( Parameter_List_Clone.size() < 1 ) { System.err.println ("Error TaskTemplateFun__Use_Task_DBT_Template " + parameter_name + " needs 1 parameter"); }
	        a_parameter = Parameter_List_Clone.getFirst();  //needs has a single parameter
	        Parameter_List_Clone.removeFirst();
	        if ( a_parameter.charAt(0) == ':' || a_parameter.charAt(0) == '(' || a_parameter.charAt(0) == ')'){  System.err.println ("Error TaskTemplateFun__Use_Task_DBT_Template " + parameter_name + " needs 1 parameter. not " + a_parameter);}
	        if (a_parameter.equals( "t")) sim.vars.taskTemplate.Reset_Vision_Module_Before_Each_Trial = true ;
	        else if (a_parameter.equals( "nil")) sim.vars.taskTemplate.Reset_Vision_Module_Before_Each_Trial = false ;
	        else System.err.println ("Error! TaskTemplateFun__Use_Task_DBT_Template " + parameter_name +"  has a parameter not t or nil but: " +  a_parameter );
	        break;
	      }
	      
	      case ":reset_audio_module_before_each_trial" : {
	        String parameter_name = Parameter_List_Clone.getFirst();
	        Parameter_List_Clone.removeFirst(); // remove the parameter name
	        if ( Parameter_List_Clone.size() < 1 ) { System.err.println ("Error TaskTemplateFun__Use_Task_DBT_Template " + parameter_name + " needs 1 parameter"); }
	        a_parameter = Parameter_List_Clone.getFirst();  //needs has a single parameter
	        Parameter_List_Clone.removeFirst();
	        if ( a_parameter.charAt(0) == ':' || a_parameter.charAt(0) == '(' || a_parameter.charAt(0) == ')'){  System.out.println ("Error TaskTemplateFun__Use_Task_DBT_Template " + parameter_name + " needs 1 parameter. not " + a_parameter);}
	        if (a_parameter.equals( "t")) sim.vars.taskTemplate.Reset_Audio_Module_Before_Each_Trial = true ;
	        else if (a_parameter.equals( "nil")) sim.vars.taskTemplate.Reset_Audio_Module_Before_Each_Trial = false ;
	        else System.err.println ("Error! TaskTemplateFun__Use_Task_DBT_Template " + parameter_name +"  has a parameter not t or nil but: " +  a_parameter );
	        break;
	      }
	      
	      case ":reset_imaginary_module_before_each_trial" : {
	        String parameter_name = Parameter_List_Clone.getFirst();
	        Parameter_List_Clone.removeFirst(); // remove the parameter name
	        if ( Parameter_List_Clone.size() < 1 ) { System.err.println ("Error TaskTemplateFun__Use_Task_DBT_Template " + parameter_name + " needs 1 parameter"); }
	        a_parameter = Parameter_List_Clone.getFirst();  //needs has a single parameter
	        Parameter_List_Clone.removeFirst();
	        if ( a_parameter.charAt(0) == ':' || a_parameter.charAt(0) == '(' || a_parameter.charAt(0) == ')'){  System.err.println ("Error TaskTemplateFun__Use_Task_DBT_Template " + parameter_name + " needs 1 parameter. not " + a_parameter);}
	        if (a_parameter.equals( "t")) sim.vars.taskTemplate.Reset_Imaginary_Module_Before_Each_Trial = true ;
	        else if (a_parameter.equals( "nil")) sim.vars.taskTemplate.Reset_Imaginary_Module_Before_Each_Trial = false ;
	        else System.err.println ("Error! TaskTemplateFun__Use_Task_DBT_Template " + parameter_name +"  has a parameter not t or nil but: " +  a_parameter );
	        break;
	      }
	      
	      case ":reinitialize_goal_1_before_each_trial" : {
	        String parameter_name = Parameter_List_Clone.getFirst();
	        Parameter_List_Clone.removeFirst(); // remove the parameter name
	        if ( Parameter_List_Clone.size() < 1 ) { System.err.println ("Error TaskTemplateFun__Use_Task_DBT_Template " + parameter_name + " needs 1 parameter"); }
	        a_parameter = Parameter_List_Clone.getFirst();  //needs has a single parameter
	        Parameter_List_Clone.removeFirst();
	        if ( a_parameter.charAt(0) == ':' || a_parameter.charAt(0) == '(' || a_parameter.charAt(0) == ')'){  System.out.println ("Error TaskTemplateFun__Use_Task_DBT_Template " + parameter_name + " needs 1 parameter. not " + a_parameter);}
	        if (a_parameter.equals( "t")) sim.vars.taskTemplate.ReInitialize_Goal_1_Before_Each_Trial = true ;
	        else if (a_parameter.equals( "nil")) sim.vars.taskTemplate.ReInitialize_Goal_1_Before_Each_Trial = false ;
	        else System.out.println ("Error! TaskTemplateFun__Use_Task_DBT_Template " + parameter_name +"  has a parameter not t or nil but: " +  a_parameter );
	        break;
	      }
	      
	      case ":reinitialize_intentional_module_before_each_trial" : {
	        String parameter_name = Parameter_List_Clone.getFirst();
	        Parameter_List_Clone.removeFirst(); // remove the parameter name
	        if ( Parameter_List_Clone.size() < 1 ) { System.err.println ("Error TaskTemplateFun__Use_Task_DBT_Template " + parameter_name + " needs 1 parameter"); }
	        a_parameter = Parameter_List_Clone.getFirst();  //needs has a single parameter
	        Parameter_List_Clone.removeFirst();
	        if ( a_parameter.charAt(0) == ':' || a_parameter.charAt(0) == '(' || a_parameter.charAt(0) == ')'){  System.err.println ("Error TaskTemplateFun__Use_Task_DBT_Template " + parameter_name + " needs 1 parameter. not " + a_parameter);}
	        if (a_parameter.equals( "t")) sim.vars.taskTemplate.ReInitialize_Intentional_Module_Before_Each_Trial = true ;
	        else if (a_parameter.equals( "nil")) sim.vars.taskTemplate.ReInitialize_Intentional_Module_Before_Each_Trial = false ;
	        else System.err.println ("Error! TaskTemplateFun__Use_Task_DBT_Template " + parameter_name +"  has a parameter not t or nil but: " +  a_parameter );
	        break;
	      }
	      
	      case ":clear_retrieval_buffer_and_reset_declarative_module_state" : {
	        String parameter_name = Parameter_List_Clone.getFirst();
	        Parameter_List_Clone.removeFirst(); // remove the parameter name
	        if ( Parameter_List_Clone.size() < 1 ) { System.err.println ("Error TaskTemplateFun__Use_Task_DBT_Template " + parameter_name + " needs 1 parameter"); }
	        a_parameter = Parameter_List_Clone.getFirst();  //needs has a single parameter
	        Parameter_List_Clone.removeFirst();
	        if ( a_parameter.charAt(0) == ':' || a_parameter.charAt(0) == '(' || a_parameter.charAt(0) == ')'){  System.out.println ("Error TaskTemplateFun__Use_Task_DBT_Template " + parameter_name + " needs 1 parameter. not " + a_parameter);}
	        if (a_parameter.equals( "t")) sim.vars.taskTemplate.Clear_Retrieval_Buffer_And_Reset_Declarative_Module_State = true ;
	        else if (a_parameter.equals( "nil")) sim.vars.taskTemplate.Clear_Retrieval_Buffer_And_Reset_Declarative_Module_State = false ;
	        else System.err.println ("Error! TaskTemplateFun__Use_Task_DBT_Template " + parameter_name +"  has a parameter not t or nil but: " +  a_parameter );
	        break;
	      }
	      
	      
	      case ":Obsolete_ReInitialize_Goal_Focus_Before_Each_Trial" : {
	        String parameter_name = Parameter_List_Clone.getFirst();
	        Parameter_List_Clone.removeFirst(); // remove the parameter name
	        if ( Parameter_List_Clone.size() < 1 ) { System.err.println ("Error TaskTemplateFun__Use_Task_DBT_Template " + parameter_name + " needs 1 parameter"); }
	        a_parameter = Parameter_List_Clone.getFirst();  //needs has a single parameter
	        Parameter_List_Clone.removeFirst();
	        if ( a_parameter.charAt(0) == ':' || a_parameter.charAt(0) == '(' || a_parameter.charAt(0) == ')'){  System.err.println ("Error TaskTemplateFun__Use_Task_DBT_Template " + parameter_name + " needs 1 parameter. not " + a_parameter);}
	        if (a_parameter.equals( "t")) sim.vars.taskTemplate.Obsolete_ReInitialize_Goal_Focus_Before_Each_Trial = true ;
	        else if (a_parameter.equals( "nil")) sim.vars.taskTemplate.Obsolete_ReInitialize_Goal_Focus_Before_Each_Trial = false ;
	        else System.err.println ("Error! TaskTemplateFun__Use_Task_DBT_Template " + parameter_name +"  has a parameter not t or nil but: " +  a_parameter );
	        break;
	      }
	      
	      case ":reset_all_modules_before_each_trial" : {
	        String parameter_name = Parameter_List_Clone.getFirst();
	        Parameter_List_Clone.removeFirst(); // remove the parameter name
	        if ( Parameter_List_Clone.size() < 1 ) { System.out.println ("Error TaskTemplateFun__Use_Task_DBT_Template " + parameter_name + " needs 1 parameter"); }
	        a_parameter = Parameter_List_Clone.getFirst();  //needs has a single parameter
	        Parameter_List_Clone.removeFirst();
	        if ( a_parameter.charAt(0) == ':' || a_parameter.charAt(0) == '(' || a_parameter.charAt(0) == ')'){  System.out.println ("Error TaskTemplateFun__Use_Task_DBT_Template " + parameter_name + " needs 1 parameter. not " + a_parameter);}
	        if (a_parameter.equals( "t")) sim.vars.taskTemplate.Reset_All_Modules_Before_Each_Trial = true ;
	        else if (a_parameter.equals( "nil")) sim.vars.taskTemplate.Reset_All_Modules_Before_Each_Trial = false ;
	        else System.err.println ("Error! TaskTemplateFun__Use_Task_DBT_Template " + parameter_name +"  has a parameter not t or nil but: " +  a_parameter );
	        break;
	      } 
	      
	      case ":reset_all_modules_before_each_day" : {
	        String parameter_name = Parameter_List_Clone.getFirst();
	        Parameter_List_Clone.removeFirst(); // remove the parameter name
	        if ( Parameter_List_Clone.size() < 1 ) { System.err.println ("Error TaskTemplateFun__Use_Task_DBT_Template " + parameter_name + " needs 1 parameter"); }
	        a_parameter = Parameter_List_Clone.getFirst();  //needs has a single parameter
	        Parameter_List_Clone.removeFirst();
	        if ( a_parameter.charAt(0) == ':' || a_parameter.charAt(0) == '(' || a_parameter.charAt(0) == ')'){  System.err.println ("Error TaskTemplateFun__Use_Task_DBT_Template " + parameter_name + " needs 1 parameter. not " + a_parameter);}
	        if (a_parameter.equals( "t")) sim.vars.taskTemplate.Reset_All_Modules_Before_Each_Day = true ;
	        else if (a_parameter.equals( "nil")) sim.vars.taskTemplate.Reset_All_Modules_Before_Each_Day = false ;
	        else System.err.println ("Error! TaskTemplateFun__Use_Task_DBT_Template " + parameter_name +"  has a parameter not t or nil but: " +  a_parameter );
	        break;
	      } 
	      case ":response_terminates_display" : {
	        Parameter_List_Clone.removeFirst(); // remove the parameter name
	        if ( Parameter_List_Clone.size() < 1 ) { System.out.println ("Error TaskTemplateFun__Use_Task_DBT_Template " + Parameter_List_Clone.getFirst() + " needs 1 parameter"); }
	        a_parameter = Parameter_List_Clone.getFirst();  //needs has a single parameter
	        Parameter_List_Clone.removeFirst();
	        if ( a_parameter.charAt(0) == ':' || a_parameter.charAt(0) == '(' || a_parameter.charAt(0) == ')'){  System.err.println ("Error TaskTemplateFun__Use_Task_DBT_Template " + Parameter_List_Clone.getFirst() + " needs 1 parameter. not " + a_parameter);}
	        if (a_parameter.equals( "t")) sim.vars.taskTemplate.Response_Terminates_Display = true ;
	        else if (a_parameter.equals( "nil")) sim.vars.taskTemplate.Response_Terminates_Display = false ;
	        else System.out.println ("Error! TaskTemplateFun__Use_Task_DBT_Template :response_terminates_display has a parameter not t or nil but: " +  a_parameter );
	        break;
	      }
	      
	      case ":response_terminates_feedback" : {
	        Parameter_List_Clone.removeFirst(); // remove the parameter name
	        if ( Parameter_List_Clone.size() < 1 ) { System.err.println ("Error TaskTemplateFun__Use_Task_DBT_Template " + Parameter_List_Clone.getFirst() + " needs 1 parameter"); }
	        a_parameter = Parameter_List_Clone.getFirst();  //needs has a single parameter
	        Parameter_List_Clone.removeFirst();
	        if ( a_parameter.charAt(0) == ':' || a_parameter.charAt(0) == '(' || a_parameter.charAt(0) == ')'){  System.err.println ("Error TaskTemplateFun__Use_Task_DBT_Template " + Parameter_List_Clone.getFirst() + " needs 1 parameter. not " + a_parameter);}
	        if (a_parameter.equals( "t")) sim.vars.taskTemplate.Response_Terminates_Feedback = true ;
	        else if (a_parameter.equals( "nil")) sim.vars.taskTemplate.Response_Terminates_Feedback = false ;
	        else System.err.println ("Error! TaskTemplateFun__Use_Task_DBT_Template :response_terminates_display has a parameter not t or nil but: " +  a_parameter );
	        break;
	      }
	      
	      default:
	      {
	        if(sim.vars.printingModule.Popout_Message) System.out.println ("WARNING! TaskTemplateFun__Use_Task_DBT_Template. the Key is undefined: " + Parameter_List_Clone.getFirst());
	        Parameter_List_Clone.removeFirst();
	        break;
	      }
	    }
	    
	  }
	}
	
	public  void TaskTemplateFun__Use_World3D_Template (LinkedList<String> Parameter_List){
	  LinkedList<String> Parameter_List_Clone = ProgramUtilitiesFun__LinkedListString_Clone ( Parameter_List );
	  String a_parameter;
	  while ( Parameter_List_Clone.size() > 0 ) {
	    
	    switch (Parameter_List_Clone.getFirst().toLowerCase()) {
	      case ":method" : {
	        Parameter_List_Clone.removeFirst(); // remove the parameter name
	        if ( Parameter_List_Clone.size() < 1 ) {   System.err.println ("Error! TaskTemplateFun__Use_World3D_Template " + Parameter_List_Clone.getFirst() + " needs 1 parameter"); }
	        a_parameter = Parameter_List_Clone.getFirst();  //needs has a single parameter
	        Parameter_List_Clone.removeFirst();
	        if ( a_parameter.charAt(0) == ':' || a_parameter.charAt(0) == '(' || a_parameter.charAt(0) == ')'){   System.err.println ("Error! TaskTemplateFun__Use_World3D_Template " + Parameter_List_Clone.getFirst() + " needs 1 parameter. not " + a_parameter);}
	        sim.vars.world3DTemplate.Method = a_parameter ;
	        
	        switch ( sim.vars.world3DTemplate.Method ){
	          case "driving":{
	            World3D_Template_Driving_Method a_method = new World3D_Template_Driving_Method(sim);
	            sim.vars.world3DTemplate.Method_Object = a_method;
	            break;	
	          }
	          default:
	          {
	            System.err.println ("Error! TaskTemplateFun__Use_sim.vars.world3DTemplate. the sim.vars.world3DTemplate.Method is undefined: " + sim.vars.world3DTemplate.Method);
	            break;
	          }
	          
	        }
	        
	        break;
	      }
	      
	      case ":refresh_cycle" : {
	        Parameter_List_Clone.removeFirst(); // remove the parameter name
	        if ( Parameter_List_Clone.size() < 1 ) {   System.err.println ("Error! TaskTemplateFun__Use_World3D_Template " + Parameter_List_Clone.getFirst() + " needs 1 parameter"); }
	        a_parameter = Parameter_List_Clone.getFirst();  //needs has a single parameter
	        Parameter_List_Clone.removeFirst();
	        if ( a_parameter.charAt(0) == ':' || a_parameter.charAt(0) == '(' || a_parameter.charAt(0) == ')'){   System.out.println ("Error! TaskTemplateFun__Use_World3D_Template " + Parameter_List_Clone.getFirst() + " needs 1 parameter. not " + a_parameter);}
	        
	        if( !ProgramUtilitiesFun__Is_String_Double( a_parameter ) ) System.err.println("Error! TaskTemplateFun__Use_World3D_Template " + Parameter_List_Clone.getFirst() + " to be a double rather than: " + a_parameter   );
	        sim.vars.world3DTemplate.World.Refresh_Cycle =  (double) Double.parseDouble (a_parameter );
	        if(sim.vars.world3DTemplate.World.Refresh_Cycle <= 0.0)System.err.println("Error! TaskTemplateFun__Use_World3D_Template " + Parameter_List_Clone.getFirst() + " must be positive rather than: " + a_parameter   );
	        
	        break;
	      }
	      
	      default:
	      {
	        if(sim.vars.printingModule.Popout_Message) System.out.println ("WARNING! TaskTemplateFun__Use_sim.vars.world3DTemplate. the Key is undefined: " + Parameter_List_Clone.getFirst());
	        Parameter_List_Clone.removeFirst();
	        break;
	      }
	    }
	    
	  }
	}
	
	public  void TaskTemplateFun__World3D_Reset_DriverCar_To_Start_Position (World3D_DriverCar driver_car){
	  World3D_Road the_start_road = (World3D_Road)sim.vars.world3DTemplate.World.Objects.get(driver_car.Start_Road_World3D_ID);
	  
	  Three_Tuple global_parameters = ProgramUtilitiesFun__World3D_Local_Loc_And_Angle_To_Global(driver_car.Start_Road_World3D_ID, driver_car.Start_Distance, driver_car.Start_Lane_Num * the_start_road.Lane_Width, 0.0   ); //start on the center of a lane, and with heading angle same as the road.
	  
	  //initializae vehicle basic
	  driver_car.Vehicle_Basic.On_Road_World3D_ID = driver_car.Start_Road_World3D_ID;
	  driver_car.Vehicle_Basic.Angle_Between_Road_Direction = (double) 0.0;
	  driver_car.Vehicle_Basic.Distance_From_Start = driver_car.Start_Distance;
	  driver_car.Vehicle_Basic.Distance_Lateral_To_Center_Lane_Center = (double) (driver_car.Start_Lane_Num * the_start_road.Lane_Width);
	  driver_car.Vehicle_Basic.Lane_Num = driver_car.Start_Lane_Num;
	  
	  driver_car.Vehicle_Basic.Loc_X = (double)global_parameters.Ob1;
	  driver_car.Vehicle_Basic.Loc_Y = (double) 0.0; //current does not support altitude
	  driver_car.Vehicle_Basic.Loc_Z = (double)global_parameters.Ob2;
	  driver_car.Vehicle_Basic.Pitch = (double) 0.0;
	  driver_car.Vehicle_Basic.Roll = (double) 0.0;
	  driver_car.Vehicle_Basic.Yaw = (double)global_parameters.Ob3;
	}
	
	public  void TaskTemplateFun__World3D_Reset_OtherCar_To_Start_Position (World3D_OtherCar other_car){
	  World3D_Road the_start_road = (World3D_Road) sim.vars.world3DTemplate.World.Objects.get(other_car.Start_Road_World3D_ID);
	  
	  other_car.Vehicle_Basic.On_Road_World3D_ID = other_car.Start_Road_World3D_ID;
	  Three_Tuple global_parameters = ProgramUtilitiesFun__World3D_Local_Loc_And_Angle_To_Global(other_car.Start_Road_World3D_ID, other_car.Start_Distance, other_car.Start_Lane_Num * the_start_road.Lane_Width, 0.0   ); //start on the center of a lane, and with heading angle same as the road.
	  
	  //initializae vehicle basic
	  other_car.Vehicle_Basic.Angle_Between_Road_Direction = (double) 0.0;
	  other_car.Vehicle_Basic.Distance_From_Start = other_car.Start_Distance;
	  other_car.Vehicle_Basic.Distance_Lateral_To_Center_Lane_Center = (double) (other_car.Start_Lane_Num * the_start_road.Lane_Width);
	  other_car.Vehicle_Basic.Lane_Num = other_car.Start_Lane_Num;
	  other_car.Vehicle_Basic.Loc_X = (double)global_parameters.Ob1;
	  other_car.Vehicle_Basic.Loc_Y = 0.0; //current does not support altitude
	  other_car.Vehicle_Basic.Loc_Z = (double)global_parameters.Ob2;
	  other_car.Vehicle_Basic.Pitch = (double) 0.0;
	  other_car.Vehicle_Basic.Roll = (double) 0.0;
	  other_car.Vehicle_Basic.Yaw = (double)global_parameters.Ob3;
	}
	
	public  String TaskTemplateFun__World3D_Tracking_Control_Get_Manual_Joystick_Duration (String the_dimension, String the_percept){
	  //the_percept must be a number
	  
	  if( ProgramUtilitiesFun__Is_String_Double ( the_percept ) == false ) {
	    System.err.println("Error! sim.funs.TaskTemplateFun__World3D_Tracking_Control_Get_Manual_Joystick_Value the_percept must be a number, not: " + the_percept );
	    
	    return null;
	  }
	  double the_percept_double = Double.parseDouble (the_percept);
	  double return_double;
	  
	  //currently simple version, no matter which dimension and what percept
	  return_double = 0.050; //second
	  
	  return Double.toString(return_double);
	  
	}
	
	public  String TaskTemplateFun__World3D_Tracking_Control_Get_Manual_Joystick_Value (String the_dimension, String the_percept){
	  //the_percept must be a number
	  if( ProgramUtilitiesFun__Is_String_Double ( the_percept ) == false ) {
	    System.err.println("Error! sim.funs.TaskTemplateFun__World3D_Tracking_Control_Get_Manual_Joystick_Value the_percept must be a number, not: " + the_percept );
	    
	    return null;
	  }
	  double the_percept_double = Double.parseDouble (the_percept);
	  double return_double;
	  
	  
	  //currently simple version, no matter which dimension
	  //alternative 1, based on the sign of the percept
	  if(the_percept_double > 0) return_double = 1.0;
	  else if (the_percept_double < 0 ) return_double = -1.0;
	  else return_double = 0.0;
	  
	  /*
		//slternative 2, based on time to collision
		double TTC = Double.parseDouble ( sim.funs.TaskTemplateFun__World3D_Tracking_Control_Get_Time_To_Collision(the_dimension) );
		double TTC_threshold = 20.0;  //second
		if(TTC > TTC_threshold) return_double = 1.0;
		else if (TTC < -TTC_threshold ) return_double = -1.0;
		else return_double = 0.0;
	   */
	  
	  return Double.toString(return_double);
	  
	}
	
	public  String TaskTemplateFun__World3D_Tracking_Control_Get_Percept (String the_dimension){
	  
	  String return_string = "";
	  World3D_DriverCar the_driver_car = sim.funs.TaskTemplateFun__Get_World3D_DriverCar_Object();
	  
	  // parameters
	  double X_a = 1.0;
	  double X_b = 1.0;
	  double Y_a = 1.0;
	  double Y_b = 1.0;
	  double Z_a = 1.0;
	  double Z_b = 1.0;
	  double Pitch_a = 1.0;
	  double Pitch_b = 1.0;
	  double Yaw_a = 1.0;
	  double Yaw_b = 1.0;
	  double Roll_a = 1.0;
	  double Roll_b = 1.0;
	  
	  switch (the_dimension){
	    case "x":{
	      //alternative 1, 
	      double delta_X_in_cm =  (double)sim.vars.spaceDrivingVar__Target_Initiatial_Location_And_Rotation.Ob1 -  the_driver_car.Vehicle_Basic.Loc_X  ;
	      double delta_Speed_X_in_cm_s =  the_driver_car.Vehicle_Basic.Speed_X;
	      double percept = X_a * delta_X_in_cm -  X_b * delta_Speed_X_in_cm_s;
	      return return_string = Double.toString(percept);
	      
	      //alternative 2,
	      //return		TaskTemplateFun__World3D_Tracking_Control_Get_Time_To_Collision (the_dimension);
	      
	    }
	    
	    case "y":{
	      
	      double delta_Y_in_cm =  (double)sim.vars.spaceDrivingVar__Target_Initiatial_Location_And_Rotation.Ob2 -  the_driver_car.Vehicle_Basic.Loc_Y  ;
	      double delta_Speed_Y_in_cm_s =  the_driver_car.Vehicle_Basic.Speed_Y;
	      double percept = Y_a * delta_Y_in_cm -  Y_b * delta_Speed_Y_in_cm_s;
	      return return_string = Double.toString(percept);
	      
	    }
	    
	    
	    case "z":{
	      
	      double delta_Z_in_cm =  (double)sim.vars.spaceDrivingVar__Target_Initiatial_Location_And_Rotation.Ob3 -  the_driver_car.Vehicle_Basic.Loc_Z  ;
	      double delta_Speed_Z_in_cm_s =  the_driver_car.Vehicle_Basic.Speed_Z;
	      double percept = Z_a * delta_Z_in_cm -  Z_b * delta_Speed_Z_in_cm_s;
	      return return_string = Double.toString(percept);
	      
	    }
	    
	    
	    case "pitch":{
	      
	      double delta_Pitch_in_degree =  (double)sim.vars.spaceDrivingVar__Target_Initiatial_Location_And_Rotation.Ob4 -  the_driver_car.Vehicle_Basic.Pitch  ;
	      double delta_Speed_Pitch_in_degree_s =  the_driver_car.Vehicle_Basic.Speed_Pitch;
	      double percept = Pitch_a * delta_Pitch_in_degree -  Pitch_b * delta_Speed_Pitch_in_degree_s;
	      return return_string = Double.toString(percept);
	      
	    }
	    
	    
	    case "yaw":{
	      
	      double delta_Yaw_in_degree =  (double)sim.vars.spaceDrivingVar__Target_Initiatial_Location_And_Rotation.Ob5 -  the_driver_car.Vehicle_Basic.Yaw  ;
	      double delta_Speed_Yaw_in_degree_s =  the_driver_car.Vehicle_Basic.Speed_Yaw;
	      double percept = Yaw_a * delta_Yaw_in_degree -  Yaw_b * delta_Speed_Yaw_in_degree_s;
	      return return_string = Double.toString(percept);
	      
	    }
	    
	    
	    case "roll":{
	      
	      double delta_Roll_in_degree =  (double)sim.vars.spaceDrivingVar__Target_Initiatial_Location_And_Rotation.Ob6 -  the_driver_car.Vehicle_Basic.Roll  ;
	      double delta_Speed_Roll_in_degree_s =  the_driver_car.Vehicle_Basic.Speed_Roll;
	      double percept = Roll_a * delta_Roll_in_degree -  Roll_b * delta_Speed_Roll_in_degree_s;
	      return return_string =Double.toString(percept);
	      
	    }
	    
	    default:
	    {
	      System.err.println("Error! sim.funs.TaskTemplateFun__World3D_Tracking_Control_Get_Percept has undefined the_dimension: " + the_dimension);
	      SimSystem.abort();
	      return return_string;
	      
	    }
	    
	    
	  }
	}
	
	public  String TaskTemplateFun__World3D_Tracking_Control_Get_Time_To_Collision (String the_dimension){
	  
	  String return_string = "";
	  World3D_DriverCar the_driver_car = sim.funs.TaskTemplateFun__Get_World3D_DriverCar_Object();
	  double TTC;
	  
	  switch (the_dimension){
	    case "x":{
	      double delta_X_in_cm =  (double)sim.vars.spaceDrivingVar__Target_Initiatial_Location_And_Rotation.Ob1 -  the_driver_car.Vehicle_Basic.Loc_X  ;
	      double delta_Speed_X_in_cm_s =  the_driver_car.Vehicle_Basic.Speed_X;
	      
	      
	      if (delta_Speed_X_in_cm_s == 0.0) {
	        if(delta_X_in_cm > 0) TTC = 99999999.0;  // infinite max, set a very large value
	        else if(delta_X_in_cm < 0) TTC = -99999999.0;  // infinite max, set a very large value
	        else TTC = 0;
	      }
	      else TTC = delta_X_in_cm / delta_Speed_X_in_cm_s;
	      
	      return return_string = Double.toString(TTC);
	    }
	    
	    default:
	    {
	      System.err.println("Error! sim.funs.TaskTemplateFun__World3D_Tracking_Control_Get_Time_To_Collision has undefined the_dimension: " + the_dimension);
	      SimSystem.abort();
	      return return_string;
	     
	    }
	    
	    
	  }
	}	
	
	//UtilityModuleFun
	
	
//UtilityModuleFun
	
	public  void   UtilityModuleFun__Add_Selected_Rule_Since_Last_Reward (String the_rule_name){

	  if (sim.vars.utilityModule.utility_Computation_Method.equals( "temporal-difference-reinforcement")){
	    sim.vars.productionModule.Since_Last_Reward_Selected_Rule_Name.addLast(the_rule_name);
	    sim.vars.productionModule.Since_Last_Reward_Selected_Rule_Time.addLast(GlobalUtilities.round(SimSystem.clock(),3));
	  }
	  else if (sim.vars.utilityModule.utility_Computation_Method.equals( "PG-C")){
	    sim.vars.productionModule.PG_C_Since_Last_Flag_Selected_Rule_Name.addLast(the_rule_name);
	    sim.vars.productionModule.PG_C_Since_Last_Flag_Selected_Rule_Time.addLast(GlobalUtilities.round(SimSystem.clock(),3));
	  }
	  else System.out.println("UtilityModuleFun__Add_Selected_Rule_Since_Last_Reward has undefined sim.vars.utilityModule.utility_Computation_Method case: " + sim.vars.utilityModule.utility_Computation_Method);
	}
	
	public  void   UtilityModuleFun__Initialize_Utility_For_Compiled_Production (String the_new_rule_name, String the_p1_name, String the_p2_name){
	  if (sim.vars.utilityModule.utility_Computation_Method.equals( "temporal-difference-reinforcement")){
	    
	    //currently do not have :at other than 0.05 s
	    String r1 = (String)sim.vars.utilityModule.reward.get(the_p1_name);
	    String r2 = (String)sim.vars.utilityModule.reward.get(the_p2_name);
	    String reward = "";
	    if (!r1.equals( "" ) && r2.equals( "" ) ){
	      reward = r1;
	    }
	    else if (r1.equals( "") && !r2.equals( "" )){
	      reward = r2;
	    }
	    else if (!r1.equals( "" ) && !r2.equals( "") ){
	      double dr1 = Double.parseDouble(r1);
	      double dr2 = Double.parseDouble(r2);
	      if (dr1 > dr2)	reward = Double.toString(dr1);
	      else reward = Double.toString(dr2);
	    }
	    
	    //System.out.println(the_new_rule_name + " : " + r1 + " : " + r2 + " : " +  reward + " : " + the_p1_name);
	    
	    //manually change utility for the new rule from iu to nu.
	    ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.utility, the_new_rule_name, Double.toString(sim.vars.utilityModule.nu));
	    ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.U_N_Without_Noise, the_new_rule_name, Double.toString(sim.vars.utilityModule.nu));
	    ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.reward, the_new_rule_name, reward);
	  }
	  else if (sim.vars.utilityModule.utility_Computation_Method.equals( "PG-C")){
	    //translated from defun initialize-utility-for-compiled-production in utility-and-reward.lisp (old-utility)
	    //System.out.println ("UtilityModuleFun__Initialize_Utility_For_Compiled_Production NEEDS TO to work on when sim.vars.utilityModule.utility_Computation_Method == PG-C");
	    double p =  Double.parseDouble ((String)sim.vars.utilityModule.PG_C_p.get(the_p1_name));
	    double c =  Double.parseDouble ((String)sim.vars.utilityModule.PG_C_c.get(the_p1_name));
	    double effort1 =  Double.parseDouble ((String)sim.vars.utilityModule.PG_C_effort_rule_firing_time.get(the_p1_name));
	    double effort2 = Double.parseDouble ((String)sim.vars.utilityModule.PG_C_effort_rule_firing_time.get(the_p2_name));
	    double effort = Math.max(effort1, effort2 );
	    boolean s1 = sim.vars.utilityModule.PG_C_success_flags.containsKey(the_p1_name);
	    boolean s2 = sim.vars.utilityModule.PG_C_success_flags.containsKey(the_p2_name);
	    boolean f1 = sim.vars.utilityModule.PG_C_failure_flags.containsKey(the_p1_name);
	    boolean f2 = sim.vars.utilityModule.PG_C_failure_flags.containsKey(the_p2_name);
	    boolean s = s1 || s2;
	    boolean f = f1 || f2;
	    if (  ProgramUtilitiesFun__Is_String_Double(sim.vars.utilityModule.PG_C_pl ) ){
	      System.out.println("UtilityModuleFun__Initialize_Utility_For_Compiled_Production Compilation does not work with decaying utilities (sim.vars.utilityModule.PG_C_pl is a number). ");
	    }
	    else if (sim.vars.utilityModule.PG_C_pl.equals( "nil")){
	      ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.PG_C_p, the_new_rule_name, Double.toString(p) );
	      ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.PG_C_c, the_new_rule_name, Double.toString(c) );
	      ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.PG_C_effort_rule_firing_time, the_new_rule_name, Double.toString(effort) );
	    }
	    else{ // when pl = t
	      UtilityModuleFun__PG_C_Update_Priors_For_Production ( the_new_rule_name, (double) p, (double) c  );
	      
	      if(s)ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.PG_C_success_flags, the_new_rule_name, null );
	      if(f)ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.PG_C_failure_flags, the_new_rule_name, null );
	      ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.PG_C_effort_rule_firing_time, the_new_rule_name, Double.toString(effort));
	      
	      ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.PG_C_successes_num_for_each_rule, the_new_rule_name, Double.toString(sim.vars.utilityModule.PG_C_initial_successes_num) );
	      ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.PG_C_failures_num_for_each_rule, the_new_rule_name, Double.toString(sim.vars.utilityModule.PG_C_initial_failures_num) );
	      ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.PG_C_efforts_for_cost_calculation, the_new_rule_name, Double.toString(sim.vars.utilityModule.PG_C_initial_efforts_for_cost_calculation) );
	      
	      //(compute-utility new-p)
	      double pp = UtilityModuleFun__PG_C_Compute_P (the_new_rule_name) ;
	      //System.out.println("Initialize_Utility_For_Compiled_Production " + pp);
	      ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.PG_C_p, the_new_rule_name, Double.toString(pp) );
	      double g = sim.vars.utilityModule.PG_C_g ;
	      double cc = UtilityModuleFun__PG_C_Compute_C (the_new_rule_name) ; 
	      ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.PG_C_c, the_new_rule_name, Double.toString(cc) );
	      double utility_without_noise = pp * g - cc;
	      ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.pg_c, the_new_rule_name, Double.toString(utility_without_noise) );
	      double noise;
	      if (sim.vars.utilityModule.egs == 0.0) noise = 0.0;
	      else noise = ProgramUtilitiesFun__Act_R_Noise(sim.vars.utilityModule.egs); // when egs = 0, noise = 0
	      ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.utility, the_new_rule_name, Double.toString(utility_without_noise + noise)   );	
	      //end (compute-utility new-p)
	    }
	    
	  }
	  else System.err.println("Initialize_Utility_For_Compiled_Production has undefined sim.vars.utilityModule.utility_Computation_Method case: " + sim.vars.utilityModule.utility_Computation_Method);
	}
	
	public  double UtilityModuleFun__PG_C_Compute_C (String the_rule_name){
	  
	  if (sim.vars.utilityModule.PG_C_pl.equals( "nil")) return  Double.parseDouble ((String)sim.vars.utilityModule.PG_C_c.get(the_rule_name));
	  //else (compute-costs u production)
	  Production_Rule temp_rule = ProductionModuleFun__Find_Production_Rule_Pointer_By_Rule_Name(the_rule_name);
	  String compilation_note = temp_rule.Compilation_Note_For_New_Rule;
	  if (!compilation_note.equals( "" ) && sim.vars.utilityModule.PG_C_pl.equals( "t")){ // compute for a compiled production, only works for :pl t
	    double m = Double.parseDouble ((String)sim.vars.utilityModule.PG_C_successes_num_for_each_rule.get(the_rule_name)) + Double.parseDouble ((String)sim.vars.utilityModule.PG_C_failures_num_for_each_rule.get(the_rule_name)) ;
	    double ie = sim.vars.utilityModule.PG_C_ie; // (utility-ie u)
	    double prior_c =  Double.parseDouble ( (String) sim.vars.utilityModule.PG_C_prior_c.get(the_rule_name) );  //(production-priorc production)
	    double if_1, if_2;
	    if (m == 0.0) { //if_1 = (if (zerop m) 0 (* m (compute-costs-regular u production)))
	      if_1 = 0;
	    }
	    else if_1 = m * UtilityModuleFun__PG_C_Compute_Costs_Regular(the_rule_name);
	    if ( (ie + m) == 0.0 ){//if_2 = (if (zerop (+ ie m))         1       (+ ie m))
	      if_2 = 1;
	    }
	    else if_2 = ie + m ;
	    double return_value = ((ie * prior_c )  +  if_1   )   /  if_2 ;
	    return return_value;
	  }
	  else { //for a user defined rule (not compiled)
	    double return_value =  UtilityModuleFun__PG_C_Compute_Costs_Regular(the_rule_name);
	    return return_value;
	  }
	}
	
	public  double UtilityModuleFun__PG_C_Compute_Costs_Regular (String the_rule_name){
	  double s = 0.0;
	  double f = 0.0;
	  double e = 0.0;
	  if(sim.funs.ProgramUtilitiesFun__Is_String_Double(sim.vars.utilityModule.PG_C_pl)){
	    System.out.println("UtilityModuleFun__PG_C_Compute_Costs_Regular ToDo: sim.vars.utilityModule.PG_C_pl is a number");
	    return 0.0;
	    /*
		(let ((minus-d (- (utility-pl u)))
		                 (successes (production-success-list production))
		                 (failures (production-failure-list production))
		                 (efforts (production-efforts-list production))
		                 (decay 0.0))
		             (loop
		               (when (or (and (null successes) (null failures))
		                         (null efforts))
		                 (return))
		               (setf decay
		                 (if (and successes
		                          (or (null failures)
		                              (> (first successes) 
		                                 (first failures))))
		                     (pop successes) 
		                   (pop failures)))
		               (setf decay (expt-coerced (max (utility-dat u)
		                                              (- (mp-time) decay))
		                                         minus-d))
		               (incf s decay)
		               (incf e (* (pop efforts) decay))))
	     */
	  }
	  else{
	    s = Double.parseDouble ((String)sim.vars.utilityModule.PG_C_successes_num_for_each_rule.get(the_rule_name));
	    f = Double.parseDouble ((String)sim.vars.utilityModule.PG_C_failures_num_for_each_rule.get(the_rule_name));
	    e = Double.parseDouble ((String)sim.vars.utilityModule.PG_C_efforts_for_cost_calculation.get(the_rule_name));
	    return e / ( s + f ) ;
	  }
	}
	
	public  double UtilityModuleFun__PG_C_Compute_P (String the_rule_name){
	  if (sim.vars.utilityModule.PG_C_pl.equals( "nil")) return Double.parseDouble ((String)sim.vars.utilityModule.PG_C_p.get(the_rule_name));
	  //else do compute-probabilities
	  
	  Production_Rule temp_rule = ProductionModuleFun__Find_Production_Rule_Pointer_By_Rule_Name(the_rule_name);
	  String compilation_note = temp_rule.Compilation_Note_For_New_Rule;
	  //System.out.println("PG_C_Compute_P " + temp_rule.Rule_Name + " " + compilation_note );
	  if (!compilation_note.equals( "" ) && sim.vars.utilityModule.PG_C_pl.equals( "t")){ // compute for a compiled production, only works for :pl t
	    double m = Double.parseDouble ((String)sim.vars.utilityModule.PG_C_successes_num_for_each_rule.get(the_rule_name)) + Double.parseDouble ((String)sim.vars.utilityModule.PG_C_failures_num_for_each_rule.get(the_rule_name)) ;
	    double ie = sim.vars.utilityModule.PG_C_ie; // (utility-ie u)
	    double prior_p = Double.parseDouble ( (String) sim.vars.utilityModule.PG_C_prior_p.get(the_rule_name) );  //(production-priorp production)
	    double if_1, if_2;
	    if (m == 0.0) { //if_1 = (if (zerop m) 0 (* m (compute-probabilities-regular u production)))
	      if_1 = 0;
	    }
	    else if_1 = m * UtilityModuleFun__PG_C_Compute_Probabilities_Regular(the_rule_name);
	    if ( (ie + m) == 0.0 ){//if_2 = (if (zerop (+ ie m))         1       (+ ie m))
	      if_2 = 1;
	    }
	    else if_2 = ie + m ;
	    double return_value = ((ie * prior_p )  +  if_1   )   /  if_2 ;
	    return return_value;
	  }
	  else { //for a user defined rule (not compiled)
	    double return_value =  UtilityModuleFun__PG_C_Compute_Probabilities_Regular(the_rule_name);
	    return return_value;
	  }
	  
	  
	}
	
	public  double UtilityModuleFun__PG_C_Compute_Probabilities_Regular (String the_rule_name){
	  double successes = 0.0;
	  double failures = 0.0;
	  if(sim.funs.ProgramUtilitiesFun__Is_String_Double(sim.vars.utilityModule.PG_C_pl)){
	    System.out.println("UtilityModuleFun__PG_C_Compute_Probabilities_Regular ToDo: sim.vars.utilityModule.PG_C_pl is a number");
	    return 0.0;
	    /*
			(let ((minus-d (- (utility-pl u))))
		             (dolist (success (production-success-list production))
		               (incf successes (expt-coerced (max (utility-dat u) (- (mp-time) success))
		                                             minus-d)))
		             (dolist (failure (production-failure-list production))
		               (incf failures (expt-coerced (max (utility-dat u) (- (mp-time) failure))
		                                            minus-d))))
	     */
	    
	  }
	  else{
	    successes = Double.parseDouble ((String)sim.vars.utilityModule.PG_C_successes_num_for_each_rule.get(the_rule_name));
	    failures = Double.parseDouble ((String)sim.vars.utilityModule.PG_C_failures_num_for_each_rule.get (the_rule_name));
	    return successes / ( successes + failures ) ;
	  }
	  
	}
		
	public  double UtilityModuleFun__PG_C_Update_Prior_Parameter (double the_prior, double old){
	  return the_prior + ( sim.vars.utilityModule.alpha * (old - the_prior) );
	}
	
		
	public  void UtilityModuleFun__PG_C_Update_Priors_For_Production (String the_rule_name, double Obsolete_p, double Obsolete_c){
	  
	  double new_p = UtilityModuleFun__PG_C_Update_Prior_Parameter( Float.parseFloat( (String)sim.vars.utilityModule.PG_C_prior_p.get(the_rule_name)), Obsolete_p  );
	  double new_c = UtilityModuleFun__PG_C_Update_Prior_Parameter( Float.parseFloat( (String)sim.vars.utilityModule.PG_C_prior_c.get(the_rule_name)), Obsolete_c  );
	  
	  ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.PG_C_prior_p, the_rule_name, Double.toString(new_p) );
	  ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.PG_C_prior_c, the_rule_name, Double.toString(new_c) );
	  
	  if ( sim.vars.productionCompilationModule.pct ) {
	    ProgramUtilitiesFun__Output_Trace_Txt("  Current values of priorP: " + new_p + "  priorC:" + new_c ) ;
	  }
	}
	
		
	public  void UtilityModuleFun__Print_Utility_For_A_Rule (String rule_name){
	  //common codes for all methods
	  ProgramUtilitiesFun__Output_Trace_Txt ("Parameters for production: " + rule_name);
	  Production_Rule rule_pointer = ProductionModuleFun__Find_Production_Rule_Pointer_By_Rule_Name(rule_name);
	  if (sim.vars.centralParametersModule.Use_Procedural_Resources) {
	    ProgramUtilitiesFun__Output_Trace_Txt (" .Num_Low_Level_Requests    " + Integer.toString(rule_pointer.Num_Low_Level_Requests) );
	    ProgramUtilitiesFun__Output_Trace_Txt (" .Num_High_Level_Requests    " + Integer.toString(rule_pointer.Num_High_Level_Requests) );
	  }
	  if (sim.vars.utilityModule.utility_Computation_Method.equals( "temporal-difference-reinforcement")){
	    ProgramUtilitiesFun__Output_Trace_Txt (" :UTILITY    " + (String)sim.vars.utilityModule.utility.get( rule_name) );
	    ProgramUtilitiesFun__Output_Trace_Txt (" :U          " + (String)sim.vars.utilityModule.U_N_Without_Noise.get( rule_name));
	    ProgramUtilitiesFun__Output_Trace_Txt (" :REWARD     " +  (String)sim.vars.utilityModule.reward.get(rule_name));
	  }
	  else if (sim.vars.utilityModule.utility_Computation_Method.equals( "PG-C")){
	    //System.out.println ("UtilityModuleFun__Print_Utility_For_A_Rule NEEDS TO to work on when sim.vars.utilityModule.utility_Computation_Method == PG-C");
	    ProgramUtilitiesFun__Output_Trace_Txt (" :UTILITY    " + (String)sim.vars.utilityModule.utility.get(rule_name) );
	    String temp_rule_name = rule_name;
	    ProgramUtilitiesFun__Output_Trace_Txt (" :Effort    " +   sim.vars.utilityModule.PG_C_effort_rule_firing_time.get(temp_rule_name) );
	    ProgramUtilitiesFun__Output_Trace_Txt (" :P    " +   sim.vars.utilityModule.PG_C_p.get(temp_rule_name) );
	    ProgramUtilitiesFun__Output_Trace_Txt (" :C    " +   sim.vars.utilityModule.PG_C_c.get(temp_rule_name) );
	    ProgramUtilitiesFun__Output_Trace_Txt (" :PG-C    " +   sim.vars.utilityModule.pg_c.get(temp_rule_name) );
	    ProgramUtilitiesFun__Output_Trace_Txt (" :Successes    " +   sim.vars.utilityModule.PG_C_successes_num_for_each_rule.get(temp_rule_name) );
	    ProgramUtilitiesFun__Output_Trace_Txt (" :Failures    " +   sim.vars.utilityModule.PG_C_failures_num_for_each_rule.get(temp_rule_name) );
	    ProgramUtilitiesFun__Output_Trace_Txt (" :Efforts    " +   sim.vars.utilityModule.PG_C_efforts_for_cost_calculation.get(temp_rule_name) );
	    ProgramUtilitiesFun__Output_Trace_Txt (" :Success    " +   sim.vars.utilityModule.PG_C_success_flags.containsKey(temp_rule_name) );
	    ProgramUtilitiesFun__Output_Trace_Txt (" :Failure    " +   sim.vars.utilityModule.PG_C_failure_flags.containsKey(temp_rule_name) );
	    
	  }
	  else System.out.println("UtilityModuleFun__Print_Utility_For_A_Rule has undefined sim.vars.utilityModule.utility_Computation_Method case: " + sim.vars.utilityModule.utility_Computation_Method);
	  
	}
	
	public  void UtilityModuleFun__Update_Utility_For_Compiled_Production(String recreating_rule_name, String the_p1_name, String the_p2_name){
	  
	  if (sim.vars.utilityModule.utility_Computation_Method.equals( "temporal-difference-reinforcement")){
	    double u_n_minus_1 = Double.parseDouble ((String) sim.vars.utilityModule.U_N_Without_Noise.get( recreating_rule_name));
	    double r_n = Double.parseDouble ((String) sim.vars.utilityModule.U_N_Without_Noise.get(  the_p1_name ));
	    double u_n = u_n_minus_1 + sim.vars.utilityModule.alpha * (r_n - u_n_minus_1);
	    ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value (sim.vars.utilityModule.U_N_Without_Noise, recreating_rule_name, Double.toString(u_n));
	  }
	  else if (sim.vars.utilityModule.utility_Computation_Method.equals( "PG-C")){
	    double p =  Double.parseDouble ((String)sim.vars.utilityModule.PG_C_p.get(the_p1_name));
	    double c =  Double.parseDouble ((String)sim.vars.utilityModule.PG_C_c.get(the_p1_name));
	    double effort1 =  Double.parseDouble ((String)sim.vars.utilityModule.PG_C_effort_rule_firing_time.get(the_p1_name));
	    double effort2 =  Double.parseDouble ((String)sim.vars.utilityModule.PG_C_effort_rule_firing_time.get(the_p2_name));
	    double effort = Math.max(effort1, effort2 );
	    if (  ProgramUtilitiesFun__Is_String_Double(sim.vars.utilityModule.PG_C_pl ) ){
	      System.out.println("UtilityModuleFun__Update_Utility_For_Compiled_Production Compilation does not work with decaying utilities (sim.vars.utilityModule.PG_C_pl is a number). ");
	    }
	    else if (sim.vars.utilityModule.PG_C_pl.equals( "nil")){
	      ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.PG_C_p, recreating_rule_name, Double.toString(p) );
	      ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.PG_C_c, recreating_rule_name, Double.toString(c) );
	      ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.PG_C_effort_rule_firing_time, recreating_rule_name, Double.toString(effort) );
	    }
	    else{ // when pl = t
	      UtilityModuleFun__PG_C_Update_Priors_For_Production ( recreating_rule_name, (double) p, (double) c  );
	      
	      //(compute-utility new-p)
	      double pp = UtilityModuleFun__PG_C_Compute_P (recreating_rule_name) ;
	      ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.PG_C_p, recreating_rule_name, Double.toString(pp) );
	      double g = sim.vars.utilityModule.PG_C_g ;
	      double cc = UtilityModuleFun__PG_C_Compute_C (recreating_rule_name) ; 
	      ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.PG_C_c, recreating_rule_name, Double.toString(cc) );
	      double utility_without_noise = pp * g - cc;
	      ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.pg_c, recreating_rule_name, Double.toString(utility_without_noise) );
	      double noise;
	      if (sim.vars.utilityModule.egs == 0.0) noise = 0.0;
	      else noise = ProgramUtilitiesFun__Act_R_Noise(sim.vars.utilityModule.egs); // when egs = 0, noise = 0
	      ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.utility, recreating_rule_name, Double.toString(utility_without_noise + noise)   );	
	      //end (compute-utility new-p)
	    }
	    
	    /*

	          (t ;; pl = t
	           (update-priors-for-production u p3 p c)
	           
	           (compute-utility p3)))))
	     */
	  }
	  else System.out.println("UtilityModuleFun__Update_Utility_For_Compiled_Production has undefined sim.vars.utilityModule.utility_Computation_Method case: " + sim.vars.utilityModule.utility_Computation_Method);
	  
	  
	}
	
	public  void UtilityModuleFun__Print_Utility_For_All_Rules (){
	  Enumeration myEnumeratorValue = sim.vars.utilityModule.utility.elements();
	  Enumeration myEnumeratorKey = sim.vars.utilityModule.utility.elements();
	  while ( myEnumeratorValue.hasMoreElements() ){  // get every element
	    String rule_name = (String)myEnumeratorKey.nextElement();
	    UtilityModuleFun__Print_Utility_For_A_Rule (rule_name);
	  }
	}
	
	public  void UtilityModuleFun__Propagate_Reward (String the_rule_name){
	  
	  boolean debug = false;
	  if (sim.vars.utilityModule.utility_Computation_Method.equals( "temporal-difference-reinforcement")){
	    
	    //obsolete and error:
	    //String reward_string;
	    //reward_string = (String)sim.vars.utilityModule.reward[the_rule_name];
	    //if (reward_string.equals( "" )) return; //when no reward is associated to the rule, do nothing
	    
	    //corrected:
	    
	    if (sim.vars.utilityModule.reward.containsKey(the_rule_name) == false ) {
	      System.err.println("Error! UtilityModuleFun__Propagate_Reward has sim.vars.utilityModule.reward.ContainsKey(the_rule_name) == false");
	    }
	    else if ( ((String)sim.vars.utilityModule.reward.get(the_rule_name)).equals( "" ) ) return; //when no reward is associated to the rule, do nothing
	    else{
	      String reward_string;
	      reward_string = (String)sim.vars.utilityModule.reward.get(the_rule_name);
	      if(debug) System.out.println("reward_string: __" + reward_string  );
	      ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(), 3) + "\t" + "UTILITY" + "\t\t" + "PROPAGATE-REWARD " + reward_string);
	      //System.out.println ("UtilityModuleFun__Propagate_Reward line 6: reward_string=" + reward_string);
	      if(!ProgramUtilitiesFun__Is_String_Double(reward_string)) {
	        System.err.println("Error! UtilityModuleFun__Propagate_Reward has reward_string not a double but: " + reward_string);
	        return;
	      }
	      double reward_double = Double.parseDouble (reward_string);
	      
	      Enumeration enum_rule_name = Collections.enumeration(sim.vars.productionModule.Since_Last_Reward_Selected_Rule_Name);
	      Enumeration enum_rule_time = Collections.enumeration(sim.vars.productionModule.Since_Last_Reward_Selected_Rule_Time);
	      while(enum_rule_name.hasMoreElements() && enum_rule_time.hasMoreElements()){
	        String rule_name = (String)enum_rule_name.nextElement();
	        double rule_time = (double)enum_rule_time.nextElement();
	        
	        double u_n_minus_1 = Double.parseDouble ((String) sim.vars.utilityModule.U_N_Without_Noise.get( rule_name ));
	        double r_n = reward_double - (GlobalUtilities.round(SimSystem.clock(),3) - rule_time ) ;
	        double u_n = u_n_minus_1 + sim.vars.utilityModule.alpha * (r_n - u_n_minus_1);
	        ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value (sim.vars.utilityModule.U_N_Without_Noise, rule_name, Double.toString(u_n));
	        
	        if(debug) System.out.println("UtilityModuleFun__Propagate_Reward give rule: " + rule_name + ", rule_time: " + rule_time + ", u_n_minus_1: " + u_n_minus_1 + ", r_n: " + r_n + ", u_n: " + u_n);
	      }
	      sim.vars.productionModule.Since_Last_Reward_Selected_Rule_Name.clear();
	      sim.vars.productionModule.Since_Last_Reward_Selected_Rule_Time.clear();
	      
	    }
	  }
	  else if (sim.vars.utilityModule.utility_Computation_Method.equals( "PG-C")){
	    String flag;
	    if ( sim.vars.utilityModule.PG_C_success_flags.containsKey(the_rule_name) && !sim.vars.utilityModule.PG_C_failure_flags.containsKey(the_rule_name) ) {
	      flag = ":success";
	    }
	    else if ( !sim.vars.utilityModule.PG_C_success_flags.containsKey(the_rule_name) && sim.vars.utilityModule.PG_C_failure_flags.containsKey(the_rule_name) ){
	      flag = ":failure";
	    }
	    else if ( sim.vars.utilityModule.PG_C_success_flags.containsKey(the_rule_name) && sim.vars.utilityModule.PG_C_failure_flags.containsKey(the_rule_name) ){
	      System.out.println("UtilityModuleFun__Propagate_Reward has both flag success and failure for: " + the_rule_name);
	      return;
	    }
	    else {
	      //no flag, do nothing
	      return;
	    }
	    //System.out.println("UtilityModuleFun__Propagate_Reward: " + flag);
	    //when has a flag
	    Enumeration enum_rule_name = Collections.enumeration(sim.vars.productionModule.PG_C_Since_Last_Flag_Selected_Rule_Name);
	    Enumeration enum_rule_time = Collections.enumeration(sim.vars.productionModule.PG_C_Since_Last_Flag_Selected_Rule_Time);
	    while(enum_rule_name.hasMoreElements() && enum_rule_time.hasMoreElements()){	
	      //always count successes, failures and efforts
	      String a_rule_name = (String)enum_rule_name.nextElement();
	      double a_rule_fired_clock_time = (double)enum_rule_time.nextElement();
	      double an_effort = GlobalUtilities.round(SimSystem.clock(),3) - GlobalUtilities.round(a_rule_fired_clock_time,3);
	      if (flag.equals( ":success")){
	        double Obsolete_num =  Double.parseDouble ( (String)sim.vars.utilityModule.PG_C_successes_num_for_each_rule.get(a_rule_name) );
	        Obsolete_num ++;
	        ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.PG_C_successes_num_for_each_rule, a_rule_name, Double.toString(Obsolete_num) );
	      }
	      else if (flag.equals( ":failure")){
	        double Obsolete_num =  Double.parseDouble ( (String)sim.vars.utilityModule.PG_C_failures_num_for_each_rule.get(a_rule_name) );
	        Obsolete_num ++;
	        ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.PG_C_failures_num_for_each_rule, a_rule_name, Double.toString(Obsolete_num) );
	      }
	      //efforts
	      double Obsolete_efforts =  Double.parseDouble ( (String)sim.vars.utilityModule.PG_C_efforts_for_cost_calculation.get(a_rule_name) );
	      Obsolete_efforts += an_effort;
	      ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.PG_C_efforts_for_cost_calculation, a_rule_name, Double.toString(Obsolete_efforts) );
	      
	      // record details when learning with the decay (:pl is a number)
	      if (sim.funs.ProgramUtilitiesFun__Is_String_Double(sim.vars.utilityModule.PG_C_pl))System.out.println("ToDo in UtilityModuleFun__Propagate_Reward :pl is a number");
	    }
	    sim.vars.productionModule.PG_C_Since_Last_Flag_Selected_Rule_Name.clear();
	    sim.vars.productionModule.PG_C_Since_Last_Flag_Selected_Rule_Time.clear();
	    /*
			(dolist (production-and-time (utility-history u))
		           (let* ((previous-production (car production-and-time))
		                  (previous-time (cdr production-and-time))
		                  (effort (- (mp-time) previous-time)))
		             
		             ;; always count successes, failures and efforts
		             
		             (if (eq value :success)
		                 (incf (production-successes previous-production) 1.0)
		               (incf (production-failures previous-production) 1.0))
		             
		             (incf (production-efforts previous-production) effort)
		             
		             ;; record details when learning with the decay
		             
		             (when (numberp (utility-pl u))
		               
		               (if (eq value :success)
		                   (push previous-time (production-success-list previous-production))
		                 (push previous-time (production-failure-list previous-production)))
		               
		               (push effort (production-efforts-list previous-production)))))
		         
		         (setf (utility-history u) nil))
	     */
	  }
	  else System.out.println("UtilityModuleFun__Propagate_Reward has undefined sim.vars.utilityModule.utility_Computation_Method case: " + sim.vars.utilityModule.utility_Computation_Method);
	  
	}
	
	public  void UtilityModuleFun__Utility_Update (String the_rule_name){
	  if (sim.vars.utilityModule.utility_Computation_Method.equals( "temporal-difference-reinforcement" )){
	    double u_n_without_noise,  noise ;
	    
	    //get utility without noise
	    u_n_without_noise = Double.parseDouble((String)sim.vars.utilityModule.U_N_Without_Noise.get(the_rule_name));
	    
	    
	    //get utility noise
	    if (sim.vars.utilityModule.egs == 0.0) noise = 0.0;  //sim.vars.centralParametersModule.esc  true or false
	    else if ( sim.vars.centralParametersModule.esc == false) { // sim.vars.utilityModule.egs != 0.0
	      System.out.println("WARNING! UtilityModuleFun__Utility_Update has sim.vars.centralParametersModule.esc == false  &&  sim.vars.utilityModule.egs != 0.0. Utility noise is generated.");
	      noise = ProgramUtilitiesFun__Act_R_Noise(sim.vars.utilityModule.egs);
	    }
	    else noise = ProgramUtilitiesFun__Act_R_Noise(sim.vars.utilityModule.egs); // when egs = 0, noise = 0
	    
	    
	    
	    ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.utility, the_rule_name, Double.toString(u_n_without_noise + noise)   );
	    
	    //System.out.println ("UtilityModuleFun__Utility_Update: " + the_rule_name + " noise: " + noise.ToString());
	  }
	  else if (sim.vars.utilityModule.utility_Computation_Method.equals( "PG-C")){
	    /*
			(setf (production-pg-c production)
			                    (cond ((null (utility-esc u))
		                            (production-value production))
		                           (t
		                            (let ((p (compute-p u production))
		                                  (c (compute-c u production)))
		                              (- (* p (utility-g u)) c)))))
	     */
	    double p, g, c, utility_without_noise, noise ;							
	    
	    
	    //get utility without noise
	    if (sim.vars.centralParametersModule.esc == false ){
	      utility_without_noise = Double.parseDouble((String)sim.vars.utilityModule.PG_C_value.get(the_rule_name));
	    }
	    else {
	      //System.out.println("Utility_Update debug the_rule_name: " + the_rule_name);
	      
	      p = UtilityModuleFun__PG_C_Compute_P (the_rule_name) ;
	      ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.PG_C_p, the_rule_name, Double.toString(p) );
	      g = sim.vars.utilityModule.PG_C_g ;
	      c = UtilityModuleFun__PG_C_Compute_C (the_rule_name) ; 
	      ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.PG_C_c, the_rule_name, Double.toString(c) );
	      utility_without_noise = p * g - c;
	      ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.pg_c, the_rule_name, Double.toString(utility_without_noise) );
	    }
	    
	    
	    //get utility noise
	    if (sim.vars.utilityModule.egs == 0.0) noise = 0.0;  //sim.vars.centralParametersModule.esc  true or false
	    else if ( sim.vars.centralParametersModule.esc == false) { // sim.vars.utilityModule.egs != 0.0
	      System.out.println("WARNING! UtilityModuleFun__Utility_Update has sim.vars.centralParametersModule.esc == false  &&  sim.vars.utilityModule.egs != 0.0. Utility noise is generated.");
	      noise = ProgramUtilitiesFun__Act_R_Noise(sim.vars.utilityModule.egs);
	    }
	    else noise = ProgramUtilitiesFun__Act_R_Noise(sim.vars.utilityModule.egs); // when egs = 0, noise = 0
	    
	    
	    
	    ProgramUtilitiesFun__Hashtable_Add_OR_Set_Value(sim.vars.utilityModule.utility, the_rule_name, Double.toString(utility_without_noise + noise)   );						
	  }
	  else System.err.println("UtilityModuleFun__Utility_Update has undefined sim.vars.utilityModule.utility_Computation_Method case: " + sim.vars.utilityModule.utility_Computation_Method);
	}
	
	public  double UtilizationFun__Get_Utilization_Of_A_Module_From_Changes_In_A_Second (String the_module_name, Hashtable the_change_table){
	  boolean debug_flag = false;
	  double return_double = -1.0;
	  
	  if( SimSystem.clock() == 0 ) { //initialization
	    the_change_table.put( 0.0, 0.0 );
	    if(debug_flag)System.out.println(" UtilizationFun__Get_Utilization_Of_A_Module_From_Changes_In_A_Second clock == 0 " );
	    return_double = 0.0; //this return value does not matter, because in the snapshot figure, use clock - 1 (or perhaps 0.5 is better) = 0 as time = 0, so that the utilization computed at clock = 1 will be used as the step value of from time 0 to 1.
	  }
	  
	  else if(the_change_table.size() == 0 ) {
	    System.err.println( "Error! UtilizationFun__Get_Utilization_Of_A_Module_From_Changes_In_A_Second has the_change_table.Count == 0 for the_module_name: " + the_module_name);
	    return_double = -1.0;
	  }
	  
	  else if ( the_change_table.size()  == 1){ //no utilization change during this second.
	    
	    Iterator<Entry> itrEntries = the_change_table.entrySet().iterator();
	    
	    Entry currentEntry = itrEntries.next();
	    
	    double utilization =  (double) currentEntry.getValue() ;
	    if(debug_flag) System.out.println("UtilizationFun__Get_Utilization_Of_A_Module_From_Changes_In_A_Second computes utilization in this second from 1 record:  " + currentEntry.getKey() + ", " + utilization );
	    
	    the_change_table.clear();
	    the_change_table.put( (double)GlobalUtilities.round(SimSystem.clock(), 3) ,  utilization);
	    return_double = utilization / 1; 
	  }
	  
	  else { // the_change_table.Count  >=2 
	    //get the sum of ( instant_utilization * delta_time ) , which will be the average utilization over the one second from  Clock - 1 to Clock
	    List<Double> keys_list = new ArrayList<Double> ();
	    List<Double> values_list = new ArrayList<Double> ();
	    
	    Iterator<Entry> itrEntries = the_change_table.entrySet().iterator();
	    
	    while (itrEntries.hasNext()) {
	      Entry<Double, Double> entry = itrEntries.next();
	      keys_list.add(entry.getKey());
	    }
	    
	    Collections.sort(keys_list);  //	    keys_list.Sort(); //SORT
	    
	    for (Double a_key : keys_list){
	      values_list.add( (double) the_change_table.get(a_key));
	    }
	    
	    if(debug_flag) System.out.println("UtilizationFun__Get_Utilization_Of_A_Module_From_Changes_In_A_Second has sorted keys: " +  ProgramUtilitiesFun__ListDouble_To_String( keys_list ) + ";  values : " + ProgramUtilitiesFun__ListDouble_To_String(values_list ));
	    
	    
	    double sum = 0;
	    double time_1 = -999;
	    double time_2 = -999;
	    
	    //			IDictionaryEnumerator itr = the_change_table.GetEnumerator();
	    time_1 = (double) keys_list.get(0);
	    double instant_utilization =  (double) the_change_table.get(time_1) ;
	    for ( int e=0; e< keys_list.size(); e++ ){
	      time_2 = (double) keys_list.get(e) ;
	      
	      sum +=  instant_utilization * ( time_2 - time_1 );
	      
	      time_1 = time_2; 
	      instant_utilization =  (double) the_change_table.get(time_1) ;
	    }
	    
	    //add the last part, including the case of delta_time = 0
	    time_2 = GlobalUtilities.round( SimSystem.clock(), 3);
	    sum +=  instant_utilization * ( time_2 - time_1 );
	    
	    the_change_table.clear();
	    the_change_table.put( (double)GlobalUtilities.round(SimSystem.clock(), 3) ,  instant_utilization);
	    return_double = sum / 1 ;
	  }
	  
	  if(debug_flag) System.out.println(" UtilizationFun__Get_Utilization_Of_A_Module_From_Changes_In_A_Second return : " + return_double );
	  
	  return return_double ;
	}
		
	
//VisionModuleFun
	
	public void VisionModuleFun__Clear_Last_Attended_Info(){
	  
	  sim.vars.visionModule.Last_Attended_Screen_X = "";
	  sim.vars.visionModule.Last_Attended_Screen_Y = "";
	  sim.vars.visionModule.Last_Attended_Visicon_Name = "";
	  sim.vars.visualization__Vision_Module_Last_Attended_Visicon_Name = sim.vars.visionModule.Last_Attended_Visicon_Name;
	  sim.vars.visionModule.Last_Attended_Visual_Location_Name = "";
	}
	
	public  double VisionModuleFun__Distance (Chunk location1, Chunk location2){
	  return Math.sqrt(Math.pow(Double.parseDouble((String)location1.Slot.get("screen-x")) - Double.parseDouble((String)location2.Slot.get("screen-x")), 2)
	      + Math.pow(Double.parseDouble((String)location1.Slot.get("screen-y")) - Double.parseDouble((String)location2.Slot.get("screen-y")), 2));
	}
	
	public  ArrayList<Chunk> VisionModuleFun__Feat_Match_XY (ArrayList<Chunk> Feat_List, Chunk XY_Loc){
	  
	  // lambda expression?
	  
	  // vision.lisp:1460
	  // TODO act-r version took actual values as xy-loc instead of a chunk with screen-(x|y)
	  // TODO act-r version took list of visual-location chunk symbols instead of the actual chunks
	  // return the objects in the list that have the same x,y as the given location chunk
	  
//	  Chunk loc = (Chunk)XY_Loc.Slot.get("screen-pos");
//	  boolean tempBool=Chunk.Slot.get("screen-x").equals( loc.Slot.get("screen-x") ) && Chunk.Slot.get("screen-y").equals( loc.Slot.get("screen-y") );
//	  if (tempBool){
//	    return (ArrayList<Chunk>)Feat_List;
//	  }
//	  return Feat_List;
	  
	  System.out.println("TODO VisionModuleFun__Feat_Match_XY");
	  return null;
	  
	}

	
//VisionModuleFun
	
	public int VisionModuleFun__Find_The_Visicon_ID_By_Visicon_Name(String the_visicon_name){
		//System.out.println("VisionModuleFun__Find_The_Visicon_ID_By_Visicon_Name, print all visicons: ");
	  Enumeration enum_chunk = Collections.enumeration(sim.vars.visualDisplay.Visicon);
	  int i = 0 ;
	  while(enum_chunk.hasMoreElements()){
		  String name = ((Chunk)enum_chunk.nextElement()).Chunk_Name;
		  //System.out.println( name+ ", the_visicon_name: " + the_visicon_name);
	    if (  name.equals(  the_visicon_name ) ) {
	    	//System.out.println("VisionModuleFun__Find_The_Visicon_ID_By_Visicon_Name, found with i=" + i);
	    	return i;
	    }
	    i++;
	  }
	  System.err.println("VisionModuleFun__Find_The_Visicon_ID_By_Visicon_Name, visicon: " + the_visicon_name + " not found");
	  return -1;
	  
	  
	  /*int i;
		for (i = 0; i < sim.vars.visualDisplay.Visicon.Count ; i++){ 	
			if (sim.vars.visualDisplay.Visicon[i].Chunk_Name.equals( The_Visicon_Name )){
				return i;
				}
			}

		//error report
		System.out.println ("VisionModuleFun__Find_Visicon_Index_By_Name Error");
		return -1;
	   */
	}
	
	public  Chunk VisionModuleFun__Find_Visicon_By_Chunk_Spec(Chunk The_Chunk_Spec){
	  //used for +visual-location>
	  //before searching, must check whether :attended new and t are out-of-date
	  VisionModuleFun__Update_Visual_Onset_New_And_T();
	  //VisionModuleFun__Visual_Onset_New_Update();
	  //VisionModuleFun__Visual_Finst_T_Update();
	  
	  
	  //for World3D visual objects
	  if (The_Chunk_Spec.Chunk_Type.equals( "near-point")){
	    System.err.println("Error! VisionModuleFun__Find_Visicon_By_Chunk_Spec has undefined The_Chunk_Spec.Chunk_Type: " + The_Chunk_Spec.Chunk_Type);
	    
	    return new Chunk();
	  }
	  else if (The_Chunk_Spec.Chunk_Type.equals( "far-point")){ 
	    String visual_location_chunk_name = sim.funs.ChunkFun__Get_Chunk_Slot_Value(The_Chunk_Spec, "screen-pos"); //far-point-ID
	    String world3d_id = visual_location_chunk_name.substring( 10 );
	    //System.out.println(visual_location_chunk_name + ", " + world3d_id);
	    Chunk return_chunk = new Chunk();
	    Object world3d_obj = sim.vars.world3DTemplate.World.Objects.get(world3d_id);
	    if( world3d_obj instanceof World3D_Point){
	      //World3D_Point the_point = (World3D_Point)world3d_obj;
	      return_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(new String[] { "world3d-point-" + world3d_id , "isa", "world3d-visual-point",  "screen-pos", visual_location_chunk_name,  "world-3d-id", world3d_id  });
	      
	    }
	    else if (world3d_obj instanceof World3D_OtherCar){
	      //World3D_OtherCar the_car = (World3D_OtherCar) world3d_obj;
	      return_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(new String[] { "world3d-car-" + world3d_id , "isa", "world3d-visual-car",  "screen-pos", visual_location_chunk_name,  "world-3d-id", world3d_id  });
	    }
	    else{
	      System.err.println("Error! VisionModuleFun__Find_Visicon_By_Chunk_Spec The_Chunk_Spec.Chunk_Type == far-point has undefined world3d_obj  type" );
	      
	      
	    }
	    return return_chunk; 
	  }
	  else if (The_Chunk_Spec.Chunk_Type.equals( "vehicle-a")){ 
	    String visual_location_chunk_name = sim.funs.ChunkFun__Get_Chunk_Slot_Value(The_Chunk_Spec, "screen-pos");
	    
	    Chunk return_chunk = new Chunk();
	    return_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(new String[] { "world3d-vehicle-a" , "isa", "world3d-visual-car",  "screen-pos", visual_location_chunk_name,  "world-3d-id", "nil"  });
	    //System.out.println(visual_location_chunk_name);
	    return return_chunk; 
	  }
	  
	  
	  // Normal 2D visicon codes:
	  int i;
	  int Matched_Chunk_Number = 0; //how many matched chunk found, and also the index of the next empty index of Matched_Chunk_Index
	  if (sim.vars.visualDisplay.Visicon.size() < 1) {//this happens when visual display is cleared right after a add visual request was issued
	    //System.out.println("VisionModuleFun__Find_Visicon_By_Chunk_Spec() Error! sim.vars.visualDisplay.Visicon.Count < 1");
	    return new Chunk();
	  }
	  int[] Matched_Chunk_Index = new int[sim.vars.visualDisplay.Visicon.size()]; //at this time, should Add at least 1 Visicon, sim.vars.visualDisplay.Visicon.Count need to > 0
	  
	  //name match is another function, because each chunk should have an unique name.
	  
	  if (The_Chunk_Spec.Chunk_Type.equals( "nil")){  //the first round is chunk type, ISA match
	    //may add later for chunk type is nil
	    System.out.println("VisionModuleFun__Find_Visicon_By_Chunk_Spec has chunk type nil");
	  }
	  else if (The_Chunk_Spec.Chunk_Type.equals( "" )){
	    //matching any chunk type that is not nil
	    //System.out.println("VisionModuleFun__Find_Visicon_By_Chunk_Spec has chunk type empty");
	    for (i = 0; i < sim.vars.visualDisplay.Visicon.size() ; i ++){ 	
	      if (!sim.funs.ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer(sim.vars.visualDisplay.Visicon, i).Chunk_Type.equals( "nil")){
	        Matched_Chunk_Index[Matched_Chunk_Number] = i;
	        Matched_Chunk_Number++;
	      }
	    }
	    
	  }
	  
	  else {  //matching a specific chunk type 
	    for (i = 0; i < sim.vars.visualDisplay.Visicon.size() ; i ++){ 	
	      if (sim.funs.ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer(sim.vars.visualDisplay.Visicon, i).Chunk_Type.equals( The_Chunk_Spec.Chunk_Type)){
	        //if (sim.vars.visualDisplay.Visicon[i].Chunk_Type.equals(The_Chunk_Spec.Chunk_Type){
	        Matched_Chunk_Index[Matched_Chunk_Number] = i;
	        Matched_Chunk_Number++;
	      }
	    }
	  }
	  
	  if (Matched_Chunk_Number == 0){	 return new Chunk();}
	  
	  //int Slot_Matching_Round = 0;
	  int[] Temp_Index;
	  int Temp_Index_Current = 0;
	  
	  
	  Iterator<Entry<String, String>> itrEntries = The_Chunk_Spec.Slot.entrySet().iterator();
	  
	  while ( itrEntries.hasNext() ){  // get every element
	    Entry<String, String> anEntry = itrEntries.next();
	    //System.out.println( myEnumerator.Key + " " + myEnumerator.Value);
	    Temp_Index = new int[Matched_Chunk_Number];
	    for (i = 0; i < Matched_Chunk_Number; i++){   //matching chunks survived are recorded in Temp_Index array
	      Chunk temp_chunk_pointer = ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer( sim.vars.visualDisplay.Visicon,  Matched_Chunk_Index[i] );
	      if ( anEntry.getKey().equals( ":attended" ) && anEntry.getValue().equals( "nil")){ //special slot like ":attended" and if test "nil", note that "new" must also be "nil"
	        if (  sim.funs.ChunkFun__Get_Chunk_Slot_Value( temp_chunk_pointer , ":attended").equals( "nil") || sim.funs.ChunkFun__Get_Chunk_Slot_Value( temp_chunk_pointer , ":attended").equals( "new" ) ){
	          Temp_Index[Temp_Index_Current] = Matched_Chunk_Index[i];
	          Temp_Index_Current++;
	        }
	      }
	      else{ //normal slot like "value" //and special slot like ":attended" when testing "t" and "new" test, same with normal slot test, because "nil" cannot not be "new"
	        if (anEntry.getValue().length() >= 4 ) { //protection for out of index
	          if(!anEntry.getValue().substring(0,4).equals( "NOT_")){	//normal match "arg1 book"
	            if (  ProgramUtilitiesFun__StringsEqualByStringOrDouble(sim.funs.ChunkFun__Get_Chunk_Slot_Value( temp_chunk_pointer, anEntry.getKey()), anEntry.getValue()) ){
	              Temp_Index[Temp_Index_Current] = Matched_Chunk_Index[i];
	              Temp_Index_Current++;
	            }
	          }
	          
	          else {//NOT match "arg1 NOT_book" (changed from "-arg1 book") , match !"arg1 book"
	            String new_slot_value = anEntry.getValue().substring(4, (anEntry.getValue()).length());
	            //System.out.println(The_Chunk_Spec.Slot.get(Slot_Matching_Round, 1].substring(0,4));
	            //System.out.println(new_slot_value);
	            if ( ! ProgramUtilitiesFun__StringsEqualByStringOrDouble(sim.funs.ChunkFun__Get_Chunk_Slot_Value( temp_chunk_pointer, anEntry.getKey()), new_slot_value )){
	              Temp_Index[Temp_Index_Current] = Matched_Chunk_Index[i];
	              Temp_Index_Current++;
	            }
	          }
	        }
	        else{ //normal match "arg1 book" or "screen-x 150" for direct visual-location match
	          if( anEntry.getKey().equals( "screen-x") || anEntry.getKey().equals( "screen-y")){
	            String screen_pos =  sim.funs.ChunkFun__Get_Chunk_Slot_Value( temp_chunk_pointer, "screen-pos" );
	            Chunk temp_chunk_pointer_2 = (Chunk) sim.vars.centralParametersModule.Chunks.get(screen_pos); //find the visual-location chunk
	            if (  ProgramUtilitiesFun__StringsEqualByStringOrDouble(sim.funs.ChunkFun__Get_Chunk_Slot_Value( temp_chunk_pointer_2, anEntry.getKey()), anEntry.getValue() )){
	              Temp_Index[Temp_Index_Current] = Matched_Chunk_Index[i];
	              Temp_Index_Current++;
	            }
	          }
	          else if ( ProgramUtilitiesFun__StringsEqualByStringOrDouble( sim.funs.ChunkFun__Get_Chunk_Slot_Value( temp_chunk_pointer, anEntry.getKey()), anEntry.getValue()) ){
	            Temp_Index[Temp_Index_Current] = Matched_Chunk_Index[i];
	            Temp_Index_Current++;
	          }
	        }
	      }
	    }
	    for (i = 0; i < Temp_Index_Current; i++){      //put Temp_Index array into Matched_Chunk_Index array
	      Matched_Chunk_Index[i] = Temp_Index[i];
	    }
	    Matched_Chunk_Number = Temp_Index_Current;
	    Temp_Index_Current = 0;
	    //Slot_Matching_Round++;
	  }
	  
	  
	  if (Matched_Chunk_Number == 0) return new Chunk();
	  else if (Matched_Chunk_Number == 1){
	    Chunk the_matched_chunk_pointer = ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer( sim.vars.visualDisplay.Visicon,  Matched_Chunk_Index[0] );
	    return sim.funs.ChunkFun__Chunk_Clone(the_matched_chunk_pointer);
	  }
	  else{
	    //Chunk[] Matched_Chunk = new Chunk[Matched_Chunk_Number];
	    //for (i = 0; i < Matched_Chunk_Number; i++){       //put all matched chunks together in an array of chunks
	    //	Matched_Chunk[i] = sim.vars.visualDisplay.Visicon[ Matched_Chunk_Index[i] ];
	    //}
	    //ToDo: may add conflict resolution for multipal visicons matched later. currently just return the first match. This should be the earliest added on, because visicon uses AddFirst
	    System.out.println("VisionModuleFun__Find_Visicon_By_Chunk_Spec has multiple matches");
	    Chunk the_matched_chunk_pointer = ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer( sim.vars.visualDisplay.Visicon,  Matched_Chunk_Index[0] );
	    return sim.funs.ChunkFun__Chunk_Clone(the_matched_chunk_pointer);
	  }
	}
	
	public Chunk VisionModuleFun__Find_Visicon_By_Location(Chunk visual_location){
		// added by Yelly
		// return the vision chunk for critical element
		// place it and return at the very beginning because the former driving model just return empty chunk as near point and far point does not have neccessary visual representation
		if(visual_location.Chunk_Type.equals("visual-location-world3d-driving-criticalelement")) {
			if( !visual_location.Slot.containsKey("id") ){
				System.err.println("Error! VisionModuleFun__Find_Visicon_By_Location has no 'id' key");
				return null;
			}
			if( !visual_location.Slot.containsKey("viewarea") ){
				System.err.println("Error! VisionModuleFun__Find_Visual_Location_In_World3D_By_Chunk_Spec has no 'viewarea' key");
				return null;
			}

			String id = (String)visual_location.Slot.get("id");
			if(id.contains("\"")) id = id.substring(1, id.lastIndexOf('"'));
			String viewArea = (String)visual_location.Slot.get("viewarea");
			if(viewArea.contains("\"")) viewArea = viewArea.substring(1, viewArea.lastIndexOf('"'));

			CriticalElement focusing = ((World3D_Template_Driving_Method)sim.vars.world3DTemplate.Method_Object).getCEByIdAndViewArea(id, viewArea);
			if(focusing == null) {
				System.out.println("VisionModuleFun__Find_Visicon_By_Location for a chosen critical element while the element doesn't exist");
				return new Chunk();
			}
			else if(focusing.type.equals("vehicle")) {
				Chunk temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(new String[] { "critical-element-" + Double.toString(GlobalUtilities.round(SimSystem.clock(), 3)), "isa", "world3d-driving-criticalelement-vehicle",  "screen-pos", visual_location.Chunk_Name, "id", "\"" + id + "\"", "color", "\"" + focusing.content + "\""});
					  
				int temp_int = sim.funs.DeclarativeModuleFun__Find_The_DM_Chunk_ID_By_Chunk_Spec (temp_chunk);
	    		if (temp_int == -1) {
	    			// a new chunk
	    			// for critical elements, add visicon here
	                // copied from "Visual Display Onset" part
	                Chunk cloned_chunk = sim.funs.ChunkFun__Chunk_Clone(temp_chunk);
	                cloned_chunk.Creation_Time = SimSystem.clock();
	                sim.vars.visualDisplay.Visicon.addLast(cloned_chunk);
	                    
	    			return temp_chunk;
	    		}
	    		else if (temp_int >= 0 && temp_int < sim.vars.declarativeModule.Number_of_Chunks) {
	    			// the chunk with the same content already exists
	    			// return that existing chunk
	    			return sim.funs.ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer(sim.vars.declarativeModule.DM_Chunk, temp_int) ;
	    		}
	    		else {
	    			System.err.println ("VisionModuleFun__Find_Visicon_By_Location, dm_chunk_id range Error!");
	    			return new Chunk();
	    		}
	    			
	    	}
	    	else if(focusing.type.equals("sign")) {
	    		Chunk temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(new String[] { "critical-element-" + Double.toString(GlobalUtilities.round(SimSystem.clock(), 3)), "isa", "world3d-driving-criticalelement-sign",  "screen-pos", visual_location.Chunk_Name, "id", "\"" + id + "\"", "content", "\"" + focusing.content + "\""});
					  
	    		int temp_int = sim.funs.DeclarativeModuleFun__Find_The_DM_Chunk_ID_By_Chunk_Spec (temp_chunk);
	    		if (temp_int == -1) {
	    			// a new chunk
	    			// for critical elements, add visicon here
	                // copied from "Visual Display Onset" part
	                Chunk cloned_chunk = sim.funs.ChunkFun__Chunk_Clone(temp_chunk);
	                cloned_chunk.Creation_Time = SimSystem.clock();
	                sim.vars.visualDisplay.Visicon.addLast(cloned_chunk);
	                    
	    			return temp_chunk;
	    		}
	    		else if (temp_int >= 0 && temp_int < sim.vars.declarativeModule.Number_of_Chunks) {
	    			// the chunk with the same content already exists
	    			// return that existing chunk
	    			return sim.funs.ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer(sim.vars.declarativeModule.DM_Chunk, temp_int) ;
	    		}
	    		else {
	    			System.err.println ("VisionModuleFun__Find_Visicon_By_Location, dm_chunk_id range Error!");
	    			return new Chunk();
	    		}
	    			
	    	}
	    	else {
	    		System.err.println("unspecified type of critical element");
	    		return new Chunk();
	    	}
		}
		// return the vision chunk for speed
		else if(visual_location.Chunk_Type.equals("visual-location-world3d-driving-speed")) {
			String speed_val = ((World3D_Template_Driving_Method)sim.vars.world3DTemplate.Method_Object).getSpeedLevel().getRange();
    		Chunk temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(new String[] { "speedometer-" + Double.toString(GlobalUtilities.round(SimSystem.clock(), 3)), "isa", "world3d-driving-speed",  "screen-pos", visual_location.Chunk_Name, "speed", "\"" + speed_val + "\""});
			  
    		int temp_int = sim.funs.DeclarativeModuleFun__Find_The_DM_Chunk_ID_By_Chunk_Spec (temp_chunk);
    		if (temp_int == -1) {
    			// a new chunk
    			// for critical elements, add visicon here
                // copied from "Visual Display Onset" part
                Chunk cloned_chunk = sim.funs.ChunkFun__Chunk_Clone(temp_chunk);
                cloned_chunk.Creation_Time = SimSystem.clock();
                sim.vars.visualDisplay.Visicon.addLast(cloned_chunk);
                    
    			return temp_chunk;
    		}
    		else if (temp_int >= 0 && temp_int < sim.vars.declarativeModule.Number_of_Chunks) {
    			// the chunk with the same content already exists
    			// return that existing chunk
    			return sim.funs.ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer(sim.vars.declarativeModule.DM_Chunk, temp_int) ;
    		}
    		else {
    			System.err.println ("VisionModuleFun__Find_Visicon_By_Location, dm_chunk_id range Error!");
    			return new Chunk();
    		}
		}
		else if(visual_location.Chunk_Type.equals("visual-location-world3d-driving")) {
			// in driving model, near point/far point don't have visicon representation, 
			// so I just let it return empty chunk
		    return new Chunk();
		}
		
		
	  

	  // TODO support for phrase, word from vision.lisp:1490
	  
	  // the code below is translated incorrectly, but the C# code was not used acutally.
//	  // get list of all visual-location objects
//	  LinkedList<Chunk> newVisicon=new LinkedList<Chunk>();
//	  
//	  while (sim.vars.visualDisplay.Visicon.contains((Chunk)sim.vars.centralParametersModule.Chunks.get(Chunk.Slot.get("screen-pos"))))
//	  {
//	    newVisicon.add((Chunk)sim.vars.centralParametersModule.Chunks.get(Chunk.Slot.get("screen-pos")));
//	  }
//	  
//	  Enumeration<Chunk> visicon_chunks = Collections.enumeration(newVisicon);
	  
	  
	  // feat-lis = withinMove(location)
	  ArrayList<Chunk> Feat_Lis = VisionModuleFun__Within_Move(visual_location);
	  
	  if(Feat_Lis.size() == 0) {
	    ProgramUtilitiesFun__Output_Trace_Txt("\t" + GlobalUtilities.round (SimSystem.clock(), 3) + "\t" + "VISION" + "\t\t" + "No items within move range");
	    return new Chunk();
	  }
	  
	  // if feat-lis not empty,
	  // return featlis-to-focus (location, feat-lis)
	  //if(Feat_Lis.Count > 0) return VisionModuleFun__Feat_Lis_To_Focus(visual_location, Feat_Lis);
	  // return the closest Object to the location
	  double dist = VisionModuleFun__Distance((Chunk)sim.vars.centralParametersModule.Chunks.get((String)Feat_Lis.get(0).Slot.get("screen-pos")), visual_location);
	  ArrayList<Chunk> closest = new ArrayList<Chunk>();
	  closest.add(Feat_Lis.get(0));
	  for (Chunk feat : Feat_Lis) {
		//ChunkFun__Print_Chunk(feat);
	    double cur_dist = VisionModuleFun__Distance((Chunk)sim.vars.centralParametersModule.Chunks.get((String)feat.Slot.get("screen-pos")), visual_location);
	    if(cur_dist < dist) {
	      dist = cur_dist;
	      closest.clear();
	      closest.add(feat);
	    } else if(cur_dist == dist) {
	      closest.add(feat);
	    }
	  }
	  
	  boolean requireLocationKindMatch = true; //to specify that the considered visual locations must have the same kind as the requested location.
	  
	  if (requireLocationKindMatch && visual_location.Slot.containsKey("kind")){
		  String kind = sim.funs.ChunkFun__Get_Chunk_Slot_Value(visual_location, "kind");
		  ArrayList<Chunk> closestNew = new ArrayList<Chunk>();
		  for (Chunk aVisicon : closest){
			  String aVisiconLocationName =  sim.funs.ChunkFun__Get_Chunk_Slot_Value(aVisicon, "screen-pos");
			  Chunk  aVisiconLocation = (Chunk) sim.vars.centralParametersModule.Chunks.get(aVisiconLocationName);
			  String aVisiconLocationKind = sim.funs.ChunkFun__Get_Chunk_Slot_Value(aVisiconLocation, "kind");
			  if (aVisiconLocationKind.equals(kind)) closestNew.add(aVisicon);
		  }
		  return  sim.funs.ChunkFun__Chunk_Clone(closestNew.get(new Random().nextInt(closestNew.size()))); 
	  }
	  else return  sim.funs.ChunkFun__Chunk_Clone(closest.get(new Random().nextInt(closest.size())));  // TODO there is probably a source of random numbers we should use here instead of creating a new Random instance
	  
	}
	
	public Chunk VisionModuleFun__Find_Visual_Location_In_World3D_By_Chunk_Spec(Chunk the_chunk_spec){
//		System.out.println("VisionModuleFun__Find_Visual_Location_In_World3D_By_Chunk_Spec, the_chunk_spec: ");
//		sim.funs.ChunkFun__Print_Chunk(the_chunk_spec);
		
		World3D_Template_Driving_Method the_method = null;
		if (sim.vars.programGlobalVar__Use_Predefined_Model_Setup.equals( "model_drive_opends" ) || sim.vars.programGlobalVar__Use_Predefined_Model_Setup.equals( "model_drive_torcs" )){
			if(sim.vars.world3DTemplate.Method_Object != null && sim.vars.world3DTemplate.Method_Object instanceof World3D_Template_Driving_Method) the_method = sim.funs.TaskTemplateFun__Get_World3D_Driving_Method_Object();
		}
		else{
			//	TODO Animator3D class
			System.out.println("TODO VisionModuleFun__Find_Visual_Location_In_World3D_By_Chunk_Spec Animator3D");
		}
	  
	  //VisionModuleFun__Find_Visual_Location_In_World3D_By_Chunk_Spec
	  String visual_location_isa = the_chunk_spec.Chunk_Type;

	  if(visual_location_isa.equals( "visual-location-world3d-driving")) {
	    if( sim.vars.world3DTemplate.Method_Object == null || !(sim.vars.world3DTemplate.Method_Object instanceof World3D_Template_Driving_Method) ) {
	      System.err.println("Error! add location isa visual-location-world3d-driving need needs sim.vars.world3DTemplate.Method_Object is World3D_Template_Driving_Method");
	      return null;
	    }
	    if( !the_chunk_spec.Slot.containsKey("kind") ){
	      System.err.println("Error! VisionModuleFun__Find_Visual_Location_In_World3D_By_Chunk_Spec has no 'kind' key");
	     
	      return null;
	    }
	    String kind = (String)the_chunk_spec.Slot.get("kind");
	    
	    
	    
	    if(kind.equals( "near-point")){

	    	if (sim.vars.programGlobalVar__Use_Predefined_Model_Setup.equals( "model_drive_opends" )){
	    		double near_point_ahead_distance = ((World3D_Template_Driving_Method)sim.vars.world3DTemplate.Method_Object).Near_Point_Distance;
	    		String lane = (String)the_chunk_spec.Slot.get("lane");
			      if( !ProgramUtilitiesFun__Is_String_Int(lane)) {
			        System.err.println("Error! VisionModuleFun__Find_Visual_Location_In_World3D_By_Chunk_Spec 'lane' is not integer but: " + lane);
			        
			        return null;
			      }
	    		return sim.funs.ChunkFun__Make_Chunk_From_Descritption(new String[] { "near-point-" + Double.toString(GlobalUtilities.round(SimSystem.clock(), 3)) , "isa", "visual-location-world3d-driving",  "distance", Double.toString(near_point_ahead_distance), "kind",kind, "lane",lane,  "angle", Double.toString(the_method.getOpenDSPercept().nearPointAngleDegree)     });
			}
	    	else if (sim.vars.programGlobalVar__Use_Predefined_Model_Setup.equals( "model_drive_torcs" )){
	    		double near_point_ahead_distance = ((World3D_Template_Driving_Method)sim.vars.world3DTemplate.Method_Object).Near_Point_Distance;
	    		String lane = (String)the_chunk_spec.Slot.get("lane");
			      if( !ProgramUtilitiesFun__Is_String_Int(lane)) {
			        System.err.println("Error! VisionModuleFun__Find_Visual_Location_In_World3D_By_Chunk_Spec 'lane' is not integer but: " + lane);
			        
			        return null;
			      }
	    		return sim.funs.ChunkFun__Make_Chunk_From_Descritption(new String[] { "near-point-" + Double.toString(GlobalUtilities.round(SimSystem.clock(), 3)) , "isa", "visual-location-world3d-driving",  "distance", Double.toString(near_point_ahead_distance), "kind",kind, "lane",lane,  "angle", Double.toString(the_method.getTorcsPercept().nearPointAngleDegree)     });
			}
			else{
		      World3D_DriverCar the_driver_car = ((World3D_DriverCar)sim.vars.world3DTemplate.World.Objects.get(((World3D_Template_Driving_Method)sim.vars.world3DTemplate.Method_Object).DriverCar_World3D_ID  ));
		      String driver_on_road_id =  the_driver_car.Vehicle_Basic.On_Road_World3D_ID;
		      World3D_Road the_road = (World3D_Road)sim.vars.world3DTemplate.World.Objects.get(driver_on_road_id);
		      if( !the_chunk_spec.Slot.containsKey("lane") ){
		        System.err.println("Error! VisionModuleFun__Find_Visual_Location_In_World3D_By_Chunk_Spec near-point has no 'lane' key");
		      
		        return null;
		      }
		      String lane = (String)the_chunk_spec.Slot.get("lane");
		      if( !ProgramUtilitiesFun__Is_String_Int(lane)) {
		        System.err.println("Error! VisionModuleFun__Find_Visual_Location_In_World3D_By_Chunk_Spec 'lane' is not integer but: " + lane);
		        
		        return null;
		      }
		      int lane_num = Integer.parseInt(lane);
		      double driver_X = the_driver_car.Vehicle_Basic.Loc_X;
		      double driver_Z = the_driver_car.Vehicle_Basic.Loc_Z;
		      double near_point_ahead_distance = ((World3D_Template_Driving_Method)sim.vars.world3DTemplate.Method_Object).Near_Point_Distance;
		      //System.out.println(the_driver_car.Vehicle_Basic.Distance_From_Start);		
		      double near_point_distance_on_road = the_driver_car.Vehicle_Basic.Distance_From_Start + near_point_ahead_distance;
		      double near_point_lateral_position =  lane_num *  the_road.Lane_Width;
		      Three_Tuple near_point_global = ProgramUtilitiesFun__World3D_Local_Loc_And_Angle_To_Global( driver_on_road_id, (double) near_point_distance_on_road, (double)near_point_lateral_position, (double)0.0);
		      double near_point_X = (double)near_point_global.Ob1;
		      double near_point_Z = (double)near_point_global.Ob2;
		      double vector_angle = ProgramUtilitiesFun__World3D_Get_2D_Vector_Angle_Degree ((double)driver_X, (double)driver_Z, (double)near_point_X, (double)near_point_Z );
		      double near_angle = vector_angle - the_driver_car.Vehicle_Basic.Yaw;
		      near_angle = ProgramUtilitiesFun__Normalize_Angle_Degree_Within_Plus_Minus_180 ((double)near_angle );
		      //System.out.println( "near_point_X: " + near_point_X + ", near_point_Z: " + near_point_Z + ". vector_angle: " + vector_angle +  ", Yaw: " + the_driver_car.Vehicle_Basic.Yaw);		
		      return sim.funs.ChunkFun__Make_Chunk_From_Descritption(new String[] { "near-point-" + Double.toString(GlobalUtilities.round(SimSystem.clock(), 3)) , "isa", "visual-location-world3d-driving",  "distance", Double.toString(near_point_ahead_distance), "kind",kind, "lane",lane,  "angle", Double.toString(near_angle)     });
		      //currently don't have World3D Object for near point, because Salvucci's model don't +visual at any near point.
	    	}
	    } // end of kind near-point
	    else if (kind.equals( "far-point")){
	    	if (sim.vars.programGlobalVar__Use_Predefined_Model_Setup.equals( "model_drive_opends" )){
	    		double near_point_ahead_distance = ((World3D_Template_Driving_Method)sim.vars.world3DTemplate.Method_Object).Near_Point_Distance;
	    		String lane = (String)the_chunk_spec.Slot.get("lane");
			      if( !ProgramUtilitiesFun__Is_String_Int(lane)) {
			        System.err.println("Error! VisionModuleFun__Find_Visual_Location_In_World3D_By_Chunk_Spec 'lane' is not integer but: " + lane);
			        
			        return null;
			      }
			      
			      Chunk return_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(new String[] { "far-point-" + Double.toString(GlobalUtilities.round(SimSystem.clock(), 3)) , "isa", "visual-location-world3d-driving",  "distance", Double.toString(the_method.getOpenDSPercept().farPointDistanceMeter), "kind",kind, "lane",lane,  "angle", Double.toString(the_method.getOpenDSPercept().farPointAngleDegree)   });
			      return return_chunk;	    		
			}
	    	else if (sim.vars.programGlobalVar__Use_Predefined_Model_Setup.equals( "model_drive_torcs" )){
	    		double near_point_ahead_distance = ((World3D_Template_Driving_Method)sim.vars.world3DTemplate.Method_Object).Near_Point_Distance;
	    		String lane = (String)the_chunk_spec.Slot.get("lane");
			      if( !ProgramUtilitiesFun__Is_String_Int(lane)) {
			        System.err.println("Error! VisionModuleFun__Find_Visual_Location_In_World3D_By_Chunk_Spec 'lane' is not integer but: " + lane);
			        
			        return null;
			      }
			      
			      Chunk return_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(new String[] { "far-point-" + Double.toString(GlobalUtilities.round(SimSystem.clock(), 3)) , "isa", "visual-location-world3d-driving",  "distance", Double.toString(the_method.getTorcsPercept().farPointDistanceMeter), "kind",kind, "lane",lane,  "angle", Double.toString(the_method.getTorcsPercept().farPointAngleDegree)   });
			      return return_chunk;	    		
			}
			else{
		      World3D_DriverCar the_driver_car = ((World3D_DriverCar)sim.vars.world3DTemplate.World.Objects.get(  ((World3D_Template_Driving_Method)sim.vars.world3DTemplate.Method_Object).DriverCar_World3D_ID  ));
		      String driver_on_road_id =  the_driver_car.Vehicle_Basic.On_Road_World3D_ID;
		      World3D_Road the_road = (World3D_Road)sim.vars.world3DTemplate.World.Objects.get(driver_on_road_id);
		      if( !the_chunk_spec.Slot.containsKey("lane") ){
		        System.err.println("Error! VisionModuleFun__Find_Visual_Location_In_World3D_By_Chunk_Spec far-point has no 'lane' key");
		  
		        return null;
		      }
		      String lane = (String)the_chunk_spec.Slot.get("lane");
		      if( !ProgramUtilitiesFun__Is_String_Int(lane)) {
		        System.err.println("Error! VisionModuleFun__Find_Visual_Location_In_World3D_By_Chunk_Spec 'lane' is not integer but: " + lane);
		        
		        return null;
		      }
		      int lane_num = Integer.parseInt(lane);
		      double driver_X = the_driver_car.Vehicle_Basic.Loc_X;
		      double driver_Z = the_driver_car.Vehicle_Basic.Loc_Z;
		      double far_point_ahead_distance = ((World3D_Template_Driving_Method)sim.vars.world3DTemplate.Method_Object).Far_Point_Time_Ahead  * the_driver_car.Vehicle_Basic.Speed  ;
		      
		      if(far_point_ahead_distance == 0.0) return sim.funs.ChunkFun__Make_Chunk_From_Descritption(new String[] { "far-point" + Double.toString(SimSystem.clock()) , "isa", "visual-location-world3d-driving",  "distance", Double.toString(far_point_ahead_distance), "kind",kind, "lane",lane,  "angle", "0.0"     });
		      //System.out.println("Orignal far_point_ahead_distance: " + far_point_ahead_distance);		
		      String the_other_car_ID = "";
		      double closest_ahead_distance = far_point_ahead_distance;
		      //check whether there is any car closer ahead in the target lane
		      World3D_Template_Driving_Method newOne=(World3D_Template_Driving_Method) sim.vars.world3DTemplate.Method_Object;
		      for(int w=0; w<newOne.OtherCar_World3D_ID.size(); w++){
		        String car_id=newOne.OtherCar_World3D_ID.get(w);
		        //need same road, target lane, distance > driver_car.dis && distance < driver_car.dis + closest_ahead_distance
		        World3D_OtherCar another_car = (World3D_OtherCar) sim.vars.world3DTemplate.World.Objects.get(car_id);
		        String another_road_id = another_car.Vehicle_Basic.On_Road_World3D_ID;
		        int another_lane_num = another_car.Vehicle_Basic.Lane_Num;
		        double another_distance = another_car.Vehicle_Basic.Distance_From_Start;
		        if(another_road_id.equals( driver_on_road_id) &&  another_lane_num == lane_num && another_distance > the_driver_car.Vehicle_Basic.Distance_From_Start  && another_distance < the_driver_car.Vehicle_Basic.Distance_From_Start + closest_ahead_distance){
		          the_other_car_ID = car_id;
		          closest_ahead_distance = another_distance - the_driver_car.Vehicle_Basic.Distance_From_Start;
		        }
		      }
		      //System.out.println("closest_ahead_distance: " + closest_ahead_distance);		
		      double far_point_distance_on_road = the_driver_car.Vehicle_Basic.Distance_From_Start + closest_ahead_distance;
		      double far_point_lateral_position;
		      String far_point_world3d_id;
		      if( the_other_car_ID.equals( "" ) ){ //use far point, center point for straight road, tangent point for curved road
		        
		        String road_type_at_far_point;
		        World3D_Road_Segment the_segment = new World3D_Road_Segment();
		        for( World3D_Road_Segment a_segment : the_road.Segments){
		          if( far_point_distance_on_road > a_segment.Distance_Start && far_point_distance_on_road <= a_segment.Distance_End){
		            the_segment = 	a_segment;
		            break;
		          }
		        }
		        road_type_at_far_point = the_segment.Type;
		        
		        String far_point_object_type_name =  "far-point-lane-"; // see definitions in Event_05_World3D_Initialization
		        int far_point_object_lane_num;
		        
		        if( road_type_at_far_point.equals( "straight")){
		          far_point_object_type_name += "center";
		          far_point_object_lane_num = lane_num;
		          
		          far_point_lateral_position =  lane_num *  the_road.Lane_Width;
		          if(sim.vars.animator3DModule.Show_Animator3D){
	//	            Animator3D.SetCommentText(13, "Far Point Type: " + "road center");	
		          }
		        }
		        else if ( road_type_at_far_point.equals( "right")){
		          if( lane_num >= 0 ){ //middle or right lane
		            far_point_object_lane_num = lane_num; //use this lane
		            far_point_object_type_name += "right";
		          }
		          else{ //left lane
		            far_point_object_lane_num = lane_num + 1; //the the lane right of this
		            far_point_object_type_name += "left"; //use left edge of the right side lane, because it is that same as the right edge of this lane.
		          }
		          
		          far_point_lateral_position =  lane_num *  the_road.Lane_Width + 	the_road.Lane_Width / 2.0 ;
		          if(sim.vars.animator3DModule.Show_Animator3D){
	//	            Animator3D.SetCommentText(13, "Far Point Type: " + "road right curve");	
		          }
		        }
		        else if ( road_type_at_far_point.equals( "left")){
		          if(lane_num <= 0 ){
		            far_point_object_lane_num = lane_num; //use this lane
		            far_point_object_type_name += "left";	
		          }
		          else{
		            far_point_object_lane_num = lane_num - 1;	
		            far_point_object_type_name += "right";
		          }
		          
		          far_point_lateral_position =  lane_num *  the_road.Lane_Width - 	the_road.Lane_Width / 2.0 ;
		          if(sim.vars.animator3DModule.Show_Animator3D){
	//	            Animator3D.SetCommentText(13, "Far Point Type: " + "road left curve");	
		          }
		          
		        }
		        else{
		          System.err.println("Error! VisionModuleFun__Find_Visual_Location_In_World3D_By_Chunk_Spec has undefined road_type_at_far_point: " + road_type_at_far_point);	
		          //far_point_lateral_position = -1; //dummy for compiler
		          
		          return null;
		        }
		        
		        //find the world3d Object ID for this far point.
		        String found_id = "";
		        
		        Iterator <Entry <String, Object>> itr_Objects = sim.vars.world3DTemplate.World.Objects.entrySet().iterator();
		        while(itr_Objects.hasNext()){
		          Entry an_object = itr_Objects.next();
		        
	//	        for(DictionaryEntry an_object :  sim.vars.world3DTemplate.World.Objects){
		          //only look for World3D_Point
		          if ( an_object.getValue() instanceof World3D_Point ){
		            World3D_Point a_point = (World3D_Point) 	an_object.getValue() ;
		            /*
			System.out.println(a_point.On_Road_World3D_ID + " " + a_point.On_Road_Lane + " " + a_point.Type);			
			System.out.println("    " + 		driver_on_road_id + " " + far_point_object_lane_num + " " + far_point_object_type_name );
			System.out.println(a_point.On_Road_World3D_ID.equals( driver_on_road_id ));		
			System.out.println(a_point.On_Road_Lane == (far_point_object_lane_num);	
			System.out.println(a_point.Type.equals(  far_point_object_type_name);	
		             */					
		            if( a_point.On_Road_World3D_ID.equals( driver_on_road_id ) && a_point.On_Road_Lane == far_point_object_lane_num && a_point.Type.equals(  far_point_object_type_name) ){
		              //System.out.println("a_point.World3D_ID: " + a_point.World3D_ID);
		              found_id = 	a_point.World3D_ID;
		              break;
		            }
		          }
		        }
		        if (found_id.equals( "" )){
		          System.err.println("Error! VisionModuleFun__Find_Visual_Location_In_World3D_By_Chunk_Spec cannot find the far-point on road");
		          
		          
		          return new Chunk();
		        }
		        else{
		          far_point_world3d_id = 	found_id;
		        }
		        
		      } //end of road point
		      else{ //use car point
		        World3D_OtherCar the_other_car = (World3D_OtherCar) sim.vars.world3DTemplate.World.Objects.get( the_other_car_ID );
		        far_point_lateral_position = the_other_car.Vehicle_Basic.Distance_Lateral_To_Center_Lane_Center;
		        far_point_world3d_id = the_other_car_ID ;
		        if(sim.vars.animator3DModule.Show_Animator3D){
	//	          Animator3D.SetCommentText(13, "Far Point Type: " + "car");	
		        }
		      }
		      
		      Three_Tuple far_point_global = ProgramUtilitiesFun__World3D_Local_Loc_And_Angle_To_Global( driver_on_road_id, far_point_distance_on_road, far_point_lateral_position, 0.0);
		      double far_point_X = (double)far_point_global.Ob1;
		      double far_point_Z = (double)far_point_global.Ob2;
		      double vector_angle = ProgramUtilitiesFun__World3D_Get_2D_Vector_Angle_Degree (driver_X, driver_Z, far_point_X, far_point_Z );
		      double far_angle = vector_angle - the_driver_car.Vehicle_Basic.Yaw;
		      
		      far_angle = ProgramUtilitiesFun__Normalize_Angle_Degree_Within_Plus_Minus_180 ( far_angle);
		      
		      //System.out.println(" " );		
		      
		      Chunk return_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(new String[] { "far-point-" + far_point_world3d_id , "isa", "visual-location-world3d-driving",  "distance", Double.toString(closest_ahead_distance), "kind",kind, "lane",lane,  "angle", Double.toString(far_angle)   });
		      //				if (!ChunkFun__Is_Chunk_Name (return_chunk.Chunk_Name)) sim.funs.ChunkFun__Define_Chunk(return_chunk);
		      return return_chunk;
	      
	    	}
	    } //end of far point
	    else if (kind.equals( "customized-local-point")){
	      String name = sim.funs.ChunkFun__Get_Chunk_Slot_Value(the_chunk_spec, "name");
	      if( name.charAt(0) == '"') name = name.substring(1);
	      if( name.charAt(name.length() - 1) == '"') name = name.substring(0, name.length() - 1);
	      if(name.toLowerCase().equals( "nil"))System.out.println("WARNING! VisionModuleFun__Find_Visual_Location_In_World3D_By_Chunk_Spec has customized-local-point name == nil");
	      World3D_Point the_point_pointer = new World3D_Point();
	      
	      Iterator <Entry <String, Object>> itr_Objects = sim.vars.world3DTemplate.World.Objects.entrySet().iterator();
	      while (itr_Objects.hasNext()){
	        Entry an_object = itr_Objects.next();
	            
//	      for(DictionaryEntry an_object :  sim.vars.world3DTemplate.World.Objects){
	        if(an_object.getValue() instanceof World3D_Point){
	          World3D_Point a_point = (World3D_Point)	an_object.getValue();
	          //System.out.println( (a_point.Type.equals( "customized-local-point" )) + ", " + (a_point.Name.equals( name)) + name);					
	          if( a_point.Type.equals( "customized-local-point") && a_point.Name.equals( name)) {
	            the_point_pointer = a_point;
	            break;
	          }
	        }
	      }
	      if ( the_point_pointer.Type.equals( "" )) return new Chunk();  //did not find 
	      
	      //compute properties.
	      World3D_DriverCar the_driver_car = sim.funs.TaskTemplateFun__Get_World3D_DriverCar_Object();
	      String driver_on_road_id =  the_driver_car.Vehicle_Basic.On_Road_World3D_ID;
	      if(!driver_on_road_id.equals(the_point_pointer.On_Road_World3D_ID))System.out.println("WARNING! VisionModuleFun__Find_Visual_Location_In_World3D_By_Chunk_Spec has customized-local-point  has driver_on_road_id != the_point_pointer.On_Road_World3D_ID ");
	      double point_distance_on_road = the_point_pointer.Distance_From_Start;
	      double point_lateral_position = the_point_pointer.Distance_Lateral_To_Center_Lane_Center;
	      
	      Three_Tuple customized_point_global = ProgramUtilitiesFun__World3D_Local_Loc_And_Angle_To_Global( driver_on_road_id, point_distance_on_road, point_lateral_position, 0.0);
	      double point_X = (double)customized_point_global.Ob1;
	      double point_Z = (double)customized_point_global.Ob2;
	      double driver_X = the_driver_car.Vehicle_Basic.Loc_X;
	      double driver_Z = the_driver_car.Vehicle_Basic.Loc_Z;
	      double vector_angle = ProgramUtilitiesFun__World3D_Get_2D_Vector_Angle_Degree (driver_X, driver_Z, point_X, point_Z );
	      
	      double customized_point_angle = vector_angle - the_driver_car.Vehicle_Basic.Yaw;
	      
	      customized_point_angle = ProgramUtilitiesFun__Normalize_Angle_Degree_Within_Plus_Minus_180 ( customized_point_angle );
	      
	      String point_world3d_id = the_point_pointer.World3D_ID;
	      double distance = point_distance_on_road - the_driver_car.Vehicle_Basic.Distance_From_Start;
	      int lane_num = the_point_pointer.On_Road_Lane;
	      return sim.funs.ChunkFun__Make_Chunk_From_Descritption(new String[] { "customized-point-" + point_world3d_id , "isa", "visual-location-world3d-driving",  "distance", Double.toString(distance), "kind",kind, "lane",Double.toString(lane_num),  "angle", Double.toString(customized_point_angle)   });
	      
	    }     //end of customized-local-point
	    else if (kind.equals( "vehicle-a")){ //dummy-visual-location-point-vehicle-a
	      
	      return sim.funs.ChunkFun__Make_Chunk_From_Descritption(new String[] { "customized-point-dummy-visual-location-point-vehicle-a" , "isa", "visual-location-world3d-driving",  "distance", "0.0" , "kind", "vehicle-a", "lane", "0",  "angle", "0.0"   });
	      
	    }
	    else {
	      System.err.println("Error! VisionModuleFun__Find_Visual_Location_In_World3D_By_Chunk_Spec has undefined kind: "+ kind);
	     
	      return null;
	    }
	  }
	  else if(visual_location_isa.equals( "visual-location-world3d-driving-criticalelement")) {
		  if( sim.vars.world3DTemplate.Method_Object == null || !(sim.vars.world3DTemplate.Method_Object instanceof World3D_Template_Driving_Method) ) {
			  System.err.println("Error! add location isa visual-location-world3d-driving need needs sim.vars.world3DTemplate.Method_Object is World3D_Template_Driving_Method");
			  return null;
		  }
		  if( !the_chunk_spec.Slot.containsKey("kind") ){
			  System.err.println("Error! VisionModuleFun__Find_Visual_Location_In_World3D_By_Chunk_Spec has no 'kind' key");
			  return null;
		  }
		  if( !the_chunk_spec.Slot.containsKey("viewarea") ){
			  System.err.println("Error! VisionModuleFun__Find_Visual_Location_In_World3D_By_Chunk_Spec has no 'viewarea' key");
			  return null;
		  }

		  String kind = (String)the_chunk_spec.Slot.get("kind");
		  if(kind.contains("\"")) kind = kind.substring(1, kind.lastIndexOf('"'));
		  String viewArea = (String)the_chunk_spec.Slot.get("viewarea");
		  if(viewArea.contains("\"")) viewArea = viewArea.substring(1, viewArea.lastIndexOf('"'));
			    
		  if (sim.vars.programGlobalVar__Use_Predefined_Model_Setup.equals( "model_drive_opends" )){
			  World3D_Template_Driving_Method theMethod = (World3D_Template_Driving_Method)sim.vars.world3DTemplate.Method_Object;
			  String chosenCE_id = theMethod.chooseFocusingCriticalElementFromViewArea(viewArea);
				  
			  if(chosenCE_id == null)	{
				  	System.out.println("after chooseFocusingCriticalElementFromViewArea" + viewArea +" , focusing on no critical element");
				  	return new Chunk();
			  }
			  else {
				  Chunk temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(new String[] { "critical-element-location-" + Double.toString(GlobalUtilities.round(SimSystem.clock(), 3)), "isa", "visual-location-world3d-driving-criticalelement",  "kind", "\"" + kind + "\"", "id", "\"" + chosenCE_id + "\"", "viewarea", "\"" + viewArea + "\""});    	
				  
				  int temp_int = sim.funs.DeclarativeModuleFun__Find_The_DM_Chunk_ID_By_Chunk_Spec (temp_chunk);
				  if (temp_int == -1) {
					  // a new chunk
					  return temp_chunk;
				  }
				  else if (temp_int >= 0 && temp_int < sim.vars.declarativeModule.Number_of_Chunks) {
					  // the chunk with the same content already exists
					  // return that existing chunk
					  return sim.funs.ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer(sim.vars.declarativeModule.DM_Chunk, temp_int) ;
				  }
				  else {
					  System.err.println ("VisionModuleFun__Find_Visual_Location_In_World3D_By_Chunk_Spec, dm_chunk_id range Error!");
					  return new Chunk();
				  }
			  }
		  }
		  else{
			  //TODO: actually I don't know what to do because this is not for our experiment  
			  return null;
		  }
	  }
	  else if(visual_location_isa.equals( "visual-location-world3d-driving-speed")) {
		  if (sim.vars.programGlobalVar__Use_Predefined_Model_Setup.equals( "model_drive_opends" )){
			  
			  // speedometer location does not change
			  Chunk temp_chunk = sim.funs.ChunkFun__Make_Chunk_From_Descritption(new String[] { "speedometer-location", "isa", "visual-location-world3d-driving-speed"});    	
			  
			  int temp_int = sim.funs.DeclarativeModuleFun__Find_The_DM_Chunk_ID_By_Chunk_Spec (temp_chunk);
			  if (temp_int == -1) {
				  // a new chunk
				  return temp_chunk;
			  }
			  else if (temp_int >= 0 && temp_int < sim.vars.declarativeModule.Number_of_Chunks) {
				  // the chunk with the same content already exists
				  // return that existing chunk
				  return sim.funs.ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer(sim.vars.declarativeModule.DM_Chunk, temp_int) ;
			  }
			  else {
				  System.err.println ("VisionModuleFun__Find_Visual_Location_In_World3D_By_Chunk_Spec, dm_chunk_id range Error!");
				  return new Chunk();
			  }
		  }
		  else return null; // else don't know how to deal because this is not our case
	  }
	  else{
	    System.err.println("Error! VisionModuleFun__Find_Visual_Location_In_World3D_By_Chunk_Spec has undefined visual_location_isa: "+ visual_location_isa);
	    return null;
	  }
	}
	
	public Chunk VisionModuleFun__Find_Visual_Location_In_Visicons_By_Chunk_Spec(Chunk The_Chunk_Spec, boolean Exclude_Buffer_Stuffing_Just_Selected_Attended_Nil_Locations){
	  
	  boolean debug_trace = false;
	  //System.out.println( sim.funs.ChunkFun__Get_Chunk_Contents(The_Chunk_Spec)  );
	  
	  Iterator<Entry<String, String>> itrEntries = The_Chunk_Spec.Slot.entrySet().iterator();
	  
	  while (itrEntries.hasNext()){
	    Entry<String, String> anEntry = itrEntries.next();
	    String a_key = (String) anEntry.getKey();
	    //if the order of slot names is not specified, must add it as default hashtable order here for the lowest and highest test order to work properly
	    if ( The_Chunk_Spec.Slot_Names_In_Order.contains( a_key ) == false) The_Chunk_Spec.Slot_Names_In_Order.addLast(a_key);
	  }
	  
	  //used for +visual-location>
	  //before searching, must check whether :attended new and t are out-of-date
	  VisionModuleFun__Update_Visual_Onset_New_And_T();
	  //VisionModuleFun__Visual_Onset_New_Update();
	  //VisionModuleFun__Visual_Finst_T_Update();
	  
	  
	  //get all the visual-location chunks that belongs to the chunks currently in the visicon list
	  LinkedList<Chunk> visual_location_chunk_list = new LinkedList<Chunk> ();
	  Enumeration enum_visicon_chunk = Collections.enumeration(sim.vars.visualDisplay.Visicon);
	  while(enum_visicon_chunk.hasMoreElements()){
	    Chunk visicon_chunk = (Chunk) enum_visicon_chunk.nextElement();
	    String screen_pos = sim.funs.ChunkFun__Get_Chunk_Slot_Value( visicon_chunk, "screen-pos") ;
	    //System.out.println( screen_pos);	
	    if( Exclude_Buffer_Stuffing_Just_Selected_Attended_Nil_Locations && sim.vars.visionModule.Buffer_Stuffing_Just_Selected_Attended_Nil_Visual_Location_Names.contains( screen_pos ) ){
	      //pass
	      // TODO is this a fatal error? if not, why are we forcing a message box up? if so, why aren't we actually failing? (by Chris)
	      // Was unclear whether this will happen and what the effect is, so left a message for further examination (by Shi)
	      //System.out.println("Show. VisionModuleFun__Find_Visual_Location_In_Visicons_By_Chunk_Spec has passed Buffer_Stuffing_Just_Selected_Attended_Nil_Visual_Location_Names screen_pos: "+ screen_pos);
	    }
	    else visual_location_chunk_list.addLast( (Chunk) sim.vars.centralParametersModule.Chunks.get(screen_pos) );
	  }
	  
	  
	  
	  
	  int i;
	  int Matched_Chunk_Number = 0; //how many matched chunk found, and also the index of the next empty index of Matched_Chunk_Index
	  if (visual_location_chunk_list.size() < 1){
	    //System.out.println("VisionModuleFun__Find_Visual_Location_In_Visicons_By_Chunk_Spec Error! visual_location_chunk_list.Count < 1");
	    return new Chunk();	
	  }
	  int[] Matched_Chunk_Index = new int[visual_location_chunk_list.size()]; 
	  
	  //name match is another function, because each chunk should have an unique name.
	  
	  if (The_Chunk_Spec.Chunk_Type.equals( "nil")){  //the first round is chunk type, ISA match
	    //may add later for chunk type is nil
	    System.out.println("VisionModuleFun__Find_Visual_Location_In_Visicons_By_Chunk_Spec has chunk type nil");
	  }
	  else if (The_Chunk_Spec.Chunk_Type.equals( "" )){
	    //matching any chunk type that is not nil
	    for (i = 0; i < visual_location_chunk_list.size() ; i ++){ 	
	      if (!sim.funs.ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer(visual_location_chunk_list, i).Chunk_Type.equals( "nil")){
	        Matched_Chunk_Index[Matched_Chunk_Number] = i;
	        Matched_Chunk_Number++;
	      }
	    }
	  }
	  else {  //matching a specific chunk type 
	    for (i = 0; i < visual_location_chunk_list.size() ; i ++){ 	
	      if (sim.funs.ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer(visual_location_chunk_list, i).Chunk_Type.equals( The_Chunk_Spec.Chunk_Type)){
	        Matched_Chunk_Index[Matched_Chunk_Number] = i;
	        Matched_Chunk_Number++;
	      }
	    }
	  }
	  
	  if (Matched_Chunk_Number == 0){	 return new Chunk();}
	  
	  //int Slot_Matching_Round = 0;
	  int[] Temp_Index;
	  int Temp_Index_Current = 0;
	  
	  Hashtable lowest_highest_slots = new Hashtable (); //stores any lowest or highest slot tests in the request
	  String nearest_spec = null;
	  
	  
	  Iterator<Entry<String, String>> itrEntries1 = The_Chunk_Spec.Slot.entrySet().iterator();
	  
	  while ( itrEntries1.hasNext() ){  // get every element
	    Entry<String, String> anEntry = itrEntries1.next();
	    //System.out.println( myEnumerator.Key + " " + myEnumerator.Value);
	    String key = anEntry.getKey();
	    String value = anEntry.getValue();
	    if(value.equals( "lowest" ) || value.equals( "highest" )){ //get the lowest/highest value //You can use the values lowest and highest in the specification of any slot which has a numeric value.
	      //save this to the next round.
	      lowest_highest_slots.put(key, value );
	      continue;
	    }
	    
	    
	    
	    Temp_Index = new int[Matched_Chunk_Number];
	    for (i = 0; i < Matched_Chunk_Number; i++){   //matching chunks survived are recorded in Temp_Index array
	      Chunk temp_chunk_pointer = ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer( visual_location_chunk_list,  Matched_Chunk_Index[i] );
	      if (key.equals( ":attended" ) && value.equals( "nil")){ //special slot like ":attended" and if test "nil", note that "new" must also be "nil"
	        //System.out.println( sim.funs.ChunkFun__Get_Chunk_Slot_Value( temp_chunk_pointer , ":attended")  );		
	        if (  sim.funs.ChunkFun__Get_Chunk_Slot_Value( temp_chunk_pointer , ":attended").equals( "nil") || sim.funs.ChunkFun__Get_Chunk_Slot_Value( temp_chunk_pointer , ":attended").equals( "new" ) ){
	          Temp_Index[Temp_Index_Current] = Matched_Chunk_Index[i];
	          Temp_Index_Current++;
	        }
	      }
	      else if (key.equals( ":nearest")) {
	        // nearest condition is processed after all of the other tests, so just store the spec here
	        nearest_spec = value;
	        // keep all matched chunks
	        Temp_Index[Temp_Index_Current] = Matched_Chunk_Index[i];
	        Temp_Index_Current++;
	      }
	      else{ //normal slot like "value" //and special slot like ":attended" when testing "t" and "new" test, same with normal slot test, because "nil" cannot not be "new"
	        //ToDo : change this NOT_ to slot name "-" test method. 
	        if ((value).length() >= 4 && (value).substring(0,4).equals( "NOT_")) { //protection for out of index  
	          //NOT match "arg1 NOT_book" (changed from "-arg1 book") , match !"arg1 book"
	          String new_slot_value = (value).substring(4, (value).length());
	          //System.out.println(The_Chunk_Spec.Slot[Slot_Matching_Round, 1].Substring(0,4));
	          //System.out.println(new_slot_value);
	          if ( ! ProgramUtilitiesFun__StringsEqualByStringOrDouble(sim.funs.ChunkFun__Get_Chunk_Slot_Value( temp_chunk_pointer, key), new_slot_value )){
	            Temp_Index[Temp_Index_Current] = Matched_Chunk_Index[i];
	            Temp_Index_Current++;
	          }
	        }
	        else{ 
	          String slot_key = key; 
	          String slot_value = value;
	          if (!slot_key.substring(0,2).equals( "<=" ) && slot_key.substring(0,1).equals( "<") ){ //match "<arg1 book"
	            //modified from ProductionModuleFun__Match_A_Rule_Test
	            //debug_trace = true;
	            String new_slot_key = slot_key.substring(1); // without the first char '<'
	            if (debug_trace) System.out.println("Find_Visual_Location_In_Visicons_By_Chunk_Spec < match, new_slot_key: " + new_slot_key);
	            if (temp_chunk_pointer.Slot.containsKey(new_slot_key) == false && !new_slot_key.toLowerCase().equals( "isa") ){ // if the buffer chunk does not have the slot. 
	              if (debug_trace) System.out.println("Find_Visual_Location_In_Visicons_By_Chunk_Spec '<' test, Buffer_chunk doesn't have the slot_key. test fail");
	              continue;
	            }
	            if(sim.funs.ProgramUtilitiesFun__Is_String_Double(slot_value) == false){
	              System.out.println("VisionModuleFun__Find_Visual_Location_In_Visicons_By_Chunk_Spec:   relative value test must have numbers as slot values.");
	              continue;
	            }
	            if (new_slot_key.toLowerCase().equals( "isa") ){ //< isa test. illegal
	              System.out.println("VisionModuleFun__Find_Visual_Location_In_Visicons_By_Chunk_Spec:   relative value test cannot be applied to isa chunk type.");
	            }
	            else{ //< test match value, not isa 
	              String buffer_chunk_value_string = sim.funs.ChunkFun__Get_Chunk_Slot_Value(temp_chunk_pointer, new_slot_key);
	              if(sim.funs.ProgramUtilitiesFun__Is_String_Double( buffer_chunk_value_string ) == false){
	                System.out.println("VisionModuleFun__Find_Visual_Location_In_Visicons_By_Chunk_Spec:   relative value test has buffer chunk slot value that is not a number: " + buffer_chunk_value_string);
	                continue;
	              }
	              
	              if ( (Double.parseDouble(buffer_chunk_value_string) < Double.parseDouble(slot_value) ) == false){
	                if (debug_trace) System.out.println("Find_Visual_Location_In_Visicons_By_Chunk_Spec, < Match value, not ISA test fail");
	                continue;
	              }
	              else{
	                if(debug_trace)	System.out.println(slot_key + " " + slot_value + " pass");
	                Temp_Index[Temp_Index_Current] = Matched_Chunk_Index[i];
	                Temp_Index_Current++;	
	              }
	            }
	          }// end of < test
	          else if (slot_key.substring(0,2).equals( "<=")){ // <= test
	            //modified from ProductionModuleFun__Match_A_Rule_Test
	            //debug_trace = true;
	            String new_slot_key = slot_key.substring(2); // without the first char '<='
	            if (debug_trace) System.out.println("Find_Visual_Location_In_Visicons_By_Chunk_Spec <= match, new_slot_key: " + new_slot_key);
	            if (temp_chunk_pointer.Slot.containsKey(new_slot_key) == false && !new_slot_key.toLowerCase().equals( "isa")){ // if the buffer chunk does not have the slot. 
	              if (debug_trace) System.out.println("Find_Visual_Location_In_Visicons_By_Chunk_Spec '<=' test, Buffer_chunk doesn't have the slot_key. test fail");
	              continue;
	            }
	            if(sim.funs.ProgramUtilitiesFun__Is_String_Double(slot_value) == false){
	              System.out.println("VisionModuleFun__Find_Visual_Location_In_Visicons_By_Chunk_Spec:   relative value test must have numbers as slot values.");
	              continue;
	            }
	            if (new_slot_key.toLowerCase().equals( "isa") ){ //< isa test. illegal
	              System.out.println("VisionModuleFun__Find_Visual_Location_In_Visicons_By_Chunk_Spec:   relative value test cannot be applied to isa chunk type.");
	            }
	            else{ //<= test match value, not isa 
	              String buffer_chunk_value_string = sim.funs.ChunkFun__Get_Chunk_Slot_Value(temp_chunk_pointer, new_slot_key);
	              if(sim.funs.ProgramUtilitiesFun__Is_String_Double( buffer_chunk_value_string ) == false){
	                System.out.println("VisionModuleFun__Find_Visual_Location_In_Visicons_By_Chunk_Spec:   relative value test has buffer chunk slot value that is not a number: " + buffer_chunk_value_string);
	                continue;
	              }
	              
	              if ( (Double.parseDouble(buffer_chunk_value_string) <= Double.parseDouble(slot_value) ) == false){
	                if (debug_trace) System.out.println("Find_Visual_Location_In_Visicons_By_Chunk_Spec, < Match value, not ISA test fail");
	                continue;
	              }
	              else{
	                if(debug_trace)	System.out.println(slot_key + " " + slot_value + " pass");
	                Temp_Index[Temp_Index_Current] = Matched_Chunk_Index[i];
	                Temp_Index_Current++;	
	              }
	            }
	          }// end of <= test
	          else if (!slot_key.substring(0,2).equals( ">=" ) && slot_key.charAt(0) == '>'){ // > test
	            //modified from ProductionModuleFun__Match_A_Rule_Test
	            //debug_trace = true;
	            String new_slot_key = slot_key.substring(1); // without the first char '>'
	            if (debug_trace) System.out.println("Find_Visual_Location_In_Visicons_By_Chunk_Spec > match, new_slot_key: " + new_slot_key);
	            if (temp_chunk_pointer.Slot.containsKey(new_slot_key) == false && !new_slot_key.toLowerCase().equals( "isa" )){ // if the buffer chunk does not have the slot. 
	              if (debug_trace) System.out.println("Find_Visual_Location_In_Visicons_By_Chunk_Spec '>' test, Buffer_chunk doesn't have the slot_key. test fail");
	              continue;
	            }
	            if(sim.funs.ProgramUtilitiesFun__Is_String_Double(slot_value) == false){
	              System.out.println("VisionModuleFun__Find_Visual_Location_In_Visicons_By_Chunk_Spec:   relative value test must have numbers as slot values.");
	              continue;
	            }
	            if (new_slot_key.toLowerCase().equals( "isa") ){ //> isa test. illegal
	              System.out.println("VisionModuleFun__Find_Visual_Location_In_Visicons_By_Chunk_Spec:   relative value test cannot be applied to isa chunk type.");
	            }
	            else{ //> test match value, not isa 
	              String buffer_chunk_value_string = sim.funs.ChunkFun__Get_Chunk_Slot_Value(temp_chunk_pointer, new_slot_key);
	              if(sim.funs.ProgramUtilitiesFun__Is_String_Double( buffer_chunk_value_string ) == false){
	                System.out.println("VisionModuleFun__Find_Visual_Location_In_Visicons_By_Chunk_Spec:   relative value test has buffer chunk slot value that is not a number: " + buffer_chunk_value_string);
	                continue;
	              }
	              
	              if ( (Double.parseDouble(buffer_chunk_value_string) > Double.parseDouble(slot_value) ) == false){
	                if (debug_trace) System.out.println("Find_Visual_Location_In_Visicons_By_Chunk_Spec, > Match value, not ISA test fail");
	                continue;
	              }
	              else{
	                if(debug_trace)	System.out.println(slot_key + " " + slot_value + " pass");
	                Temp_Index[Temp_Index_Current] = Matched_Chunk_Index[i];
	                Temp_Index_Current++;	
	              }
	            }
	          }// end of > test
	          else if (slot_key.substring(0,2).equals( ">=")){ // >= test
	            //modified from ProductionModuleFun__Match_A_Rule_Test
	            //debug_trace = true;
	            String new_slot_key = slot_key.substring(2); // without the first char '>='
	            if (debug_trace) System.out.println("Find_Visual_Location_In_Visicons_By_Chunk_Spec >= match, new_slot_key: " + new_slot_key);
	            if (temp_chunk_pointer.Slot.containsKey(new_slot_key) == false && !new_slot_key.toLowerCase().equals( "isa" )){ // if the buffer chunk does not have the slot. 
	              if (debug_trace) System.out.println("Find_Visual_Location_In_Visicons_By_Chunk_Spec '>=' test, Buffer_chunk doesn't have the slot_key. test fail");
	              continue;
	            }
	            if(sim.funs.ProgramUtilitiesFun__Is_String_Double(slot_value) == false){
	              System.out.println("VisionModuleFun__Find_Visual_Location_In_Visicons_By_Chunk_Spec:   relative value test must have numbers as slot values.");
	              continue;
	            }
	            if (new_slot_key.toLowerCase().equals( "isa") ){ //>= isa test. illegal
	              System.out.println("VisionModuleFun__Find_Visual_Location_In_Visicons_By_Chunk_Spec:   relative value test cannot be applied to isa chunk type.");
	            }
	            else{ //>= test match value, not isa 
	              String buffer_chunk_value_string = sim.funs.ChunkFun__Get_Chunk_Slot_Value(temp_chunk_pointer, new_slot_key);
	              if(sim.funs.ProgramUtilitiesFun__Is_String_Double( buffer_chunk_value_string ) == false){
	                System.out.println("VisionModuleFun__Find_Visual_Location_In_Visicons_By_Chunk_Spec:   relative value test has buffer chunk slot value that is not a number: " + buffer_chunk_value_string);
	                continue;
	              }
	              
	              if ( (Double.parseDouble(buffer_chunk_value_string) >= Double.parseDouble(slot_value) ) == false){
	                if (debug_trace) System.out.println("Find_Visual_Location_In_Visicons_By_Chunk_Spec, >= Match value, not ISA test fail");
	                continue;
	              }
	              else{
	                if(debug_trace)	System.out.println(slot_key + " " + slot_value + " pass");
	                Temp_Index[Temp_Index_Current] = Matched_Chunk_Index[i];
	                Temp_Index_Current++;	
	              }
	            }
	          }// end of >= test
	          else if (slot_key.substring(0,1).equals( "-")){
	            System.out.println("VisionModuleFun__Find_Visual_Location_In_Visicons_By_Chunk_Spec ToDo: slot_key.Substring(0,1) == - "   );
	          }
	          else if (  ProgramUtilitiesFun__StringsEqualByStringOrDouble(sim.funs.ChunkFun__Get_Chunk_Slot_Value( temp_chunk_pointer, key), value )){ // normal test like "arg1 book"
	            Temp_Index[Temp_Index_Current] = Matched_Chunk_Index[i];
	            Temp_Index_Current++;
	          }
	        }
	      }
	    }
	    for (i = 0; i < Temp_Index_Current; i++){      //put Temp_Index array into Matched_Chunk_Index array
	      Matched_Chunk_Index[i] = Temp_Index[i];
	    }
	    Matched_Chunk_Number = Temp_Index_Current;
	    Temp_Index_Current = 0;
	    //Slot_Matching_Round++;
	    if(Matched_Chunk_Number == 0) break;
	  }
	  
	  
	  // lowest and highest must be used in the end, if there is any, after other test to make sense. only when previous tests get more than 1 candidate.
	  if(lowest_highest_slots.size() > 0 && Matched_Chunk_Number > 1) {
	    
	    
	    //old ordering method, cannot order screen-x and -y lowest tests order as specified in a +visual-location action.
	    //	IDictionaryEnumerator myEnumerator_2 =  lowest_highest_slots.GetEnumerator();
	    //	while ( myEnumerator_2.MoveNext() ){  // get every element
	    
	    //new orderthing method
	    
	    for(String a_slot_name : The_Chunk_Spec.Slot_Names_In_Order){
	      if (lowest_highest_slots.containsKey(a_slot_name) == false) continue; 
	      //else go below:
	      
	      //System.out.println( myEnumerator_2.Key + " " + myEnumerator_2.Value);
	      //String key = (String)myEnumerator_2.Key;
	      //String value = (String)myEnumerator_2.Value;
	      String key = a_slot_name;
	      String value = (String)lowest_highest_slots.get(a_slot_name);
	      //System.out.println(a_slot_name + "  " +   value );
	      
	      if(value.equals( "lowest" ) || value.equals( "highest" )){ //get the lowest/highest value //You can use the values lowest and highest in the specification of any slot which has a numeric value.
	        Chunk temp_chunk_pointer = ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer( visual_location_chunk_list,  Matched_Chunk_Index[0] );
	        String extreme_value_string =   sim.funs.ChunkFun__Get_Chunk_Slot_Value( temp_chunk_pointer , key) ;
	        double extreme_value;
	        if (sim.funs.ProgramUtilitiesFun__Is_String_Double(extreme_value_string) ) extreme_value = Double.parseDouble(extreme_value_string);
	        else {
	          System.out.println("VisionModuleFun__Find_Visual_Location_In_Visicons_By_Chunk_Spec, String: " + extreme_value_string + " cannot be converted to a number.");
	          return null;
	        }
	        for (i = 1; i < Matched_Chunk_Number; i++){
	          temp_chunk_pointer = ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer( visual_location_chunk_list,  Matched_Chunk_Index[i] );
	          String temp_value_string =   sim.funs.ChunkFun__Get_Chunk_Slot_Value( temp_chunk_pointer , key) ;
	          double temp_value;
	          if (sim.funs.ProgramUtilitiesFun__Is_String_Double(temp_value_string) ) temp_value = Double.parseDouble(temp_value_string);
	          else {
	            System.out.println("VisionModuleFun__Find_Visual_Location_In_Visicons_By_Chunk_Spec, String: " + temp_value_string + " cannot be converted to a number.");
	            return null;
	          }
	          if(value.equals( "lowest" )){
	            if (temp_value < extreme_value)  extreme_value = temp_value;
	          }
	          else if (value.equals( "highest" )){
	            if (temp_value > extreme_value)  extreme_value = temp_value;
	          }
	        }
	        value =Double.toString(extreme_value);		
	      }
	      
	      
	      Temp_Index = new int[Matched_Chunk_Number];
	      for (i = 0; i < Matched_Chunk_Number; i++){   //matching chunks survived are recorded in Temp_Index array
	        Chunk temp_chunk_pointer = ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer( visual_location_chunk_list,  Matched_Chunk_Index[i] );
	        if (key.equals( ":attended" ) && value.equals( "nil")){ //special slot like ":attended" and if test "nil", note that "new" must also be "nil"
	          if (  sim.funs.ChunkFun__Get_Chunk_Slot_Value( temp_chunk_pointer , ":attended").equals( "nil") || sim.funs.ChunkFun__Get_Chunk_Slot_Value( temp_chunk_pointer , ":attended").equals( "new" ) ){
	            Temp_Index[Temp_Index_Current] = Matched_Chunk_Index[i];
	            Temp_Index_Current++;
	          }
	        }
	        else{ //normal slot like "value" //and special slot like ":attended" when testing "t" and "new" test, same with normal slot test, because "nil" cannot not be "new"
	          //ToDo : change this NOT_ to slot name "-" test method. 
	          if ((value).length() >= 4 && (value).substring(0,4).equals( "NOT_")) { //protection for out of index  
	            //NOT match "arg1 NOT_book" (changed from "-arg1 book") , match !"arg1 book"
	            String new_slot_value = (value).substring(4, (value).length());
	            //System.out.println(The_Chunk_Spec.Slot[Slot_Matching_Round, 1].Substring(0,4));
	            //System.out.println(new_slot_value);
	            if (  ! ProgramUtilitiesFun__StringsEqualByStringOrDouble(sim.funs.ChunkFun__Get_Chunk_Slot_Value( temp_chunk_pointer, key), new_slot_value )){
	              Temp_Index[Temp_Index_Current] = Matched_Chunk_Index[i];
	              Temp_Index_Current++;
	            }
	          }
	          else{ 
	            String slot_key = key; 
	            String slot_value = value;
	            if (!slot_key.substring(0,2).equals( "<=" ) && slot_key.substring(0,1).equals( "<") ){ //match "<arg1 book"
	              //modified from ProductionModuleFun__Match_A_Rule_Test
	              //debug_trace = true;
	              String new_slot_key = slot_key.substring(1); // without the first char '<'
	              if (debug_trace) System.out.println("Find_Visual_Location_In_Visicons_By_Chunk_Spec < match, new_slot_key: " + new_slot_key);
	              if (temp_chunk_pointer.Slot.containsKey(new_slot_key) == false && !new_slot_key.toLowerCase().equals( "isa")){ // if the buffer chunk does not have the slot. 
	                if (debug_trace) System.out.println("Find_Visual_Location_In_Visicons_By_Chunk_Spec '<' test, Buffer_chunk doesn't have the slot_key. test fail");
	                continue;
	              }
	              if(sim.funs.ProgramUtilitiesFun__Is_String_Double(slot_value) == false){
	                System.out.println("VisionModuleFun__Find_Visual_Location_In_Visicons_By_Chunk_Spec:   relative value test must have numbers as slot values.");
	                continue;
	              }
	              if (new_slot_key.toLowerCase().equals( "isa") ){ //< isa test. illegal
	                System.out.println("VisionModuleFun__Find_Visual_Location_In_Visicons_By_Chunk_Spec:   relative value test cannot be applied to isa chunk type.");
	              }
	              else{ //< test match value, not isa 
	                String buffer_chunk_value_string = sim.funs.ChunkFun__Get_Chunk_Slot_Value(temp_chunk_pointer, new_slot_key);
	                if(sim.funs.ProgramUtilitiesFun__Is_String_Double( buffer_chunk_value_string ) == false){
	                  System.out.println("VisionModuleFun__Find_Visual_Location_In_Visicons_By_Chunk_Spec:   relative value test has buffer chunk slot value that is not a number: " + buffer_chunk_value_string);
	                  continue;
	                }
	                
	                if ( (Double.parseDouble(buffer_chunk_value_string) < Double.parseDouble(slot_value) ) == false){
	                  if (debug_trace) System.out.println("Find_Visual_Location_In_Visicons_By_Chunk_Spec, < Match value, not ISA test fail");
	                  continue;
	                }
	                else{
	                  if(debug_trace)	System.out.println(slot_key + " " + slot_value + " pass");
	                  Temp_Index[Temp_Index_Current] = Matched_Chunk_Index[i];
	                  Temp_Index_Current++;	
	                }
	              }
	            }// end of < test
	            else if (slot_key.substring(0,2).equals( "<=")){ // <= test
	              //modified from ProductionModuleFun__Match_A_Rule_Test
	              //debug_trace = true;
	              String new_slot_key = slot_key.substring(2); // without the first char '<='
	              if (debug_trace) System.out.println("Find_Visual_Location_In_Visicons_By_Chunk_Spec <= match, new_slot_key: " + new_slot_key);
	              if (temp_chunk_pointer.Slot.containsKey(new_slot_key) == false && !new_slot_key.toLowerCase().equals( "isa")){ // if the buffer chunk does not have the slot. 
	                if (debug_trace) System.out.println("Find_Visual_Location_In_Visicons_By_Chunk_Spec '<=' test, Buffer_chunk doesn't have the slot_key. test fail");
	                continue;
	              }
	              if(sim.funs.ProgramUtilitiesFun__Is_String_Double(slot_value) == false){
	                System.out.println("VisionModuleFun__Find_Visual_Location_In_Visicons_By_Chunk_Spec:   relative value test must have numbers as slot values.");
	                continue;
	              }
	              if (new_slot_key.toLowerCase().equals( "isa") ){ //< isa test. illegal
	                System.out.println("VisionModuleFun__Find_Visual_Location_In_Visicons_By_Chunk_Spec:   relative value test cannot be applied to isa chunk type.");
	              }
	              else{ //<= test match value, not isa 
	                String buffer_chunk_value_string = sim.funs.ChunkFun__Get_Chunk_Slot_Value(temp_chunk_pointer, new_slot_key);
	                if(sim.funs.ProgramUtilitiesFun__Is_String_Double( buffer_chunk_value_string ) == false){
	                  System.out.println("VisionModuleFun__Find_Visual_Location_In_Visicons_By_Chunk_Spec:   relative value test has buffer chunk slot value that is not a number: " + buffer_chunk_value_string);
	                  continue;
	                }
	                
	                if ( (Double.parseDouble(buffer_chunk_value_string) <= Double.parseDouble(slot_value) ) == false){
	                  if (debug_trace) System.out.println("Find_Visual_Location_In_Visicons_By_Chunk_Spec, < Match value, not ISA test fail");
	                  continue;
	                }
	                else{
	                  if(debug_trace)	System.out.println(slot_key + " " + slot_value + " pass");
	                  Temp_Index[Temp_Index_Current] = Matched_Chunk_Index[i];
	                  Temp_Index_Current++;	
	                }
	              }
	            }// end of <= test
	            else if (!slot_key.substring(0,2).equals( ">=") && slot_key.charAt(0) == '>'){ // > test
	              //modified from ProductionModuleFun__Match_A_Rule_Test
	              //debug_trace = true;
	              String new_slot_key = slot_key.substring(1); // without the first char '>'
	              if (debug_trace) System.out.println("Find_Visual_Location_In_Visicons_By_Chunk_Spec > match, new_slot_key: " + new_slot_key);
	              if (temp_chunk_pointer.Slot.containsKey(new_slot_key) == false && !new_slot_key.toLowerCase().equals( "isa")){ // if the buffer chunk does not have the slot. 
	                if (debug_trace) System.out.println("Find_Visual_Location_In_Visicons_By_Chunk_Spec '>' test, Buffer_chunk doesn't have the slot_key. test fail");
	                continue;
	              }
	              if(sim.funs.ProgramUtilitiesFun__Is_String_Double(slot_value) == false){
	                System.out.println("VisionModuleFun__Find_Visual_Location_In_Visicons_By_Chunk_Spec:   relative value test must have numbers as slot values.");
	                continue;
	              }
	              if (new_slot_key.toLowerCase().equals( "isa") ){ //> isa test. illegal
	                System.out.println("VisionModuleFun__Find_Visual_Location_In_Visicons_By_Chunk_Spec:   relative value test cannot be applied to isa chunk type.");
	              }
	              else{ //> test match value, not isa 
	                String buffer_chunk_value_string = sim.funs.ChunkFun__Get_Chunk_Slot_Value(temp_chunk_pointer, new_slot_key);
	                if(sim.funs.ProgramUtilitiesFun__Is_String_Double( buffer_chunk_value_string ) == false){
	                  System.out.println("VisionModuleFun__Find_Visual_Location_In_Visicons_By_Chunk_Spec:   relative value test has buffer chunk slot value that is not a number: " + buffer_chunk_value_string);
	                  continue;
	                }
	                
	                if ( (Double.parseDouble(buffer_chunk_value_string) > Double.parseDouble(slot_value) ) == false){
	                  if (debug_trace) System.out.println("Find_Visual_Location_In_Visicons_By_Chunk_Spec, > Match value, not ISA test fail");
	                  continue;
	                }
	                else{
	                  if(debug_trace)System.out.println(slot_key + " " + slot_value + " pass");
	                  Temp_Index[Temp_Index_Current] = Matched_Chunk_Index[i];
	                  Temp_Index_Current++;	
	                }
	              }
	            }// end of > test
	            else if (slot_key.substring(0,2).equals( ">=")){ // >= test
	              //modified from ProductionModuleFun__Match_A_Rule_Test
	              //debug_trace = true;
	              String new_slot_key = slot_key.substring(2); // without the first char '>='
	              if (debug_trace) System.out.println("Find_Visual_Location_In_Visicons_By_Chunk_Spec >= match, new_slot_key: " + new_slot_key);
	              if (temp_chunk_pointer.Slot.containsKey(new_slot_key) == false && !new_slot_key.toLowerCase().equals( "isa" )){ // if the buffer chunk does not have the slot. 
	                if (debug_trace) System.out.println("Find_Visual_Location_In_Visicons_By_Chunk_Spec '>=' test, Buffer_chunk doesn't have the slot_key. test fail");
	                continue;
	              }
	              if(sim.funs.ProgramUtilitiesFun__Is_String_Double(slot_value) == false){
	                System.out.println("VisionModuleFun__Find_Visual_Location_In_Visicons_By_Chunk_Spec:   relative value test must have numbers as slot values.");
	                continue;
	              }
	              if (new_slot_key.toLowerCase().equals( "isa") ){ //>= isa test. illegal
	                System.out.println("VisionModuleFun__Find_Visual_Location_In_Visicons_By_Chunk_Spec:   relative value test cannot be applied to isa chunk type.");
	              }
	              else{ //>= test match value, not isa 
	                String buffer_chunk_value_string = sim.funs.ChunkFun__Get_Chunk_Slot_Value(temp_chunk_pointer, new_slot_key);
	                if(sim.funs.ProgramUtilitiesFun__Is_String_Double( buffer_chunk_value_string ) == false){
	                  System.out.println("VisionModuleFun__Find_Visual_Location_In_Visicons_By_Chunk_Spec:   relative value test has buffer chunk slot value that is not a number: " + buffer_chunk_value_string);
	                  continue;
	                }
	                
	                if ( (Double.parseDouble(buffer_chunk_value_string) >= Double.parseDouble(slot_value) ) == false){
	                  if (debug_trace)System.out.println("Find_Visual_Location_In_Visicons_By_Chunk_Spec, >= Match value, not ISA test fail");
	                  continue;
	                }
	                else{
	                  if(debug_trace)	System.out.println(slot_key + " " + slot_value + " pass");
	                  Temp_Index[Temp_Index_Current] = Matched_Chunk_Index[i];
	                  Temp_Index_Current++;	
	                }
	              }
	            }// end of >= test
	            else if (slot_key.substring(0,1).equals( "-")){
	              System.out.println("VisionModuleFun__Find_Visual_Location_In_Visicons_By_Chunk_Spec ToDo: slot_key.Substring(0,1) == - "   );
	            }
	            
	            
//	            else if (  sim.funs.ChunkFun__Get_Chunk_Slot_Value( temp_chunk_pointer, key).equals( value) ){ // normal test like "arg1 book"
//	              Temp_Index[Temp_Index_Current] = Matched_Chunk_Index[i];
//	              Temp_Index_Current++;
//	            }
	            
	            //[2013-08-03] Shi Cao, the above old verion compares value as String, it works in C# version, because there double 20.0 to String is "20", whereas in Java, it is "20.0"
	            else { // normal test like "arg1 book"  OR "value 20"
	              String tempSlotValue = sim.funs.ChunkFun__Get_Chunk_Slot_Value( temp_chunk_pointer, key);
	              if(ProgramUtilitiesFun__StringsEqualByStringOrDouble(tempSlotValue, value)){
	                if(Double.parseDouble(tempSlotValue) == Double.parseDouble(value) ){ 
	                  Temp_Index[Temp_Index_Current] = Matched_Chunk_Index[i];
	                  Temp_Index_Current++;
	                }
	              }           
	            }
	            
	          }
	        }
	      }
	      for (i = 0; i < Temp_Index_Current; i++){      //put Temp_Index array into Matched_Chunk_Index array
	        Matched_Chunk_Index[i] = Temp_Index[i];
	      }
	      Matched_Chunk_Number = Temp_Index_Current;
	      Temp_Index_Current = 0;
	      //Slot_Matching_Round++;
	      if(Matched_Chunk_Number == 0) break;
	    }
	    
	    
	  }
	  
	  // do :nearest filter
	  Chunk flag;
	  if(nearest_spec != null) {
	    // determine if it is a visual-location chunk
	    Chunk nearest_spec_chunk = null;
	    
	    if (sim.vars.centralParametersModule.Chunks.get(nearest_spec) instanceof Chunk){
	      flag=(Chunk) sim.vars.centralParametersModule.Chunks.get(nearest_spec);
	    }
	    else
	    {
	      flag=null;
	    }
	    if(sim.vars.centralParametersModule.Chunks.containsKey(nearest_spec) && flag.Chunk_Type.equals( "visual-location") && flag!=null) {
	      // store the chunk
	      nearest_spec_chunk = (Chunk)sim.vars.centralParametersModule.Chunks.get(nearest_spec);
	      // overwrite the spec
	      nearest_spec = "visual-location";
	    }
	    // condition on spec type
	    switch(nearest_spec) {
	      case "current":
	      case "current-x":
	      case "current-y":
	      case "visual-location":
	        
	        HashSet<Integer> Temp_Index_Set = new HashSet<Integer>();
	        double distance = -1;
	        int compare_x, compare_y;
	        if(nearest_spec.equals( "visual-location")) {
	          compare_x = Integer.parseInt((String)nearest_spec_chunk.Slot.get("screen-x"));
	          compare_y = Integer.parseInt((String)nearest_spec_chunk.Slot.get("screen-y"));
	        } else {
	          if(sim.vars.visionModule.Last_Attended_Screen_X.equals( "" )) {
	            System.out.println("VisionModuleFun__Find_Visual_Location_In_Visicons_By_Chunk_Spec:    No location has yet been attended so current is assumed to be at 0, 0.");
	            compare_x = compare_y = 0;
	          } else {
	            compare_x = Integer.parseInt(sim.vars.visionModule.Last_Attended_Screen_X);
	            compare_y = Integer.parseInt(sim.vars.visionModule.Last_Attended_Screen_Y);
	          }
	        }
	        //matching chunks survived are recorded in Temp_Index array
	        for (i = 0; i < Matched_Chunk_Number; i++) {
	          Chunk temp_chunk_pointer = ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer(visual_location_chunk_list,  Matched_Chunk_Index[i]);
	          double cur_distance;
	          int chunk_x = Integer.parseInt((String)temp_chunk_pointer.Slot.get("screen-x"));
	          int chunk_y = Integer.parseInt((String)temp_chunk_pointer.Slot.get("screen-y"));
	          // calculate distance
	          if(nearest_spec.equals( "current")) {
	            cur_distance = Math.sqrt(Math.pow(chunk_x - compare_x, 2) + Math.pow(chunk_y - compare_y, 2));
	          } else if(nearest_spec.equals( "current-x")) {
	            cur_distance = Math.abs(chunk_x - compare_x);
	          } else { // if (nearest_spec.equals( "currenty-y")) {
	            cur_distance = Math.abs(chunk_y - compare_y);
	          }
	          if(distance == -1 || cur_distance < distance) {
	            // update distance
	            distance = cur_distance;
	            
	            // clear current matches
	            Temp_Index_Set.clear();
	            
	            // add new match
	            Temp_Index_Set.add(Matched_Chunk_Index[i]);
	          } else if(distance == cur_distance) {
	            // if there is a tie, add index to the set
	            Temp_Index_Set.add(Matched_Chunk_Index[i]);
	          }
	        }
	        
	        // update match list
	        Object[] tempArr=Temp_Index_Set.toArray();
	        int templength  = Matched_Chunk_Index.length;
	        for (int t=0; t<tempArr.length; t++)
	        {
	          
	          Matched_Chunk_Index[templength]=(int) tempArr[t];
	          templength++;
	        }
	        Matched_Chunk_Number = Temp_Index_Set.size();
	        break;
	      case "clockwise":
	      case "counterclockwise":
	        System.out.println("VisionModuleFun__Find_Visual_Location_In_Visicons_By_Chunk_Spec:   Nearest test for " + nearest_spec + " is not yet supported");
	        break;
	      default:
	        System.out.println("VisionModuleFun__Find_Visual_Location_In_Visicons_By_Chunk_Spec:   Nearest test in a visual-location request must be current, current-x, current-y, clockwise, counterclockwise, or a chunk that is a subtype of visual-location");
	        System.out.println("VisionModuleFun__Find_Visual_Location_In_Visicons_By_Chunk_Spec:   Ignoring nearest request for " + nearest_spec);
	        break;
	    }
	  }
	  
	  
	  if (Matched_Chunk_Number == 0) return new Chunk();
	  else if (Matched_Chunk_Number == 1){
	    Chunk the_matched_chunk_pointer = ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer( visual_location_chunk_list,  Matched_Chunk_Index[0] );
	    return sim.funs.ChunkFun__Chunk_Clone(the_matched_chunk_pointer);
	  }
	  else{
	    //ACT-R visual-location request multiple matches: Choose a random one. If there is more than one item which is found as a match, then the one which has been added to the visicon most recently will be the one chosen, and if there is more than one with the same recent onset time, then a random one of those will be chosen. 
	    Random generator=new Random();
	    int rand_int = generator.nextInt(Matched_Chunk_Number); //need multiple runs and randomize seed in Micro Saint execution settings to word randomly from run to run
	    //System.out.println(Matched_Chunk_Number + " " + rand_int);
	    Chunk the_matched_chunk_pointer = ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer( visual_location_chunk_list,  Matched_Chunk_Index[rand_int] );
	    return sim.funs.ChunkFun__Chunk_Clone(the_matched_chunk_pointer);
	  }	  
	  
	}
	
	public boolean VisionModuleFun__Is_Re_Encoding(){
	  if( ! sim.vars.visionModule.Reencoding_Enabled  ) return false;
	  
	  //ACT-R version
	  //in this way, how to determine whether to re-encode?
	  //if sim.vars.visionModule.Last_Attended_Visicon_Name is EMPTY ,  --> no re-encoding
	  //else  if  sim.vars.visionModule.Last_Attended_Visicon_Name's chunk (a visicon chunk) is in the current on-screen visicon list, representing no change to the visual Object,  --> no re-encoding
	  //		      else sim.vars.visionModule.Last_Attended_Visicon_Name's chunk is not there in the current on-screen visicon list, representing some change to the visual Object           --> re-encoding
	  if ( sim.vars.visionModule.Last_Attended_Visicon_Name.equals( "" ) ) return false;
	  else {
	    
	    boolean last_attended_visicon_still_there = false;
	    for(Chunk a_visicon : sim.vars.visualDisplay.Visicon){
	      if ( a_visicon.Chunk_Name.equals( sim.vars.visionModule.Last_Attended_Visicon_Name)) {
	        last_attended_visicon_still_there = true;
	        break;
	      }
	    }
	    //System.out.println("VisionModuleFun__Is_Re_Encoding." + sim.vars.visionModule.Last_Attended_Visicon_Name + " " + ! last_attended_visicon_still_there);
	    return	! last_attended_visicon_still_there ;
	    
	  }
	  
	  
	  /*
		//this is an alternative way of determine re-encoding, which is a little different from ACT-R Lisp code implementation. 
		//in this way, how to determine whether to re-encode?
		//if visual buffer is empty --> no re-encoding
		//else  if  the visual buffer chunk (a visicon chunk) is in the current on-screen visicon list, representing no change to the visual Object,  --> no re-encoding
//		      else the visual buffer chunk is not there in the current on-screen visicon list, representing some change to the visual Object           --> re-encoding



		// in ACT-R, only +visual> isa clear can reset information about the last attended visual Object and therefore disable re-encoding,  implicit clear visual or -visual> cannot.


		// return true when re-encoding is needed.
		//re-encoding is needed when and only when: 
		//there is still a chunk in the visual buffer, but the chunk is no longer in the visicon list (items on the screen)
		//since any visual display change will result in removing an old visicon (and its visual location) and add a new vision, check visicon name is enough to detect the change.
		//!sim.vars.visionModule.Last_Attended_Screen_X.equals("") && !sim.vars.visionModule.Last_Attended_Screen_Y.equals("") is the old way, can serve as a double check

		if( sim.vars.visualBuffer.Visual_Buffer_Chunk.Chunk_Name.equals( "" ) ){ //nothing in the current visual buffer, no re-encoding

			//double check
			if(!sim.vars.visualBuffer.Visual_Buffer_Chunk.Chunk_Name.equals( "" ) || !sim.vars.visionModule.Last_Attended_Screen_X.equals("") || !sim.vars.visionModule.Last_Attended_Screen_Y.equals("")) System.out.println("Error! VisionModuleFun__Is_Re_Encoding double check 1");
			return false;
		}
		//else there must be a chunk in the visual buffer.
		//double check
		if(sim.vars.visualBuffer.Visual_Buffer_Chunk.Chunk_Name.equals( "" )  || sim.vars.visionModule.Last_Attended_Screen_X.equals( "" ) || sim.vars.visionModule.Last_Attended_Screen_Y.equals( "" )) System.out.println("Error! VisionModuleFun__Is_Re_Encoding double check 2, sim.vars.visualBuffer.Visual_Buffer_Chunk.Chunk_Name: " + sim.vars.visualBuffer.Visual_Buffer_Chunk.Chunk_Name + ", sim.vars.visionModule.Last_Attended_Screen_X: " + sim.vars.visionModule.Last_Attended_Screen_X + ", sim.vars.visionModule.Last_Attended_Screen_Y" + sim.vars.visionModule.Last_Attended_Screen_Y);

		//System.out.println("VisionModuleFun__Is_Re_Encoding flag");

		bool last_attended_visicon_still_there = false;
		foreach (Chunk a_visicon in sim.vars.visualDisplay.Visicon){
			if ( a_visicon.Chunk_Name.equals( sim.vars.visionModule.Last_Attended_Visicon_Name) {
				last_attended_visicon_still_there = true;
				break;
			}
		}

		return	! last_attended_visicon_still_there ;

	   */
	}
	
	public void VisionModuleFun__Place_Visual_Finst_On(String the_visicon_name){
	  
	  VisionModuleFun__Update_Visual_Onset_New_And_T(); //update :attended new and t 
	  
	  int temp_ID = VisionModuleFun__Find_The_Visicon_ID_By_Visicon_Name(the_visicon_name);
	  //System.out.println("VisionModuleFun__Place_Visual_Finst_On, the_visicon_name: " + the_visicon_name + ", Visicon_ID: " + temp_ID);
	  
	  if (sim.vars.visionModule.Visual_Finst_ID_Track.size() < sim.vars.visionModule.Visual_Num_Finsts || sim.vars.visionModule.Visual_Finst_ID_Track.contains(temp_ID)){//if Finst table is not yet full OR it is full; but the temp_ID was there in the Finst table, so just renew it.
	    if(sim.vars.visionModule.Visual_Finst_ID_Track.contains(temp_ID)) {
	      sim.vars.visionModule.Visual_Finst_ID_Track.remove((Object)temp_ID);	//otherwise, Java will use int as item index in the LinkedList.
	    }	
	    sim.vars.visionModule.Visual_Finst_ID_Track.addLast (temp_ID);
	    Chunk temp_chunk_pointer =  ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer( sim.vars.visualDisplay.Visicon ,  temp_ID );
	    //sim.funs.ChunkFun__Print_Chunk(temp_chunk_pointer);
	    String screen_pos = sim.funs.ChunkFun__Get_Chunk_Slot_Value(temp_chunk_pointer, "screen-pos");
	    Chunk visual_location_chunk = (Chunk) sim.vars.centralParametersModule.Chunks.get(screen_pos);
	    sim.funs.ChunkFun__Set_Chunk_Slot_Value( visual_location_chunk , ":attended", "t");
	    if(sim.vars.visionModule.Buffer_Stuffing_Just_Selected_Attended_Nil_Visual_Location_Names.contains( visual_location_chunk.Chunk_Name)){
	      sim.vars.visionModule.Buffer_Stuffing_Just_Selected_Attended_Nil_Visual_Location_Names.remove( visual_location_chunk.Chunk_Name );
	      if(sim.vars.visionModule.Buffer_Stuffing_Just_Selected_Attended_Nil_Visual_Location_Names.contains( visual_location_chunk.Chunk_Name) )System.err.println("Error! VisionModuleFun__Place_Visual_Finst_On has visual_location_chunk.Chunk_Name still there after removing, 1 ");
	    }
	    else{ // pass and do nothing
	    }
	    temp_chunk_pointer.Last_Marked_T_Time = GlobalUtilities.round(SimSystem.clock(),3);	
	    
	    //Visual_Finst_Index_Track.Index[Visicon_Finst_T_Number] = VisionModuleFun__Find_Visicon_Index_By_Name(The_Visicon_Name);
	    //Visual_Finst_Index_Track.Last_T_Time [Visicon_Finst_T_Number] = SimSystem.clock();
	    //Visicon_Finst_T_Number++;
	  }
	  else if (sim.vars.visionModule.Visual_Finst_ID_Track.size() == sim.vars.visionModule.Visual_Num_Finsts){//Finst table is full, and temp_ID was not there in the Finst list, push out the oldest one.
	    if(sim.vars.visionModule.Visual_Finst_ID_Track.contains(temp_ID)) System.err.println("Error! VisionModuleFun__Place_Visual_Finst_On this condition should be taken care of in the previous if condition" );
	    
	    sim.vars.visionModule.Visual_Finst_ID_Track.removeFirst();
	    sim.vars.visionModule.Visual_Finst_ID_Track.addLast (temp_ID);
	    Chunk temp_chunk_pointer =  ProgramUtilitiesFun__LinkedList_Get_i_th_Chunk_Pointer( sim.vars.visualDisplay.Visicon ,  temp_ID );
	    String screen_pos = sim.funs.ChunkFun__Get_Chunk_Slot_Value(temp_chunk_pointer, "screen-pos");
	    Chunk visual_location_chunk = (Chunk) sim.vars.centralParametersModule.Chunks.get(screen_pos);
	    
	    sim.funs.ChunkFun__Set_Chunk_Slot_Value( visual_location_chunk , ":attended", "t");
	    if(sim.vars.visionModule.Buffer_Stuffing_Just_Selected_Attended_Nil_Visual_Location_Names.contains( visual_location_chunk.Chunk_Name)){
	      sim.vars.visionModule.Buffer_Stuffing_Just_Selected_Attended_Nil_Visual_Location_Names.remove( visual_location_chunk.Chunk_Name );
	      if(sim.vars.visionModule.Buffer_Stuffing_Just_Selected_Attended_Nil_Visual_Location_Names.contains( visual_location_chunk.Chunk_Name) )System.err.println("Error! VisionModuleFun__Place_Visual_Finst_On has visual_location_chunk.Chunk_Name still there after removing, 2 ");
	    }
	    else{ // pass and do nothing
	    }
	    temp_chunk_pointer.Last_Marked_T_Time = GlobalUtilities.round(SimSystem.clock(),3);	
	    
	    /*
			ChunkFun__Set_Chunk_Slot_Value( sim.vars.visualDisplay.Visicon[ Visual_Finst_Index_Track.Index[0] ], ":attended", "nil");
			int i;
			for (i=0; i < sim.vars.visionModule.Visual_Num_Finsts - 1 ; i++){
			Visual_Finst_Index_Track.Index[i] = Visual_Finst_Index_Track.Index[i+1];
			Visual_Finst_Index_Track.Last_T_Time[i] = Visual_Finst_Index_Track.Last_T_Time[i+1];
			}
			Visual_Finst_Index_Track.Index[Visicon_Finst_T_Number-1] = VisionModuleFun__Find_Visicon_Index_By_Name(The_Visicon_Name);
			Visual_Finst_Index_Track.Last_T_Time [Visicon_Finst_T_Number-1] = SimSystem.clock();
	     */
	  }
	  else System.err.println ("VisionModuleFun__Place_Visual_Finst_On error");
	  
	}
		
	public void VisionModuleFun__Print_All_Visicons(){
	  ProgramUtilitiesFun__Output_Trace_Txt(" ");
	  ProgramUtilitiesFun__Output_Trace_Txt(" ------------------ all visicons: ------------------ ");
	  
	  Enumeration enum_chunk = Collections.enumeration(sim.vars.visualDisplay.Visicon);
	  while(enum_chunk.hasMoreElements()){
	    Chunk temp_chunk_pointer = (Chunk) enum_chunk.nextElement();
	    sim.funs.ChunkFun__Print_Chunk (temp_chunk_pointer);
	  }
	  
	  
	  ProgramUtilitiesFun__Output_Trace_Txt(" ------------------ ------------- ------------------ ");
	  ProgramUtilitiesFun__Output_Trace_Txt(" ");
	}
	
	public  void VisionModuleFun__Update_World3D_Driving_Method_Visible_Objects(){
	  
	  //update visible world3d objects 
	  LinkedList <String> current_visible_world3d_IDs_clone = ProgramUtilitiesFun__LinkedListString_Clone(sim.vars.visualDisplay.World3D_Visible_Object_IDs);
	  
	  Iterator<Entry> itrEntries = sim.vars.world3DTemplate.World.Objects.entrySet().iterator();
	  while (itrEntries.hasNext()){
	    Entry anEntry = itrEntries.next();
	    
	    if( VisionModuleFun__World3D_Driving_Method_Is_An_Object_Visible( anEntry.getValue()) ){ // visible now
	      if(current_visible_world3d_IDs_clone.contains( (String)anEntry.getKey())  ) { //also visible before
	        //no change
	      }
	      else { // no visible before, add it
	        //System.out.println("VisionModuleFun__Update_World3D_Driving_Method_Visible_Objects add: "+ (String)an_entry.Key);
	        DeviceModuleFun__Visual_World3D_Add_Object((String)anEntry.getKey());	 //sim.vars.visualDisplay.World3D_Visible_Object_IDs.Add( (String)an_object.Key );
	      }
	    }
	    else{// not visible now
	      if(current_visible_world3d_IDs_clone.contains((String)anEntry.getKey())  ) { //but visible before. remove it
	        DeviceModuleFun__Visual_World3D_Remove_Object((String)anEntry.getKey());
	      }
	      else{// neither visible before
	        //no change
	      }
	    }
	  }
	  
	}
	
	public  void VisionModuleFun__Update_Visual_Onset_New_And_T(){
	  
	  Enumeration<Chunk> enum_visicon = Collections.enumeration(sim.vars.visualDisplay.Visicon);
	  while(enum_visicon.hasMoreElements()){
	    Chunk currentChunk = (Chunk)enum_visicon.nextElement();
		//System.out.println("VisionModuleFun__Update_Visual_Onset_New_And_T, current visicon: " + currentChunk.Chunk_Name);
	    //sim.funs.ChunkFun__Print_Chunk(currentChunk);
	    String screen_pos = sim.funs.ChunkFun__Get_Chunk_Slot_Value (currentChunk , "screen-pos" );
		//System.out.println("VisionModuleFun__Update_Visual_Onset_New_And_T, visual_location: " + screen_pos);
	    Chunk visual_location_chunk_pointer = (Chunk) sim.vars.centralParametersModule.Chunks.get(screen_pos);
		//System.out.println("VisionModuleFun__Update_Visual_Onset_New_And_T, visual_location_chunk_pointer: ");
		//sim.funs.ChunkFun__Print_Chunk(visual_location_chunk_pointer);
	    if (ChunkFun__Get_Chunk_Slot_Value( visual_location_chunk_pointer, ":attended").equals( "new" ) && ( GlobalUtilities.round(SimSystem.clock(),3) >= ( currentChunk.Creation_Time + sim.vars.visionModule.Visual_Onset_Span) ) ){ //"new" is a special kind of "nil"
	      sim.funs.ChunkFun__Set_Chunk_Slot_Value( visual_location_chunk_pointer, ":attended", "nil");
	    }
	    if (ChunkFun__Get_Chunk_Slot_Value( visual_location_chunk_pointer, ":attended").equals( "t")   && ( GlobalUtilities.round(SimSystem.clock(),3) >= ( currentChunk.Last_Marked_T_Time + sim.vars.visionModule.Visual_Finst_Span) ) ){ //"t" is :attented true
	      sim.funs.ChunkFun__Set_Chunk_Slot_Value( visual_location_chunk_pointer, ":attended", "nil");
	      String visicon_name = currentChunk.Chunk_Name;
	      int temp_ID = VisionModuleFun__Find_The_Visicon_ID_By_Visicon_Name(visicon_name);
	      sim.vars.visionModule.Visual_Finst_ID_Track.remove((Object)temp_ID); //here temp_ID is not LinkedList index
	      //Visicon_Finst_T_Number-- ;
	    }
	  }
	  
	}
	
	public  ArrayList<Chunk> VisionModuleFun__Within_Move(Chunk location){
	  // vision.lisp:1447
	  // get list of all visual objects currently in the visicon
	  ArrayList<Chunk> visicon = new ArrayList<Chunk>(sim.vars.visualDisplay.Visicon);
	  
	  // if tolerance is 0, return visual-location chunks currently in the visicon that exactly match the provided x,y
	  // withinMove(location) {
	  // if move-allowance == 0
	  if(sim.vars.visionModule.Visual_Movement_Tolerance == 0) {
	    //		    return feat-match-xy (visicon-chunks, location)
	    return VisionModuleFun__Feat_Match_XY(visicon, location);
	  }
	  
	  // get the max distance in pixels
	  double max = DeviceModuleFun__Visual_Angle_To_Pixels(sim.vars.visionModule.Visual_Movement_Tolerance);
	  // max = pm-angle-to-pixels(move-allowance)
	  
	  // return the visual-location chunks currently in the visicon that are less than the max distance from the given location
	  List<Chunk> returnList = new ArrayList<Chunk>();
	  
	  for(Chunk aChunk : visicon){
	    if(max >= VisionModuleFun__Distance(location,   (Chunk)sim.vars.centralParametersModule.Chunks.get( aChunk.Slot.get("screen-pos") )) ) {
	      returnList.add(aChunk);
	    }
	  }
	  
//	  C# version
//	  IEnumerable<Chunk> accum = visicon.Where((chunk) => max >= VisionModuleFun__Distance(location,
//	      (Chunk)Central_Parameters_Module.Chunks[chunk.Slot["screen-pos"]]));
	  
	  return (ArrayList<Chunk>) returnList;


	}
	
	public  boolean VisionModuleFun__World3D_Driving_Method_Is_An_Object_Visible(Object an_object){
	  if( sim.vars.world3DTemplate.Method_Object == null || !(sim.vars.world3DTemplate.Method_Object instanceof World3D_Template_Driving_Method) ){
	    System.err.println("Error! VisionModuleFun__World3D_Driving_Method_Is_An_Object_Visible needs sim.vars.world3DTemplate.Method_Object is World3D_Template_Driving_Method");
	    
	    return false;
	  }
	  
	  World3D_DriverCar the_driver_car = ((World3D_DriverCar)sim.vars.world3DTemplate.World.Objects.get(((World3D_Template_Driving_Method)sim.vars.world3DTemplate.Method_Object).DriverCar_World3D_ID  ));
	  String driver_on_road_id =  the_driver_car.Vehicle_Basic.On_Road_World3D_ID;
	  //System.out.println("driver_on_road_id: " + driver_on_road_id );
	  
	  
	  if(an_object instanceof World3D_DriverCar){
	    return false; // cannot see self car
	  } 
	  else if(an_object instanceof  World3D_OtherCar){
	    World3D_OtherCar other_car = (World3D_OtherCar)an_object;
	    if(other_car.Vehicle_Basic.On_Road_World3D_ID.equals( driver_on_road_id ) &&  other_car.Vehicle_Basic.Distance_From_Start > the_driver_car.Vehicle_Basic.Distance_From_Start ){
	      return true;	
	    }
	    else return false;	
	  } 
	  else if (an_object instanceof World3D_Road){
	    World3D_Road a_road = (World3D_Road)an_object;
	    if(a_road.World3D_ID.equals(  driver_on_road_id))return true;
	    else return false;	
	  } 
	  else if (an_object instanceof World3D_Point){
	    World3D_Point a_point = (World3D_Point) an_object ;
	    if( a_point.On_Road_World3D_ID.equals( driver_on_road_id)) return true;
	    else return false;	
	  }
	  else if (an_object instanceof World3D_Line_Segment){
	    World3D_Line_Segment a_seg = (World3D_Line_Segment) an_object ;
	    if( a_seg.On_Road_World3D_ID.equals( driver_on_road_id))return true;
	    else return false;	
	  }
	  else{
	    System.err.println("Error! VisionModuleFun__World3D_Driving_Method_Is_An_Object_Visible has undefined world3d object type");	
	    
	    return false;	
	  }
	  
	  
	}



	
	
	}



	

