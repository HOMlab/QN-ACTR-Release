package qnactr.objectDesigner;

import java.util.*;

import qnactr.sim.QnactrSimulation;
import qnactr.sim.Functions;

import jmt.engine.simEngine.SimSystem;


public class World3D_Road {

	public double Distance_Total;
	public QnactrSimulation sim;
	
	/**
	 * a segment has many fragments
Hashtable< double start_distance, World3D_Road_Fragment> (generated by program, used for driving simulation and visualization)
	 */
	public Hashtable<Double,World3D_Road_Fragment> Fragments=new Hashtable<Double,World3D_Road_Fragment>();
	public boolean hide;
	public int Lane_Num_Left;
	public int Lane_Num_Right;
	public double Lane_Width;
	public String Name = "";
	public LinkedList<World3D_Road_Segment> Segments=new LinkedList<World3D_Road_Segment>();
	public double Start_Heading_Angle;
	public double Start_Loc_X;
	public double Start_Loc_Z;
	public String World3D_ID = "";
	
	

	
	public World3D_Road(){
		Distance_Total=0.0F;
		hide=false;
		Lane_Num_Left=1;
		Lane_Num_Right=0;
		Lane_Width=4.0F;
		Start_Heading_Angle=0.0F;
		Start_Loc_X=0.0F;
		Start_Loc_Z=0.0F;
		
		
	}
	
	
	public Two_Tuple Get_Loc_At_Segment ( double loc_X, double loc_Z, double min_distance){
	  World3D_Road_Segment the_segment = new World3D_Road_Segment();
	  boolean segment_found = false;
	  if(this.Segments.size() < 1)System.out.println("Error! World3D_Road.Get_Loc_At_Segment has no segment");
	  double start_X = 0.0;
	  double start_Z = 0.0;
	  double end_X = 0.0;
	  double end_Z = 0.0;
	  double start_to_the_point_angle_degree = 0.0;
	  double the_point_to_end_angle_degree  = 0.0;
	  double angle_difference_with_start = 0.0;
	  double angle_difference_with_end = 0.0;
	  for (World3D_Road_Segment a_seg : this.Segments){
	    if (a_seg.Distance_End < min_distance) continue;
	    start_X = a_seg.Start_Loc_X;
	    start_Z = a_seg.Start_Loc_Z;
	    double start_heading = a_seg.Start_Heading_Angle;
	    end_X = a_seg.End_Loc_X;
	    end_Z = a_seg.End_Loc_Z;
	    double end_heading = a_seg.Start_Heading_Angle + a_seg.Turn_Angle;
	    start_to_the_point_angle_degree = sim.funs.ProgramUtilitiesFun__World3D_Get_2D_Vector_Angle_Degree( start_X, start_Z, loc_X, loc_Z);
	    the_point_to_end_angle_degree = sim.funs.ProgramUtilitiesFun__World3D_Get_2D_Vector_Angle_Degree(  loc_X, loc_Z, end_X, end_Z );
	    
	    angle_difference_with_start = sim.funs.ProgramUtilitiesFun__Normalize_Angle_Degree_Within_Plus_Minus_180(start_to_the_point_angle_degree - start_heading );
	    angle_difference_with_end =   sim.funs.ProgramUtilitiesFun__Normalize_Angle_Degree_Within_Plus_Minus_180(the_point_to_end_angle_degree - end_heading );
	    
	    if( Math.abs(angle_difference_with_start) <= 90.0 &&  Math.abs(angle_difference_with_end) < 90.0 ){
	      the_segment = a_seg;
	      segment_found = true;
	      break;
	    }
	  }
	  if( segment_found == false){ //then must be the last segment, otherwise, running to the end of the road
	    
	    //Simulation.Model.Message("Error! World3D_Road.Get_Loc_At_Segment cannot find a seg containing the input point");;
	    //Simulation.Model.Halt();
	    SimSystem.abort();
	    
	    return null;
	  } 
	  
	  //Simulation.Model.PrintOutput( "start_X: " + start_X + ", start_Z: " +  start_Z + ", start_to_the_point_angle_degree: " + start_to_the_point_angle_degree + ", angle_difference_with_start: " + angle_difference_with_start + ", the_point_to_end_angle_degree: " + the_point_to_end_angle_degree + ", angle_difference_with_end: " + angle_difference_with_end);
	  Two_Tuple return_tuple = new Two_Tuple();
	  return_tuple.Ob1 = the_segment;
	  return_tuple.Ob2 = angle_difference_with_start;
	  return return_tuple;
	}
	
}
